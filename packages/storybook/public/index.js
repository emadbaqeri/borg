var sM = Object.create
var yu = Object.defineProperty
var oM = Object.getOwnPropertyDescriptor
var aM = Object.getOwnPropertyNames,
  vu = Object.getOwnPropertySymbols,
  cM = Object.getPrototypeOf,
  Vf = Object.prototype.hasOwnProperty,
  sm = Object.prototype.propertyIsEnumerable
var om = (e, r, t) => (r in e ? yu(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : (e[r] = t)),
  am = (e, r) => {
    for (var t in r || (r = {})) Vf.call(r, t) && om(e, t, r[t])
    if (vu) for (var t of vu(r)) sm.call(r, t) && om(e, t, r[t])
    return e
  }
var uM = (e) => yu(e, '__esModule', { value: !0 })
var cm = (e, r) => {
  var t = {}
  for (var n in e) Vf.call(e, n) && r.indexOf(n) < 0 && (t[n] = e[n])
  if (e != null && vu) for (var n of vu(e)) r.indexOf(n) < 0 && sm.call(e, n) && (t[n] = e[n])
  return t
}
var Vi = (e, r) => () => r || e((r = { exports: {} }).exports, r), r.exports
var lM = (e, r, t) => {
    if ((r && typeof r == 'object') || typeof r == 'function')
      for (let n of aM(r))
        !Vf.call(e, n) && n !== 'default' && yu(e, n, { get: () => r[n], enumerable: !(t = oM(r, n)) || t.enumerable })
    return e
  },
  oa = (e) =>
    lM(
      uM(
        yu(
          e != null ? sM(cM(e)) : {},
          'default',
          e && e.__esModule && 'default' in e ? { get: () => e.default, enumerable: !0 } : { value: e, enumerable: !0 }
        )
      ),
      e
    )
var gu = (e, r, t) =>
  new Promise((n, i) => {
    var s = (l) => {
        try {
          o(t.next(l))
        } catch (a) {
          i(a)
        }
      },
      u = (l) => {
        try {
          o(t.throw(l))
        } catch (a) {
          i(a)
        }
      },
      o = (l) => (l.done ? n(l.value) : Promise.resolve(l.value).then(s, u))
    o((t = t.apply(e, r)).next())
  })
var Hf = Vi((jz, lm) => {
  'use strict'
  var um = Object.getOwnPropertySymbols,
    fM = Object.prototype.hasOwnProperty,
    dM = Object.prototype.propertyIsEnumerable
  function hM(e) {
    if (e == null) throw new TypeError('Object.assign cannot be called with null or undefined')
    return Object(e)
  }
  function pM() {
    try {
      if (!Object.assign) return !1
      var e = new String('abc')
      if (((e[5] = 'de'), Object.getOwnPropertyNames(e)[0] === '5')) return !1
      for (var r = {}, t = 0; t < 10; t++) r['_' + String.fromCharCode(t)] = t
      var n = Object.getOwnPropertyNames(r).map(function (s) {
        return r[s]
      })
      if (n.join('') !== '0123456789') return !1
      var i = {}
      return (
        'abcdefghijklmnopqrst'.split('').forEach(function (s) {
          i[s] = s
        }),
        Object.keys(Object.assign({}, i)).join('') === 'abcdefghijklmnopqrst'
      )
    } catch (s) {
      return !1
    }
  }
  lm.exports = pM()
    ? Object.assign
    : function (e, r) {
        for (var t, n = hM(e), i, s = 1; s < arguments.length; s++) {
          t = Object(arguments[s])
          for (var u in t) fM.call(t, u) && (n[u] = t[u])
          if (um) {
            i = um(t)
            for (var o = 0; o < i.length; o++) dM.call(t, i[o]) && (n[i[o]] = t[i[o]])
          }
        }
        return n
      }
})
var Tm = Vi((Ct) => {
  'use strict'
  var $f = Hf(),
    Ds = 60103,
    fm = 60106
  Ct.Fragment = 60107
  Ct.StrictMode = 60108
  Ct.Profiler = 60114
  var dm = 60109,
    hm = 60110,
    pm = 60112
  Ct.Suspense = 60113
  var mm = 60115,
    bm = 60116
  typeof Symbol == 'function' &&
    Symbol.for &&
    ((en = Symbol.for),
    (Ds = en('react.element')),
    (fm = en('react.portal')),
    (Ct.Fragment = en('react.fragment')),
    (Ct.StrictMode = en('react.strict_mode')),
    (Ct.Profiler = en('react.profiler')),
    (dm = en('react.provider')),
    (hm = en('react.context')),
    (pm = en('react.forward_ref')),
    (Ct.Suspense = en('react.suspense')),
    (mm = en('react.memo')),
    (bm = en('react.lazy')))
  var en,
    ym = typeof Symbol == 'function' && Symbol.iterator
  function mM(e) {
    return e === null || typeof e != 'object'
      ? null
      : ((e = (ym && e[ym]) || e['@@iterator']), typeof e == 'function' ? e : null)
  }
  function aa(e) {
    for (var r = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, t = 1; t < arguments.length; t++)
      r += '&args[]=' + encodeURIComponent(arguments[t])
    return (
      'Minified React error #' +
      e +
      '; visit ' +
      r +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  var vm = {
      isMounted: function () {
        return !1
      },
      enqueueForceUpdate: function () {},
      enqueueReplaceState: function () {},
      enqueueSetState: function () {}
    },
    gm = {}
  function Ls(e, r, t) {
    ;(this.props = e), (this.context = r), (this.refs = gm), (this.updater = t || vm)
  }
  Ls.prototype.isReactComponent = {}
  Ls.prototype.setState = function (e, r) {
    if (typeof e != 'object' && typeof e != 'function' && e != null) throw Error(aa(85))
    this.updater.enqueueSetState(this, e, r, 'setState')
  }
  Ls.prototype.forceUpdate = function (e) {
    this.updater.enqueueForceUpdate(this, e, 'forceUpdate')
  }
  function wm() {}
  wm.prototype = Ls.prototype
  function Gf(e, r, t) {
    ;(this.props = e), (this.context = r), (this.refs = gm), (this.updater = t || vm)
  }
  var Wf = (Gf.prototype = new wm())
  Wf.constructor = Gf
  $f(Wf, Ls.prototype)
  Wf.isPureReactComponent = !0
  var Jf = { current: null },
    _m = Object.prototype.hasOwnProperty,
    Em = { key: !0, ref: !0, __self: !0, __source: !0 }
  function Sm(e, r, t) {
    var n,
      i = {},
      s = null,
      u = null
    if (r != null)
      for (n in (r.ref !== void 0 && (u = r.ref), r.key !== void 0 && (s = '' + r.key), r))
        _m.call(r, n) && !Em.hasOwnProperty(n) && (i[n] = r[n])
    var o = arguments.length - 2
    if (o === 1) i.children = t
    else if (1 < o) {
      for (var l = Array(o), a = 0; a < o; a++) l[a] = arguments[a + 2]
      i.children = l
    }
    if (e && e.defaultProps) for (n in ((o = e.defaultProps), o)) i[n] === void 0 && (i[n] = o[n])
    return { $$typeof: Ds, type: e, key: s, ref: u, props: i, _owner: Jf.current }
  }
  function bM(e, r) {
    return { $$typeof: Ds, type: e.type, key: r, ref: e.ref, props: e.props, _owner: e._owner }
  }
  function Xf(e) {
    return typeof e == 'object' && e !== null && e.$$typeof === Ds
  }
  function yM(e) {
    var r = { '=': '=0', ':': '=2' }
    return (
      '$' +
      e.replace(/[=:]/g, function (t) {
        return r[t]
      })
    )
  }
  var Am = /\/+/g
  function Yf(e, r) {
    return typeof e == 'object' && e !== null && e.key != null ? yM('' + e.key) : r.toString(36)
  }
  function wu(e, r, t, n, i) {
    var s = typeof e
    ;(s === 'undefined' || s === 'boolean') && (e = null)
    var u = !1
    if (e === null) u = !0
    else
      switch (s) {
        case 'string':
        case 'number':
          u = !0
          break
        case 'object':
          switch (e.$$typeof) {
            case Ds:
            case fm:
              u = !0
          }
      }
    if (u)
      return (
        (u = e),
        (i = i(u)),
        (e = n === '' ? '.' + Yf(u, 0) : n),
        Array.isArray(i)
          ? ((t = ''),
            e != null && (t = e.replace(Am, '$&/') + '/'),
            wu(i, r, t, '', function (a) {
              return a
            }))
          : i != null &&
            (Xf(i) &&
              (i = bM(i, t + (!i.key || (u && u.key === i.key) ? '' : ('' + i.key).replace(Am, '$&/') + '/') + e)),
            r.push(i)),
        1
      )
    if (((u = 0), (n = n === '' ? '.' : n + ':'), Array.isArray(e)))
      for (var o = 0; o < e.length; o++) {
        s = e[o]
        var l = n + Yf(s, o)
        u += wu(s, r, t, l, i)
      }
    else if (((l = mM(e)), typeof l == 'function'))
      for (e = l.call(e), o = 0; !(s = e.next()).done; ) (s = s.value), (l = n + Yf(s, o++)), (u += wu(s, r, t, l, i))
    else if (s === 'object')
      throw (
        ((r = '' + e),
        Error(aa(31, r === '[object Object]' ? 'object with keys {' + Object.keys(e).join(', ') + '}' : r)))
      )
    return u
  }
  function _u(e, r, t) {
    if (e == null) return e
    var n = [],
      i = 0
    return (
      wu(e, n, '', '', function (s) {
        return r.call(t, s, i++)
      }),
      n
    )
  }
  function vM(e) {
    if (e._status === -1) {
      var r = e._result
      ;(r = r()),
        (e._status = 0),
        (e._result = r),
        r.then(
          function (t) {
            e._status === 0 && ((t = t.default), (e._status = 1), (e._result = t))
          },
          function (t) {
            e._status === 0 && ((e._status = 2), (e._result = t))
          }
        )
    }
    if (e._status === 1) return e._result
    throw e._result
  }
  var Im = { current: null }
  function Hn() {
    var e = Im.current
    if (e === null) throw Error(aa(321))
    return e
  }
  var gM = {
    ReactCurrentDispatcher: Im,
    ReactCurrentBatchConfig: { transition: 0 },
    ReactCurrentOwner: Jf,
    IsSomeRendererActing: { current: !1 },
    assign: $f
  }
  Ct.Children = {
    map: _u,
    forEach: function (e, r, t) {
      _u(
        e,
        function () {
          r.apply(this, arguments)
        },
        t
      )
    },
    count: function (e) {
      var r = 0
      return (
        _u(e, function () {
          r++
        }),
        r
      )
    },
    toArray: function (e) {
      return (
        _u(e, function (r) {
          return r
        }) || []
      )
    },
    only: function (e) {
      if (!Xf(e)) throw Error(aa(143))
      return e
    }
  }
  Ct.Component = Ls
  Ct.PureComponent = Gf
  Ct.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = gM
  Ct.cloneElement = function (e, r, t) {
    if (e == null) throw Error(aa(267, e))
    var n = $f({}, e.props),
      i = e.key,
      s = e.ref,
      u = e._owner
    if (r != null) {
      if (
        (r.ref !== void 0 && ((s = r.ref), (u = Jf.current)),
        r.key !== void 0 && (i = '' + r.key),
        e.type && e.type.defaultProps)
      )
        var o = e.type.defaultProps
      for (l in r) _m.call(r, l) && !Em.hasOwnProperty(l) && (n[l] = r[l] === void 0 && o !== void 0 ? o[l] : r[l])
    }
    var l = arguments.length - 2
    if (l === 1) n.children = t
    else if (1 < l) {
      o = Array(l)
      for (var a = 0; a < l; a++) o[a] = arguments[a + 2]
      n.children = o
    }
    return { $$typeof: Ds, type: e.type, key: i, ref: s, props: n, _owner: u }
  }
  Ct.createContext = function (e, r) {
    return (
      r === void 0 && (r = null),
      (e = {
        $$typeof: hm,
        _calculateChangedBits: r,
        _currentValue: e,
        _currentValue2: e,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      }),
      (e.Provider = { $$typeof: dm, _context: e }),
      (e.Consumer = e)
    )
  }
  Ct.createElement = Sm
  Ct.createFactory = function (e) {
    var r = Sm.bind(null, e)
    return (r.type = e), r
  }
  Ct.createRef = function () {
    return { current: null }
  }
  Ct.forwardRef = function (e) {
    return { $$typeof: pm, render: e }
  }
  Ct.isValidElement = Xf
  Ct.lazy = function (e) {
    return { $$typeof: bm, _payload: { _status: -1, _result: e }, _init: vM }
  }
  Ct.memo = function (e, r) {
    return { $$typeof: mm, type: e, compare: r === void 0 ? null : r }
  }
  Ct.useCallback = function (e, r) {
    return Hn().useCallback(e, r)
  }
  Ct.useContext = function (e, r) {
    return Hn().useContext(e, r)
  }
  Ct.useDebugValue = function () {}
  Ct.useEffect = function (e, r) {
    return Hn().useEffect(e, r)
  }
  Ct.useImperativeHandle = function (e, r, t) {
    return Hn().useImperativeHandle(e, r, t)
  }
  Ct.useLayoutEffect = function (e, r) {
    return Hn().useLayoutEffect(e, r)
  }
  Ct.useMemo = function (e, r) {
    return Hn().useMemo(e, r)
  }
  Ct.useReducer = function (e, r, t) {
    return Hn().useReducer(e, r, t)
  }
  Ct.useRef = function (e) {
    return Hn().useRef(e)
  }
  Ct.useState = function (e) {
    return Hn().useState(e)
  }
  Ct.version = '17.0.2'
})
var Us = Vi((Kz, Cm) => {
  'use strict'
  Cm.exports = Tm()
})
var Nm = Vi((Nt) => {
  'use strict'
  var qs, ca, Eu, Zf
  typeof performance == 'object' && typeof performance.now == 'function'
    ? ((km = performance),
      (Nt.unstable_now = function () {
        return km.now()
      }))
    : ((Qf = Date),
      (Mm = Qf.now()),
      (Nt.unstable_now = function () {
        return Qf.now() - Mm
      }))
  var km, Qf, Mm
  typeof window == 'undefined' || typeof MessageChannel != 'function'
    ? ((js = null),
      (ed = null),
      (td = function () {
        if (js !== null)
          try {
            var e = Nt.unstable_now()
            js(!0, e), (js = null)
          } catch (r) {
            throw (setTimeout(td, 0), r)
          }
      }),
      (qs = function (e) {
        js !== null ? setTimeout(qs, 0, e) : ((js = e), setTimeout(td, 0))
      }),
      (ca = function (e, r) {
        ed = setTimeout(e, r)
      }),
      (Eu = function () {
        clearTimeout(ed)
      }),
      (Nt.unstable_shouldYield = function () {
        return !1
      }),
      (Zf = Nt.unstable_forceFrameRate = function () {}))
    : ((xm = window.setTimeout),
      (Rm = window.clearTimeout),
      typeof console != 'undefined' &&
        ((Bm = window.cancelAnimationFrame),
        typeof window.requestAnimationFrame != 'function' &&
          console.error(
            "This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
          ),
        typeof Bm != 'function' &&
          console.error(
            "This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
          )),
      (ua = !1),
      (la = null),
      (Su = -1),
      (rd = 5),
      (nd = 0),
      (Nt.unstable_shouldYield = function () {
        return Nt.unstable_now() >= nd
      }),
      (Zf = function () {}),
      (Nt.unstable_forceFrameRate = function (e) {
        0 > e || 125 < e
          ? console.error(
              'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
            )
          : (rd = 0 < e ? Math.floor(1e3 / e) : 5)
      }),
      (id = new MessageChannel()),
      (Au = id.port2),
      (id.port1.onmessage = function () {
        if (la !== null) {
          var e = Nt.unstable_now()
          nd = e + rd
          try {
            la(!0, e) ? Au.postMessage(null) : ((ua = !1), (la = null))
          } catch (r) {
            throw (Au.postMessage(null), r)
          }
        } else ua = !1
      }),
      (qs = function (e) {
        ;(la = e), ua || ((ua = !0), Au.postMessage(null))
      }),
      (ca = function (e, r) {
        Su = xm(function () {
          e(Nt.unstable_now())
        }, r)
      }),
      (Eu = function () {
        Rm(Su), (Su = -1)
      }))
  var js, ed, td, xm, Rm, Bm, ua, la, Su, rd, nd, id, Au
  function sd(e, r) {
    var t = e.length
    e.push(r)
    e: for (;;) {
      var n = (t - 1) >>> 1,
        i = e[n]
      if (i !== void 0 && 0 < Tu(i, r)) (e[n] = r), (e[t] = i), (t = n)
      else break e
    }
  }
  function mn(e) {
    return (e = e[0]), e === void 0 ? null : e
  }
  function Iu(e) {
    var r = e[0]
    if (r !== void 0) {
      var t = e.pop()
      if (t !== r) {
        e[0] = t
        e: for (var n = 0, i = e.length; n < i; ) {
          var s = 2 * (n + 1) - 1,
            u = e[s],
            o = s + 1,
            l = e[o]
          if (u !== void 0 && 0 > Tu(u, t))
            l !== void 0 && 0 > Tu(l, u) ? ((e[n] = l), (e[o] = t), (n = o)) : ((e[n] = u), (e[s] = t), (n = s))
          else if (l !== void 0 && 0 > Tu(l, t)) (e[n] = l), (e[o] = t), (n = o)
          else break e
        }
      }
      return r
    }
    return null
  }
  function Tu(e, r) {
    var t = e.sortIndex - r.sortIndex
    return t !== 0 ? t : e.id - r.id
  }
  var In = [],
    mi = [],
    wM = 1,
    tn = null,
    Sr = 3,
    Cu = !1,
    Hi = !1,
    fa = !1
  function od(e) {
    for (var r = mn(mi); r !== null; ) {
      if (r.callback === null) Iu(mi)
      else if (r.startTime <= e) Iu(mi), (r.sortIndex = r.expirationTime), sd(In, r)
      else break
      r = mn(mi)
    }
  }
  function ad(e) {
    if (((fa = !1), od(e), !Hi))
      if (mn(In) !== null) (Hi = !0), qs(cd)
      else {
        var r = mn(mi)
        r !== null && ca(ad, r.startTime - e)
      }
  }
  function cd(e, r) {
    ;(Hi = !1), fa && ((fa = !1), Eu()), (Cu = !0)
    var t = Sr
    try {
      for (od(r), tn = mn(In); tn !== null && (!(tn.expirationTime > r) || (e && !Nt.unstable_shouldYield())); ) {
        var n = tn.callback
        if (typeof n == 'function') {
          ;(tn.callback = null), (Sr = tn.priorityLevel)
          var i = n(tn.expirationTime <= r)
          ;(r = Nt.unstable_now()), typeof i == 'function' ? (tn.callback = i) : tn === mn(In) && Iu(In), od(r)
        } else Iu(In)
        tn = mn(In)
      }
      if (tn !== null) var s = !0
      else {
        var u = mn(mi)
        u !== null && ca(ad, u.startTime - r), (s = !1)
      }
      return s
    } finally {
      ;(tn = null), (Sr = t), (Cu = !1)
    }
  }
  var _M = Zf
  Nt.unstable_IdlePriority = 5
  Nt.unstable_ImmediatePriority = 1
  Nt.unstable_LowPriority = 4
  Nt.unstable_NormalPriority = 3
  Nt.unstable_Profiling = null
  Nt.unstable_UserBlockingPriority = 2
  Nt.unstable_cancelCallback = function (e) {
    e.callback = null
  }
  Nt.unstable_continueExecution = function () {
    Hi || Cu || ((Hi = !0), qs(cd))
  }
  Nt.unstable_getCurrentPriorityLevel = function () {
    return Sr
  }
  Nt.unstable_getFirstCallbackNode = function () {
    return mn(In)
  }
  Nt.unstable_next = function (e) {
    switch (Sr) {
      case 1:
      case 2:
      case 3:
        var r = 3
        break
      default:
        r = Sr
    }
    var t = Sr
    Sr = r
    try {
      return e()
    } finally {
      Sr = t
    }
  }
  Nt.unstable_pauseExecution = function () {}
  Nt.unstable_requestPaint = _M
  Nt.unstable_runWithPriority = function (e, r) {
    switch (e) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break
      default:
        e = 3
    }
    var t = Sr
    Sr = e
    try {
      return r()
    } finally {
      Sr = t
    }
  }
  Nt.unstable_scheduleCallback = function (e, r, t) {
    var n = Nt.unstable_now()
    switch (
      (typeof t == 'object' && t !== null ? ((t = t.delay), (t = typeof t == 'number' && 0 < t ? n + t : n)) : (t = n),
      e)
    ) {
      case 1:
        var i = -1
        break
      case 2:
        i = 250
        break
      case 5:
        i = 1073741823
        break
      case 4:
        i = 1e4
        break
      default:
        i = 5e3
    }
    return (
      (i = t + i),
      (e = { id: wM++, callback: r, priorityLevel: e, startTime: t, expirationTime: i, sortIndex: -1 }),
      t > n
        ? ((e.sortIndex = t), sd(mi, e), mn(In) === null && e === mn(mi) && (fa ? Eu() : (fa = !0), ca(ad, t - n)))
        : ((e.sortIndex = i), sd(In, e), Hi || Cu || ((Hi = !0), qs(cd))),
      e
    )
  }
  Nt.unstable_wrapCallback = function (e) {
    var r = Sr
    return function () {
      var t = Sr
      Sr = r
      try {
        return e.apply(this, arguments)
      } finally {
        Sr = t
      }
    }
  }
})
var Om = Vi((Vz, Pm) => {
  'use strict'
  Pm.exports = Nm()
})
var _v = Vi((cn) => {
  'use strict'
  var ku = Us(),
    Wt = Hf(),
    cr = Om()
  function Ke(e) {
    for (var r = 'https://reactjs.org/docs/error-decoder.html?invariant=' + e, t = 1; t < arguments.length; t++)
      r += '&args[]=' + encodeURIComponent(arguments[t])
    return (
      'Minified React error #' +
      e +
      '; visit ' +
      r +
      ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
    )
  }
  if (!ku) throw Error(Ke(227))
  var Dm = new Set(),
    da = {}
  function $i(e, r) {
    zs(e, r), zs(e + 'Capture', r)
  }
  function zs(e, r) {
    for (da[e] = r, e = 0; e < r.length; e++) Dm.add(r[e])
  }
  var $n = !(
      typeof window == 'undefined' ||
      typeof window.document == 'undefined' ||
      typeof window.document.createElement == 'undefined'
    ),
    EM =
      /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Lm = Object.prototype.hasOwnProperty,
    Um = {},
    qm = {}
  function SM(e) {
    return Lm.call(qm, e) ? !0 : Lm.call(Um, e) ? !1 : EM.test(e) ? (qm[e] = !0) : ((Um[e] = !0), !1)
  }
  function AM(e, r, t, n) {
    if (t !== null && t.type === 0) return !1
    switch (typeof r) {
      case 'function':
      case 'symbol':
        return !0
      case 'boolean':
        return n
          ? !1
          : t !== null
          ? !t.acceptsBooleans
          : ((e = e.toLowerCase().slice(0, 5)), e !== 'data-' && e !== 'aria-')
      default:
        return !1
    }
  }
  function IM(e, r, t, n) {
    if (r === null || typeof r == 'undefined' || AM(e, r, t, n)) return !0
    if (n) return !1
    if (t !== null)
      switch (t.type) {
        case 3:
          return !r
        case 4:
          return r === !1
        case 5:
          return isNaN(r)
        case 6:
          return isNaN(r) || 1 > r
      }
    return !1
  }
  function Ur(e, r, t, n, i, s, u) {
    ;(this.acceptsBooleans = r === 2 || r === 3 || r === 4),
      (this.attributeName = n),
      (this.attributeNamespace = i),
      (this.mustUseProperty = t),
      (this.propertyName = e),
      (this.type = r),
      (this.sanitizeURL = s),
      (this.removeEmptyString = u)
  }
  var vr = {}
  'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
    .split(' ')
    .forEach(function (e) {
      vr[e] = new Ur(e, 0, !1, e, null, !1, !1)
    })
  ;[
    ['acceptCharset', 'accept-charset'],
    ['className', 'class'],
    ['htmlFor', 'for'],
    ['httpEquiv', 'http-equiv']
  ].forEach(function (e) {
    var r = e[0]
    vr[r] = new Ur(r, 1, !1, e[1], null, !1, !1)
  })
  ;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function (e) {
    vr[e] = new Ur(e, 2, !1, e.toLowerCase(), null, !1, !1)
  })
  ;['autoReverse', 'externalResourcesRequired', 'focusable', 'preserveAlpha'].forEach(function (e) {
    vr[e] = new Ur(e, 2, !1, e, null, !1, !1)
  })
  'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
    .split(' ')
    .forEach(function (e) {
      vr[e] = new Ur(e, 3, !1, e.toLowerCase(), null, !1, !1)
    })
  ;['checked', 'multiple', 'muted', 'selected'].forEach(function (e) {
    vr[e] = new Ur(e, 3, !0, e, null, !1, !1)
  })
  ;['capture', 'download'].forEach(function (e) {
    vr[e] = new Ur(e, 4, !1, e, null, !1, !1)
  })
  ;['cols', 'rows', 'size', 'span'].forEach(function (e) {
    vr[e] = new Ur(e, 6, !1, e, null, !1, !1)
  })
  ;['rowSpan', 'start'].forEach(function (e) {
    vr[e] = new Ur(e, 5, !1, e.toLowerCase(), null, !1, !1)
  })
  var ud = /[\-:]([a-z])/g
  function ld(e) {
    return e[1].toUpperCase()
  }
  'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
    .split(' ')
    .forEach(function (e) {
      var r = e.replace(ud, ld)
      vr[r] = new Ur(r, 1, !1, e, null, !1, !1)
    })
  'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'.split(' ').forEach(function (e) {
    var r = e.replace(ud, ld)
    vr[r] = new Ur(r, 1, !1, e, 'http://www.w3.org/1999/xlink', !1, !1)
  })
  ;['xml:base', 'xml:lang', 'xml:space'].forEach(function (e) {
    var r = e.replace(ud, ld)
    vr[r] = new Ur(r, 1, !1, e, 'http://www.w3.org/XML/1998/namespace', !1, !1)
  })
  ;['tabIndex', 'crossOrigin'].forEach(function (e) {
    vr[e] = new Ur(e, 1, !1, e.toLowerCase(), null, !1, !1)
  })
  vr.xlinkHref = new Ur('xlinkHref', 1, !1, 'xlink:href', 'http://www.w3.org/1999/xlink', !0, !1)
  ;['src', 'href', 'action', 'formAction'].forEach(function (e) {
    vr[e] = new Ur(e, 1, !1, e.toLowerCase(), null, !0, !0)
  })
  function fd(e, r, t, n) {
    var i = vr.hasOwnProperty(r) ? vr[r] : null,
      s =
        i !== null
          ? i.type === 0
          : n
          ? !1
          : !(!(2 < r.length) || (r[0] !== 'o' && r[0] !== 'O') || (r[1] !== 'n' && r[1] !== 'N'))
    s ||
      (IM(r, t, i, n) && (t = null),
      n || i === null
        ? SM(r) && (t === null ? e.removeAttribute(r) : e.setAttribute(r, '' + t))
        : i.mustUseProperty
        ? (e[i.propertyName] = t === null ? (i.type === 3 ? !1 : '') : t)
        : ((r = i.attributeName),
          (n = i.attributeNamespace),
          t === null
            ? e.removeAttribute(r)
            : ((i = i.type),
              (t = i === 3 || (i === 4 && t === !0) ? '' : '' + t),
              n ? e.setAttributeNS(n, r, t) : e.setAttribute(r, t))))
  }
  var Gi = ku.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    ha = 60103,
    Wi = 60106,
    bi = 60107,
    dd = 60108,
    pa = 60114,
    hd = 60109,
    pd = 60110,
    Mu = 60112,
    ma = 60113,
    xu = 60120,
    Ru = 60115,
    md = 60116,
    bd = 60121,
    yd = 60128,
    jm = 60129,
    vd = 60130,
    gd = 60131
  typeof Symbol == 'function' &&
    Symbol.for &&
    ((ir = Symbol.for),
    (ha = ir('react.element')),
    (Wi = ir('react.portal')),
    (bi = ir('react.fragment')),
    (dd = ir('react.strict_mode')),
    (pa = ir('react.profiler')),
    (hd = ir('react.provider')),
    (pd = ir('react.context')),
    (Mu = ir('react.forward_ref')),
    (ma = ir('react.suspense')),
    (xu = ir('react.suspense_list')),
    (Ru = ir('react.memo')),
    (md = ir('react.lazy')),
    (bd = ir('react.block')),
    ir('react.scope'),
    (yd = ir('react.opaque.id')),
    (jm = ir('react.debug_trace_mode')),
    (vd = ir('react.offscreen')),
    (gd = ir('react.legacy_hidden')))
  var ir,
    zm = typeof Symbol == 'function' && Symbol.iterator
  function ba(e) {
    return e === null || typeof e != 'object'
      ? null
      : ((e = (zm && e[zm]) || e['@@iterator']), typeof e == 'function' ? e : null)
  }
  var wd
  function ya(e) {
    if (wd === void 0)
      try {
        throw Error()
      } catch (t) {
        var r = t.stack.trim().match(/\n( *(at )?)/)
        wd = (r && r[1]) || ''
      }
    return (
      `
` +
      wd +
      e
    )
  }
  var _d = !1
  function Bu(e, r) {
    if (!e || _d) return ''
    _d = !0
    var t = Error.prepareStackTrace
    Error.prepareStackTrace = void 0
    try {
      if (r)
        if (
          ((r = function () {
            throw Error()
          }),
          Object.defineProperty(r.prototype, 'props', {
            set: function () {
              throw Error()
            }
          }),
          typeof Reflect == 'object' && Reflect.construct)
        ) {
          try {
            Reflect.construct(r, [])
          } catch (l) {
            var n = l
          }
          Reflect.construct(e, [], r)
        } else {
          try {
            r.call()
          } catch (l) {
            n = l
          }
          e.call(r.prototype)
        }
      else {
        try {
          throw Error()
        } catch (l) {
          n = l
        }
        e()
      }
    } catch (l) {
      if (l && n && typeof l.stack == 'string') {
        for (
          var i = l.stack.split(`
`),
            s = n.stack.split(`
`),
            u = i.length - 1,
            o = s.length - 1;
          1 <= u && 0 <= o && i[u] !== s[o];

        )
          o--
        for (; 1 <= u && 0 <= o; u--, o--)
          if (i[u] !== s[o]) {
            if (u !== 1 || o !== 1)
              do
                if ((u--, o--, 0 > o || i[u] !== s[o]))
                  return (
                    `
` + i[u].replace(' at new ', ' at ')
                  )
              while (1 <= u && 0 <= o)
            break
          }
      }
    } finally {
      ;(_d = !1), (Error.prepareStackTrace = t)
    }
    return (e = e ? e.displayName || e.name : '') ? ya(e) : ''
  }
  function TM(e) {
    switch (e.tag) {
      case 5:
        return ya(e.type)
      case 16:
        return ya('Lazy')
      case 13:
        return ya('Suspense')
      case 19:
        return ya('SuspenseList')
      case 0:
      case 2:
      case 15:
        return (e = Bu(e.type, !1)), e
      case 11:
        return (e = Bu(e.type.render, !1)), e
      case 22:
        return (e = Bu(e.type._render, !1)), e
      case 1:
        return (e = Bu(e.type, !0)), e
      default:
        return ''
    }
  }
  function Ks(e) {
    if (e == null) return null
    if (typeof e == 'function') return e.displayName || e.name || null
    if (typeof e == 'string') return e
    switch (e) {
      case bi:
        return 'Fragment'
      case Wi:
        return 'Portal'
      case pa:
        return 'Profiler'
      case dd:
        return 'StrictMode'
      case ma:
        return 'Suspense'
      case xu:
        return 'SuspenseList'
    }
    if (typeof e == 'object')
      switch (e.$$typeof) {
        case pd:
          return (e.displayName || 'Context') + '.Consumer'
        case hd:
          return (e._context.displayName || 'Context') + '.Provider'
        case Mu:
          var r = e.render
          return (
            (r = r.displayName || r.name || ''), e.displayName || (r !== '' ? 'ForwardRef(' + r + ')' : 'ForwardRef')
          )
        case Ru:
          return Ks(e.type)
        case bd:
          return Ks(e._render)
        case md:
          ;(r = e._payload), (e = e._init)
          try {
            return Ks(e(r))
          } catch (t) {}
      }
    return null
  }
  function yi(e) {
    switch (typeof e) {
      case 'boolean':
      case 'number':
      case 'object':
      case 'string':
      case 'undefined':
        return e
      default:
        return ''
    }
  }
  function Km(e) {
    var r = e.type
    return (e = e.nodeName) && e.toLowerCase() === 'input' && (r === 'checkbox' || r === 'radio')
  }
  function CM(e) {
    var r = Km(e) ? 'checked' : 'value',
      t = Object.getOwnPropertyDescriptor(e.constructor.prototype, r),
      n = '' + e[r]
    if (!e.hasOwnProperty(r) && typeof t != 'undefined' && typeof t.get == 'function' && typeof t.set == 'function') {
      var i = t.get,
        s = t.set
      return (
        Object.defineProperty(e, r, {
          configurable: !0,
          get: function () {
            return i.call(this)
          },
          set: function (u) {
            ;(n = '' + u), s.call(this, u)
          }
        }),
        Object.defineProperty(e, r, { enumerable: t.enumerable }),
        {
          getValue: function () {
            return n
          },
          setValue: function (u) {
            n = '' + u
          },
          stopTracking: function () {
            ;(e._valueTracker = null), delete e[r]
          }
        }
      )
    }
  }
  function Nu(e) {
    e._valueTracker || (e._valueTracker = CM(e))
  }
  function Fm(e) {
    if (!e) return !1
    var r = e._valueTracker
    if (!r) return !0
    var t = r.getValue(),
      n = ''
    return e && (n = Km(e) ? (e.checked ? 'true' : 'false') : e.value), (e = n), e !== t ? (r.setValue(e), !0) : !1
  }
  function Pu(e) {
    if (((e = e || (typeof document != 'undefined' ? document : void 0)), typeof e == 'undefined')) return null
    try {
      return e.activeElement || e.body
    } catch (r) {
      return e.body
    }
  }
  function Ed(e, r) {
    var t = r.checked
    return Wt({}, r, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: t ?? e._wrapperState.initialChecked
    })
  }
  function Vm(e, r) {
    var t = r.defaultValue == null ? '' : r.defaultValue,
      n = r.checked != null ? r.checked : r.defaultChecked
    ;(t = yi(r.value != null ? r.value : t)),
      (e._wrapperState = {
        initialChecked: n,
        initialValue: t,
        controlled: r.type === 'checkbox' || r.type === 'radio' ? r.checked != null : r.value != null
      })
  }
  function Hm(e, r) {
    ;(r = r.checked), r != null && fd(e, 'checked', r, !1)
  }
  function Sd(e, r) {
    Hm(e, r)
    var t = yi(r.value),
      n = r.type
    if (t != null)
      n === 'number'
        ? ((t === 0 && e.value === '') || e.value != t) && (e.value = '' + t)
        : e.value !== '' + t && (e.value = '' + t)
    else if (n === 'submit' || n === 'reset') {
      e.removeAttribute('value')
      return
    }
    r.hasOwnProperty('value')
      ? Ad(e, r.type, t)
      : r.hasOwnProperty('defaultValue') && Ad(e, r.type, yi(r.defaultValue)),
      r.checked == null && r.defaultChecked != null && (e.defaultChecked = !!r.defaultChecked)
  }
  function $m(e, r, t) {
    if (r.hasOwnProperty('value') || r.hasOwnProperty('defaultValue')) {
      var n = r.type
      if (!((n !== 'submit' && n !== 'reset') || (r.value !== void 0 && r.value !== null))) return
      ;(r = '' + e._wrapperState.initialValue), t || r === e.value || (e.value = r), (e.defaultValue = r)
    }
    ;(t = e.name),
      t !== '' && (e.name = ''),
      (e.defaultChecked = !!e._wrapperState.initialChecked),
      t !== '' && (e.name = t)
  }
  function Ad(e, r, t) {
    ;(r !== 'number' || Pu(e.ownerDocument) !== e) &&
      (t == null
        ? (e.defaultValue = '' + e._wrapperState.initialValue)
        : e.defaultValue !== '' + t && (e.defaultValue = '' + t))
  }
  function kM(e) {
    var r = ''
    return (
      ku.Children.forEach(e, function (t) {
        t != null && (r += t)
      }),
      r
    )
  }
  function Id(e, r) {
    return (e = Wt({ children: void 0 }, r)), (r = kM(r.children)) && (e.children = r), e
  }
  function Fs(e, r, t, n) {
    if (((e = e.options), r)) {
      r = {}
      for (var i = 0; i < t.length; i++) r['$' + t[i]] = !0
      for (t = 0; t < e.length; t++)
        (i = r.hasOwnProperty('$' + e[t].value)),
          e[t].selected !== i && (e[t].selected = i),
          i && n && (e[t].defaultSelected = !0)
    } else {
      for (t = '' + yi(t), r = null, i = 0; i < e.length; i++) {
        if (e[i].value === t) {
          ;(e[i].selected = !0), n && (e[i].defaultSelected = !0)
          return
        }
        r !== null || e[i].disabled || (r = e[i])
      }
      r !== null && (r.selected = !0)
    }
  }
  function Td(e, r) {
    if (r.dangerouslySetInnerHTML != null) throw Error(Ke(91))
    return Wt({}, r, { value: void 0, defaultValue: void 0, children: '' + e._wrapperState.initialValue })
  }
  function Gm(e, r) {
    var t = r.value
    if (t == null) {
      if (((t = r.children), (r = r.defaultValue), t != null)) {
        if (r != null) throw Error(Ke(92))
        if (Array.isArray(t)) {
          if (!(1 >= t.length)) throw Error(Ke(93))
          t = t[0]
        }
        r = t
      }
      r == null && (r = ''), (t = r)
    }
    e._wrapperState = { initialValue: yi(t) }
  }
  function Wm(e, r) {
    var t = yi(r.value),
      n = yi(r.defaultValue)
    t != null &&
      ((t = '' + t),
      t !== e.value && (e.value = t),
      r.defaultValue == null && e.defaultValue !== t && (e.defaultValue = t)),
      n != null && (e.defaultValue = '' + n)
  }
  function Jm(e) {
    var r = e.textContent
    r === e._wrapperState.initialValue && r !== '' && r !== null && (e.value = r)
  }
  var Cd = {
    html: 'http://www.w3.org/1999/xhtml',
    mathml: 'http://www.w3.org/1998/Math/MathML',
    svg: 'http://www.w3.org/2000/svg'
  }
  function Xm(e) {
    switch (e) {
      case 'svg':
        return 'http://www.w3.org/2000/svg'
      case 'math':
        return 'http://www.w3.org/1998/Math/MathML'
      default:
        return 'http://www.w3.org/1999/xhtml'
    }
  }
  function kd(e, r) {
    return e == null || e === 'http://www.w3.org/1999/xhtml'
      ? Xm(r)
      : e === 'http://www.w3.org/2000/svg' && r === 'foreignObject'
      ? 'http://www.w3.org/1999/xhtml'
      : e
  }
  var Ou,
    Ym = (function (e) {
      return typeof MSApp != 'undefined' && MSApp.execUnsafeLocalFunction
        ? function (r, t, n, i) {
            MSApp.execUnsafeLocalFunction(function () {
              return e(r, t, n, i)
            })
          }
        : e
    })(function (e, r) {
      if (e.namespaceURI !== Cd.svg || 'innerHTML' in e) e.innerHTML = r
      else {
        for (
          Ou = Ou || document.createElement('div'),
            Ou.innerHTML = '<svg>' + r.valueOf().toString() + '</svg>',
            r = Ou.firstChild;
          e.firstChild;

        )
          e.removeChild(e.firstChild)
        for (; r.firstChild; ) e.appendChild(r.firstChild)
      }
    })
  function va(e, r) {
    if (r) {
      var t = e.firstChild
      if (t && t === e.lastChild && t.nodeType === 3) {
        t.nodeValue = r
        return
      }
    }
    e.textContent = r
  }
  var ga = {
      animationIterationCount: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    },
    MM = ['Webkit', 'ms', 'Moz', 'O']
  Object.keys(ga).forEach(function (e) {
    MM.forEach(function (r) {
      ;(r = r + e.charAt(0).toUpperCase() + e.substring(1)), (ga[r] = ga[e])
    })
  })
  function Zm(e, r, t) {
    return r == null || typeof r == 'boolean' || r === ''
      ? ''
      : t || typeof r != 'number' || r === 0 || (ga.hasOwnProperty(e) && ga[e])
      ? ('' + r).trim()
      : r + 'px'
  }
  function Qm(e, r) {
    e = e.style
    for (var t in r)
      if (r.hasOwnProperty(t)) {
        var n = t.indexOf('--') === 0,
          i = Zm(t, r[t], n)
        t === 'float' && (t = 'cssFloat'), n ? e.setProperty(t, i) : (e[t] = i)
      }
  }
  var xM = Wt(
    { menuitem: !0 },
    {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
    }
  )
  function Md(e, r) {
    if (r) {
      if (xM[e] && (r.children != null || r.dangerouslySetInnerHTML != null)) throw Error(Ke(137, e))
      if (r.dangerouslySetInnerHTML != null) {
        if (r.children != null) throw Error(Ke(60))
        if (!(typeof r.dangerouslySetInnerHTML == 'object' && '__html' in r.dangerouslySetInnerHTML))
          throw Error(Ke(61))
      }
      if (r.style != null && typeof r.style != 'object') throw Error(Ke(62))
    }
  }
  function xd(e, r) {
    if (e.indexOf('-') === -1) return typeof r.is == 'string'
    switch (e) {
      case 'annotation-xml':
      case 'color-profile':
      case 'font-face':
      case 'font-face-src':
      case 'font-face-uri':
      case 'font-face-format':
      case 'font-face-name':
      case 'missing-glyph':
        return !1
      default:
        return !0
    }
  }
  function Rd(e) {
    return (
      (e = e.target || e.srcElement || window),
      e.correspondingUseElement && (e = e.correspondingUseElement),
      e.nodeType === 3 ? e.parentNode : e
    )
  }
  var Bd = null,
    Vs = null,
    Hs = null
  function eb(e) {
    if ((e = La(e))) {
      if (typeof Bd != 'function') throw Error(Ke(280))
      var r = e.stateNode
      r && ((r = rl(r)), Bd(e.stateNode, e.type, r))
    }
  }
  function tb(e) {
    Vs ? (Hs ? Hs.push(e) : (Hs = [e])) : (Vs = e)
  }
  function rb() {
    if (Vs) {
      var e = Vs,
        r = Hs
      if (((Hs = Vs = null), eb(e), r)) for (e = 0; e < r.length; e++) eb(r[e])
    }
  }
  function Nd(e, r) {
    return e(r)
  }
  function nb(e, r, t, n, i) {
    return e(r, t, n, i)
  }
  function Pd() {}
  var ib = Nd,
    Ji = !1,
    Od = !1
  function Dd() {
    ;(Vs !== null || Hs !== null) && (Pd(), rb())
  }
  function RM(e, r, t) {
    if (Od) return e(r, t)
    Od = !0
    try {
      return ib(e, r, t)
    } finally {
      ;(Od = !1), Dd()
    }
  }
  function wa(e, r) {
    var t = e.stateNode
    if (t === null) return null
    var n = rl(t)
    if (n === null) return null
    t = n[r]
    e: switch (r) {
      case 'onClick':
      case 'onClickCapture':
      case 'onDoubleClick':
      case 'onDoubleClickCapture':
      case 'onMouseDown':
      case 'onMouseDownCapture':
      case 'onMouseMove':
      case 'onMouseMoveCapture':
      case 'onMouseUp':
      case 'onMouseUpCapture':
      case 'onMouseEnter':
        ;(n = !n.disabled) ||
          ((e = e.type), (n = !(e === 'button' || e === 'input' || e === 'select' || e === 'textarea'))),
          (e = !n)
        break e
      default:
        e = !1
    }
    if (e) return null
    if (t && typeof t != 'function') throw Error(Ke(231, r, typeof t))
    return t
  }
  var Ld = !1
  if ($n)
    try {
      ;($s = {}),
        Object.defineProperty($s, 'passive', {
          get: function () {
            Ld = !0
          }
        }),
        window.addEventListener('test', $s, $s),
        window.removeEventListener('test', $s, $s)
    } catch (e) {
      Ld = !1
    }
  var $s
  function BM(e, r, t, n, i, s, u, o, l) {
    var a = Array.prototype.slice.call(arguments, 3)
    try {
      r.apply(t, a)
    } catch (c) {
      this.onError(c)
    }
  }
  var _a = !1,
    Du = null,
    Lu = !1,
    Ud = null,
    NM = {
      onError: function (e) {
        ;(_a = !0), (Du = e)
      }
    }
  function PM(e, r, t, n, i, s, u, o, l) {
    ;(_a = !1), (Du = null), BM.apply(NM, arguments)
  }
  function OM(e, r, t, n, i, s, u, o, l) {
    if ((PM.apply(this, arguments), _a)) {
      if (_a) {
        var a = Du
        ;(_a = !1), (Du = null)
      } else throw Error(Ke(198))
      Lu || ((Lu = !0), (Ud = a))
    }
  }
  function Xi(e) {
    var r = e,
      t = e
    if (e.alternate) for (; r.return; ) r = r.return
    else {
      e = r
      do (r = e), (r.flags & 1026) != 0 && (t = r.return), (e = r.return)
      while (e)
    }
    return r.tag === 3 ? t : null
  }
  function sb(e) {
    if (e.tag === 13) {
      var r = e.memoizedState
      if ((r === null && ((e = e.alternate), e !== null && (r = e.memoizedState)), r !== null)) return r.dehydrated
    }
    return null
  }
  function ob(e) {
    if (Xi(e) !== e) throw Error(Ke(188))
  }
  function DM(e) {
    var r = e.alternate
    if (!r) {
      if (((r = Xi(e)), r === null)) throw Error(Ke(188))
      return r !== e ? null : e
    }
    for (var t = e, n = r; ; ) {
      var i = t.return
      if (i === null) break
      var s = i.alternate
      if (s === null) {
        if (((n = i.return), n !== null)) {
          t = n
          continue
        }
        break
      }
      if (i.child === s.child) {
        for (s = i.child; s; ) {
          if (s === t) return ob(i), e
          if (s === n) return ob(i), r
          s = s.sibling
        }
        throw Error(Ke(188))
      }
      if (t.return !== n.return) (t = i), (n = s)
      else {
        for (var u = !1, o = i.child; o; ) {
          if (o === t) {
            ;(u = !0), (t = i), (n = s)
            break
          }
          if (o === n) {
            ;(u = !0), (n = i), (t = s)
            break
          }
          o = o.sibling
        }
        if (!u) {
          for (o = s.child; o; ) {
            if (o === t) {
              ;(u = !0), (t = s), (n = i)
              break
            }
            if (o === n) {
              ;(u = !0), (n = s), (t = i)
              break
            }
            o = o.sibling
          }
          if (!u) throw Error(Ke(189))
        }
      }
      if (t.alternate !== n) throw Error(Ke(190))
    }
    if (t.tag !== 3) throw Error(Ke(188))
    return t.stateNode.current === t ? e : r
  }
  function ab(e) {
    if (((e = DM(e)), !e)) return null
    for (var r = e; ; ) {
      if (r.tag === 5 || r.tag === 6) return r
      if (r.child) (r.child.return = r), (r = r.child)
      else {
        if (r === e) break
        for (; !r.sibling; ) {
          if (!r.return || r.return === e) return null
          r = r.return
        }
        ;(r.sibling.return = r.return), (r = r.sibling)
      }
    }
    return null
  }
  function cb(e, r) {
    for (var t = e.alternate; r !== null; ) {
      if (r === e || r === t) return !0
      r = r.return
    }
    return !1
  }
  var ub,
    qd,
    lb,
    fb,
    jd = !1,
    Tn = [],
    vi = null,
    gi = null,
    wi = null,
    Ea = new Map(),
    Sa = new Map(),
    Aa = [],
    db =
      'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
        ' '
      )
  function zd(e, r, t, n, i) {
    return { blockedOn: e, domEventName: r, eventSystemFlags: t | 16, nativeEvent: i, targetContainers: [n] }
  }
  function hb(e, r) {
    switch (e) {
      case 'focusin':
      case 'focusout':
        vi = null
        break
      case 'dragenter':
      case 'dragleave':
        gi = null
        break
      case 'mouseover':
      case 'mouseout':
        wi = null
        break
      case 'pointerover':
      case 'pointerout':
        Ea.delete(r.pointerId)
        break
      case 'gotpointercapture':
      case 'lostpointercapture':
        Sa.delete(r.pointerId)
    }
  }
  function Ia(e, r, t, n, i, s) {
    return e === null || e.nativeEvent !== s
      ? ((e = zd(r, t, n, i, s)), r !== null && ((r = La(r)), r !== null && qd(r)), e)
      : ((e.eventSystemFlags |= n), (r = e.targetContainers), i !== null && r.indexOf(i) === -1 && r.push(i), e)
  }
  function LM(e, r, t, n, i) {
    switch (r) {
      case 'focusin':
        return (vi = Ia(vi, e, r, t, n, i)), !0
      case 'dragenter':
        return (gi = Ia(gi, e, r, t, n, i)), !0
      case 'mouseover':
        return (wi = Ia(wi, e, r, t, n, i)), !0
      case 'pointerover':
        var s = i.pointerId
        return Ea.set(s, Ia(Ea.get(s) || null, e, r, t, n, i)), !0
      case 'gotpointercapture':
        return (s = i.pointerId), Sa.set(s, Ia(Sa.get(s) || null, e, r, t, n, i)), !0
    }
    return !1
  }
  function UM(e) {
    var r = Yi(e.target)
    if (r !== null) {
      var t = Xi(r)
      if (t !== null) {
        if (((r = t.tag), r === 13)) {
          if (((r = sb(t)), r !== null)) {
            ;(e.blockedOn = r),
              fb(e.lanePriority, function () {
                cr.unstable_runWithPriority(e.priority, function () {
                  lb(t)
                })
              })
            return
          }
        } else if (r === 3 && t.stateNode.hydrate) {
          e.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null
          return
        }
      }
    }
    e.blockedOn = null
  }
  function Uu(e) {
    if (e.blockedOn !== null) return !1
    for (var r = e.targetContainers; 0 < r.length; ) {
      var t = Gd(e.domEventName, e.eventSystemFlags, r[0], e.nativeEvent)
      if (t !== null) return (r = La(t)), r !== null && qd(r), (e.blockedOn = t), !1
      r.shift()
    }
    return !0
  }
  function pb(e, r, t) {
    Uu(e) && t.delete(r)
  }
  function qM() {
    for (jd = !1; 0 < Tn.length; ) {
      var e = Tn[0]
      if (e.blockedOn !== null) {
        ;(e = La(e.blockedOn)), e !== null && ub(e)
        break
      }
      for (var r = e.targetContainers; 0 < r.length; ) {
        var t = Gd(e.domEventName, e.eventSystemFlags, r[0], e.nativeEvent)
        if (t !== null) {
          e.blockedOn = t
          break
        }
        r.shift()
      }
      e.blockedOn === null && Tn.shift()
    }
    vi !== null && Uu(vi) && (vi = null),
      gi !== null && Uu(gi) && (gi = null),
      wi !== null && Uu(wi) && (wi = null),
      Ea.forEach(pb),
      Sa.forEach(pb)
  }
  function Ta(e, r) {
    e.blockedOn === r &&
      ((e.blockedOn = null), jd || ((jd = !0), cr.unstable_scheduleCallback(cr.unstable_NormalPriority, qM)))
  }
  function mb(e) {
    function r(i) {
      return Ta(i, e)
    }
    if (0 < Tn.length) {
      Ta(Tn[0], e)
      for (var t = 1; t < Tn.length; t++) {
        var n = Tn[t]
        n.blockedOn === e && (n.blockedOn = null)
      }
    }
    for (
      vi !== null && Ta(vi, e), gi !== null && Ta(gi, e), wi !== null && Ta(wi, e), Ea.forEach(r), Sa.forEach(r), t = 0;
      t < Aa.length;
      t++
    )
      (n = Aa[t]), n.blockedOn === e && (n.blockedOn = null)
    for (; 0 < Aa.length && ((t = Aa[0]), t.blockedOn === null); ) UM(t), t.blockedOn === null && Aa.shift()
  }
  function qu(e, r) {
    var t = {}
    return (t[e.toLowerCase()] = r.toLowerCase()), (t['Webkit' + e] = 'webkit' + r), (t['Moz' + e] = 'moz' + r), t
  }
  var Gs = {
      animationend: qu('Animation', 'AnimationEnd'),
      animationiteration: qu('Animation', 'AnimationIteration'),
      animationstart: qu('Animation', 'AnimationStart'),
      transitionend: qu('Transition', 'TransitionEnd')
    },
    Kd = {},
    bb = {}
  $n &&
    ((bb = document.createElement('div').style),
    'AnimationEvent' in window ||
      (delete Gs.animationend.animation, delete Gs.animationiteration.animation, delete Gs.animationstart.animation),
    'TransitionEvent' in window || delete Gs.transitionend.transition)
  function ju(e) {
    if (Kd[e]) return Kd[e]
    if (!Gs[e]) return e
    var r = Gs[e],
      t
    for (t in r) if (r.hasOwnProperty(t) && t in bb) return (Kd[e] = r[t])
    return e
  }
  var yb = ju('animationend'),
    vb = ju('animationiteration'),
    gb = ju('animationstart'),
    wb = ju('transitionend'),
    _b = new Map(),
    Fd = new Map(),
    jM = [
      'abort',
      'abort',
      yb,
      'animationEnd',
      vb,
      'animationIteration',
      gb,
      'animationStart',
      'canplay',
      'canPlay',
      'canplaythrough',
      'canPlayThrough',
      'durationchange',
      'durationChange',
      'emptied',
      'emptied',
      'encrypted',
      'encrypted',
      'ended',
      'ended',
      'error',
      'error',
      'gotpointercapture',
      'gotPointerCapture',
      'load',
      'load',
      'loadeddata',
      'loadedData',
      'loadedmetadata',
      'loadedMetadata',
      'loadstart',
      'loadStart',
      'lostpointercapture',
      'lostPointerCapture',
      'playing',
      'playing',
      'progress',
      'progress',
      'seeking',
      'seeking',
      'stalled',
      'stalled',
      'suspend',
      'suspend',
      'timeupdate',
      'timeUpdate',
      wb,
      'transitionEnd',
      'waiting',
      'waiting'
    ]
  function Vd(e, r) {
    for (var t = 0; t < e.length; t += 2) {
      var n = e[t],
        i = e[t + 1]
      ;(i = 'on' + (i[0].toUpperCase() + i.slice(1))), Fd.set(n, r), _b.set(n, i), $i(i, [n])
    }
  }
  var zM = cr.unstable_now
  zM()
  var jt = 8
  function Ws(e) {
    if ((1 & e) != 0) return (jt = 15), 1
    if ((2 & e) != 0) return (jt = 14), 2
    if ((4 & e) != 0) return (jt = 13), 4
    var r = 24 & e
    return r !== 0
      ? ((jt = 12), r)
      : (e & 32) != 0
      ? ((jt = 11), 32)
      : ((r = 192 & e),
        r !== 0
          ? ((jt = 10), r)
          : (e & 256) != 0
          ? ((jt = 9), 256)
          : ((r = 3584 & e),
            r !== 0
              ? ((jt = 8), r)
              : (e & 4096) != 0
              ? ((jt = 7), 4096)
              : ((r = 4186112 & e),
                r !== 0
                  ? ((jt = 6), r)
                  : ((r = 62914560 & e),
                    r !== 0
                      ? ((jt = 5), r)
                      : e & 67108864
                      ? ((jt = 4), 67108864)
                      : (e & 134217728) != 0
                      ? ((jt = 3), 134217728)
                      : ((r = 805306368 & e),
                        r !== 0 ? ((jt = 2), r) : (1073741824 & e) != 0 ? ((jt = 1), 1073741824) : ((jt = 8), e))))))
  }
  function KM(e) {
    switch (e) {
      case 99:
        return 15
      case 98:
        return 10
      case 97:
      case 96:
        return 8
      case 95:
        return 2
      default:
        return 0
    }
  }
  function FM(e) {
    switch (e) {
      case 15:
      case 14:
        return 99
      case 13:
      case 12:
      case 11:
      case 10:
        return 98
      case 9:
      case 8:
      case 7:
      case 6:
      case 4:
      case 5:
        return 97
      case 3:
      case 2:
      case 1:
        return 95
      case 0:
        return 90
      default:
        throw Error(Ke(358, e))
    }
  }
  function Ca(e, r) {
    var t = e.pendingLanes
    if (t === 0) return (jt = 0)
    var n = 0,
      i = 0,
      s = e.expiredLanes,
      u = e.suspendedLanes,
      o = e.pingedLanes
    if (s !== 0) (n = s), (i = jt = 15)
    else if (((s = t & 134217727), s !== 0)) {
      var l = s & ~u
      l !== 0 ? ((n = Ws(l)), (i = jt)) : ((o &= s), o !== 0 && ((n = Ws(o)), (i = jt)))
    } else (s = t & ~u), s !== 0 ? ((n = Ws(s)), (i = jt)) : o !== 0 && ((n = Ws(o)), (i = jt))
    if (n === 0) return 0
    if (((n = 31 - _i(n)), (n = t & (((0 > n ? 0 : 1 << n) << 1) - 1)), r !== 0 && r !== n && (r & u) == 0)) {
      if ((Ws(r), i <= jt)) return r
      jt = i
    }
    if (((r = e.entangledLanes), r !== 0))
      for (e = e.entanglements, r &= n; 0 < r; ) (t = 31 - _i(r)), (i = 1 << t), (n |= e[t]), (r &= ~i)
    return n
  }
  function Eb(e) {
    return (e = e.pendingLanes & -1073741825), e !== 0 ? e : e & 1073741824 ? 1073741824 : 0
  }
  function zu(e, r) {
    switch (e) {
      case 15:
        return 1
      case 14:
        return 2
      case 12:
        return (e = Js(24 & ~r)), e === 0 ? zu(10, r) : e
      case 10:
        return (e = Js(192 & ~r)), e === 0 ? zu(8, r) : e
      case 8:
        return (e = Js(3584 & ~r)), e === 0 && ((e = Js(4186112 & ~r)), e === 0 && (e = 512)), e
      case 2:
        return (r = Js(805306368 & ~r)), r === 0 && (r = 268435456), r
    }
    throw Error(Ke(358, e))
  }
  function Js(e) {
    return e & -e
  }
  function Hd(e) {
    for (var r = [], t = 0; 31 > t; t++) r.push(e)
    return r
  }
  function Ku(e, r, t) {
    e.pendingLanes |= r
    var n = r - 1
    ;(e.suspendedLanes &= n), (e.pingedLanes &= n), (e = e.eventTimes), (r = 31 - _i(r)), (e[r] = t)
  }
  var _i = Math.clz32 ? Math.clz32 : $M,
    VM = Math.log,
    HM = Math.LN2
  function $M(e) {
    return e === 0 ? 32 : (31 - ((VM(e) / HM) | 0)) | 0
  }
  var GM = cr.unstable_UserBlockingPriority,
    WM = cr.unstable_runWithPriority,
    Fu = !0
  function JM(e, r, t, n) {
    Ji || Pd()
    var i = $d,
      s = Ji
    Ji = !0
    try {
      nb(i, e, r, t, n)
    } finally {
      ;(Ji = s) || Dd()
    }
  }
  function XM(e, r, t, n) {
    WM(GM, $d.bind(null, e, r, t, n))
  }
  function $d(e, r, t, n) {
    if (Fu) {
      var i
      if ((i = (r & 4) == 0) && 0 < Tn.length && -1 < db.indexOf(e)) (e = zd(null, e, r, t, n)), Tn.push(e)
      else {
        var s = Gd(e, r, t, n)
        if (s === null) i && hb(e, n)
        else {
          if (i) {
            if (-1 < db.indexOf(e)) {
              ;(e = zd(s, e, r, t, n)), Tn.push(e)
              return
            }
            if (LM(s, e, r, t, n)) return
            hb(e, n)
          }
          Xb(e, r, n, null, t)
        }
      }
    }
  }
  function Gd(e, r, t, n) {
    var i = Rd(n)
    if (((i = Yi(i)), i !== null)) {
      var s = Xi(i)
      if (s === null) i = null
      else {
        var u = s.tag
        if (u === 13) {
          if (((i = sb(s)), i !== null)) return i
          i = null
        } else if (u === 3) {
          if (s.stateNode.hydrate) return s.tag === 3 ? s.stateNode.containerInfo : null
          i = null
        } else s !== i && (i = null)
      }
    }
    return Xb(e, r, n, i, t), null
  }
  var Ei = null,
    Wd = null,
    Vu = null
  function Sb() {
    if (Vu) return Vu
    var e,
      r = Wd,
      t = r.length,
      n,
      i = 'value' in Ei ? Ei.value : Ei.textContent,
      s = i.length
    for (e = 0; e < t && r[e] === i[e]; e++);
    var u = t - e
    for (n = 1; n <= u && r[t - n] === i[s - n]; n++);
    return (Vu = i.slice(e, 1 < n ? 1 - n : void 0))
  }
  function Hu(e) {
    var r = e.keyCode
    return (
      'charCode' in e ? ((e = e.charCode), e === 0 && r === 13 && (e = 13)) : (e = r),
      e === 10 && (e = 13),
      32 <= e || e === 13 ? e : 0
    )
  }
  function $u() {
    return !0
  }
  function Ab() {
    return !1
  }
  function Jr(e) {
    function r(t, n, i, s, u) {
      ;(this._reactName = t),
        (this._targetInst = i),
        (this.type = n),
        (this.nativeEvent = s),
        (this.target = u),
        (this.currentTarget = null)
      for (var o in e) e.hasOwnProperty(o) && ((t = e[o]), (this[o] = t ? t(s) : s[o]))
      return (
        (this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? $u : Ab),
        (this.isPropagationStopped = Ab),
        this
      )
    }
    return (
      Wt(r.prototype, {
        preventDefault: function () {
          this.defaultPrevented = !0
          var t = this.nativeEvent
          t &&
            (t.preventDefault ? t.preventDefault() : typeof t.returnValue != 'unknown' && (t.returnValue = !1),
            (this.isDefaultPrevented = $u))
        },
        stopPropagation: function () {
          var t = this.nativeEvent
          t &&
            (t.stopPropagation ? t.stopPropagation() : typeof t.cancelBubble != 'unknown' && (t.cancelBubble = !0),
            (this.isPropagationStopped = $u))
        },
        persist: function () {},
        isPersistent: $u
      }),
      r
    )
  }
  var Xs = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function (e) {
        return e.timeStamp || Date.now()
      },
      defaultPrevented: 0,
      isTrusted: 0
    },
    Jd = Jr(Xs),
    ka = Wt({}, Xs, { view: 0, detail: 0 }),
    YM = Jr(ka),
    Xd,
    Yd,
    Ma,
    Gu = Wt({}, ka, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Qd,
      button: 0,
      buttons: 0,
      relatedTarget: function (e) {
        return e.relatedTarget === void 0
          ? e.fromElement === e.srcElement
            ? e.toElement
            : e.fromElement
          : e.relatedTarget
      },
      movementX: function (e) {
        return 'movementX' in e
          ? e.movementX
          : (e !== Ma &&
              (Ma && e.type === 'mousemove'
                ? ((Xd = e.screenX - Ma.screenX), (Yd = e.screenY - Ma.screenY))
                : (Yd = Xd = 0),
              (Ma = e)),
            Xd)
      },
      movementY: function (e) {
        return 'movementY' in e ? e.movementY : Yd
      }
    }),
    Ib = Jr(Gu),
    ZM = Wt({}, Gu, { dataTransfer: 0 }),
    QM = Jr(ZM),
    ex = Wt({}, ka, { relatedTarget: 0 }),
    Zd = Jr(ex),
    tx = Wt({}, Xs, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
    rx = Jr(tx),
    nx = Wt({}, Xs, {
      clipboardData: function (e) {
        return 'clipboardData' in e ? e.clipboardData : window.clipboardData
      }
    }),
    ix = Jr(nx),
    sx = Wt({}, Xs, { data: 0 }),
    Tb = Jr(sx),
    ox = {
      Esc: 'Escape',
      Spacebar: ' ',
      Left: 'ArrowLeft',
      Up: 'ArrowUp',
      Right: 'ArrowRight',
      Down: 'ArrowDown',
      Del: 'Delete',
      Win: 'OS',
      Menu: 'ContextMenu',
      Apps: 'ContextMenu',
      Scroll: 'ScrollLock',
      MozPrintableKey: 'Unidentified'
    },
    ax = {
      8: 'Backspace',
      9: 'Tab',
      12: 'Clear',
      13: 'Enter',
      16: 'Shift',
      17: 'Control',
      18: 'Alt',
      19: 'Pause',
      20: 'CapsLock',
      27: 'Escape',
      32: ' ',
      33: 'PageUp',
      34: 'PageDown',
      35: 'End',
      36: 'Home',
      37: 'ArrowLeft',
      38: 'ArrowUp',
      39: 'ArrowRight',
      40: 'ArrowDown',
      45: 'Insert',
      46: 'Delete',
      112: 'F1',
      113: 'F2',
      114: 'F3',
      115: 'F4',
      116: 'F5',
      117: 'F6',
      118: 'F7',
      119: 'F8',
      120: 'F9',
      121: 'F10',
      122: 'F11',
      123: 'F12',
      144: 'NumLock',
      145: 'ScrollLock',
      224: 'Meta'
    },
    cx = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
  function ux(e) {
    var r = this.nativeEvent
    return r.getModifierState ? r.getModifierState(e) : (e = cx[e]) ? !!r[e] : !1
  }
  function Qd() {
    return ux
  }
  var lx = Wt({}, ka, {
      key: function (e) {
        if (e.key) {
          var r = ox[e.key] || e.key
          if (r !== 'Unidentified') return r
        }
        return e.type === 'keypress'
          ? ((e = Hu(e)), e === 13 ? 'Enter' : String.fromCharCode(e))
          : e.type === 'keydown' || e.type === 'keyup'
          ? ax[e.keyCode] || 'Unidentified'
          : ''
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Qd,
      charCode: function (e) {
        return e.type === 'keypress' ? Hu(e) : 0
      },
      keyCode: function (e) {
        return e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0
      },
      which: function (e) {
        return e.type === 'keypress' ? Hu(e) : e.type === 'keydown' || e.type === 'keyup' ? e.keyCode : 0
      }
    }),
    fx = Jr(lx),
    dx = Wt({}, Gu, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }),
    Cb = Jr(dx),
    hx = Wt({}, ka, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Qd
    }),
    px = Jr(hx),
    mx = Wt({}, Xs, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
    bx = Jr(mx),
    yx = Wt({}, Gu, {
      deltaX: function (e) {
        return 'deltaX' in e ? e.deltaX : 'wheelDeltaX' in e ? -e.wheelDeltaX : 0
      },
      deltaY: function (e) {
        return 'deltaY' in e ? e.deltaY : 'wheelDeltaY' in e ? -e.wheelDeltaY : 'wheelDelta' in e ? -e.wheelDelta : 0
      },
      deltaZ: 0,
      deltaMode: 0
    }),
    vx = Jr(yx),
    gx = [9, 13, 27, 32],
    eh = $n && 'CompositionEvent' in window,
    xa = null
  $n && 'documentMode' in document && (xa = document.documentMode)
  var wx = $n && 'TextEvent' in window && !xa,
    kb = $n && (!eh || (xa && 8 < xa && 11 >= xa)),
    Mb = String.fromCharCode(32),
    xb = !1
  function Rb(e, r) {
    switch (e) {
      case 'keyup':
        return gx.indexOf(r.keyCode) !== -1
      case 'keydown':
        return r.keyCode !== 229
      case 'keypress':
      case 'mousedown':
      case 'focusout':
        return !0
      default:
        return !1
    }
  }
  function Bb(e) {
    return (e = e.detail), typeof e == 'object' && 'data' in e ? e.data : null
  }
  var Ys = !1
  function _x(e, r) {
    switch (e) {
      case 'compositionend':
        return Bb(r)
      case 'keypress':
        return r.which !== 32 ? null : ((xb = !0), Mb)
      case 'textInput':
        return (e = r.data), e === Mb && xb ? null : e
      default:
        return null
    }
  }
  function Ex(e, r) {
    if (Ys)
      return e === 'compositionend' || (!eh && Rb(e, r)) ? ((e = Sb()), (Vu = Wd = Ei = null), (Ys = !1), e) : null
    switch (e) {
      case 'paste':
        return null
      case 'keypress':
        if (!(r.ctrlKey || r.altKey || r.metaKey) || (r.ctrlKey && r.altKey)) {
          if (r.char && 1 < r.char.length) return r.char
          if (r.which) return String.fromCharCode(r.which)
        }
        return null
      case 'compositionend':
        return kb && r.locale !== 'ko' ? null : r.data
      default:
        return null
    }
  }
  var Sx = {
    color: !0,
    date: !0,
    datetime: !0,
    'datetime-local': !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  }
  function Nb(e) {
    var r = e && e.nodeName && e.nodeName.toLowerCase()
    return r === 'input' ? !!Sx[e.type] : r === 'textarea'
  }
  function Pb(e, r, t, n) {
    tb(n),
      (r = Zu(r, 'onChange')),
      0 < r.length && ((t = new Jd('onChange', 'change', null, t, n)), e.push({ event: t, listeners: r }))
  }
  var Ra = null,
    Ba = null
  function Ax(e) {
    Hb(e, 0)
  }
  function Wu(e) {
    var r = ro(e)
    if (Fm(r)) return e
  }
  function Ix(e, r) {
    if (e === 'change') return r
  }
  var Ob = !1
  $n &&
    ($n
      ? ((Xu = 'oninput' in document),
        Xu ||
          ((th = document.createElement('div')),
          th.setAttribute('oninput', 'return;'),
          (Xu = typeof th.oninput == 'function')),
        (Ju = Xu))
      : (Ju = !1),
    (Ob = Ju && (!document.documentMode || 9 < document.documentMode)))
  var Ju, Xu, th
  function Db() {
    Ra && (Ra.detachEvent('onpropertychange', Lb), (Ba = Ra = null))
  }
  function Lb(e) {
    if (e.propertyName === 'value' && Wu(Ba)) {
      var r = []
      if ((Pb(r, Ba, e, Rd(e)), (e = Ax), Ji)) e(r)
      else {
        Ji = !0
        try {
          Nd(e, r)
        } finally {
          ;(Ji = !1), Dd()
        }
      }
    }
  }
  function Tx(e, r, t) {
    e === 'focusin' ? (Db(), (Ra = r), (Ba = t), Ra.attachEvent('onpropertychange', Lb)) : e === 'focusout' && Db()
  }
  function Cx(e) {
    if (e === 'selectionchange' || e === 'keyup' || e === 'keydown') return Wu(Ba)
  }
  function kx(e, r) {
    if (e === 'click') return Wu(r)
  }
  function Mx(e, r) {
    if (e === 'input' || e === 'change') return Wu(r)
  }
  function xx(e, r) {
    return (e === r && (e !== 0 || 1 / e == 1 / r)) || (e !== e && r !== r)
  }
  var rn = typeof Object.is == 'function' ? Object.is : xx,
    Rx = Object.prototype.hasOwnProperty
  function Na(e, r) {
    if (rn(e, r)) return !0
    if (typeof e != 'object' || e === null || typeof r != 'object' || r === null) return !1
    var t = Object.keys(e),
      n = Object.keys(r)
    if (t.length !== n.length) return !1
    for (n = 0; n < t.length; n++) if (!Rx.call(r, t[n]) || !rn(e[t[n]], r[t[n]])) return !1
    return !0
  }
  function Ub(e) {
    for (; e && e.firstChild; ) e = e.firstChild
    return e
  }
  function qb(e, r) {
    var t = Ub(e)
    e = 0
    for (var n; t; ) {
      if (t.nodeType === 3) {
        if (((n = e + t.textContent.length), e <= r && n >= r)) return { node: t, offset: r - e }
        e = n
      }
      e: {
        for (; t; ) {
          if (t.nextSibling) {
            t = t.nextSibling
            break e
          }
          t = t.parentNode
        }
        t = void 0
      }
      t = Ub(t)
    }
  }
  function jb(e, r) {
    return e && r
      ? e === r
        ? !0
        : e && e.nodeType === 3
        ? !1
        : r && r.nodeType === 3
        ? jb(e, r.parentNode)
        : 'contains' in e
        ? e.contains(r)
        : e.compareDocumentPosition
        ? !!(e.compareDocumentPosition(r) & 16)
        : !1
      : !1
  }
  function zb() {
    for (var e = window, r = Pu(); r instanceof e.HTMLIFrameElement; ) {
      try {
        var t = typeof r.contentWindow.location.href == 'string'
      } catch (n) {
        t = !1
      }
      if (t) e = r.contentWindow
      else break
      r = Pu(e.document)
    }
    return r
  }
  function rh(e) {
    var r = e && e.nodeName && e.nodeName.toLowerCase()
    return (
      r &&
      ((r === 'input' &&
        (e.type === 'text' || e.type === 'search' || e.type === 'tel' || e.type === 'url' || e.type === 'password')) ||
        r === 'textarea' ||
        e.contentEditable === 'true')
    )
  }
  var Bx = $n && 'documentMode' in document && 11 >= document.documentMode,
    Zs = null,
    nh = null,
    Pa = null,
    ih = !1
  function Kb(e, r, t) {
    var n = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument
    ih ||
      Zs == null ||
      Zs !== Pu(n) ||
      ((n = Zs),
      'selectionStart' in n && rh(n)
        ? (n = { start: n.selectionStart, end: n.selectionEnd })
        : ((n = ((n.ownerDocument && n.ownerDocument.defaultView) || window).getSelection()),
          (n = {
            anchorNode: n.anchorNode,
            anchorOffset: n.anchorOffset,
            focusNode: n.focusNode,
            focusOffset: n.focusOffset
          })),
      (Pa && Na(Pa, n)) ||
        ((Pa = n),
        (n = Zu(nh, 'onSelect')),
        0 < n.length &&
          ((r = new Jd('onSelect', 'select', null, r, t)), e.push({ event: r, listeners: n }), (r.target = Zs))))
  }
  Vd(
    'cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange'.split(
      ' '
    ),
    0
  )
  Vd(
    'drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel'.split(
      ' '
    ),
    1
  )
  Vd(jM, 2)
  for (
    sh = 'change selectionchange textInput compositionstart compositionend compositionupdate'.split(' '), Yu = 0;
    Yu < sh.length;
    Yu++
  )
    Fd.set(sh[Yu], 0)
  var sh, Yu
  zs('onMouseEnter', ['mouseout', 'mouseover'])
  zs('onMouseLeave', ['mouseout', 'mouseover'])
  zs('onPointerEnter', ['pointerout', 'pointerover'])
  zs('onPointerLeave', ['pointerout', 'pointerover'])
  $i('onChange', 'change click focusin focusout input keydown keyup selectionchange'.split(' '))
  $i('onSelect', 'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(' '))
  $i('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste'])
  $i('onCompositionEnd', 'compositionend focusout keydown keypress keyup mousedown'.split(' '))
  $i('onCompositionStart', 'compositionstart focusout keydown keypress keyup mousedown'.split(' '))
  $i('onCompositionUpdate', 'compositionupdate focusout keydown keypress keyup mousedown'.split(' '))
  var Oa =
      'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting'.split(
        ' '
      ),
    Fb = new Set('cancel close invalid load scroll toggle'.split(' ').concat(Oa))
  function Vb(e, r, t) {
    var n = e.type || 'unknown-event'
    ;(e.currentTarget = t), OM(n, r, void 0, e), (e.currentTarget = null)
  }
  function Hb(e, r) {
    r = (r & 4) != 0
    for (var t = 0; t < e.length; t++) {
      var n = e[t],
        i = n.event
      n = n.listeners
      e: {
        var s = void 0
        if (r)
          for (var u = n.length - 1; 0 <= u; u--) {
            var o = n[u],
              l = o.instance,
              a = o.currentTarget
            if (((o = o.listener), l !== s && i.isPropagationStopped())) break e
            Vb(i, o, a), (s = l)
          }
        else
          for (u = 0; u < n.length; u++) {
            if (
              ((o = n[u]),
              (l = o.instance),
              (a = o.currentTarget),
              (o = o.listener),
              l !== s && i.isPropagationStopped())
            )
              break e
            Vb(i, o, a), (s = l)
          }
      }
    }
    if (Lu) throw ((e = Ud), (Lu = !1), (Ud = null), e)
  }
  function Vt(e, r) {
    var t = ry(r),
      n = e + '__bubble'
    t.has(n) || (Jb(r, e, 2, !1), t.add(n))
  }
  var $b = '_reactListening' + Math.random().toString(36).slice(2)
  function Gb(e) {
    e[$b] ||
      ((e[$b] = !0),
      Dm.forEach(function (r) {
        Fb.has(r) || Wb(r, !1, e, null), Wb(r, !0, e, null)
      }))
  }
  function Wb(e, r, t, n) {
    var i = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0,
      s = t
    if ((e === 'selectionchange' && t.nodeType !== 9 && (s = t.ownerDocument), n !== null && !r && Fb.has(e))) {
      if (e !== 'scroll') return
      ;(i |= 2), (s = n)
    }
    var u = ry(s),
      o = e + '__' + (r ? 'capture' : 'bubble')
    u.has(o) || (r && (i |= 4), Jb(s, e, i, r), u.add(o))
  }
  function Jb(e, r, t, n) {
    var i = Fd.get(r)
    switch (i === void 0 ? 2 : i) {
      case 0:
        i = JM
        break
      case 1:
        i = XM
        break
      default:
        i = $d
    }
    ;(t = i.bind(null, r, t, e)),
      (i = void 0),
      !Ld || (r !== 'touchstart' && r !== 'touchmove' && r !== 'wheel') || (i = !0),
      n
        ? i !== void 0
          ? e.addEventListener(r, t, { capture: !0, passive: i })
          : e.addEventListener(r, t, !0)
        : i !== void 0
        ? e.addEventListener(r, t, { passive: i })
        : e.addEventListener(r, t, !1)
  }
  function Xb(e, r, t, n, i) {
    var s = n
    if ((r & 1) == 0 && (r & 2) == 0 && n !== null)
      e: for (;;) {
        if (n === null) return
        var u = n.tag
        if (u === 3 || u === 4) {
          var o = n.stateNode.containerInfo
          if (o === i || (o.nodeType === 8 && o.parentNode === i)) break
          if (u === 4)
            for (u = n.return; u !== null; ) {
              var l = u.tag
              if (
                (l === 3 || l === 4) &&
                ((l = u.stateNode.containerInfo), l === i || (l.nodeType === 8 && l.parentNode === i))
              )
                return
              u = u.return
            }
          for (; o !== null; ) {
            if (((u = Yi(o)), u === null)) return
            if (((l = u.tag), l === 5 || l === 6)) {
              n = s = u
              continue e
            }
            o = o.parentNode
          }
        }
        n = n.return
      }
    RM(function () {
      var a = s,
        c = Rd(t),
        f = []
      e: {
        var p = _b.get(e)
        if (p !== void 0) {
          var y = Jd,
            d = e
          switch (e) {
            case 'keypress':
              if (Hu(t) === 0) break e
            case 'keydown':
            case 'keyup':
              y = fx
              break
            case 'focusin':
              ;(d = 'focus'), (y = Zd)
              break
            case 'focusout':
              ;(d = 'blur'), (y = Zd)
              break
            case 'beforeblur':
            case 'afterblur':
              y = Zd
              break
            case 'click':
              if (t.button === 2) break e
            case 'auxclick':
            case 'dblclick':
            case 'mousedown':
            case 'mousemove':
            case 'mouseup':
            case 'mouseout':
            case 'mouseover':
            case 'contextmenu':
              y = Ib
              break
            case 'drag':
            case 'dragend':
            case 'dragenter':
            case 'dragexit':
            case 'dragleave':
            case 'dragover':
            case 'dragstart':
            case 'drop':
              y = QM
              break
            case 'touchcancel':
            case 'touchend':
            case 'touchmove':
            case 'touchstart':
              y = px
              break
            case yb:
            case vb:
            case gb:
              y = rx
              break
            case wb:
              y = bx
              break
            case 'scroll':
              y = YM
              break
            case 'wheel':
              y = vx
              break
            case 'copy':
            case 'cut':
            case 'paste':
              y = ix
              break
            case 'gotpointercapture':
            case 'lostpointercapture':
            case 'pointercancel':
            case 'pointerdown':
            case 'pointermove':
            case 'pointerout':
            case 'pointerover':
            case 'pointerup':
              y = Cb
          }
          var h = (r & 4) != 0,
            m = !h && e === 'scroll',
            _ = h ? (p !== null ? p + 'Capture' : null) : p
          h = []
          for (var A = a, T; A !== null; ) {
            T = A
            var E = T.stateNode
            if (
              (T.tag === 5 && E !== null && ((T = E), _ !== null && ((E = wa(A, _)), E != null && h.push(Da(A, E, T)))),
              m)
            )
              break
            A = A.return
          }
          0 < h.length && ((p = new y(p, d, null, t, c)), f.push({ event: p, listeners: h }))
        }
      }
      if ((r & 7) == 0) {
        e: {
          if (
            ((p = e === 'mouseover' || e === 'pointerover'),
            (y = e === 'mouseout' || e === 'pointerout'),
            p && (r & 16) == 0 && (d = t.relatedTarget || t.fromElement) && (Yi(d) || d[to]))
          )
            break e
          if (
            (y || p) &&
            ((p = c.window === c ? c : (p = c.ownerDocument) ? p.defaultView || p.parentWindow : window),
            y
              ? ((d = t.relatedTarget || t.toElement),
                (y = a),
                (d = d ? Yi(d) : null),
                d !== null && ((m = Xi(d)), d !== m || (d.tag !== 5 && d.tag !== 6)) && (d = null))
              : ((y = null), (d = a)),
            y !== d)
          ) {
            if (
              ((h = Ib),
              (E = 'onMouseLeave'),
              (_ = 'onMouseEnter'),
              (A = 'mouse'),
              (e === 'pointerout' || e === 'pointerover') &&
                ((h = Cb), (E = 'onPointerLeave'), (_ = 'onPointerEnter'), (A = 'pointer')),
              (m = y == null ? p : ro(y)),
              (T = d == null ? p : ro(d)),
              (p = new h(E, A + 'leave', y, t, c)),
              (p.target = m),
              (p.relatedTarget = T),
              (E = null),
              Yi(c) === a && ((h = new h(_, A + 'enter', d, t, c)), (h.target = T), (h.relatedTarget = m), (E = h)),
              (m = E),
              y && d)
            )
              t: {
                for (h = y, _ = d, A = 0, T = h; T; T = Qs(T)) A++
                for (T = 0, E = _; E; E = Qs(E)) T++
                for (; 0 < A - T; ) (h = Qs(h)), A--
                for (; 0 < T - A; ) (_ = Qs(_)), T--
                for (; A--; ) {
                  if (h === _ || (_ !== null && h === _.alternate)) break t
                  ;(h = Qs(h)), (_ = Qs(_))
                }
                h = null
              }
            else h = null
            y !== null && Yb(f, p, y, h, !1), d !== null && m !== null && Yb(f, m, d, h, !0)
          }
        }
        e: {
          if (
            ((p = a ? ro(a) : window),
            (y = p.nodeName && p.nodeName.toLowerCase()),
            y === 'select' || (y === 'input' && p.type === 'file'))
          )
            var k = Ix
          else if (Nb(p))
            if (Ob) k = Mx
            else {
              k = Cx
              var w = Tx
            }
          else
            (y = p.nodeName) && y.toLowerCase() === 'input' && (p.type === 'checkbox' || p.type === 'radio') && (k = kx)
          if (k && (k = k(e, a))) {
            Pb(f, k, t, c)
            break e
          }
          w && w(e, p, a),
            e === 'focusout' && (w = p._wrapperState) && w.controlled && p.type === 'number' && Ad(p, 'number', p.value)
        }
        switch (((w = a ? ro(a) : window), e)) {
          case 'focusin':
            ;(Nb(w) || w.contentEditable === 'true') && ((Zs = w), (nh = a), (Pa = null))
            break
          case 'focusout':
            Pa = nh = Zs = null
            break
          case 'mousedown':
            ih = !0
            break
          case 'contextmenu':
          case 'mouseup':
          case 'dragend':
            ;(ih = !1), Kb(f, t, c)
            break
          case 'selectionchange':
            if (Bx) break
          case 'keydown':
          case 'keyup':
            Kb(f, t, c)
        }
        var v
        if (eh)
          e: {
            switch (e) {
              case 'compositionstart':
                var I = 'onCompositionStart'
                break e
              case 'compositionend':
                I = 'onCompositionEnd'
                break e
              case 'compositionupdate':
                I = 'onCompositionUpdate'
                break e
            }
            I = void 0
          }
        else
          Ys ? Rb(e, t) && (I = 'onCompositionEnd') : e === 'keydown' && t.keyCode === 229 && (I = 'onCompositionStart')
        I &&
          (kb &&
            t.locale !== 'ko' &&
            (Ys || I !== 'onCompositionStart'
              ? I === 'onCompositionEnd' && Ys && (v = Sb())
              : ((Ei = c), (Wd = 'value' in Ei ? Ei.value : Ei.textContent), (Ys = !0))),
          (w = Zu(a, I)),
          0 < w.length &&
            ((I = new Tb(I, e, null, t, c)),
            f.push({ event: I, listeners: w }),
            v ? (I.data = v) : ((v = Bb(t)), v !== null && (I.data = v)))),
          (v = wx ? _x(e, t) : Ex(e, t)) &&
            ((a = Zu(a, 'onBeforeInput')),
            0 < a.length &&
              ((c = new Tb('onBeforeInput', 'beforeinput', null, t, c)),
              f.push({ event: c, listeners: a }),
              (c.data = v)))
      }
      Hb(f, r)
    })
  }
  function Da(e, r, t) {
    return { instance: e, listener: r, currentTarget: t }
  }
  function Zu(e, r) {
    for (var t = r + 'Capture', n = []; e !== null; ) {
      var i = e,
        s = i.stateNode
      i.tag === 5 &&
        s !== null &&
        ((i = s),
        (s = wa(e, t)),
        s != null && n.unshift(Da(e, s, i)),
        (s = wa(e, r)),
        s != null && n.push(Da(e, s, i))),
        (e = e.return)
    }
    return n
  }
  function Qs(e) {
    if (e === null) return null
    do e = e.return
    while (e && e.tag !== 5)
    return e || null
  }
  function Yb(e, r, t, n, i) {
    for (var s = r._reactName, u = []; t !== null && t !== n; ) {
      var o = t,
        l = o.alternate,
        a = o.stateNode
      if (l !== null && l === n) break
      o.tag === 5 &&
        a !== null &&
        ((o = a),
        i
          ? ((l = wa(t, s)), l != null && u.unshift(Da(t, l, o)))
          : i || ((l = wa(t, s)), l != null && u.push(Da(t, l, o)))),
        (t = t.return)
    }
    u.length !== 0 && e.push({ event: r, listeners: u })
  }
  function Qu() {}
  var oh = null,
    ah = null
  function Zb(e, r) {
    switch (e) {
      case 'button':
      case 'input':
      case 'select':
      case 'textarea':
        return !!r.autoFocus
    }
    return !1
  }
  function ch(e, r) {
    return (
      e === 'textarea' ||
      e === 'option' ||
      e === 'noscript' ||
      typeof r.children == 'string' ||
      typeof r.children == 'number' ||
      (typeof r.dangerouslySetInnerHTML == 'object' &&
        r.dangerouslySetInnerHTML !== null &&
        r.dangerouslySetInnerHTML.__html != null)
    )
  }
  var Qb = typeof setTimeout == 'function' ? setTimeout : void 0,
    Nx = typeof clearTimeout == 'function' ? clearTimeout : void 0
  function uh(e) {
    e.nodeType === 1 ? (e.textContent = '') : e.nodeType === 9 && ((e = e.body), e != null && (e.textContent = ''))
  }
  function eo(e) {
    for (; e != null; e = e.nextSibling) {
      var r = e.nodeType
      if (r === 1 || r === 3) break
    }
    return e
  }
  function ey(e) {
    e = e.previousSibling
    for (var r = 0; e; ) {
      if (e.nodeType === 8) {
        var t = e.data
        if (t === '$' || t === '$!' || t === '$?') {
          if (r === 0) return e
          r--
        } else t === '/$' && r++
      }
      e = e.previousSibling
    }
    return null
  }
  var lh = 0
  function Px(e) {
    return { $$typeof: yd, toString: e, valueOf: e }
  }
  var el = Math.random().toString(36).slice(2),
    Si = '__reactFiber$' + el,
    tl = '__reactProps$' + el,
    to = '__reactContainer$' + el,
    ty = '__reactEvents$' + el
  function Yi(e) {
    var r = e[Si]
    if (r) return r
    for (var t = e.parentNode; t; ) {
      if ((r = t[to] || t[Si])) {
        if (((t = r.alternate), r.child !== null || (t !== null && t.child !== null)))
          for (e = ey(e); e !== null; ) {
            if ((t = e[Si])) return t
            e = ey(e)
          }
        return r
      }
      ;(e = t), (t = e.parentNode)
    }
    return null
  }
  function La(e) {
    return (e = e[Si] || e[to]), !e || (e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3) ? null : e
  }
  function ro(e) {
    if (e.tag === 5 || e.tag === 6) return e.stateNode
    throw Error(Ke(33))
  }
  function rl(e) {
    return e[tl] || null
  }
  function ry(e) {
    var r = e[ty]
    return r === void 0 && (r = e[ty] = new Set()), r
  }
  var fh = [],
    no = -1
  function Ai(e) {
    return { current: e }
  }
  function Ht(e) {
    0 > no || ((e.current = fh[no]), (fh[no] = null), no--)
  }
  function Jt(e, r) {
    no++, (fh[no] = e.current), (e.current = r)
  }
  var Ii = {},
    Ar = Ai(Ii),
    Kr = Ai(!1),
    Zi = Ii
  function io(e, r) {
    var t = e.type.contextTypes
    if (!t) return Ii
    var n = e.stateNode
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === r) return n.__reactInternalMemoizedMaskedChildContext
    var i = {},
      s
    for (s in t) i[s] = r[s]
    return (
      n &&
        ((e = e.stateNode),
        (e.__reactInternalMemoizedUnmaskedChildContext = r),
        (e.__reactInternalMemoizedMaskedChildContext = i)),
      i
    )
  }
  function Fr(e) {
    return (e = e.childContextTypes), e != null
  }
  function nl() {
    Ht(Kr), Ht(Ar)
  }
  function ny(e, r, t) {
    if (Ar.current !== Ii) throw Error(Ke(168))
    Jt(Ar, r), Jt(Kr, t)
  }
  function iy(e, r, t) {
    var n = e.stateNode
    if (((e = r.childContextTypes), typeof n.getChildContext != 'function')) return t
    n = n.getChildContext()
    for (var i in n) if (!(i in e)) throw Error(Ke(108, Ks(r) || 'Unknown', i))
    return Wt({}, t, n)
  }
  function il(e) {
    return (
      (e = ((e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext) || Ii),
      (Zi = Ar.current),
      Jt(Ar, e),
      Jt(Kr, Kr.current),
      !0
    )
  }
  function sy(e, r, t) {
    var n = e.stateNode
    if (!n) throw Error(Ke(169))
    t ? ((e = iy(e, r, Zi)), (n.__reactInternalMemoizedMergedChildContext = e), Ht(Kr), Ht(Ar), Jt(Ar, e)) : Ht(Kr),
      Jt(Kr, t)
  }
  var dh = null,
    Qi = null,
    Ox = cr.unstable_runWithPriority,
    hh = cr.unstable_scheduleCallback,
    ph = cr.unstable_cancelCallback,
    Dx = cr.unstable_shouldYield,
    oy = cr.unstable_requestPaint,
    mh = cr.unstable_now,
    Lx = cr.unstable_getCurrentPriorityLevel,
    sl = cr.unstable_ImmediatePriority,
    ay = cr.unstable_UserBlockingPriority,
    cy = cr.unstable_NormalPriority,
    uy = cr.unstable_LowPriority,
    ly = cr.unstable_IdlePriority,
    bh = {},
    Ux = oy !== void 0 ? oy : function () {},
    Gn = null,
    ol = null,
    yh = !1,
    fy = mh(),
    Ir =
      1e4 > fy
        ? mh
        : function () {
            return mh() - fy
          }
  function so() {
    switch (Lx()) {
      case sl:
        return 99
      case ay:
        return 98
      case cy:
        return 97
      case uy:
        return 96
      case ly:
        return 95
      default:
        throw Error(Ke(332))
    }
  }
  function dy(e) {
    switch (e) {
      case 99:
        return sl
      case 98:
        return ay
      case 97:
        return cy
      case 96:
        return uy
      case 95:
        return ly
      default:
        throw Error(Ke(332))
    }
  }
  function es(e, r) {
    return (e = dy(e)), Ox(e, r)
  }
  function Ua(e, r, t) {
    return (e = dy(e)), hh(e, r, t)
  }
  function Cn() {
    if (ol !== null) {
      var e = ol
      ;(ol = null), ph(e)
    }
    hy()
  }
  function hy() {
    if (!yh && Gn !== null) {
      yh = !0
      var e = 0
      try {
        var r = Gn
        es(99, function () {
          for (; e < r.length; e++) {
            var t = r[e]
            do t = t(!0)
            while (t !== null)
          }
        }),
          (Gn = null)
      } catch (t) {
        throw (Gn !== null && (Gn = Gn.slice(e + 1)), hh(sl, Cn), t)
      } finally {
        yh = !1
      }
    }
  }
  var qx = Gi.ReactCurrentBatchConfig
  function bn(e, r) {
    if (e && e.defaultProps) {
      ;(r = Wt({}, r)), (e = e.defaultProps)
      for (var t in e) r[t] === void 0 && (r[t] = e[t])
      return r
    }
    return r
  }
  var al = Ai(null),
    cl = null,
    oo = null,
    ul = null
  function vh() {
    ul = oo = cl = null
  }
  function gh(e) {
    var r = al.current
    Ht(al), (e.type._context._currentValue = r)
  }
  function py(e, r) {
    for (; e !== null; ) {
      var t = e.alternate
      if ((e.childLanes & r) === r) {
        if (t === null || (t.childLanes & r) === r) break
        t.childLanes |= r
      } else (e.childLanes |= r), t !== null && (t.childLanes |= r)
      e = e.return
    }
  }
  function ao(e, r) {
    ;(cl = e),
      (ul = oo = null),
      (e = e.dependencies),
      e !== null && e.firstContext !== null && ((e.lanes & r) != 0 && (yn = !0), (e.firstContext = null))
  }
  function nn(e, r) {
    if (ul !== e && r !== !1 && r !== 0)
      if (
        ((typeof r != 'number' || r === 1073741823) && ((ul = e), (r = 1073741823)),
        (r = { context: e, observedBits: r, next: null }),
        oo === null)
      ) {
        if (cl === null) throw Error(Ke(308))
        ;(oo = r), (cl.dependencies = { lanes: 0, firstContext: r, responders: null })
      } else oo = oo.next = r
    return e._currentValue
  }
  var Ti = !1
  function wh(e) {
    e.updateQueue = {
      baseState: e.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null },
      effects: null
    }
  }
  function my(e, r) {
    ;(e = e.updateQueue),
      r.updateQueue === e &&
        (r.updateQueue = {
          baseState: e.baseState,
          firstBaseUpdate: e.firstBaseUpdate,
          lastBaseUpdate: e.lastBaseUpdate,
          shared: e.shared,
          effects: e.effects
        })
  }
  function Ci(e, r) {
    return { eventTime: e, lane: r, tag: 0, payload: null, callback: null, next: null }
  }
  function ki(e, r) {
    if (((e = e.updateQueue), e !== null)) {
      e = e.shared
      var t = e.pending
      t === null ? (r.next = r) : ((r.next = t.next), (t.next = r)), (e.pending = r)
    }
  }
  function by(e, r) {
    var t = e.updateQueue,
      n = e.alternate
    if (n !== null && ((n = n.updateQueue), t === n)) {
      var i = null,
        s = null
      if (((t = t.firstBaseUpdate), t !== null)) {
        do {
          var u = {
            eventTime: t.eventTime,
            lane: t.lane,
            tag: t.tag,
            payload: t.payload,
            callback: t.callback,
            next: null
          }
          s === null ? (i = s = u) : (s = s.next = u), (t = t.next)
        } while (t !== null)
        s === null ? (i = s = r) : (s = s.next = r)
      } else i = s = r
      ;(t = { baseState: n.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: n.shared, effects: n.effects }),
        (e.updateQueue = t)
      return
    }
    ;(e = t.lastBaseUpdate), e === null ? (t.firstBaseUpdate = r) : (e.next = r), (t.lastBaseUpdate = r)
  }
  function qa(e, r, t, n) {
    var i = e.updateQueue
    Ti = !1
    var s = i.firstBaseUpdate,
      u = i.lastBaseUpdate,
      o = i.shared.pending
    if (o !== null) {
      i.shared.pending = null
      var l = o,
        a = l.next
      ;(l.next = null), u === null ? (s = a) : (u.next = a), (u = l)
      var c = e.alternate
      if (c !== null) {
        c = c.updateQueue
        var f = c.lastBaseUpdate
        f !== u && (f === null ? (c.firstBaseUpdate = a) : (f.next = a), (c.lastBaseUpdate = l))
      }
    }
    if (s !== null) {
      ;(f = i.baseState), (u = 0), (c = a = l = null)
      do {
        o = s.lane
        var p = s.eventTime
        if ((n & o) === o) {
          c !== null &&
            (c = c.next = { eventTime: p, lane: 0, tag: s.tag, payload: s.payload, callback: s.callback, next: null })
          e: {
            var y = e,
              d = s
            switch (((o = r), (p = t), d.tag)) {
              case 1:
                if (((y = d.payload), typeof y == 'function')) {
                  f = y.call(p, f, o)
                  break e
                }
                f = y
                break e
              case 3:
                y.flags = (y.flags & -4097) | 64
              case 0:
                if (((y = d.payload), (o = typeof y == 'function' ? y.call(p, f, o) : y), o == null)) break e
                f = Wt({}, f, o)
                break e
              case 2:
                Ti = !0
            }
          }
          s.callback !== null && ((e.flags |= 32), (o = i.effects), o === null ? (i.effects = [s]) : o.push(s))
        } else
          (p = { eventTime: p, lane: o, tag: s.tag, payload: s.payload, callback: s.callback, next: null }),
            c === null ? ((a = c = p), (l = f)) : (c = c.next = p),
            (u |= o)
        if (((s = s.next), s === null)) {
          if (((o = i.shared.pending), o === null)) break
          ;(s = o.next), (o.next = null), (i.lastBaseUpdate = o), (i.shared.pending = null)
        }
      } while (1)
      c === null && (l = f),
        (i.baseState = l),
        (i.firstBaseUpdate = a),
        (i.lastBaseUpdate = c),
        (Ya |= u),
        (e.lanes = u),
        (e.memoizedState = f)
    }
  }
  function yy(e, r, t) {
    if (((e = r.effects), (r.effects = null), e !== null))
      for (r = 0; r < e.length; r++) {
        var n = e[r],
          i = n.callback
        if (i !== null) {
          if (((n.callback = null), (n = t), typeof i != 'function')) throw Error(Ke(191, i))
          i.call(n)
        }
      }
  }
  var vy = new ku.Component().refs
  function ll(e, r, t, n) {
    ;(r = e.memoizedState),
      (t = t(n, r)),
      (t = t == null ? r : Wt({}, r, t)),
      (e.memoizedState = t),
      e.lanes === 0 && (e.updateQueue.baseState = t)
  }
  var fl = {
    isMounted: function (e) {
      return (e = e._reactInternals) ? Xi(e) === e : !1
    },
    enqueueSetState: function (e, r, t) {
      e = e._reactInternals
      var n = Xr(),
        i = Ri(e),
        s = Ci(n, i)
      ;(s.payload = r), t != null && (s.callback = t), ki(e, s), Bi(e, i, n)
    },
    enqueueReplaceState: function (e, r, t) {
      e = e._reactInternals
      var n = Xr(),
        i = Ri(e),
        s = Ci(n, i)
      ;(s.tag = 1), (s.payload = r), t != null && (s.callback = t), ki(e, s), Bi(e, i, n)
    },
    enqueueForceUpdate: function (e, r) {
      e = e._reactInternals
      var t = Xr(),
        n = Ri(e),
        i = Ci(t, n)
      ;(i.tag = 2), r != null && (i.callback = r), ki(e, i), Bi(e, n, t)
    }
  }
  function gy(e, r, t, n, i, s, u) {
    return (
      (e = e.stateNode),
      typeof e.shouldComponentUpdate == 'function'
        ? e.shouldComponentUpdate(n, s, u)
        : r.prototype && r.prototype.isPureReactComponent
        ? !Na(t, n) || !Na(i, s)
        : !0
    )
  }
  function wy(e, r, t) {
    var n = !1,
      i = Ii,
      s = r.contextType
    return (
      typeof s == 'object' && s !== null
        ? (s = nn(s))
        : ((i = Fr(r) ? Zi : Ar.current), (n = r.contextTypes), (s = (n = n != null) ? io(e, i) : Ii)),
      (r = new r(t, s)),
      (e.memoizedState = r.state !== null && r.state !== void 0 ? r.state : null),
      (r.updater = fl),
      (e.stateNode = r),
      (r._reactInternals = e),
      n &&
        ((e = e.stateNode),
        (e.__reactInternalMemoizedUnmaskedChildContext = i),
        (e.__reactInternalMemoizedMaskedChildContext = s)),
      r
    )
  }
  function _y(e, r, t, n) {
    ;(e = r.state),
      typeof r.componentWillReceiveProps == 'function' && r.componentWillReceiveProps(t, n),
      typeof r.UNSAFE_componentWillReceiveProps == 'function' && r.UNSAFE_componentWillReceiveProps(t, n),
      r.state !== e && fl.enqueueReplaceState(r, r.state, null)
  }
  function _h(e, r, t, n) {
    var i = e.stateNode
    ;(i.props = t), (i.state = e.memoizedState), (i.refs = vy), wh(e)
    var s = r.contextType
    typeof s == 'object' && s !== null ? (i.context = nn(s)) : ((s = Fr(r) ? Zi : Ar.current), (i.context = io(e, s))),
      qa(e, t, i, n),
      (i.state = e.memoizedState),
      (s = r.getDerivedStateFromProps),
      typeof s == 'function' && (ll(e, r, s, t), (i.state = e.memoizedState)),
      typeof r.getDerivedStateFromProps == 'function' ||
        typeof i.getSnapshotBeforeUpdate == 'function' ||
        (typeof i.UNSAFE_componentWillMount != 'function' && typeof i.componentWillMount != 'function') ||
        ((r = i.state),
        typeof i.componentWillMount == 'function' && i.componentWillMount(),
        typeof i.UNSAFE_componentWillMount == 'function' && i.UNSAFE_componentWillMount(),
        r !== i.state && fl.enqueueReplaceState(i, i.state, null),
        qa(e, t, i, n),
        (i.state = e.memoizedState)),
      typeof i.componentDidMount == 'function' && (e.flags |= 4)
  }
  var dl = Array.isArray
  function ja(e, r, t) {
    if (((e = t.ref), e !== null && typeof e != 'function' && typeof e != 'object')) {
      if (t._owner) {
        if (((t = t._owner), t)) {
          if (t.tag !== 1) throw Error(Ke(309))
          var n = t.stateNode
        }
        if (!n) throw Error(Ke(147, e))
        var i = '' + e
        return r !== null && r.ref !== null && typeof r.ref == 'function' && r.ref._stringRef === i
          ? r.ref
          : ((r = function (s) {
              var u = n.refs
              u === vy && (u = n.refs = {}), s === null ? delete u[i] : (u[i] = s)
            }),
            (r._stringRef = i),
            r)
      }
      if (typeof e != 'string') throw Error(Ke(284))
      if (!t._owner) throw Error(Ke(290, e))
    }
    return e
  }
  function hl(e, r) {
    if (e.type !== 'textarea')
      throw Error(
        Ke(
          31,
          Object.prototype.toString.call(r) === '[object Object]'
            ? 'object with keys {' + Object.keys(r).join(', ') + '}'
            : r
        )
      )
  }
  function Ey(e) {
    function r(m, _) {
      if (e) {
        var A = m.lastEffect
        A !== null ? ((A.nextEffect = _), (m.lastEffect = _)) : (m.firstEffect = m.lastEffect = _),
          (_.nextEffect = null),
          (_.flags = 8)
      }
    }
    function t(m, _) {
      if (!e) return null
      for (; _ !== null; ) r(m, _), (_ = _.sibling)
      return null
    }
    function n(m, _) {
      for (m = new Map(); _ !== null; ) _.key !== null ? m.set(_.key, _) : m.set(_.index, _), (_ = _.sibling)
      return m
    }
    function i(m, _) {
      return (m = Oi(m, _)), (m.index = 0), (m.sibling = null), m
    }
    function s(m, _, A) {
      return (
        (m.index = A),
        e ? ((A = m.alternate), A !== null ? ((A = A.index), A < _ ? ((m.flags = 2), _) : A) : ((m.flags = 2), _)) : _
      )
    }
    function u(m) {
      return e && m.alternate === null && (m.flags = 2), m
    }
    function o(m, _, A, T) {
      return _ === null || _.tag !== 6
        ? ((_ = n0(A, m.mode, T)), (_.return = m), _)
        : ((_ = i(_, A)), (_.return = m), _)
    }
    function l(m, _, A, T) {
      return _ !== null && _.elementType === A.type
        ? ((T = i(_, A.props)), (T.ref = ja(m, _, A)), (T.return = m), T)
        : ((T = Rl(A.type, A.key, A.props, null, m.mode, T)), (T.ref = ja(m, _, A)), (T.return = m), T)
    }
    function a(m, _, A, T) {
      return _ === null ||
        _.tag !== 4 ||
        _.stateNode.containerInfo !== A.containerInfo ||
        _.stateNode.implementation !== A.implementation
        ? ((_ = i0(A, m.mode, T)), (_.return = m), _)
        : ((_ = i(_, A.children || [])), (_.return = m), _)
    }
    function c(m, _, A, T, E) {
      return _ === null || _.tag !== 7
        ? ((_ = bo(A, m.mode, T, E)), (_.return = m), _)
        : ((_ = i(_, A)), (_.return = m), _)
    }
    function f(m, _, A) {
      if (typeof _ == 'string' || typeof _ == 'number') return (_ = n0('' + _, m.mode, A)), (_.return = m), _
      if (typeof _ == 'object' && _ !== null) {
        switch (_.$$typeof) {
          case ha:
            return (A = Rl(_.type, _.key, _.props, null, m.mode, A)), (A.ref = ja(m, null, _)), (A.return = m), A
          case Wi:
            return (_ = i0(_, m.mode, A)), (_.return = m), _
        }
        if (dl(_) || ba(_)) return (_ = bo(_, m.mode, A, null)), (_.return = m), _
        hl(m, _)
      }
      return null
    }
    function p(m, _, A, T) {
      var E = _ !== null ? _.key : null
      if (typeof A == 'string' || typeof A == 'number') return E !== null ? null : o(m, _, '' + A, T)
      if (typeof A == 'object' && A !== null) {
        switch (A.$$typeof) {
          case ha:
            return A.key === E ? (A.type === bi ? c(m, _, A.props.children, T, E) : l(m, _, A, T)) : null
          case Wi:
            return A.key === E ? a(m, _, A, T) : null
        }
        if (dl(A) || ba(A)) return E !== null ? null : c(m, _, A, T, null)
        hl(m, A)
      }
      return null
    }
    function y(m, _, A, T, E) {
      if (typeof T == 'string' || typeof T == 'number') return (m = m.get(A) || null), o(_, m, '' + T, E)
      if (typeof T == 'object' && T !== null) {
        switch (T.$$typeof) {
          case ha:
            return (
              (m = m.get(T.key === null ? A : T.key) || null),
              T.type === bi ? c(_, m, T.props.children, E, T.key) : l(_, m, T, E)
            )
          case Wi:
            return (m = m.get(T.key === null ? A : T.key) || null), a(_, m, T, E)
        }
        if (dl(T) || ba(T)) return (m = m.get(A) || null), c(_, m, T, E, null)
        hl(_, T)
      }
      return null
    }
    function d(m, _, A, T) {
      for (var E = null, k = null, w = _, v = (_ = 0), I = null; w !== null && v < A.length; v++) {
        w.index > v ? ((I = w), (w = null)) : (I = w.sibling)
        var M = p(m, w, A[v], T)
        if (M === null) {
          w === null && (w = I)
          break
        }
        e && w && M.alternate === null && r(m, w),
          (_ = s(M, _, v)),
          k === null ? (E = M) : (k.sibling = M),
          (k = M),
          (w = I)
      }
      if (v === A.length) return t(m, w), E
      if (w === null) {
        for (; v < A.length; v++)
          (w = f(m, A[v], T)), w !== null && ((_ = s(w, _, v)), k === null ? (E = w) : (k.sibling = w), (k = w))
        return E
      }
      for (w = n(m, w); v < A.length; v++)
        (I = y(w, m, v, A[v], T)),
          I !== null &&
            (e && I.alternate !== null && w.delete(I.key === null ? v : I.key),
            (_ = s(I, _, v)),
            k === null ? (E = I) : (k.sibling = I),
            (k = I))
      return (
        e &&
          w.forEach(function (q) {
            return r(m, q)
          }),
        E
      )
    }
    function h(m, _, A, T) {
      var E = ba(A)
      if (typeof E != 'function') throw Error(Ke(150))
      if (((A = E.call(A)), A == null)) throw Error(Ke(151))
      for (var k = (E = null), w = _, v = (_ = 0), I = null, M = A.next(); w !== null && !M.done; v++, M = A.next()) {
        w.index > v ? ((I = w), (w = null)) : (I = w.sibling)
        var q = p(m, w, M.value, T)
        if (q === null) {
          w === null && (w = I)
          break
        }
        e && w && q.alternate === null && r(m, w),
          (_ = s(q, _, v)),
          k === null ? (E = q) : (k.sibling = q),
          (k = q),
          (w = I)
      }
      if (M.done) return t(m, w), E
      if (w === null) {
        for (; !M.done; v++, M = A.next())
          (M = f(m, M.value, T)), M !== null && ((_ = s(M, _, v)), k === null ? (E = M) : (k.sibling = M), (k = M))
        return E
      }
      for (w = n(m, w); !M.done; v++, M = A.next())
        (M = y(w, m, v, M.value, T)),
          M !== null &&
            (e && M.alternate !== null && w.delete(M.key === null ? v : M.key),
            (_ = s(M, _, v)),
            k === null ? (E = M) : (k.sibling = M),
            (k = M))
      return (
        e &&
          w.forEach(function (G) {
            return r(m, G)
          }),
        E
      )
    }
    return function (m, _, A, T) {
      var E = typeof A == 'object' && A !== null && A.type === bi && A.key === null
      E && (A = A.props.children)
      var k = typeof A == 'object' && A !== null
      if (k)
        switch (A.$$typeof) {
          case ha:
            e: {
              for (k = A.key, E = _; E !== null; ) {
                if (E.key === k) {
                  switch (E.tag) {
                    case 7:
                      if (A.type === bi) {
                        t(m, E.sibling), (_ = i(E, A.props.children)), (_.return = m), (m = _)
                        break e
                      }
                      break
                    default:
                      if (E.elementType === A.type) {
                        t(m, E.sibling), (_ = i(E, A.props)), (_.ref = ja(m, E, A)), (_.return = m), (m = _)
                        break e
                      }
                  }
                  t(m, E)
                  break
                } else r(m, E)
                E = E.sibling
              }
              A.type === bi
                ? ((_ = bo(A.props.children, m.mode, T, A.key)), (_.return = m), (m = _))
                : ((T = Rl(A.type, A.key, A.props, null, m.mode, T)), (T.ref = ja(m, _, A)), (T.return = m), (m = T))
            }
            return u(m)
          case Wi:
            e: {
              for (E = A.key; _ !== null; ) {
                if (_.key === E)
                  if (
                    _.tag === 4 &&
                    _.stateNode.containerInfo === A.containerInfo &&
                    _.stateNode.implementation === A.implementation
                  ) {
                    t(m, _.sibling), (_ = i(_, A.children || [])), (_.return = m), (m = _)
                    break e
                  } else {
                    t(m, _)
                    break
                  }
                else r(m, _)
                _ = _.sibling
              }
              ;(_ = i0(A, m.mode, T)), (_.return = m), (m = _)
            }
            return u(m)
        }
      if (typeof A == 'string' || typeof A == 'number')
        return (
          (A = '' + A),
          _ !== null && _.tag === 6
            ? (t(m, _.sibling), (_ = i(_, A)), (_.return = m), (m = _))
            : (t(m, _), (_ = n0(A, m.mode, T)), (_.return = m), (m = _)),
          u(m)
        )
      if (dl(A)) return d(m, _, A, T)
      if (ba(A)) return h(m, _, A, T)
      if ((k && hl(m, A), typeof A == 'undefined' && !E))
        switch (m.tag) {
          case 1:
          case 22:
          case 0:
          case 11:
          case 15:
            throw Error(Ke(152, Ks(m.type) || 'Component'))
        }
      return t(m, _)
    }
  }
  var pl = Ey(!0),
    Sy = Ey(!1),
    za = {},
    kn = Ai(za),
    Ka = Ai(za),
    Fa = Ai(za)
  function ts(e) {
    if (e === za) throw Error(Ke(174))
    return e
  }
  function Eh(e, r) {
    switch ((Jt(Fa, r), Jt(Ka, e), Jt(kn, za), (e = r.nodeType), e)) {
      case 9:
      case 11:
        r = (r = r.documentElement) ? r.namespaceURI : kd(null, '')
        break
      default:
        ;(e = e === 8 ? r.parentNode : r), (r = e.namespaceURI || null), (e = e.tagName), (r = kd(r, e))
    }
    Ht(kn), Jt(kn, r)
  }
  function co() {
    Ht(kn), Ht(Ka), Ht(Fa)
  }
  function Ay(e) {
    ts(Fa.current)
    var r = ts(kn.current),
      t = kd(r, e.type)
    r !== t && (Jt(Ka, e), Jt(kn, t))
  }
  function Sh(e) {
    Ka.current === e && (Ht(kn), Ht(Ka))
  }
  var Xt = Ai(0)
  function ml(e) {
    for (var r = e; r !== null; ) {
      if (r.tag === 13) {
        var t = r.memoizedState
        if (t !== null && ((t = t.dehydrated), t === null || t.data === '$?' || t.data === '$!')) return r
      } else if (r.tag === 19 && r.memoizedProps.revealOrder !== void 0) {
        if ((r.flags & 64) != 0) return r
      } else if (r.child !== null) {
        ;(r.child.return = r), (r = r.child)
        continue
      }
      if (r === e) break
      for (; r.sibling === null; ) {
        if (r.return === null || r.return === e) return null
        r = r.return
      }
      ;(r.sibling.return = r.return), (r = r.sibling)
    }
    return null
  }
  var Wn = null,
    Mi = null,
    Mn = !1
  function Iy(e, r) {
    var t = an(5, null, null, 0)
    ;(t.elementType = 'DELETED'),
      (t.type = 'DELETED'),
      (t.stateNode = r),
      (t.return = e),
      (t.flags = 8),
      e.lastEffect !== null ? ((e.lastEffect.nextEffect = t), (e.lastEffect = t)) : (e.firstEffect = e.lastEffect = t)
  }
  function Ty(e, r) {
    switch (e.tag) {
      case 5:
        var t = e.type
        return (
          (r = r.nodeType !== 1 || t.toLowerCase() !== r.nodeName.toLowerCase() ? null : r),
          r !== null ? ((e.stateNode = r), !0) : !1
        )
      case 6:
        return (r = e.pendingProps === '' || r.nodeType !== 3 ? null : r), r !== null ? ((e.stateNode = r), !0) : !1
      case 13:
        return !1
      default:
        return !1
    }
  }
  function Ah(e) {
    if (Mn) {
      var r = Mi
      if (r) {
        var t = r
        if (!Ty(e, r)) {
          if (((r = eo(t.nextSibling)), !r || !Ty(e, r))) {
            ;(e.flags = (e.flags & -1025) | 2), (Mn = !1), (Wn = e)
            return
          }
          Iy(Wn, t)
        }
        ;(Wn = e), (Mi = eo(r.firstChild))
      } else (e.flags = (e.flags & -1025) | 2), (Mn = !1), (Wn = e)
    }
  }
  function Cy(e) {
    for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13; ) e = e.return
    Wn = e
  }
  function bl(e) {
    if (e !== Wn) return !1
    if (!Mn) return Cy(e), (Mn = !0), !1
    var r = e.type
    if (e.tag !== 5 || (r !== 'head' && r !== 'body' && !ch(r, e.memoizedProps)))
      for (r = Mi; r; ) Iy(e, r), (r = eo(r.nextSibling))
    if ((Cy(e), e.tag === 13)) {
      if (((e = e.memoizedState), (e = e !== null ? e.dehydrated : null), !e)) throw Error(Ke(317))
      e: {
        for (e = e.nextSibling, r = 0; e; ) {
          if (e.nodeType === 8) {
            var t = e.data
            if (t === '/$') {
              if (r === 0) {
                Mi = eo(e.nextSibling)
                break e
              }
              r--
            } else (t !== '$' && t !== '$!' && t !== '$?') || r++
          }
          e = e.nextSibling
        }
        Mi = null
      }
    } else Mi = Wn ? eo(e.stateNode.nextSibling) : null
    return !0
  }
  function Ih() {
    ;(Mi = Wn = null), (Mn = !1)
  }
  var uo = []
  function Th() {
    for (var e = 0; e < uo.length; e++) uo[e]._workInProgressVersionPrimary = null
    uo.length = 0
  }
  var Va = Gi.ReactCurrentDispatcher,
    sn = Gi.ReactCurrentBatchConfig,
    Ha = 0,
    Qt = null,
    Tr = null,
    gr = null,
    yl = !1,
    $a = !1
  function Vr() {
    throw Error(Ke(321))
  }
  function Ch(e, r) {
    if (r === null) return !1
    for (var t = 0; t < r.length && t < e.length; t++) if (!rn(e[t], r[t])) return !1
    return !0
  }
  function kh(e, r, t, n, i, s) {
    if (
      ((Ha = s),
      (Qt = r),
      (r.memoizedState = null),
      (r.updateQueue = null),
      (r.lanes = 0),
      (Va.current = e === null || e.memoizedState === null ? zx : Kx),
      (e = t(n, i)),
      $a)
    ) {
      s = 0
      do {
        if ((($a = !1), !(25 > s))) throw Error(Ke(301))
        ;(s += 1), (gr = Tr = null), (r.updateQueue = null), (Va.current = Fx), (e = t(n, i))
      } while ($a)
    }
    if (((Va.current = _l), (r = Tr !== null && Tr.next !== null), (Ha = 0), (gr = Tr = Qt = null), (yl = !1), r))
      throw Error(Ke(300))
    return e
  }
  function rs() {
    var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }
    return gr === null ? (Qt.memoizedState = gr = e) : (gr = gr.next = e), gr
  }
  function ns() {
    if (Tr === null) {
      var e = Qt.alternate
      e = e !== null ? e.memoizedState : null
    } else e = Tr.next
    var r = gr === null ? Qt.memoizedState : gr.next
    if (r !== null) (gr = r), (Tr = e)
    else {
      if (e === null) throw Error(Ke(310))
      ;(Tr = e),
        (e = {
          memoizedState: Tr.memoizedState,
          baseState: Tr.baseState,
          baseQueue: Tr.baseQueue,
          queue: Tr.queue,
          next: null
        }),
        gr === null ? (Qt.memoizedState = gr = e) : (gr = gr.next = e)
    }
    return gr
  }
  function xn(e, r) {
    return typeof r == 'function' ? r(e) : r
  }
  function Ga(e) {
    var r = ns(),
      t = r.queue
    if (t === null) throw Error(Ke(311))
    t.lastRenderedReducer = e
    var n = Tr,
      i = n.baseQueue,
      s = t.pending
    if (s !== null) {
      if (i !== null) {
        var u = i.next
        ;(i.next = s.next), (s.next = u)
      }
      ;(n.baseQueue = i = s), (t.pending = null)
    }
    if (i !== null) {
      ;(i = i.next), (n = n.baseState)
      var o = (u = s = null),
        l = i
      do {
        var a = l.lane
        if ((Ha & a) === a)
          o !== null &&
            (o = o.next =
              { lane: 0, action: l.action, eagerReducer: l.eagerReducer, eagerState: l.eagerState, next: null }),
            (n = l.eagerReducer === e ? l.eagerState : e(n, l.action))
        else {
          var c = { lane: a, action: l.action, eagerReducer: l.eagerReducer, eagerState: l.eagerState, next: null }
          o === null ? ((u = o = c), (s = n)) : (o = o.next = c), (Qt.lanes |= a), (Ya |= a)
        }
        l = l.next
      } while (l !== null && l !== i)
      o === null ? (s = n) : (o.next = u),
        rn(n, r.memoizedState) || (yn = !0),
        (r.memoizedState = n),
        (r.baseState = s),
        (r.baseQueue = o),
        (t.lastRenderedState = n)
    }
    return [r.memoizedState, t.dispatch]
  }
  function Wa(e) {
    var r = ns(),
      t = r.queue
    if (t === null) throw Error(Ke(311))
    t.lastRenderedReducer = e
    var n = t.dispatch,
      i = t.pending,
      s = r.memoizedState
    if (i !== null) {
      t.pending = null
      var u = (i = i.next)
      do (s = e(s, u.action)), (u = u.next)
      while (u !== i)
      rn(s, r.memoizedState) || (yn = !0),
        (r.memoizedState = s),
        r.baseQueue === null && (r.baseState = s),
        (t.lastRenderedState = s)
    }
    return [s, n]
  }
  function ky(e, r, t) {
    var n = r._getVersion
    n = n(r._source)
    var i = r._workInProgressVersionPrimary
    if (
      (i !== null
        ? (e = i === n)
        : ((e = e.mutableReadLanes), (e = (Ha & e) === e) && ((r._workInProgressVersionPrimary = n), uo.push(r))),
      e)
    )
      return t(r._source)
    throw (uo.push(r), Error(Ke(350)))
  }
  function My(e, r, t, n) {
    var i = qr
    if (i === null) throw Error(Ke(349))
    var s = r._getVersion,
      u = s(r._source),
      o = Va.current,
      l = o.useState(function () {
        return ky(i, r, t)
      }),
      a = l[1],
      c = l[0]
    l = gr
    var f = e.memoizedState,
      p = f.refs,
      y = p.getSnapshot,
      d = f.source
    f = f.subscribe
    var h = Qt
    return (
      (e.memoizedState = { refs: p, source: r, subscribe: n }),
      o.useEffect(
        function () {
          ;(p.getSnapshot = t), (p.setSnapshot = a)
          var m = s(r._source)
          if (!rn(u, m)) {
            ;(m = t(r._source)),
              rn(c, m) || (a(m), (m = Ri(h)), (i.mutableReadLanes |= m & i.pendingLanes)),
              (m = i.mutableReadLanes),
              (i.entangledLanes |= m)
            for (var _ = i.entanglements, A = m; 0 < A; ) {
              var T = 31 - _i(A),
                E = 1 << T
              ;(_[T] |= m), (A &= ~E)
            }
          }
        },
        [t, r, n]
      ),
      o.useEffect(
        function () {
          return n(r._source, function () {
            var m = p.getSnapshot,
              _ = p.setSnapshot
            try {
              _(m(r._source))
              var A = Ri(h)
              i.mutableReadLanes |= A & i.pendingLanes
            } catch (T) {
              _(function () {
                throw T
              })
            }
          })
        },
        [r, n]
      ),
      (rn(y, t) && rn(d, r) && rn(f, n)) ||
        ((e = { pending: null, dispatch: null, lastRenderedReducer: xn, lastRenderedState: c }),
        (e.dispatch = a = Bh.bind(null, Qt, e)),
        (l.queue = e),
        (l.baseQueue = null),
        (c = ky(i, r, t)),
        (l.memoizedState = l.baseState = c)),
      c
    )
  }
  function xy(e, r, t) {
    var n = ns()
    return My(n, e, r, t)
  }
  function Ja(e) {
    var r = rs()
    return (
      typeof e == 'function' && (e = e()),
      (r.memoizedState = r.baseState = e),
      (e = r.queue = { pending: null, dispatch: null, lastRenderedReducer: xn, lastRenderedState: e }),
      (e = e.dispatch = Bh.bind(null, Qt, e)),
      [r.memoizedState, e]
    )
  }
  function vl(e, r, t, n) {
    return (
      (e = { tag: e, create: r, destroy: t, deps: n, next: null }),
      (r = Qt.updateQueue),
      r === null
        ? ((r = { lastEffect: null }), (Qt.updateQueue = r), (r.lastEffect = e.next = e))
        : ((t = r.lastEffect),
          t === null ? (r.lastEffect = e.next = e) : ((n = t.next), (t.next = e), (e.next = n), (r.lastEffect = e))),
      e
    )
  }
  function Ry(e) {
    var r = rs()
    return (e = { current: e }), (r.memoizedState = e)
  }
  function gl() {
    return ns().memoizedState
  }
  function Mh(e, r, t, n) {
    var i = rs()
    ;(Qt.flags |= e), (i.memoizedState = vl(1 | r, t, void 0, n === void 0 ? null : n))
  }
  function xh(e, r, t, n) {
    var i = ns()
    n = n === void 0 ? null : n
    var s = void 0
    if (Tr !== null) {
      var u = Tr.memoizedState
      if (((s = u.destroy), n !== null && Ch(n, u.deps))) {
        vl(r, t, s, n)
        return
      }
    }
    ;(Qt.flags |= e), (i.memoizedState = vl(1 | r, t, s, n))
  }
  function By(e, r) {
    return Mh(516, 4, e, r)
  }
  function wl(e, r) {
    return xh(516, 4, e, r)
  }
  function Ny(e, r) {
    return xh(4, 2, e, r)
  }
  function Py(e, r) {
    if (typeof r == 'function')
      return (
        (e = e()),
        r(e),
        function () {
          r(null)
        }
      )
    if (r != null)
      return (
        (e = e()),
        (r.current = e),
        function () {
          r.current = null
        }
      )
  }
  function Oy(e, r, t) {
    return (t = t != null ? t.concat([e]) : null), xh(4, 2, Py.bind(null, r, e), t)
  }
  function Rh() {}
  function Dy(e, r) {
    var t = ns()
    r = r === void 0 ? null : r
    var n = t.memoizedState
    return n !== null && r !== null && Ch(r, n[1]) ? n[0] : ((t.memoizedState = [e, r]), e)
  }
  function Ly(e, r) {
    var t = ns()
    r = r === void 0 ? null : r
    var n = t.memoizedState
    return n !== null && r !== null && Ch(r, n[1]) ? n[0] : ((e = e()), (t.memoizedState = [e, r]), e)
  }
  function jx(e, r) {
    var t = so()
    es(98 > t ? 98 : t, function () {
      e(!0)
    }),
      es(97 < t ? 97 : t, function () {
        var n = sn.transition
        sn.transition = 1
        try {
          e(!1), r()
        } finally {
          sn.transition = n
        }
      })
  }
  function Bh(e, r, t) {
    var n = Xr(),
      i = Ri(e),
      s = { lane: i, action: t, eagerReducer: null, eagerState: null, next: null },
      u = r.pending
    if (
      (u === null ? (s.next = s) : ((s.next = u.next), (u.next = s)),
      (r.pending = s),
      (u = e.alternate),
      e === Qt || (u !== null && u === Qt))
    )
      $a = yl = !0
    else {
      if (e.lanes === 0 && (u === null || u.lanes === 0) && ((u = r.lastRenderedReducer), u !== null))
        try {
          var o = r.lastRenderedState,
            l = u(o, t)
          if (((s.eagerReducer = u), (s.eagerState = l), rn(l, o))) return
        } catch (a) {
        } finally {
        }
      Bi(e, i, n)
    }
  }
  var _l = {
      readContext: nn,
      useCallback: Vr,
      useContext: Vr,
      useEffect: Vr,
      useImperativeHandle: Vr,
      useLayoutEffect: Vr,
      useMemo: Vr,
      useReducer: Vr,
      useRef: Vr,
      useState: Vr,
      useDebugValue: Vr,
      useDeferredValue: Vr,
      useTransition: Vr,
      useMutableSource: Vr,
      useOpaqueIdentifier: Vr,
      unstable_isNewReconciler: !1
    },
    zx = {
      readContext: nn,
      useCallback: function (e, r) {
        return (rs().memoizedState = [e, r === void 0 ? null : r]), e
      },
      useContext: nn,
      useEffect: By,
      useImperativeHandle: function (e, r, t) {
        return (t = t != null ? t.concat([e]) : null), Mh(4, 2, Py.bind(null, r, e), t)
      },
      useLayoutEffect: function (e, r) {
        return Mh(4, 2, e, r)
      },
      useMemo: function (e, r) {
        var t = rs()
        return (r = r === void 0 ? null : r), (e = e()), (t.memoizedState = [e, r]), e
      },
      useReducer: function (e, r, t) {
        var n = rs()
        return (
          (r = t !== void 0 ? t(r) : r),
          (n.memoizedState = n.baseState = r),
          (e = n.queue = { pending: null, dispatch: null, lastRenderedReducer: e, lastRenderedState: r }),
          (e = e.dispatch = Bh.bind(null, Qt, e)),
          [n.memoizedState, e]
        )
      },
      useRef: Ry,
      useState: Ja,
      useDebugValue: Rh,
      useDeferredValue: function (e) {
        var r = Ja(e),
          t = r[0],
          n = r[1]
        return (
          By(
            function () {
              var i = sn.transition
              sn.transition = 1
              try {
                n(e)
              } finally {
                sn.transition = i
              }
            },
            [e]
          ),
          t
        )
      },
      useTransition: function () {
        var e = Ja(!1),
          r = e[0]
        return (e = jx.bind(null, e[1])), Ry(e), [e, r]
      },
      useMutableSource: function (e, r, t) {
        var n = rs()
        return (
          (n.memoizedState = { refs: { getSnapshot: r, setSnapshot: null }, source: e, subscribe: t }), My(n, e, r, t)
        )
      },
      useOpaqueIdentifier: function () {
        if (Mn) {
          var e = !1,
            r = Px(function () {
              throw (e || ((e = !0), t('r:' + (lh++).toString(36))), Error(Ke(355)))
            }),
            t = Ja(r)[1]
          return (
            (Qt.mode & 2) == 0 &&
              ((Qt.flags |= 516),
              vl(
                5,
                function () {
                  t('r:' + (lh++).toString(36))
                },
                void 0,
                null
              )),
            r
          )
        }
        return (r = 'r:' + (lh++).toString(36)), Ja(r), r
      },
      unstable_isNewReconciler: !1
    },
    Kx = {
      readContext: nn,
      useCallback: Dy,
      useContext: nn,
      useEffect: wl,
      useImperativeHandle: Oy,
      useLayoutEffect: Ny,
      useMemo: Ly,
      useReducer: Ga,
      useRef: gl,
      useState: function () {
        return Ga(xn)
      },
      useDebugValue: Rh,
      useDeferredValue: function (e) {
        var r = Ga(xn),
          t = r[0],
          n = r[1]
        return (
          wl(
            function () {
              var i = sn.transition
              sn.transition = 1
              try {
                n(e)
              } finally {
                sn.transition = i
              }
            },
            [e]
          ),
          t
        )
      },
      useTransition: function () {
        var e = Ga(xn)[0]
        return [gl().current, e]
      },
      useMutableSource: xy,
      useOpaqueIdentifier: function () {
        return Ga(xn)[0]
      },
      unstable_isNewReconciler: !1
    },
    Fx = {
      readContext: nn,
      useCallback: Dy,
      useContext: nn,
      useEffect: wl,
      useImperativeHandle: Oy,
      useLayoutEffect: Ny,
      useMemo: Ly,
      useReducer: Wa,
      useRef: gl,
      useState: function () {
        return Wa(xn)
      },
      useDebugValue: Rh,
      useDeferredValue: function (e) {
        var r = Wa(xn),
          t = r[0],
          n = r[1]
        return (
          wl(
            function () {
              var i = sn.transition
              sn.transition = 1
              try {
                n(e)
              } finally {
                sn.transition = i
              }
            },
            [e]
          ),
          t
        )
      },
      useTransition: function () {
        var e = Wa(xn)[0]
        return [gl().current, e]
      },
      useMutableSource: xy,
      useOpaqueIdentifier: function () {
        return Wa(xn)[0]
      },
      unstable_isNewReconciler: !1
    },
    Vx = Gi.ReactCurrentOwner,
    yn = !1
  function Hr(e, r, t, n) {
    r.child = e === null ? Sy(r, null, t, n) : pl(r, e.child, t, n)
  }
  function Uy(e, r, t, n, i) {
    t = t.render
    var s = r.ref
    return (
      ao(r, i),
      (n = kh(e, r, t, n, s, i)),
      e !== null && !yn
        ? ((r.updateQueue = e.updateQueue), (r.flags &= -517), (e.lanes &= ~i), Jn(e, r, i))
        : ((r.flags |= 1), Hr(e, r, n, i), r.child)
    )
  }
  function qy(e, r, t, n, i, s) {
    if (e === null) {
      var u = t.type
      return typeof u == 'function' &&
        !t0(u) &&
        u.defaultProps === void 0 &&
        t.compare === null &&
        t.defaultProps === void 0
        ? ((r.tag = 15), (r.type = u), jy(e, r, u, n, i, s))
        : ((e = Rl(t.type, null, n, r, r.mode, s)), (e.ref = r.ref), (e.return = r), (r.child = e))
    }
    return (
      (u = e.child),
      (i & s) == 0 && ((i = u.memoizedProps), (t = t.compare), (t = t !== null ? t : Na), t(i, n) && e.ref === r.ref)
        ? Jn(e, r, s)
        : ((r.flags |= 1), (e = Oi(u, n)), (e.ref = r.ref), (e.return = r), (r.child = e))
    )
  }
  function jy(e, r, t, n, i, s) {
    if (e !== null && Na(e.memoizedProps, n) && e.ref === r.ref)
      if (((yn = !1), (s & i) != 0)) (e.flags & 16384) != 0 && (yn = !0)
      else return (r.lanes = e.lanes), Jn(e, r, s)
    return Ph(e, r, t, n, s)
  }
  function Nh(e, r, t) {
    var n = r.pendingProps,
      i = n.children,
      s = e !== null ? e.memoizedState : null
    if (n.mode === 'hidden' || n.mode === 'unstable-defer-without-hiding')
      if ((r.mode & 4) == 0) (r.memoizedState = { baseLanes: 0 }), xl(r, t)
      else if ((t & 1073741824) != 0) (r.memoizedState = { baseLanes: 0 }), xl(r, s !== null ? s.baseLanes : t)
      else
        return (
          (e = s !== null ? s.baseLanes | t : t),
          (r.lanes = r.childLanes = 1073741824),
          (r.memoizedState = { baseLanes: e }),
          xl(r, e),
          null
        )
    else s !== null ? ((n = s.baseLanes | t), (r.memoizedState = null)) : (n = t), xl(r, n)
    return Hr(e, r, i, t), r.child
  }
  function zy(e, r) {
    var t = r.ref
    ;((e === null && t !== null) || (e !== null && e.ref !== t)) && (r.flags |= 128)
  }
  function Ph(e, r, t, n, i) {
    var s = Fr(t) ? Zi : Ar.current
    return (
      (s = io(r, s)),
      ao(r, i),
      (t = kh(e, r, t, n, s, i)),
      e !== null && !yn
        ? ((r.updateQueue = e.updateQueue), (r.flags &= -517), (e.lanes &= ~i), Jn(e, r, i))
        : ((r.flags |= 1), Hr(e, r, t, i), r.child)
    )
  }
  function Ky(e, r, t, n, i) {
    if (Fr(t)) {
      var s = !0
      il(r)
    } else s = !1
    if ((ao(r, i), r.stateNode === null))
      e !== null && ((e.alternate = null), (r.alternate = null), (r.flags |= 2)), wy(r, t, n), _h(r, t, n, i), (n = !0)
    else if (e === null) {
      var u = r.stateNode,
        o = r.memoizedProps
      u.props = o
      var l = u.context,
        a = t.contextType
      typeof a == 'object' && a !== null ? (a = nn(a)) : ((a = Fr(t) ? Zi : Ar.current), (a = io(r, a)))
      var c = t.getDerivedStateFromProps,
        f = typeof c == 'function' || typeof u.getSnapshotBeforeUpdate == 'function'
      f ||
        (typeof u.UNSAFE_componentWillReceiveProps != 'function' && typeof u.componentWillReceiveProps != 'function') ||
        ((o !== n || l !== a) && _y(r, u, n, a)),
        (Ti = !1)
      var p = r.memoizedState
      ;(u.state = p),
        qa(r, n, u, i),
        (l = r.memoizedState),
        o !== n || p !== l || Kr.current || Ti
          ? (typeof c == 'function' && (ll(r, t, c, n), (l = r.memoizedState)),
            (o = Ti || gy(r, t, o, n, p, l, a))
              ? (f ||
                  (typeof u.UNSAFE_componentWillMount != 'function' && typeof u.componentWillMount != 'function') ||
                  (typeof u.componentWillMount == 'function' && u.componentWillMount(),
                  typeof u.UNSAFE_componentWillMount == 'function' && u.UNSAFE_componentWillMount()),
                typeof u.componentDidMount == 'function' && (r.flags |= 4))
              : (typeof u.componentDidMount == 'function' && (r.flags |= 4),
                (r.memoizedProps = n),
                (r.memoizedState = l)),
            (u.props = n),
            (u.state = l),
            (u.context = a),
            (n = o))
          : (typeof u.componentDidMount == 'function' && (r.flags |= 4), (n = !1))
    } else {
      ;(u = r.stateNode),
        my(e, r),
        (o = r.memoizedProps),
        (a = r.type === r.elementType ? o : bn(r.type, o)),
        (u.props = a),
        (f = r.pendingProps),
        (p = u.context),
        (l = t.contextType),
        typeof l == 'object' && l !== null ? (l = nn(l)) : ((l = Fr(t) ? Zi : Ar.current), (l = io(r, l)))
      var y = t.getDerivedStateFromProps
      ;(c = typeof y == 'function' || typeof u.getSnapshotBeforeUpdate == 'function') ||
        (typeof u.UNSAFE_componentWillReceiveProps != 'function' && typeof u.componentWillReceiveProps != 'function') ||
        ((o !== f || p !== l) && _y(r, u, n, l)),
        (Ti = !1),
        (p = r.memoizedState),
        (u.state = p),
        qa(r, n, u, i)
      var d = r.memoizedState
      o !== f || p !== d || Kr.current || Ti
        ? (typeof y == 'function' && (ll(r, t, y, n), (d = r.memoizedState)),
          (a = Ti || gy(r, t, a, n, p, d, l))
            ? (c ||
                (typeof u.UNSAFE_componentWillUpdate != 'function' && typeof u.componentWillUpdate != 'function') ||
                (typeof u.componentWillUpdate == 'function' && u.componentWillUpdate(n, d, l),
                typeof u.UNSAFE_componentWillUpdate == 'function' && u.UNSAFE_componentWillUpdate(n, d, l)),
              typeof u.componentDidUpdate == 'function' && (r.flags |= 4),
              typeof u.getSnapshotBeforeUpdate == 'function' && (r.flags |= 256))
            : (typeof u.componentDidUpdate != 'function' ||
                (o === e.memoizedProps && p === e.memoizedState) ||
                (r.flags |= 4),
              typeof u.getSnapshotBeforeUpdate != 'function' ||
                (o === e.memoizedProps && p === e.memoizedState) ||
                (r.flags |= 256),
              (r.memoizedProps = n),
              (r.memoizedState = d)),
          (u.props = n),
          (u.state = d),
          (u.context = l),
          (n = a))
        : (typeof u.componentDidUpdate != 'function' ||
            (o === e.memoizedProps && p === e.memoizedState) ||
            (r.flags |= 4),
          typeof u.getSnapshotBeforeUpdate != 'function' ||
            (o === e.memoizedProps && p === e.memoizedState) ||
            (r.flags |= 256),
          (n = !1))
    }
    return Oh(e, r, t, n, s, i)
  }
  function Oh(e, r, t, n, i, s) {
    zy(e, r)
    var u = (r.flags & 64) != 0
    if (!n && !u) return i && sy(r, t, !1), Jn(e, r, s)
    ;(n = r.stateNode), (Vx.current = r)
    var o = u && typeof t.getDerivedStateFromError != 'function' ? null : n.render()
    return (
      (r.flags |= 1),
      e !== null && u ? ((r.child = pl(r, e.child, null, s)), (r.child = pl(r, null, o, s))) : Hr(e, r, o, s),
      (r.memoizedState = n.state),
      i && sy(r, t, !0),
      r.child
    )
  }
  function Fy(e) {
    var r = e.stateNode
    r.pendingContext ? ny(e, r.pendingContext, r.pendingContext !== r.context) : r.context && ny(e, r.context, !1),
      Eh(e, r.containerInfo)
  }
  var El = { dehydrated: null, retryLane: 0 }
  function Vy(e, r, t) {
    var n = r.pendingProps,
      i = Xt.current,
      s = !1,
      u
    return (
      (u = (r.flags & 64) != 0) || (u = e !== null && e.memoizedState === null ? !1 : (i & 2) != 0),
      u
        ? ((s = !0), (r.flags &= -65))
        : (e !== null && e.memoizedState === null) ||
          n.fallback === void 0 ||
          n.unstable_avoidThisFallback === !0 ||
          (i |= 1),
      Jt(Xt, i & 1),
      e === null
        ? (n.fallback !== void 0 && Ah(r),
          (e = n.children),
          (i = n.fallback),
          s
            ? ((e = Hy(r, e, i, t)), (r.child.memoizedState = { baseLanes: t }), (r.memoizedState = El), e)
            : typeof n.unstable_expectedLoadTime == 'number'
            ? ((e = Hy(r, e, i, t)),
              (r.child.memoizedState = { baseLanes: t }),
              (r.memoizedState = El),
              (r.lanes = 33554432),
              e)
            : ((t = r0({ mode: 'visible', children: e }, r.mode, t, null)), (t.return = r), (r.child = t)))
        : e.memoizedState !== null
        ? s
          ? ((n = Gy(e, r, n.children, n.fallback, t)),
            (s = r.child),
            (i = e.child.memoizedState),
            (s.memoizedState = i === null ? { baseLanes: t } : { baseLanes: i.baseLanes | t }),
            (s.childLanes = e.childLanes & ~t),
            (r.memoizedState = El),
            n)
          : ((t = $y(e, r, n.children, t)), (r.memoizedState = null), t)
        : s
        ? ((n = Gy(e, r, n.children, n.fallback, t)),
          (s = r.child),
          (i = e.child.memoizedState),
          (s.memoizedState = i === null ? { baseLanes: t } : { baseLanes: i.baseLanes | t }),
          (s.childLanes = e.childLanes & ~t),
          (r.memoizedState = El),
          n)
        : ((t = $y(e, r, n.children, t)), (r.memoizedState = null), t)
    )
  }
  function Hy(e, r, t, n) {
    var i = e.mode,
      s = e.child
    return (
      (r = { mode: 'hidden', children: r }),
      (i & 2) == 0 && s !== null ? ((s.childLanes = 0), (s.pendingProps = r)) : (s = r0(r, i, 0, null)),
      (t = bo(t, i, n, null)),
      (s.return = e),
      (t.return = e),
      (s.sibling = t),
      (e.child = s),
      t
    )
  }
  function $y(e, r, t, n) {
    var i = e.child
    return (
      (e = i.sibling),
      (t = Oi(i, { mode: 'visible', children: t })),
      (r.mode & 2) == 0 && (t.lanes = n),
      (t.return = r),
      (t.sibling = null),
      e !== null && ((e.nextEffect = null), (e.flags = 8), (r.firstEffect = r.lastEffect = e)),
      (r.child = t)
    )
  }
  function Gy(e, r, t, n, i) {
    var s = r.mode,
      u = e.child
    e = u.sibling
    var o = { mode: 'hidden', children: t }
    return (
      (s & 2) == 0 && r.child !== u
        ? ((t = r.child),
          (t.childLanes = 0),
          (t.pendingProps = o),
          (u = t.lastEffect),
          u !== null
            ? ((r.firstEffect = t.firstEffect), (r.lastEffect = u), (u.nextEffect = null))
            : (r.firstEffect = r.lastEffect = null))
        : (t = Oi(u, o)),
      e !== null ? (n = Oi(e, n)) : ((n = bo(n, s, i, null)), (n.flags |= 2)),
      (n.return = r),
      (t.return = r),
      (t.sibling = n),
      (r.child = t),
      n
    )
  }
  function Wy(e, r) {
    e.lanes |= r
    var t = e.alternate
    t !== null && (t.lanes |= r), py(e.return, r)
  }
  function Dh(e, r, t, n, i, s) {
    var u = e.memoizedState
    u === null
      ? (e.memoizedState = {
          isBackwards: r,
          rendering: null,
          renderingStartTime: 0,
          last: n,
          tail: t,
          tailMode: i,
          lastEffect: s
        })
      : ((u.isBackwards = r),
        (u.rendering = null),
        (u.renderingStartTime = 0),
        (u.last = n),
        (u.tail = t),
        (u.tailMode = i),
        (u.lastEffect = s))
  }
  function Jy(e, r, t) {
    var n = r.pendingProps,
      i = n.revealOrder,
      s = n.tail
    if ((Hr(e, r, n.children, t), (n = Xt.current), (n & 2) != 0)) (n = (n & 1) | 2), (r.flags |= 64)
    else {
      if (e !== null && (e.flags & 64) != 0)
        e: for (e = r.child; e !== null; ) {
          if (e.tag === 13) e.memoizedState !== null && Wy(e, t)
          else if (e.tag === 19) Wy(e, t)
          else if (e.child !== null) {
            ;(e.child.return = e), (e = e.child)
            continue
          }
          if (e === r) break e
          for (; e.sibling === null; ) {
            if (e.return === null || e.return === r) break e
            e = e.return
          }
          ;(e.sibling.return = e.return), (e = e.sibling)
        }
      n &= 1
    }
    if ((Jt(Xt, n), (r.mode & 2) == 0)) r.memoizedState = null
    else
      switch (i) {
        case 'forwards':
          for (t = r.child, i = null; t !== null; )
            (e = t.alternate), e !== null && ml(e) === null && (i = t), (t = t.sibling)
          ;(t = i),
            t === null ? ((i = r.child), (r.child = null)) : ((i = t.sibling), (t.sibling = null)),
            Dh(r, !1, i, t, s, r.lastEffect)
          break
        case 'backwards':
          for (t = null, i = r.child, r.child = null; i !== null; ) {
            if (((e = i.alternate), e !== null && ml(e) === null)) {
              r.child = i
              break
            }
            ;(e = i.sibling), (i.sibling = t), (t = i), (i = e)
          }
          Dh(r, !0, t, null, s, r.lastEffect)
          break
        case 'together':
          Dh(r, !1, null, null, void 0, r.lastEffect)
          break
        default:
          r.memoizedState = null
      }
    return r.child
  }
  function Jn(e, r, t) {
    if ((e !== null && (r.dependencies = e.dependencies), (Ya |= r.lanes), (t & r.childLanes) != 0)) {
      if (e !== null && r.child !== e.child) throw Error(Ke(153))
      if (r.child !== null) {
        for (e = r.child, t = Oi(e, e.pendingProps), r.child = t, t.return = r; e.sibling !== null; )
          (e = e.sibling), (t = t.sibling = Oi(e, e.pendingProps)), (t.return = r)
        t.sibling = null
      }
      return r.child
    }
    return null
  }
  var Xy, Lh, Yy, Zy
  Xy = function (e, r) {
    for (var t = r.child; t !== null; ) {
      if (t.tag === 5 || t.tag === 6) e.appendChild(t.stateNode)
      else if (t.tag !== 4 && t.child !== null) {
        ;(t.child.return = t), (t = t.child)
        continue
      }
      if (t === r) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === r) return
        t = t.return
      }
      ;(t.sibling.return = t.return), (t = t.sibling)
    }
  }
  Lh = function () {}
  Yy = function (e, r, t, n) {
    var i = e.memoizedProps
    if (i !== n) {
      ;(e = r.stateNode), ts(kn.current)
      var s = null
      switch (t) {
        case 'input':
          ;(i = Ed(e, i)), (n = Ed(e, n)), (s = [])
          break
        case 'option':
          ;(i = Id(e, i)), (n = Id(e, n)), (s = [])
          break
        case 'select':
          ;(i = Wt({}, i, { value: void 0 })), (n = Wt({}, n, { value: void 0 })), (s = [])
          break
        case 'textarea':
          ;(i = Td(e, i)), (n = Td(e, n)), (s = [])
          break
        default:
          typeof i.onClick != 'function' && typeof n.onClick == 'function' && (e.onclick = Qu)
      }
      Md(t, n)
      var u
      t = null
      for (a in i)
        if (!n.hasOwnProperty(a) && i.hasOwnProperty(a) && i[a] != null)
          if (a === 'style') {
            var o = i[a]
            for (u in o) o.hasOwnProperty(u) && (t || (t = {}), (t[u] = ''))
          } else
            a !== 'dangerouslySetInnerHTML' &&
              a !== 'children' &&
              a !== 'suppressContentEditableWarning' &&
              a !== 'suppressHydrationWarning' &&
              a !== 'autoFocus' &&
              (da.hasOwnProperty(a) ? s || (s = []) : (s = s || []).push(a, null))
      for (a in n) {
        var l = n[a]
        if (((o = i != null ? i[a] : void 0), n.hasOwnProperty(a) && l !== o && (l != null || o != null)))
          if (a === 'style')
            if (o) {
              for (u in o) !o.hasOwnProperty(u) || (l && l.hasOwnProperty(u)) || (t || (t = {}), (t[u] = ''))
              for (u in l) l.hasOwnProperty(u) && o[u] !== l[u] && (t || (t = {}), (t[u] = l[u]))
            } else t || (s || (s = []), s.push(a, t)), (t = l)
          else
            a === 'dangerouslySetInnerHTML'
              ? ((l = l ? l.__html : void 0),
                (o = o ? o.__html : void 0),
                l != null && o !== l && (s = s || []).push(a, l))
              : a === 'children'
              ? (typeof l != 'string' && typeof l != 'number') || (s = s || []).push(a, '' + l)
              : a !== 'suppressContentEditableWarning' &&
                a !== 'suppressHydrationWarning' &&
                (da.hasOwnProperty(a)
                  ? (l != null && a === 'onScroll' && Vt('scroll', e), s || o === l || (s = []))
                  : typeof l == 'object' && l !== null && l.$$typeof === yd
                  ? l.toString()
                  : (s = s || []).push(a, l))
      }
      t && (s = s || []).push('style', t)
      var a = s
      ;(r.updateQueue = a) && (r.flags |= 4)
    }
  }
  Zy = function (e, r, t, n) {
    t !== n && (r.flags |= 4)
  }
  function Xa(e, r) {
    if (!Mn)
      switch (e.tailMode) {
        case 'hidden':
          r = e.tail
          for (var t = null; r !== null; ) r.alternate !== null && (t = r), (r = r.sibling)
          t === null ? (e.tail = null) : (t.sibling = null)
          break
        case 'collapsed':
          t = e.tail
          for (var n = null; t !== null; ) t.alternate !== null && (n = t), (t = t.sibling)
          n === null ? (r || e.tail === null ? (e.tail = null) : (e.tail.sibling = null)) : (n.sibling = null)
      }
  }
  function Hx(e, r, t) {
    var n = r.pendingProps
    switch (r.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return null
      case 1:
        return Fr(r.type) && nl(), null
      case 3:
        return (
          co(),
          Ht(Kr),
          Ht(Ar),
          Th(),
          (n = r.stateNode),
          n.pendingContext && ((n.context = n.pendingContext), (n.pendingContext = null)),
          (e === null || e.child === null) && (bl(r) ? (r.flags |= 4) : n.hydrate || (r.flags |= 256)),
          Lh(r),
          null
        )
      case 5:
        Sh(r)
        var i = ts(Fa.current)
        if (((t = r.type), e !== null && r.stateNode != null)) Yy(e, r, t, n, i), e.ref !== r.ref && (r.flags |= 128)
        else {
          if (!n) {
            if (r.stateNode === null) throw Error(Ke(166))
            return null
          }
          if (((e = ts(kn.current)), bl(r))) {
            ;(n = r.stateNode), (t = r.type)
            var s = r.memoizedProps
            switch (((n[Si] = r), (n[tl] = s), t)) {
              case 'dialog':
                Vt('cancel', n), Vt('close', n)
                break
              case 'iframe':
              case 'object':
              case 'embed':
                Vt('load', n)
                break
              case 'video':
              case 'audio':
                for (e = 0; e < Oa.length; e++) Vt(Oa[e], n)
                break
              case 'source':
                Vt('error', n)
                break
              case 'img':
              case 'image':
              case 'link':
                Vt('error', n), Vt('load', n)
                break
              case 'details':
                Vt('toggle', n)
                break
              case 'input':
                Vm(n, s), Vt('invalid', n)
                break
              case 'select':
                ;(n._wrapperState = { wasMultiple: !!s.multiple }), Vt('invalid', n)
                break
              case 'textarea':
                Gm(n, s), Vt('invalid', n)
            }
            Md(t, s), (e = null)
            for (var u in s)
              s.hasOwnProperty(u) &&
                ((i = s[u]),
                u === 'children'
                  ? typeof i == 'string'
                    ? n.textContent !== i && (e = ['children', i])
                    : typeof i == 'number' && n.textContent !== '' + i && (e = ['children', '' + i])
                  : da.hasOwnProperty(u) && i != null && u === 'onScroll' && Vt('scroll', n))
            switch (t) {
              case 'input':
                Nu(n), $m(n, s, !0)
                break
              case 'textarea':
                Nu(n), Jm(n)
                break
              case 'select':
              case 'option':
                break
              default:
                typeof s.onClick == 'function' && (n.onclick = Qu)
            }
            ;(n = e), (r.updateQueue = n), n !== null && (r.flags |= 4)
          } else {
            switch (
              ((u = i.nodeType === 9 ? i : i.ownerDocument),
              e === Cd.html && (e = Xm(t)),
              e === Cd.html
                ? t === 'script'
                  ? ((e = u.createElement('div')),
                    (e.innerHTML = '<script></script>'),
                    (e = e.removeChild(e.firstChild)))
                  : typeof n.is == 'string'
                  ? (e = u.createElement(t, { is: n.is }))
                  : ((e = u.createElement(t)),
                    t === 'select' && ((u = e), n.multiple ? (u.multiple = !0) : n.size && (u.size = n.size)))
                : (e = u.createElementNS(e, t)),
              (e[Si] = r),
              (e[tl] = n),
              Xy(e, r, !1, !1),
              (r.stateNode = e),
              (u = xd(t, n)),
              t)
            ) {
              case 'dialog':
                Vt('cancel', e), Vt('close', e), (i = n)
                break
              case 'iframe':
              case 'object':
              case 'embed':
                Vt('load', e), (i = n)
                break
              case 'video':
              case 'audio':
                for (i = 0; i < Oa.length; i++) Vt(Oa[i], e)
                i = n
                break
              case 'source':
                Vt('error', e), (i = n)
                break
              case 'img':
              case 'image':
              case 'link':
                Vt('error', e), Vt('load', e), (i = n)
                break
              case 'details':
                Vt('toggle', e), (i = n)
                break
              case 'input':
                Vm(e, n), (i = Ed(e, n)), Vt('invalid', e)
                break
              case 'option':
                i = Id(e, n)
                break
              case 'select':
                ;(e._wrapperState = { wasMultiple: !!n.multiple }), (i = Wt({}, n, { value: void 0 })), Vt('invalid', e)
                break
              case 'textarea':
                Gm(e, n), (i = Td(e, n)), Vt('invalid', e)
                break
              default:
                i = n
            }
            Md(t, i)
            var o = i
            for (s in o)
              if (o.hasOwnProperty(s)) {
                var l = o[s]
                s === 'style'
                  ? Qm(e, l)
                  : s === 'dangerouslySetInnerHTML'
                  ? ((l = l ? l.__html : void 0), l != null && Ym(e, l))
                  : s === 'children'
                  ? typeof l == 'string'
                    ? (t !== 'textarea' || l !== '') && va(e, l)
                    : typeof l == 'number' && va(e, '' + l)
                  : s !== 'suppressContentEditableWarning' &&
                    s !== 'suppressHydrationWarning' &&
                    s !== 'autoFocus' &&
                    (da.hasOwnProperty(s)
                      ? l != null && s === 'onScroll' && Vt('scroll', e)
                      : l != null && fd(e, s, l, u))
              }
            switch (t) {
              case 'input':
                Nu(e), $m(e, n, !1)
                break
              case 'textarea':
                Nu(e), Jm(e)
                break
              case 'option':
                n.value != null && e.setAttribute('value', '' + yi(n.value))
                break
              case 'select':
                ;(e.multiple = !!n.multiple),
                  (s = n.value),
                  s != null
                    ? Fs(e, !!n.multiple, s, !1)
                    : n.defaultValue != null && Fs(e, !!n.multiple, n.defaultValue, !0)
                break
              default:
                typeof i.onClick == 'function' && (e.onclick = Qu)
            }
            Zb(t, n) && (r.flags |= 4)
          }
          r.ref !== null && (r.flags |= 128)
        }
        return null
      case 6:
        if (e && r.stateNode != null) Zy(e, r, e.memoizedProps, n)
        else {
          if (typeof n != 'string' && r.stateNode === null) throw Error(Ke(166))
          ;(t = ts(Fa.current)),
            ts(kn.current),
            bl(r)
              ? ((n = r.stateNode), (t = r.memoizedProps), (n[Si] = r), n.nodeValue !== t && (r.flags |= 4))
              : ((n = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(n)), (n[Si] = r), (r.stateNode = n))
        }
        return null
      case 13:
        return (
          Ht(Xt),
          (n = r.memoizedState),
          (r.flags & 64) != 0
            ? ((r.lanes = t), r)
            : ((n = n !== null),
              (t = !1),
              e === null ? r.memoizedProps.fallback !== void 0 && bl(r) : (t = e.memoizedState !== null),
              n &&
                !t &&
                (r.mode & 2) != 0 &&
                ((e === null && r.memoizedProps.unstable_avoidThisFallback !== !0) || (Xt.current & 1) != 0
                  ? wr === 0 && (wr = 3)
                  : ((wr === 0 || wr === 3) && (wr = 4),
                    qr === null || ((Ya & 134217727) == 0 && (fo & 134217727) == 0) || po(qr, Cr))),
              (n || t) && (r.flags |= 4),
              null)
        )
      case 4:
        return co(), Lh(r), e === null && Gb(r.stateNode.containerInfo), null
      case 10:
        return gh(r), null
      case 17:
        return Fr(r.type) && nl(), null
      case 19:
        if ((Ht(Xt), (n = r.memoizedState), n === null)) return null
        if (((s = (r.flags & 64) != 0), (u = n.rendering), u === null))
          if (s) Xa(n, !1)
          else {
            if (wr !== 0 || (e !== null && (e.flags & 64) != 0))
              for (e = r.child; e !== null; ) {
                if (((u = ml(e)), u !== null)) {
                  for (
                    r.flags |= 64,
                      Xa(n, !1),
                      s = u.updateQueue,
                      s !== null && ((r.updateQueue = s), (r.flags |= 4)),
                      n.lastEffect === null && (r.firstEffect = null),
                      r.lastEffect = n.lastEffect,
                      n = t,
                      t = r.child;
                    t !== null;

                  )
                    (s = t),
                      (e = n),
                      (s.flags &= 2),
                      (s.nextEffect = null),
                      (s.firstEffect = null),
                      (s.lastEffect = null),
                      (u = s.alternate),
                      u === null
                        ? ((s.childLanes = 0),
                          (s.lanes = e),
                          (s.child = null),
                          (s.memoizedProps = null),
                          (s.memoizedState = null),
                          (s.updateQueue = null),
                          (s.dependencies = null),
                          (s.stateNode = null))
                        : ((s.childLanes = u.childLanes),
                          (s.lanes = u.lanes),
                          (s.child = u.child),
                          (s.memoizedProps = u.memoizedProps),
                          (s.memoizedState = u.memoizedState),
                          (s.updateQueue = u.updateQueue),
                          (s.type = u.type),
                          (e = u.dependencies),
                          (s.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext })),
                      (t = t.sibling)
                  return Jt(Xt, (Xt.current & 1) | 2), r.child
                }
                e = e.sibling
              }
            n.tail !== null && Ir() > Wh && ((r.flags |= 64), (s = !0), Xa(n, !1), (r.lanes = 33554432))
          }
        else {
          if (!s)
            if (((e = ml(u)), e !== null)) {
              if (
                ((r.flags |= 64),
                (s = !0),
                (t = e.updateQueue),
                t !== null && ((r.updateQueue = t), (r.flags |= 4)),
                Xa(n, !0),
                n.tail === null && n.tailMode === 'hidden' && !u.alternate && !Mn)
              )
                return (r = r.lastEffect = n.lastEffect), r !== null && (r.nextEffect = null), null
            } else
              2 * Ir() - n.renderingStartTime > Wh &&
                t !== 1073741824 &&
                ((r.flags |= 64), (s = !0), Xa(n, !1), (r.lanes = 33554432))
          n.isBackwards
            ? ((u.sibling = r.child), (r.child = u))
            : ((t = n.last), t !== null ? (t.sibling = u) : (r.child = u), (n.last = u))
        }
        return n.tail !== null
          ? ((t = n.tail),
            (n.rendering = t),
            (n.tail = t.sibling),
            (n.lastEffect = r.lastEffect),
            (n.renderingStartTime = Ir()),
            (t.sibling = null),
            (r = Xt.current),
            Jt(Xt, s ? (r & 1) | 2 : r & 1),
            t)
          : null
      case 23:
      case 24:
        return (
          e0(),
          e !== null &&
            (e.memoizedState !== null) != (r.memoizedState !== null) &&
            n.mode !== 'unstable-defer-without-hiding' &&
            (r.flags |= 4),
          null
        )
    }
    throw Error(Ke(156, r.tag))
  }
  function $x(e) {
    switch (e.tag) {
      case 1:
        Fr(e.type) && nl()
        var r = e.flags
        return r & 4096 ? ((e.flags = (r & -4097) | 64), e) : null
      case 3:
        if ((co(), Ht(Kr), Ht(Ar), Th(), (r = e.flags), (r & 64) != 0)) throw Error(Ke(285))
        return (e.flags = (r & -4097) | 64), e
      case 5:
        return Sh(e), null
      case 13:
        return Ht(Xt), (r = e.flags), r & 4096 ? ((e.flags = (r & -4097) | 64), e) : null
      case 19:
        return Ht(Xt), null
      case 4:
        return co(), null
      case 10:
        return gh(e), null
      case 23:
      case 24:
        return e0(), null
      default:
        return null
    }
  }
  function Uh(e, r) {
    try {
      var t = '',
        n = r
      do (t += TM(n)), (n = n.return)
      while (n)
      var i = t
    } catch (s) {
      i =
        `
Error generating stack: ` +
        s.message +
        `
` +
        s.stack
    }
    return { value: e, source: r, stack: i }
  }
  function qh(e, r) {
    try {
      console.error(r.value)
    } catch (t) {
      setTimeout(function () {
        throw t
      })
    }
  }
  var Gx = typeof WeakMap == 'function' ? WeakMap : Map
  function Qy(e, r, t) {
    ;(t = Ci(-1, t)), (t.tag = 3), (t.payload = { element: null })
    var n = r.value
    return (
      (t.callback = function () {
        Il || ((Il = !0), (Jh = n)), qh(e, r)
      }),
      t
    )
  }
  function ev(e, r, t) {
    ;(t = Ci(-1, t)), (t.tag = 3)
    var n = e.type.getDerivedStateFromError
    if (typeof n == 'function') {
      var i = r.value
      t.payload = function () {
        return qh(e, r), n(i)
      }
    }
    var s = e.stateNode
    return (
      s !== null &&
        typeof s.componentDidCatch == 'function' &&
        (t.callback = function () {
          typeof n != 'function' && (Rn === null ? (Rn = new Set([this])) : Rn.add(this), qh(e, r))
          var u = r.stack
          this.componentDidCatch(r.value, { componentStack: u !== null ? u : '' })
        }),
      t
    )
  }
  var Wx = typeof WeakSet == 'function' ? WeakSet : Set
  function tv(e) {
    var r = e.ref
    if (r !== null)
      if (typeof r == 'function')
        try {
          r(null)
        } catch (t) {
          Pi(e, t)
        }
      else r.current = null
  }
  function Jx(e, r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        return
      case 1:
        if (r.flags & 256 && e !== null) {
          var t = e.memoizedProps,
            n = e.memoizedState
          ;(e = r.stateNode),
            (r = e.getSnapshotBeforeUpdate(r.elementType === r.type ? t : bn(r.type, t), n)),
            (e.__reactInternalSnapshotBeforeUpdate = r)
        }
        return
      case 3:
        r.flags & 256 && uh(r.stateNode.containerInfo)
        return
      case 5:
      case 6:
      case 4:
      case 17:
        return
    }
    throw Error(Ke(163))
  }
  function Xx(e, r, t) {
    switch (t.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        if (((r = t.updateQueue), (r = r !== null ? r.lastEffect : null), r !== null)) {
          e = r = r.next
          do {
            if ((e.tag & 3) == 3) {
              var n = e.create
              e.destroy = n()
            }
            e = e.next
          } while (e !== r)
        }
        if (((r = t.updateQueue), (r = r !== null ? r.lastEffect : null), r !== null)) {
          e = r = r.next
          do {
            var i = e
            ;(n = i.next), (i = i.tag), (i & 4) != 0 && (i & 1) != 0 && (bv(t, e), iR(t, e)), (e = n)
          } while (e !== r)
        }
        return
      case 1:
        ;(e = t.stateNode),
          t.flags & 4 &&
            (r === null
              ? e.componentDidMount()
              : ((n = t.elementType === t.type ? r.memoizedProps : bn(t.type, r.memoizedProps)),
                e.componentDidUpdate(n, r.memoizedState, e.__reactInternalSnapshotBeforeUpdate))),
          (r = t.updateQueue),
          r !== null && yy(t, r, e)
        return
      case 3:
        if (((r = t.updateQueue), r !== null)) {
          if (((e = null), t.child !== null))
            switch (t.child.tag) {
              case 5:
                e = t.child.stateNode
                break
              case 1:
                e = t.child.stateNode
            }
          yy(t, r, e)
        }
        return
      case 5:
        ;(e = t.stateNode), r === null && t.flags & 4 && Zb(t.type, t.memoizedProps) && e.focus()
        return
      case 6:
        return
      case 4:
        return
      case 12:
        return
      case 13:
        t.memoizedState === null &&
          ((t = t.alternate),
          t !== null && ((t = t.memoizedState), t !== null && ((t = t.dehydrated), t !== null && mb(t))))
        return
      case 19:
      case 17:
      case 20:
      case 21:
      case 23:
      case 24:
        return
    }
    throw Error(Ke(163))
  }
  function rv(e, r) {
    for (var t = e; ; ) {
      if (t.tag === 5) {
        var n = t.stateNode
        if (r)
          (n = n.style),
            typeof n.setProperty == 'function' ? n.setProperty('display', 'none', 'important') : (n.display = 'none')
        else {
          n = t.stateNode
          var i = t.memoizedProps.style
          ;(i = i != null && i.hasOwnProperty('display') ? i.display : null), (n.style.display = Zm('display', i))
        }
      } else if (t.tag === 6) t.stateNode.nodeValue = r ? '' : t.memoizedProps
      else if (((t.tag !== 23 && t.tag !== 24) || t.memoizedState === null || t === e) && t.child !== null) {
        ;(t.child.return = t), (t = t.child)
        continue
      }
      if (t === e) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === e) return
        t = t.return
      }
      ;(t.sibling.return = t.return), (t = t.sibling)
    }
  }
  function nv(e, r) {
    if (Qi && typeof Qi.onCommitFiberUnmount == 'function')
      try {
        Qi.onCommitFiberUnmount(dh, r)
      } catch (s) {}
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        if (((e = r.updateQueue), e !== null && ((e = e.lastEffect), e !== null))) {
          var t = (e = e.next)
          do {
            var n = t,
              i = n.destroy
            if (((n = n.tag), i !== void 0))
              if ((n & 4) != 0) bv(r, t)
              else {
                n = r
                try {
                  i()
                } catch (s) {
                  Pi(n, s)
                }
              }
            t = t.next
          } while (t !== e)
        }
        break
      case 1:
        if ((tv(r), (e = r.stateNode), typeof e.componentWillUnmount == 'function'))
          try {
            ;(e.props = r.memoizedProps), (e.state = r.memoizedState), e.componentWillUnmount()
          } catch (s) {
            Pi(r, s)
          }
        break
      case 5:
        tv(r)
        break
      case 4:
        av(e, r)
    }
  }
  function iv(e) {
    ;(e.alternate = null),
      (e.child = null),
      (e.dependencies = null),
      (e.firstEffect = null),
      (e.lastEffect = null),
      (e.memoizedProps = null),
      (e.memoizedState = null),
      (e.pendingProps = null),
      (e.return = null),
      (e.updateQueue = null)
  }
  function sv(e) {
    return e.tag === 5 || e.tag === 3 || e.tag === 4
  }
  function ov(e) {
    e: {
      for (var r = e.return; r !== null; ) {
        if (sv(r)) break e
        r = r.return
      }
      throw Error(Ke(160))
    }
    var t = r
    switch (((r = t.stateNode), t.tag)) {
      case 5:
        var n = !1
        break
      case 3:
        ;(r = r.containerInfo), (n = !0)
        break
      case 4:
        ;(r = r.containerInfo), (n = !0)
        break
      default:
        throw Error(Ke(161))
    }
    t.flags & 16 && (va(r, ''), (t.flags &= -17))
    e: t: for (t = e; ; ) {
      for (; t.sibling === null; ) {
        if (t.return === null || sv(t.return)) {
          t = null
          break e
        }
        t = t.return
      }
      for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
        if (t.flags & 2 || t.child === null || t.tag === 4) continue t
        ;(t.child.return = t), (t = t.child)
      }
      if (!(t.flags & 2)) {
        t = t.stateNode
        break e
      }
    }
    n ? jh(e, t, r) : zh(e, t, r)
  }
  function jh(e, r, t) {
    var n = e.tag,
      i = n === 5 || n === 6
    if (i)
      (e = i ? e.stateNode : e.stateNode.instance),
        r
          ? t.nodeType === 8
            ? t.parentNode.insertBefore(e, r)
            : t.insertBefore(e, r)
          : (t.nodeType === 8 ? ((r = t.parentNode), r.insertBefore(e, t)) : ((r = t), r.appendChild(e)),
            (t = t._reactRootContainer),
            t != null || r.onclick !== null || (r.onclick = Qu))
    else if (n !== 4 && ((e = e.child), e !== null))
      for (jh(e, r, t), e = e.sibling; e !== null; ) jh(e, r, t), (e = e.sibling)
  }
  function zh(e, r, t) {
    var n = e.tag,
      i = n === 5 || n === 6
    if (i) (e = i ? e.stateNode : e.stateNode.instance), r ? t.insertBefore(e, r) : t.appendChild(e)
    else if (n !== 4 && ((e = e.child), e !== null))
      for (zh(e, r, t), e = e.sibling; e !== null; ) zh(e, r, t), (e = e.sibling)
  }
  function av(e, r) {
    for (var t = r, n = !1, i, s; ; ) {
      if (!n) {
        n = t.return
        e: for (;;) {
          if (n === null) throw Error(Ke(160))
          switch (((i = n.stateNode), n.tag)) {
            case 5:
              s = !1
              break e
            case 3:
              ;(i = i.containerInfo), (s = !0)
              break e
            case 4:
              ;(i = i.containerInfo), (s = !0)
              break e
          }
          n = n.return
        }
        n = !0
      }
      if (t.tag === 5 || t.tag === 6) {
        e: for (var u = e, o = t, l = o; ; )
          if ((nv(u, l), l.child !== null && l.tag !== 4)) (l.child.return = l), (l = l.child)
          else {
            if (l === o) break e
            for (; l.sibling === null; ) {
              if (l.return === null || l.return === o) break e
              l = l.return
            }
            ;(l.sibling.return = l.return), (l = l.sibling)
          }
        s
          ? ((u = i), (o = t.stateNode), u.nodeType === 8 ? u.parentNode.removeChild(o) : u.removeChild(o))
          : i.removeChild(t.stateNode)
      } else if (t.tag === 4) {
        if (t.child !== null) {
          ;(i = t.stateNode.containerInfo), (s = !0), (t.child.return = t), (t = t.child)
          continue
        }
      } else if ((nv(e, t), t.child !== null)) {
        ;(t.child.return = t), (t = t.child)
        continue
      }
      if (t === r) break
      for (; t.sibling === null; ) {
        if (t.return === null || t.return === r) return
        ;(t = t.return), t.tag === 4 && (n = !1)
      }
      ;(t.sibling.return = t.return), (t = t.sibling)
    }
  }
  function Kh(e, r) {
    switch (r.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        var t = r.updateQueue
        if (((t = t !== null ? t.lastEffect : null), t !== null)) {
          var n = (t = t.next)
          do (n.tag & 3) == 3 && ((e = n.destroy), (n.destroy = void 0), e !== void 0 && e()), (n = n.next)
          while (n !== t)
        }
        return
      case 1:
        return
      case 5:
        if (((t = r.stateNode), t != null)) {
          n = r.memoizedProps
          var i = e !== null ? e.memoizedProps : n
          e = r.type
          var s = r.updateQueue
          if (((r.updateQueue = null), s !== null)) {
            for (
              t[tl] = n,
                e === 'input' && n.type === 'radio' && n.name != null && Hm(t, n),
                xd(e, i),
                r = xd(e, n),
                i = 0;
              i < s.length;
              i += 2
            ) {
              var u = s[i],
                o = s[i + 1]
              u === 'style'
                ? Qm(t, o)
                : u === 'dangerouslySetInnerHTML'
                ? Ym(t, o)
                : u === 'children'
                ? va(t, o)
                : fd(t, u, o, r)
            }
            switch (e) {
              case 'input':
                Sd(t, n)
                break
              case 'textarea':
                Wm(t, n)
                break
              case 'select':
                ;(e = t._wrapperState.wasMultiple),
                  (t._wrapperState.wasMultiple = !!n.multiple),
                  (s = n.value),
                  s != null
                    ? Fs(t, !!n.multiple, s, !1)
                    : e !== !!n.multiple &&
                      (n.defaultValue != null
                        ? Fs(t, !!n.multiple, n.defaultValue, !0)
                        : Fs(t, !!n.multiple, n.multiple ? [] : '', !1))
            }
          }
        }
        return
      case 6:
        if (r.stateNode === null) throw Error(Ke(162))
        r.stateNode.nodeValue = r.memoizedProps
        return
      case 3:
        ;(t = r.stateNode), t.hydrate && ((t.hydrate = !1), mb(t.containerInfo))
        return
      case 12:
        return
      case 13:
        r.memoizedState !== null && ((Gh = Ir()), rv(r.child, !0)), cv(r)
        return
      case 19:
        cv(r)
        return
      case 17:
        return
      case 23:
      case 24:
        rv(r, r.memoizedState !== null)
        return
    }
    throw Error(Ke(163))
  }
  function cv(e) {
    var r = e.updateQueue
    if (r !== null) {
      e.updateQueue = null
      var t = e.stateNode
      t === null && (t = e.stateNode = new Wx()),
        r.forEach(function (n) {
          var i = aR.bind(null, e, n)
          t.has(n) || (t.add(n), n.then(i, i))
        })
    }
  }
  function Yx(e, r) {
    return e !== null && ((e = e.memoizedState), e === null || e.dehydrated !== null)
      ? ((r = r.memoizedState), r !== null && r.dehydrated === null)
      : !1
  }
  var Zx = Math.ceil,
    Sl = Gi.ReactCurrentDispatcher,
    Fh = Gi.ReactCurrentOwner,
    bt = 0,
    qr = null,
    sr = null,
    Cr = 0,
    is = 0,
    Vh = Ai(0),
    wr = 0,
    Al = null,
    lo = 0,
    Ya = 0,
    fo = 0,
    Hh = 0,
    $h = null,
    Gh = 0,
    Wh = 1 / 0
  function ho() {
    Wh = Ir() + 500
  }
  var ct = null,
    Il = !1,
    Jh = null,
    Rn = null,
    xi = !1,
    Za = null,
    Qa = 90,
    Xh = [],
    Yh = [],
    Xn = null,
    ec = 0,
    Zh = null,
    Tl = -1,
    Yn = 0,
    Cl = 0,
    tc = null,
    kl = !1
  function Xr() {
    return (bt & 48) != 0 ? Ir() : Tl !== -1 ? Tl : (Tl = Ir())
  }
  function Ri(e) {
    if (((e = e.mode), (e & 2) == 0)) return 1
    if ((e & 4) == 0) return so() === 99 ? 1 : 2
    if ((Yn === 0 && (Yn = lo), qx.transition !== 0)) {
      Cl !== 0 && (Cl = $h !== null ? $h.pendingLanes : 0), (e = Yn)
      var r = 4186112 & ~Cl
      return (r &= -r), r === 0 && ((e = 4186112 & ~e), (r = e & -e), r === 0 && (r = 8192)), r
    }
    return (e = so()), (bt & 4) != 0 && e === 98 ? (e = zu(12, Yn)) : ((e = KM(e)), (e = zu(e, Yn))), e
  }
  function Bi(e, r, t) {
    if (50 < ec) throw ((ec = 0), (Zh = null), Error(Ke(185)))
    if (((e = Ml(e, r)), e === null)) return null
    Ku(e, r, t), e === qr && ((fo |= r), wr === 4 && po(e, Cr))
    var n = so()
    r === 1
      ? (bt & 8) != 0 && (bt & 48) == 0
        ? Qh(e)
        : (on(e, t), bt === 0 && (ho(), Cn()))
      : ((bt & 4) == 0 || (n !== 98 && n !== 99) || (Xn === null ? (Xn = new Set([e])) : Xn.add(e)), on(e, t)),
      ($h = e)
  }
  function Ml(e, r) {
    e.lanes |= r
    var t = e.alternate
    for (t !== null && (t.lanes |= r), t = e, e = e.return; e !== null; )
      (e.childLanes |= r), (t = e.alternate), t !== null && (t.childLanes |= r), (t = e), (e = e.return)
    return t.tag === 3 ? t.stateNode : null
  }
  function on(e, r) {
    for (
      var t = e.callbackNode, n = e.suspendedLanes, i = e.pingedLanes, s = e.expirationTimes, u = e.pendingLanes;
      0 < u;

    ) {
      var o = 31 - _i(u),
        l = 1 << o,
        a = s[o]
      if (a === -1) {
        if ((l & n) == 0 || (l & i) != 0) {
          ;(a = r), Ws(l)
          var c = jt
          s[o] = 10 <= c ? a + 250 : 6 <= c ? a + 5e3 : -1
        }
      } else a <= r && (e.expiredLanes |= l)
      u &= ~l
    }
    if (((n = Ca(e, e === qr ? Cr : 0)), (r = jt), n === 0))
      t !== null && (t !== bh && ph(t), (e.callbackNode = null), (e.callbackPriority = 0))
    else {
      if (t !== null) {
        if (e.callbackPriority === r) return
        t !== bh && ph(t)
      }
      r === 15
        ? ((t = Qh.bind(null, e)), Gn === null ? ((Gn = [t]), (ol = hh(sl, hy))) : Gn.push(t), (t = bh))
        : r === 14
        ? (t = Ua(99, Qh.bind(null, e)))
        : ((t = FM(r)), (t = Ua(t, uv.bind(null, e)))),
        (e.callbackPriority = r),
        (e.callbackNode = t)
    }
  }
  function uv(e) {
    if (((Tl = -1), (Cl = Yn = 0), (bt & 48) != 0)) throw Error(Ke(327))
    var r = e.callbackNode
    if (Ni() && e.callbackNode !== r) return null
    var t = Ca(e, e === qr ? Cr : 0)
    if (t === 0) return null
    var n = t,
      i = bt
    bt |= 16
    var s = hv()
    ;(qr !== e || Cr !== n) && (ho(), mo(e, n))
    do
      try {
        tR()
        break
      } catch (o) {
        dv(e, o)
      }
    while (1)
    if ((vh(), (Sl.current = s), (bt = i), sr !== null ? (n = 0) : ((qr = null), (Cr = 0), (n = wr)), (lo & fo) != 0))
      mo(e, 0)
    else if (n !== 0) {
      if (
        (n === 2 &&
          ((bt |= 64), e.hydrate && ((e.hydrate = !1), uh(e.containerInfo)), (t = Eb(e)), t !== 0 && (n = rc(e, t))),
        n === 1)
      )
        throw ((r = Al), mo(e, 0), po(e, t), on(e, Ir()), r)
      switch (((e.finishedWork = e.current.alternate), (e.finishedLanes = t), n)) {
        case 0:
        case 1:
          throw Error(Ke(345))
        case 2:
          ss(e)
          break
        case 3:
          if ((po(e, t), (t & 62914560) === t && ((n = Gh + 500 - Ir()), 10 < n))) {
            if (Ca(e, 0) !== 0) break
            if (((i = e.suspendedLanes), (i & t) !== t)) {
              Xr(), (e.pingedLanes |= e.suspendedLanes & i)
              break
            }
            e.timeoutHandle = Qb(ss.bind(null, e), n)
            break
          }
          ss(e)
          break
        case 4:
          if ((po(e, t), (t & 4186112) === t)) break
          for (n = e.eventTimes, i = -1; 0 < t; ) {
            var u = 31 - _i(t)
            ;(s = 1 << u), (u = n[u]), u > i && (i = u), (t &= ~s)
          }
          if (
            ((t = i),
            (t = Ir() - t),
            (t =
              (120 > t
                ? 120
                : 480 > t
                ? 480
                : 1080 > t
                ? 1080
                : 1920 > t
                ? 1920
                : 3e3 > t
                ? 3e3
                : 4320 > t
                ? 4320
                : 1960 * Zx(t / 1960)) - t),
            10 < t)
          ) {
            e.timeoutHandle = Qb(ss.bind(null, e), t)
            break
          }
          ss(e)
          break
        case 5:
          ss(e)
          break
        default:
          throw Error(Ke(329))
      }
    }
    return on(e, Ir()), e.callbackNode === r ? uv.bind(null, e) : null
  }
  function po(e, r) {
    for (r &= ~Hh, r &= ~fo, e.suspendedLanes |= r, e.pingedLanes &= ~r, e = e.expirationTimes; 0 < r; ) {
      var t = 31 - _i(r),
        n = 1 << t
      ;(e[t] = -1), (r &= ~n)
    }
  }
  function Qh(e) {
    if ((bt & 48) != 0) throw Error(Ke(327))
    if ((Ni(), e === qr && (e.expiredLanes & Cr) != 0)) {
      var r = Cr,
        t = rc(e, r)
      ;(lo & fo) != 0 && ((r = Ca(e, r)), (t = rc(e, r)))
    } else (r = Ca(e, 0)), (t = rc(e, r))
    if (
      (e.tag !== 0 &&
        t === 2 &&
        ((bt |= 64), e.hydrate && ((e.hydrate = !1), uh(e.containerInfo)), (r = Eb(e)), r !== 0 && (t = rc(e, r))),
      t === 1)
    )
      throw ((t = Al), mo(e, 0), po(e, r), on(e, Ir()), t)
    return (e.finishedWork = e.current.alternate), (e.finishedLanes = r), ss(e), on(e, Ir()), null
  }
  function Qx() {
    if (Xn !== null) {
      var e = Xn
      ;(Xn = null),
        e.forEach(function (r) {
          ;(r.expiredLanes |= 24 & r.pendingLanes), on(r, Ir())
        })
    }
    Cn()
  }
  function lv(e, r) {
    var t = bt
    bt |= 1
    try {
      return e(r)
    } finally {
      ;(bt = t), bt === 0 && (ho(), Cn())
    }
  }
  function fv(e, r) {
    var t = bt
    ;(bt &= -2), (bt |= 8)
    try {
      return e(r)
    } finally {
      ;(bt = t), bt === 0 && (ho(), Cn())
    }
  }
  function xl(e, r) {
    Jt(Vh, is), (is |= r), (lo |= r)
  }
  function e0() {
    ;(is = Vh.current), Ht(Vh)
  }
  function mo(e, r) {
    ;(e.finishedWork = null), (e.finishedLanes = 0)
    var t = e.timeoutHandle
    if ((t !== -1 && ((e.timeoutHandle = -1), Nx(t)), sr !== null))
      for (t = sr.return; t !== null; ) {
        var n = t
        switch (n.tag) {
          case 1:
            ;(n = n.type.childContextTypes), n != null && nl()
            break
          case 3:
            co(), Ht(Kr), Ht(Ar), Th()
            break
          case 5:
            Sh(n)
            break
          case 4:
            co()
            break
          case 13:
            Ht(Xt)
            break
          case 19:
            Ht(Xt)
            break
          case 10:
            gh(n)
            break
          case 23:
          case 24:
            e0()
        }
        t = t.return
      }
    ;(qr = e), (sr = Oi(e.current, null)), (Cr = is = lo = r), (wr = 0), (Al = null), (Hh = fo = Ya = 0)
  }
  function dv(e, r) {
    do {
      var t = sr
      try {
        if ((vh(), (Va.current = _l), yl)) {
          for (var n = Qt.memoizedState; n !== null; ) {
            var i = n.queue
            i !== null && (i.pending = null), (n = n.next)
          }
          yl = !1
        }
        if (((Ha = 0), (gr = Tr = Qt = null), ($a = !1), (Fh.current = null), t === null || t.return === null)) {
          ;(wr = 1), (Al = r), (sr = null)
          break
        }
        e: {
          var s = e,
            u = t.return,
            o = t,
            l = r
          if (
            ((r = Cr),
            (o.flags |= 2048),
            (o.firstEffect = o.lastEffect = null),
            l !== null && typeof l == 'object' && typeof l.then == 'function')
          ) {
            var a = l
            if ((o.mode & 2) == 0) {
              var c = o.alternate
              c
                ? ((o.updateQueue = c.updateQueue), (o.memoizedState = c.memoizedState), (o.lanes = c.lanes))
                : ((o.updateQueue = null), (o.memoizedState = null))
            }
            var f = (Xt.current & 1) != 0,
              p = u
            do {
              var y
              if ((y = p.tag === 13)) {
                var d = p.memoizedState
                if (d !== null) y = d.dehydrated !== null
                else {
                  var h = p.memoizedProps
                  y = h.fallback === void 0 ? !1 : h.unstable_avoidThisFallback !== !0 ? !0 : !f
                }
              }
              if (y) {
                var m = p.updateQueue
                if (m === null) {
                  var _ = new Set()
                  _.add(a), (p.updateQueue = _)
                } else m.add(a)
                if ((p.mode & 2) == 0) {
                  if (((p.flags |= 64), (o.flags |= 16384), (o.flags &= -2981), o.tag === 1))
                    if (o.alternate === null) o.tag = 17
                    else {
                      var A = Ci(-1, 1)
                      ;(A.tag = 2), ki(o, A)
                    }
                  o.lanes |= 1
                  break e
                }
                ;(l = void 0), (o = r)
                var T = s.pingCache
                if (
                  (T === null
                    ? ((T = s.pingCache = new Gx()), (l = new Set()), T.set(a, l))
                    : ((l = T.get(a)), l === void 0 && ((l = new Set()), T.set(a, l))),
                  !l.has(o))
                ) {
                  l.add(o)
                  var E = oR.bind(null, s, a, o)
                  a.then(E, E)
                }
                ;(p.flags |= 4096), (p.lanes = r)
                break e
              }
              p = p.return
            } while (p !== null)
            l = Error(
              (Ks(o.type) || 'A React component') +
                ` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`
            )
          }
          wr !== 5 && (wr = 2), (l = Uh(l, o)), (p = u)
          do {
            switch (p.tag) {
              case 3:
                ;(s = l), (p.flags |= 4096), (r &= -r), (p.lanes |= r)
                var k = Qy(p, s, r)
                by(p, k)
                break e
              case 1:
                s = l
                var w = p.type,
                  v = p.stateNode
                if (
                  (p.flags & 64) == 0 &&
                  (typeof w.getDerivedStateFromError == 'function' ||
                    (v !== null && typeof v.componentDidCatch == 'function' && (Rn === null || !Rn.has(v))))
                ) {
                  ;(p.flags |= 4096), (r &= -r), (p.lanes |= r)
                  var I = ev(p, s, r)
                  by(p, I)
                  break e
                }
            }
            p = p.return
          } while (p !== null)
        }
        mv(t)
      } catch (M) {
        ;(r = M), sr === t && t !== null && (sr = t = t.return)
        continue
      }
      break
    } while (1)
  }
  function hv() {
    var e = Sl.current
    return (Sl.current = _l), e === null ? _l : e
  }
  function rc(e, r) {
    var t = bt
    bt |= 16
    var n = hv()
    ;(qr === e && Cr === r) || mo(e, r)
    do
      try {
        eR()
        break
      } catch (i) {
        dv(e, i)
      }
    while (1)
    if ((vh(), (bt = t), (Sl.current = n), sr !== null)) throw Error(Ke(261))
    return (qr = null), (Cr = 0), wr
  }
  function eR() {
    for (; sr !== null; ) pv(sr)
  }
  function tR() {
    for (; sr !== null && !Dx(); ) pv(sr)
  }
  function pv(e) {
    var r = vv(e.alternate, e, is)
    ;(e.memoizedProps = e.pendingProps), r === null ? mv(e) : (sr = r), (Fh.current = null)
  }
  function mv(e) {
    var r = e
    do {
      var t = r.alternate
      if (((e = r.return), (r.flags & 2048) == 0)) {
        if (((t = Hx(t, r, is)), t !== null)) {
          sr = t
          return
        }
        if (
          ((t = r),
          (t.tag !== 24 && t.tag !== 23) || t.memoizedState === null || (is & 1073741824) != 0 || (t.mode & 4) == 0)
        ) {
          for (var n = 0, i = t.child; i !== null; ) (n |= i.lanes | i.childLanes), (i = i.sibling)
          t.childLanes = n
        }
        e !== null &&
          (e.flags & 2048) == 0 &&
          (e.firstEffect === null && (e.firstEffect = r.firstEffect),
          r.lastEffect !== null &&
            (e.lastEffect !== null && (e.lastEffect.nextEffect = r.firstEffect), (e.lastEffect = r.lastEffect)),
          1 < r.flags &&
            (e.lastEffect !== null ? (e.lastEffect.nextEffect = r) : (e.firstEffect = r), (e.lastEffect = r)))
      } else {
        if (((t = $x(r)), t !== null)) {
          ;(t.flags &= 2047), (sr = t)
          return
        }
        e !== null && ((e.firstEffect = e.lastEffect = null), (e.flags |= 2048))
      }
      if (((r = r.sibling), r !== null)) {
        sr = r
        return
      }
      sr = r = e
    } while (r !== null)
    wr === 0 && (wr = 5)
  }
  function ss(e) {
    var r = so()
    return es(99, rR.bind(null, e, r)), null
  }
  function rR(e, r) {
    do Ni()
    while (Za !== null)
    if ((bt & 48) != 0) throw Error(Ke(327))
    var t = e.finishedWork
    if (t === null) return null
    if (((e.finishedWork = null), (e.finishedLanes = 0), t === e.current)) throw Error(Ke(177))
    e.callbackNode = null
    var n = t.lanes | t.childLanes,
      i = n,
      s = e.pendingLanes & ~i
    ;(e.pendingLanes = i),
      (e.suspendedLanes = 0),
      (e.pingedLanes = 0),
      (e.expiredLanes &= i),
      (e.mutableReadLanes &= i),
      (e.entangledLanes &= i),
      (i = e.entanglements)
    for (var u = e.eventTimes, o = e.expirationTimes; 0 < s; ) {
      var l = 31 - _i(s),
        a = 1 << l
      ;(i[l] = 0), (u[l] = -1), (o[l] = -1), (s &= ~a)
    }
    if (
      (Xn !== null && (n & 24) == 0 && Xn.has(e) && Xn.delete(e),
      e === qr && ((sr = qr = null), (Cr = 0)),
      1 < t.flags
        ? t.lastEffect !== null
          ? ((t.lastEffect.nextEffect = t), (n = t.firstEffect))
          : (n = t)
        : (n = t.firstEffect),
      n !== null)
    ) {
      if (((i = bt), (bt |= 32), (Fh.current = null), (oh = Fu), (u = zb()), rh(u))) {
        if ('selectionStart' in u) o = { start: u.selectionStart, end: u.selectionEnd }
        else
          e: if (
            ((o = ((o = u.ownerDocument) && o.defaultView) || window),
            (a = o.getSelection && o.getSelection()) && a.rangeCount !== 0)
          ) {
            ;(o = a.anchorNode), (s = a.anchorOffset), (l = a.focusNode), (a = a.focusOffset)
            try {
              o.nodeType, l.nodeType
            } catch (M) {
              o = null
              break e
            }
            var c = 0,
              f = -1,
              p = -1,
              y = 0,
              d = 0,
              h = u,
              m = null
            t: for (;;) {
              for (
                var _;
                h !== o || (s !== 0 && h.nodeType !== 3) || (f = c + s),
                  h !== l || (a !== 0 && h.nodeType !== 3) || (p = c + a),
                  h.nodeType === 3 && (c += h.nodeValue.length),
                  (_ = h.firstChild) !== null;

              )
                (m = h), (h = _)
              for (;;) {
                if (h === u) break t
                if ((m === o && ++y === s && (f = c), m === l && ++d === a && (p = c), (_ = h.nextSibling) !== null))
                  break
                ;(h = m), (m = h.parentNode)
              }
              h = _
            }
            o = f === -1 || p === -1 ? null : { start: f, end: p }
          } else o = null
        o = o || { start: 0, end: 0 }
      } else o = null
      ;(ah = { focusedElem: u, selectionRange: o }), (Fu = !1), (tc = null), (kl = !1), (ct = n)
      do
        try {
          nR()
        } catch (M) {
          if (ct === null) throw Error(Ke(330))
          Pi(ct, M), (ct = ct.nextEffect)
        }
      while (ct !== null)
      ;(tc = null), (ct = n)
      do
        try {
          for (u = e; ct !== null; ) {
            var A = ct.flags
            if ((A & 16 && va(ct.stateNode, ''), A & 128)) {
              var T = ct.alternate
              if (T !== null) {
                var E = T.ref
                E !== null && (typeof E == 'function' ? E(null) : (E.current = null))
              }
            }
            switch (A & 1038) {
              case 2:
                ov(ct), (ct.flags &= -3)
                break
              case 6:
                ov(ct), (ct.flags &= -3), Kh(ct.alternate, ct)
                break
              case 1024:
                ct.flags &= -1025
                break
              case 1028:
                ;(ct.flags &= -1025), Kh(ct.alternate, ct)
                break
              case 4:
                Kh(ct.alternate, ct)
                break
              case 8:
                ;(o = ct), av(u, o)
                var k = o.alternate
                iv(o), k !== null && iv(k)
            }
            ct = ct.nextEffect
          }
        } catch (M) {
          if (ct === null) throw Error(Ke(330))
          Pi(ct, M), (ct = ct.nextEffect)
        }
      while (ct !== null)
      if (
        ((E = ah),
        (T = zb()),
        (A = E.focusedElem),
        (u = E.selectionRange),
        T !== A && A && A.ownerDocument && jb(A.ownerDocument.documentElement, A))
      ) {
        for (
          u !== null &&
            rh(A) &&
            ((T = u.start),
            (E = u.end),
            E === void 0 && (E = T),
            ('selectionStart' in A)
              ? ((A.selectionStart = T), (A.selectionEnd = Math.min(E, A.value.length)))
              : ((E = ((T = A.ownerDocument || document) && T.defaultView) || window),
                E.getSelection &&
                  ((E = E.getSelection()),
                  (o = A.textContent.length),
                  (k = Math.min(u.start, o)),
                  (u = u.end === void 0 ? k : Math.min(u.end, o)),
                  !E.extend && k > u && ((o = u), (u = k), (k = o)),
                  (o = qb(A, k)),
                  (s = qb(A, u)),
                  o &&
                    s &&
                    (E.rangeCount !== 1 ||
                      E.anchorNode !== o.node ||
                      E.anchorOffset !== o.offset ||
                      E.focusNode !== s.node ||
                      E.focusOffset !== s.offset) &&
                    ((T = T.createRange()),
                    T.setStart(o.node, o.offset),
                    E.removeAllRanges(),
                    k > u
                      ? (E.addRange(T), E.extend(s.node, s.offset))
                      : (T.setEnd(s.node, s.offset), E.addRange(T)))))),
            T = [],
            E = A;
          (E = E.parentNode);

        )
          E.nodeType === 1 && T.push({ element: E, left: E.scrollLeft, top: E.scrollTop })
        for (typeof A.focus == 'function' && A.focus(), A = 0; A < T.length; A++)
          (E = T[A]), (E.element.scrollLeft = E.left), (E.element.scrollTop = E.top)
      }
      ;(Fu = !!oh), (ah = oh = null), (e.current = t), (ct = n)
      do
        try {
          for (A = e; ct !== null; ) {
            var w = ct.flags
            if ((w & 36 && Xx(A, ct.alternate, ct), w & 128)) {
              T = void 0
              var v = ct.ref
              if (v !== null) {
                var I = ct.stateNode
                switch (ct.tag) {
                  case 5:
                    T = I
                    break
                  default:
                    T = I
                }
                typeof v == 'function' ? v(T) : (v.current = T)
              }
            }
            ct = ct.nextEffect
          }
        } catch (M) {
          if (ct === null) throw Error(Ke(330))
          Pi(ct, M), (ct = ct.nextEffect)
        }
      while (ct !== null)
      ;(ct = null), Ux(), (bt = i)
    } else e.current = t
    if (xi) (xi = !1), (Za = e), (Qa = r)
    else
      for (ct = n; ct !== null; )
        (r = ct.nextEffect),
          (ct.nextEffect = null),
          ct.flags & 8 && ((w = ct), (w.sibling = null), (w.stateNode = null)),
          (ct = r)
    if (
      ((n = e.pendingLanes),
      n === 0 && (Rn = null),
      n === 1 ? (e === Zh ? ec++ : ((ec = 0), (Zh = e))) : (ec = 0),
      (t = t.stateNode),
      Qi && typeof Qi.onCommitFiberRoot == 'function')
    )
      try {
        Qi.onCommitFiberRoot(dh, t, void 0, (t.current.flags & 64) == 64)
      } catch (M) {}
    if ((on(e, Ir()), Il)) throw ((Il = !1), (e = Jh), (Jh = null), e)
    return (bt & 8) != 0 || Cn(), null
  }
  function nR() {
    for (; ct !== null; ) {
      var e = ct.alternate
      kl ||
        tc === null ||
        ((ct.flags & 8) != 0 ? cb(ct, tc) && (kl = !0) : ct.tag === 13 && Yx(e, ct) && cb(ct, tc) && (kl = !0))
      var r = ct.flags
      ;(r & 256) != 0 && Jx(e, ct),
        (r & 512) == 0 ||
          xi ||
          ((xi = !0),
          Ua(97, function () {
            return Ni(), null
          })),
        (ct = ct.nextEffect)
    }
  }
  function Ni() {
    if (Qa !== 90) {
      var e = 97 < Qa ? 97 : Qa
      return (Qa = 90), es(e, sR)
    }
    return !1
  }
  function iR(e, r) {
    Xh.push(r, e),
      xi ||
        ((xi = !0),
        Ua(97, function () {
          return Ni(), null
        }))
  }
  function bv(e, r) {
    Yh.push(r, e),
      xi ||
        ((xi = !0),
        Ua(97, function () {
          return Ni(), null
        }))
  }
  function sR() {
    if (Za === null) return !1
    var e = Za
    if (((Za = null), (bt & 48) != 0)) throw Error(Ke(331))
    var r = bt
    bt |= 32
    var t = Yh
    Yh = []
    for (var n = 0; n < t.length; n += 2) {
      var i = t[n],
        s = t[n + 1],
        u = i.destroy
      if (((i.destroy = void 0), typeof u == 'function'))
        try {
          u()
        } catch (l) {
          if (s === null) throw Error(Ke(330))
          Pi(s, l)
        }
    }
    for (t = Xh, Xh = [], n = 0; n < t.length; n += 2) {
      ;(i = t[n]), (s = t[n + 1])
      try {
        var o = i.create
        i.destroy = o()
      } catch (l) {
        if (s === null) throw Error(Ke(330))
        Pi(s, l)
      }
    }
    for (o = e.current.firstEffect; o !== null; )
      (e = o.nextEffect), (o.nextEffect = null), o.flags & 8 && ((o.sibling = null), (o.stateNode = null)), (o = e)
    return (bt = r), Cn(), !0
  }
  function yv(e, r, t) {
    ;(r = Uh(t, r)), (r = Qy(e, r, 1)), ki(e, r), (r = Xr()), (e = Ml(e, 1)), e !== null && (Ku(e, 1, r), on(e, r))
  }
  function Pi(e, r) {
    if (e.tag === 3) yv(e, e, r)
    else
      for (var t = e.return; t !== null; ) {
        if (t.tag === 3) {
          yv(t, e, r)
          break
        } else if (t.tag === 1) {
          var n = t.stateNode
          if (
            typeof t.type.getDerivedStateFromError == 'function' ||
            (typeof n.componentDidCatch == 'function' && (Rn === null || !Rn.has(n)))
          ) {
            e = Uh(r, e)
            var i = ev(t, e, 1)
            if ((ki(t, i), (i = Xr()), (t = Ml(t, 1)), t !== null)) Ku(t, 1, i), on(t, i)
            else if (typeof n.componentDidCatch == 'function' && (Rn === null || !Rn.has(n)))
              try {
                n.componentDidCatch(r, e)
              } catch (s) {}
            break
          }
        }
        t = t.return
      }
  }
  function oR(e, r, t) {
    var n = e.pingCache
    n !== null && n.delete(r),
      (r = Xr()),
      (e.pingedLanes |= e.suspendedLanes & t),
      qr === e &&
        (Cr & t) === t &&
        (wr === 4 || (wr === 3 && (Cr & 62914560) === Cr && 500 > Ir() - Gh) ? mo(e, 0) : (Hh |= t)),
      on(e, r)
  }
  function aR(e, r) {
    var t = e.stateNode
    t !== null && t.delete(r),
      (r = 0),
      r === 0 &&
        ((r = e.mode),
        (r & 2) == 0
          ? (r = 1)
          : (r & 4) == 0
          ? (r = so() === 99 ? 1 : 2)
          : (Yn === 0 && (Yn = lo), (r = Js(62914560 & ~Yn)), r === 0 && (r = 4194304))),
      (t = Xr()),
      (e = Ml(e, r)),
      e !== null && (Ku(e, r, t), on(e, t))
  }
  var vv
  vv = function (e, r, t) {
    var n = r.lanes
    if (e !== null)
      if (e.memoizedProps !== r.pendingProps || Kr.current) yn = !0
      else if ((t & n) != 0) yn = (e.flags & 16384) != 0
      else {
        switch (((yn = !1), r.tag)) {
          case 3:
            Fy(r), Ih()
            break
          case 5:
            Ay(r)
            break
          case 1:
            Fr(r.type) && il(r)
            break
          case 4:
            Eh(r, r.stateNode.containerInfo)
            break
          case 10:
            n = r.memoizedProps.value
            var i = r.type._context
            Jt(al, i._currentValue), (i._currentValue = n)
            break
          case 13:
            if (r.memoizedState !== null)
              return (t & r.child.childLanes) != 0
                ? Vy(e, r, t)
                : (Jt(Xt, Xt.current & 1), (r = Jn(e, r, t)), r !== null ? r.sibling : null)
            Jt(Xt, Xt.current & 1)
            break
          case 19:
            if (((n = (t & r.childLanes) != 0), (e.flags & 64) != 0)) {
              if (n) return Jy(e, r, t)
              r.flags |= 64
            }
            if (
              ((i = r.memoizedState),
              i !== null && ((i.rendering = null), (i.tail = null), (i.lastEffect = null)),
              Jt(Xt, Xt.current),
              n)
            )
              break
            return null
          case 23:
          case 24:
            return (r.lanes = 0), Nh(e, r, t)
        }
        return Jn(e, r, t)
      }
    else yn = !1
    switch (((r.lanes = 0), r.tag)) {
      case 2:
        if (
          ((n = r.type),
          e !== null && ((e.alternate = null), (r.alternate = null), (r.flags |= 2)),
          (e = r.pendingProps),
          (i = io(r, Ar.current)),
          ao(r, t),
          (i = kh(null, r, n, e, i, t)),
          (r.flags |= 1),
          typeof i == 'object' && i !== null && typeof i.render == 'function' && i.$$typeof === void 0)
        ) {
          if (((r.tag = 1), (r.memoizedState = null), (r.updateQueue = null), Fr(n))) {
            var s = !0
            il(r)
          } else s = !1
          ;(r.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null), wh(r)
          var u = n.getDerivedStateFromProps
          typeof u == 'function' && ll(r, n, u, e),
            (i.updater = fl),
            (r.stateNode = i),
            (i._reactInternals = r),
            _h(r, n, e, t),
            (r = Oh(null, r, n, !0, s, t))
        } else (r.tag = 0), Hr(null, r, i, t), (r = r.child)
        return r
      case 16:
        i = r.elementType
        e: {
          switch (
            (e !== null && ((e.alternate = null), (r.alternate = null), (r.flags |= 2)),
            (e = r.pendingProps),
            (s = i._init),
            (i = s(i._payload)),
            (r.type = i),
            (s = r.tag = uR(i)),
            (e = bn(i, e)),
            s)
          ) {
            case 0:
              r = Ph(null, r, i, e, t)
              break e
            case 1:
              r = Ky(null, r, i, e, t)
              break e
            case 11:
              r = Uy(null, r, i, e, t)
              break e
            case 14:
              r = qy(null, r, i, bn(i.type, e), n, t)
              break e
          }
          throw Error(Ke(306, i, ''))
        }
        return r
      case 0:
        return (n = r.type), (i = r.pendingProps), (i = r.elementType === n ? i : bn(n, i)), Ph(e, r, n, i, t)
      case 1:
        return (n = r.type), (i = r.pendingProps), (i = r.elementType === n ? i : bn(n, i)), Ky(e, r, n, i, t)
      case 3:
        if ((Fy(r), (n = r.updateQueue), e === null || n === null)) throw Error(Ke(282))
        if (
          ((n = r.pendingProps),
          (i = r.memoizedState),
          (i = i !== null ? i.element : null),
          my(e, r),
          qa(r, n, null, t),
          (n = r.memoizedState.element),
          n === i)
        )
          Ih(), (r = Jn(e, r, t))
        else {
          if (
            ((i = r.stateNode),
            (s = i.hydrate) && ((Mi = eo(r.stateNode.containerInfo.firstChild)), (Wn = r), (s = Mn = !0)),
            s)
          ) {
            if (((e = i.mutableSourceEagerHydrationData), e != null))
              for (i = 0; i < e.length; i += 2) (s = e[i]), (s._workInProgressVersionPrimary = e[i + 1]), uo.push(s)
            for (t = Sy(r, null, n, t), r.child = t; t; ) (t.flags = (t.flags & -3) | 1024), (t = t.sibling)
          } else Hr(e, r, n, t), Ih()
          r = r.child
        }
        return r
      case 5:
        return (
          Ay(r),
          e === null && Ah(r),
          (n = r.type),
          (i = r.pendingProps),
          (s = e !== null ? e.memoizedProps : null),
          (u = i.children),
          ch(n, i) ? (u = null) : s !== null && ch(n, s) && (r.flags |= 16),
          zy(e, r),
          Hr(e, r, u, t),
          r.child
        )
      case 6:
        return e === null && Ah(r), null
      case 13:
        return Vy(e, r, t)
      case 4:
        return (
          Eh(r, r.stateNode.containerInfo),
          (n = r.pendingProps),
          e === null ? (r.child = pl(r, null, n, t)) : Hr(e, r, n, t),
          r.child
        )
      case 11:
        return (n = r.type), (i = r.pendingProps), (i = r.elementType === n ? i : bn(n, i)), Uy(e, r, n, i, t)
      case 7:
        return Hr(e, r, r.pendingProps, t), r.child
      case 8:
        return Hr(e, r, r.pendingProps.children, t), r.child
      case 12:
        return Hr(e, r, r.pendingProps.children, t), r.child
      case 10:
        e: {
          ;(n = r.type._context), (i = r.pendingProps), (u = r.memoizedProps), (s = i.value)
          var o = r.type._context
          if ((Jt(al, o._currentValue), (o._currentValue = s), u !== null))
            if (
              ((o = u.value),
              (s = rn(o, s)
                ? 0
                : (typeof n._calculateChangedBits == 'function' ? n._calculateChangedBits(o, s) : 1073741823) | 0),
              s === 0)
            ) {
              if (u.children === i.children && !Kr.current) {
                r = Jn(e, r, t)
                break e
              }
            } else
              for (o = r.child, o !== null && (o.return = r); o !== null; ) {
                var l = o.dependencies
                if (l !== null) {
                  u = o.child
                  for (var a = l.firstContext; a !== null; ) {
                    if (a.context === n && (a.observedBits & s) != 0) {
                      o.tag === 1 && ((a = Ci(-1, t & -t)), (a.tag = 2), ki(o, a)),
                        (o.lanes |= t),
                        (a = o.alternate),
                        a !== null && (a.lanes |= t),
                        py(o.return, t),
                        (l.lanes |= t)
                      break
                    }
                    a = a.next
                  }
                } else u = o.tag === 10 && o.type === r.type ? null : o.child
                if (u !== null) u.return = o
                else
                  for (u = o; u !== null; ) {
                    if (u === r) {
                      u = null
                      break
                    }
                    if (((o = u.sibling), o !== null)) {
                      ;(o.return = u.return), (u = o)
                      break
                    }
                    u = u.return
                  }
                o = u
              }
          Hr(e, r, i.children, t), (r = r.child)
        }
        return r
      case 9:
        return (
          (i = r.type),
          (s = r.pendingProps),
          (n = s.children),
          ao(r, t),
          (i = nn(i, s.unstable_observedBits)),
          (n = n(i)),
          (r.flags |= 1),
          Hr(e, r, n, t),
          r.child
        )
      case 14:
        return (i = r.type), (s = bn(i, r.pendingProps)), (s = bn(i.type, s)), qy(e, r, i, s, n, t)
      case 15:
        return jy(e, r, r.type, r.pendingProps, n, t)
      case 17:
        return (
          (n = r.type),
          (i = r.pendingProps),
          (i = r.elementType === n ? i : bn(n, i)),
          e !== null && ((e.alternate = null), (r.alternate = null), (r.flags |= 2)),
          (r.tag = 1),
          Fr(n) ? ((e = !0), il(r)) : (e = !1),
          ao(r, t),
          wy(r, n, i),
          _h(r, n, i, t),
          Oh(null, r, n, !0, e, t)
        )
      case 19:
        return Jy(e, r, t)
      case 23:
        return Nh(e, r, t)
      case 24:
        return Nh(e, r, t)
    }
    throw Error(Ke(156, r.tag))
  }
  function cR(e, r, t, n) {
    ;(this.tag = e),
      (this.key = t),
      (this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = r),
      (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
      (this.mode = n),
      (this.flags = 0),
      (this.lastEffect = this.firstEffect = this.nextEffect = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null)
  }
  function an(e, r, t, n) {
    return new cR(e, r, t, n)
  }
  function t0(e) {
    return (e = e.prototype), !(!e || !e.isReactComponent)
  }
  function uR(e) {
    if (typeof e == 'function') return t0(e) ? 1 : 0
    if (e != null) {
      if (((e = e.$$typeof), e === Mu)) return 11
      if (e === Ru) return 14
    }
    return 2
  }
  function Oi(e, r) {
    var t = e.alternate
    return (
      t === null
        ? ((t = an(e.tag, r, e.key, e.mode)),
          (t.elementType = e.elementType),
          (t.type = e.type),
          (t.stateNode = e.stateNode),
          (t.alternate = e),
          (e.alternate = t))
        : ((t.pendingProps = r),
          (t.type = e.type),
          (t.flags = 0),
          (t.nextEffect = null),
          (t.firstEffect = null),
          (t.lastEffect = null)),
      (t.childLanes = e.childLanes),
      (t.lanes = e.lanes),
      (t.child = e.child),
      (t.memoizedProps = e.memoizedProps),
      (t.memoizedState = e.memoizedState),
      (t.updateQueue = e.updateQueue),
      (r = e.dependencies),
      (t.dependencies = r === null ? null : { lanes: r.lanes, firstContext: r.firstContext }),
      (t.sibling = e.sibling),
      (t.index = e.index),
      (t.ref = e.ref),
      t
    )
  }
  function Rl(e, r, t, n, i, s) {
    var u = 2
    if (((n = e), typeof e == 'function')) t0(e) && (u = 1)
    else if (typeof e == 'string') u = 5
    else
      e: switch (e) {
        case bi:
          return bo(t.children, i, s, r)
        case jm:
          ;(u = 8), (i |= 16)
          break
        case dd:
          ;(u = 8), (i |= 1)
          break
        case pa:
          return (e = an(12, t, r, i | 8)), (e.elementType = pa), (e.type = pa), (e.lanes = s), e
        case ma:
          return (e = an(13, t, r, i)), (e.type = ma), (e.elementType = ma), (e.lanes = s), e
        case xu:
          return (e = an(19, t, r, i)), (e.elementType = xu), (e.lanes = s), e
        case vd:
          return r0(t, i, s, r)
        case gd:
          return (e = an(24, t, r, i)), (e.elementType = gd), (e.lanes = s), e
        default:
          if (typeof e == 'object' && e !== null)
            switch (e.$$typeof) {
              case hd:
                u = 10
                break e
              case pd:
                u = 9
                break e
              case Mu:
                u = 11
                break e
              case Ru:
                u = 14
                break e
              case md:
                ;(u = 16), (n = null)
                break e
              case bd:
                u = 22
                break e
            }
          throw Error(Ke(130, e == null ? e : typeof e, ''))
      }
    return (r = an(u, t, r, i)), (r.elementType = e), (r.type = n), (r.lanes = s), r
  }
  function bo(e, r, t, n) {
    return (e = an(7, e, n, r)), (e.lanes = t), e
  }
  function r0(e, r, t, n) {
    return (e = an(23, e, n, r)), (e.elementType = vd), (e.lanes = t), e
  }
  function n0(e, r, t) {
    return (e = an(6, e, null, r)), (e.lanes = t), e
  }
  function i0(e, r, t) {
    return (
      (r = an(4, e.children !== null ? e.children : [], e.key, r)),
      (r.lanes = t),
      (r.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }),
      r
    )
  }
  function lR(e, r, t) {
    ;(this.tag = r),
      (this.containerInfo = e),
      (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
      (this.timeoutHandle = -1),
      (this.pendingContext = this.context = null),
      (this.hydrate = t),
      (this.callbackNode = null),
      (this.callbackPriority = 0),
      (this.eventTimes = Hd(0)),
      (this.expirationTimes = Hd(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = Hd(0)),
      (this.mutableSourceEagerHydrationData = null)
  }
  function fR(e, r, t) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
    return { $$typeof: Wi, key: n == null ? null : '' + n, children: e, containerInfo: r, implementation: t }
  }
  function Bl(e, r, t, n) {
    var i = r.current,
      s = Xr(),
      u = Ri(i)
    e: if (t) {
      t = t._reactInternals
      t: {
        if (Xi(t) !== t || t.tag !== 1) throw Error(Ke(170))
        var o = t
        do {
          switch (o.tag) {
            case 3:
              o = o.stateNode.context
              break t
            case 1:
              if (Fr(o.type)) {
                o = o.stateNode.__reactInternalMemoizedMergedChildContext
                break t
              }
          }
          o = o.return
        } while (o !== null)
        throw Error(Ke(171))
      }
      if (t.tag === 1) {
        var l = t.type
        if (Fr(l)) {
          t = iy(t, l, o)
          break e
        }
      }
      t = o
    } else t = Ii
    return (
      r.context === null ? (r.context = t) : (r.pendingContext = t),
      (r = Ci(s, u)),
      (r.payload = { element: e }),
      (n = n === void 0 ? null : n),
      n !== null && (r.callback = n),
      ki(i, r),
      Bi(i, u, s),
      u
    )
  }
  function s0(e) {
    if (((e = e.current), !e.child)) return null
    switch (e.child.tag) {
      case 5:
        return e.child.stateNode
      default:
        return e.child.stateNode
    }
  }
  function gv(e, r) {
    if (((e = e.memoizedState), e !== null && e.dehydrated !== null)) {
      var t = e.retryLane
      e.retryLane = t !== 0 && t < r ? t : r
    }
  }
  function o0(e, r) {
    gv(e, r), (e = e.alternate) && gv(e, r)
  }
  function dR() {
    return null
  }
  function a0(e, r, t) {
    var n = (t != null && t.hydrationOptions != null && t.hydrationOptions.mutableSources) || null
    if (
      ((t = new lR(e, r, t != null && t.hydrate === !0)),
      (r = an(3, null, null, r === 2 ? 7 : r === 1 ? 3 : 0)),
      (t.current = r),
      (r.stateNode = t),
      wh(r),
      (e[to] = t.current),
      Gb(e.nodeType === 8 ? e.parentNode : e),
      n)
    )
      for (e = 0; e < n.length; e++) {
        r = n[e]
        var i = r._getVersion
        ;(i = i(r._source)),
          t.mutableSourceEagerHydrationData == null
            ? (t.mutableSourceEagerHydrationData = [r, i])
            : t.mutableSourceEagerHydrationData.push(r, i)
      }
    this._internalRoot = t
  }
  a0.prototype.render = function (e) {
    Bl(e, this._internalRoot, null, null)
  }
  a0.prototype.unmount = function () {
    var e = this._internalRoot,
      r = e.containerInfo
    Bl(null, e, null, function () {
      r[to] = null
    })
  }
  function nc(e) {
    return !(
      !e ||
      (e.nodeType !== 1 &&
        e.nodeType !== 9 &&
        e.nodeType !== 11 &&
        (e.nodeType !== 8 || e.nodeValue !== ' react-mount-point-unstable '))
    )
  }
  function hR(e, r) {
    if (
      (r ||
        ((r = e ? (e.nodeType === 9 ? e.documentElement : e.firstChild) : null),
        (r = !(!r || r.nodeType !== 1 || !r.hasAttribute('data-reactroot')))),
      !r)
    )
      for (var t; (t = e.lastChild); ) e.removeChild(t)
    return new a0(e, 0, r ? { hydrate: !0 } : void 0)
  }
  function Nl(e, r, t, n, i) {
    var s = t._reactRootContainer
    if (s) {
      var u = s._internalRoot
      if (typeof i == 'function') {
        var o = i
        i = function () {
          var a = s0(u)
          o.call(a)
        }
      }
      Bl(r, u, e, i)
    } else {
      if (((s = t._reactRootContainer = hR(t, n)), (u = s._internalRoot), typeof i == 'function')) {
        var l = i
        i = function () {
          var a = s0(u)
          l.call(a)
        }
      }
      fv(function () {
        Bl(r, u, e, i)
      })
    }
    return s0(u)
  }
  ub = function (e) {
    if (e.tag === 13) {
      var r = Xr()
      Bi(e, 4, r), o0(e, 4)
    }
  }
  qd = function (e) {
    if (e.tag === 13) {
      var r = Xr()
      Bi(e, 67108864, r), o0(e, 67108864)
    }
  }
  lb = function (e) {
    if (e.tag === 13) {
      var r = Xr(),
        t = Ri(e)
      Bi(e, t, r), o0(e, t)
    }
  }
  fb = function (e, r) {
    return r()
  }
  Bd = function (e, r, t) {
    switch (r) {
      case 'input':
        if ((Sd(e, t), (r = t.name), t.type === 'radio' && r != null)) {
          for (t = e; t.parentNode; ) t = t.parentNode
          for (
            t = t.querySelectorAll('input[name=' + JSON.stringify('' + r) + '][type="radio"]'), r = 0;
            r < t.length;
            r++
          ) {
            var n = t[r]
            if (n !== e && n.form === e.form) {
              var i = rl(n)
              if (!i) throw Error(Ke(90))
              Fm(n), Sd(n, i)
            }
          }
        }
        break
      case 'textarea':
        Wm(e, t)
        break
      case 'select':
        ;(r = t.value), r != null && Fs(e, !!t.multiple, r, !1)
    }
  }
  Nd = lv
  nb = function (e, r, t, n, i) {
    var s = bt
    bt |= 4
    try {
      return es(98, e.bind(null, r, t, n, i))
    } finally {
      ;(bt = s), bt === 0 && (ho(), Cn())
    }
  }
  Pd = function () {
    ;(bt & 49) == 0 && (Qx(), Ni())
  }
  ib = function (e, r) {
    var t = bt
    bt |= 2
    try {
      return e(r)
    } finally {
      ;(bt = t), bt === 0 && (ho(), Cn())
    }
  }
  function wv(e, r) {
    var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
    if (!nc(r)) throw Error(Ke(200))
    return fR(e, r, null, t)
  }
  var pR = { Events: [La, ro, rl, tb, rb, Ni, { current: !1 }] },
    ic = { findFiberByHostInstance: Yi, bundleType: 0, version: '17.0.2', rendererPackageName: 'react-dom' },
    mR = {
      bundleType: ic.bundleType,
      version: ic.version,
      rendererPackageName: ic.rendererPackageName,
      rendererConfig: ic.rendererConfig,
      overrideHookState: null,
      overrideHookStateDeletePath: null,
      overrideHookStateRenamePath: null,
      overrideProps: null,
      overridePropsDeletePath: null,
      overridePropsRenamePath: null,
      setSuspenseHandler: null,
      scheduleUpdate: null,
      currentDispatcherRef: Gi.ReactCurrentDispatcher,
      findHostInstanceByFiber: function (e) {
        return (e = ab(e)), e === null ? null : e.stateNode
      },
      findFiberByHostInstance: ic.findFiberByHostInstance || dR,
      findHostInstancesForRefresh: null,
      scheduleRefresh: null,
      scheduleRoot: null,
      setRefreshHandler: null,
      getCurrentFiber: null
    }
  if (
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ != 'undefined' &&
    ((sc = __REACT_DEVTOOLS_GLOBAL_HOOK__), !sc.isDisabled && sc.supportsFiber)
  )
    try {
      ;(dh = sc.inject(mR)), (Qi = sc)
    } catch (e) {}
  var sc
  cn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = pR
  cn.createPortal = wv
  cn.findDOMNode = function (e) {
    if (e == null) return null
    if (e.nodeType === 1) return e
    var r = e._reactInternals
    if (r === void 0) throw typeof e.render == 'function' ? Error(Ke(188)) : Error(Ke(268, Object.keys(e)))
    return (e = ab(r)), (e = e === null ? null : e.stateNode), e
  }
  cn.flushSync = function (e, r) {
    var t = bt
    if ((t & 48) != 0) return e(r)
    bt |= 1
    try {
      if (e) return es(99, e.bind(null, r))
    } finally {
      ;(bt = t), Cn()
    }
  }
  cn.hydrate = function (e, r, t) {
    if (!nc(r)) throw Error(Ke(200))
    return Nl(null, e, r, !0, t)
  }
  cn.render = function (e, r, t) {
    if (!nc(r)) throw Error(Ke(200))
    return Nl(null, e, r, !1, t)
  }
  cn.unmountComponentAtNode = function (e) {
    if (!nc(e)) throw Error(Ke(40))
    return e._reactRootContainer
      ? (fv(function () {
          Nl(null, null, e, !1, function () {
            ;(e._reactRootContainer = null), (e[to] = null)
          })
        }),
        !0)
      : !1
  }
  cn.unstable_batchedUpdates = lv
  cn.unstable_createPortal = function (e, r) {
    return wv(e, r, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null)
  }
  cn.unstable_renderSubtreeIntoContainer = function (e, r, t, n) {
    if (!nc(t)) throw Error(Ke(200))
    if (e == null || e._reactInternals === void 0) throw Error(Ke(38))
    return Nl(e, r, t, !1, n)
  }
  cn.version = '17.0.2'
})
var Av = Vi(($z, Sv) => {
  'use strict'
  function Ev() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ == 'undefined' ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Ev)
      } catch (e) {
        console.error(e)
      }
  }
  Ev(), (Sv.exports = _v())
})
var nM = oa(Us()),
  iM = oa(Av())
var pu = oa(Us())
var _r = oa(Us()),
  Iv = oa(Us())
var Tv = (r) => {
  var e = cm(r, [])
  return (
    (0, Iv.useEffect)(() => {}),
    _r.default.createElement(
      'div',
      am({}, e),
      _r.default.createElement(
        'header',
        null,
        _r.default.createElement('h1', { id: 'status' }, 'Starting libp2p...'),
        _r.default.createElement('input', {
          id: 'serverId',
          style: { width: '500px' },
          placeholder: "Type server's PeerId here"
        }),
        _r.default.createElement('input', { id: 'file', type: 'file' }),
        _r.default.createElement('button', { id: 'send' }, 'Send'),
        _r.default.createElement('br', null),
        _r.default.createElement('br', null),
        _r.default.createElement('input', {
          id: 'fileId',
          style: { width: '500px' },
          placeholder: 'Enter _id of a file here'
        }),
        _r.default.createElement('button', { id: 'receive' }, 'Receive'),
        _r.default.createElement('button', { id: 'meta' }, 'Meta'),
        _r.default.createElement('br', null),
        _r.default.createElement('br', null),
        _r.default.createElement('textarea', { id: 'content', style: { width: '500px', height: '100px' } })
      ),
      _r.default.createElement('main', null, _r.default.createElement('pre', { id: 'output' }))
    )
  )
}
var bR = Object.create,
  Pl = Object.defineProperty,
  yR = Object.getOwnPropertyDescriptor,
  vR = Object.getOwnPropertyNames,
  gR = Object.getPrototypeOf,
  wR = Object.prototype.hasOwnProperty,
  Cv = (e) => Pl(e, '__esModule', { value: !0 }),
  c0 = (e) => {
    if (typeof require != 'undefined') return require(e)
    throw new Error('Dynamic require of "' + e + '" is not supported')
  },
  Ie = (e, r) =>
    function () {
      return e && (r = (0, e[Object.keys(e)[0]])((e = 0))), r
    },
  te = (e, r) =>
    function () {
      return r || (0, e[Object.keys(e)[0]])((r = { exports: {} }).exports, r), r.exports
    },
  Re = (e, r) => {
    Cv(e)
    for (var t in r) Pl(e, t, { get: r[t], enumerable: !0 })
  },
  _R = (e, r, t) => {
    if ((r && typeof r == 'object') || typeof r == 'function')
      for (let n of vR(r))
        !wR.call(e, n) && n !== 'default' && Pl(e, n, { get: () => r[n], enumerable: !(t = yR(r, n)) || t.enumerable })
    return e
  },
  Yr = (e) =>
    _R(
      Cv(
        Pl(
          e != null ? bR(gR(e)) : {},
          'default',
          e && e.__esModule && 'default' in e ? { get: () => e.default, enumerable: !0 } : { value: e, enumerable: !0 }
        )
      ),
      e
    )
function kv() {
  throw new Error('setTimeout has not been defined')
}
function Mv() {
  throw new Error('clearTimeout has not been defined')
}
function xv(e) {
  if (Zn === setTimeout) return setTimeout(e, 0)
  if ((Zn === kv || !Zn) && setTimeout) return (Zn = setTimeout), setTimeout(e, 0)
  try {
    return Zn(e, 0)
  } catch (r) {
    try {
      return Zn.call(null, e, 0)
    } catch (t) {
      return Zn.call(this, e, 0)
    }
  }
}
function ER(e) {
  if (Qn === clearTimeout) return clearTimeout(e)
  if ((Qn === Mv || !Qn) && clearTimeout) return (Qn = clearTimeout), clearTimeout(e)
  try {
    return Qn(e)
  } catch (r) {
    try {
      return Qn.call(null, e)
    } catch (t) {
      return Qn.call(this, e)
    }
  }
}
function SR() {
  !as || !cs || ((as = !1), cs.length ? (Bn = cs.concat(Bn)) : (oc = -1), Bn.length && Rv())
}
function Rv() {
  if (!as) {
    var e = xv(SR)
    as = !0
    for (var r = Bn.length; r; ) {
      for (cs = Bn, Bn = []; ++oc < r; ) cs && cs[oc].run()
      ;(oc = -1), (r = Bn.length)
    }
    ;(cs = null), (as = !1), ER(e)
  }
}
function AR(e) {
  var r = new Array(arguments.length - 1)
  if (arguments.length > 1) for (var t = 1; t < arguments.length; t++) r[t - 1] = arguments[t]
  Bn.push(new Bv(e, r)), Bn.length === 1 && !as && xv(Rv)
}
function Bv(e, r) {
  ;(this.fun = e), (this.array = r)
}
function os() {}
function IR(e) {
  throw new Error('process.binding is not supported')
}
function TR() {
  return '/'
}
function CR(e) {
  throw new Error('process.chdir is not supported')
}
function kR() {
  return 0
}
function MR(e) {
  var r = Jv.call(us) * 0.001,
    t = Math.floor(r),
    n = Math.floor((r % 1) * 1e9)
  return e && ((t = t - e[0]), (n = n - e[1]), n < 0 && (t--, (n += 1e9))), [t, n]
}
function xR() {
  var e = new Date(),
    r = e - Xv
  return r / 1e3
}
var Zn,
  Qn,
  Bn,
  as,
  cs,
  oc,
  Nv,
  Pv,
  Ov,
  Dv,
  Lv,
  Uv,
  qv,
  jv,
  zv,
  Kv,
  Fv,
  Vv,
  Hv,
  $v,
  Gv,
  Wv,
  us,
  Jv,
  Xv,
  lt,
  u0,
  F = Ie({
    'node_modules/@esbuild-plugins/node-globals-polyfill/_virtual-process-polyfill_.js'() {
      ;(Zn = kv),
        (Qn = Mv),
        typeof globalThis.setTimeout == 'function' && (Zn = setTimeout),
        typeof globalThis.clearTimeout == 'function' && (Qn = clearTimeout),
        (Bn = []),
        (as = !1),
        (oc = -1),
        (Bv.prototype.run = function () {
          this.fun.apply(null, this.array)
        }),
        (Nv = 'browser'),
        (Pv = 'browser'),
        (Ov = !0),
        (Dv = {}),
        (Lv = []),
        (Uv = ''),
        (qv = {}),
        (jv = {}),
        (zv = {}),
        (Kv = os),
        (Fv = os),
        (Vv = os),
        (Hv = os),
        ($v = os),
        (Gv = os),
        (Wv = os),
        (us = globalThis.performance || {}),
        (Jv =
          us.now ||
          us.mozNow ||
          us.msNow ||
          us.oNow ||
          us.webkitNow ||
          function () {
            return new Date().getTime()
          }),
        (Xv = new Date()),
        (lt = {
          nextTick: AR,
          title: Nv,
          browser: Ov,
          env: Dv,
          argv: Lv,
          version: Uv,
          versions: qv,
          on: Kv,
          addListener: Fv,
          once: Vv,
          off: Hv,
          removeListener: $v,
          removeAllListeners: Gv,
          emit: Wv,
          binding: IR,
          cwd: TR,
          chdir: CR,
          umask: kR,
          hrtime: MR,
          platform: Pv,
          release: jv,
          config: zv,
          uptime: xR
        }),
        (u0 = { 'env.NODE_ENV': 'production' }),
        Object.keys(u0).forEach((e) => {
          let r = e.split('.'),
            t = lt
          for (let n = 0; n < r.length; n++) {
            let i = r[n]
            n === r.length - 1 ? (t[i] = u0[e]) : (t = t[i] || (t[i] = {}))
          }
        })
    }
  }),
  Yv = te({
    'node_modules/base64-js/index.js'(e) {
      V(), F(), (e.byteLength = l), (e.toByteArray = c), (e.fromByteArray = y)
      var r = [],
        t = [],
        n = typeof Uint8Array != 'undefined' ? Uint8Array : Array,
        i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
      for (s = 0, u = i.length; s < u; ++s) (r[s] = i[s]), (t[i.charCodeAt(s)] = s)
      var s, u
      ;(t['-'.charCodeAt(0)] = 62), (t['_'.charCodeAt(0)] = 63)
      function o(d) {
        var h = d.length
        if (h % 4 > 0) throw new Error('Invalid string. Length must be a multiple of 4')
        var m = d.indexOf('=')
        m === -1 && (m = h)
        var _ = m === h ? 0 : 4 - (m % 4)
        return [m, _]
      }
      function l(d) {
        var h = o(d),
          m = h[0],
          _ = h[1]
        return ((m + _) * 3) / 4 - _
      }
      function a(d, h, m) {
        return ((h + m) * 3) / 4 - m
      }
      function c(d) {
        var h,
          m = o(d),
          _ = m[0],
          A = m[1],
          T = new n(a(d, _, A)),
          E = 0,
          k = A > 0 ? _ - 4 : _,
          w
        for (w = 0; w < k; w += 4)
          (h =
            (t[d.charCodeAt(w)] << 18) |
            (t[d.charCodeAt(w + 1)] << 12) |
            (t[d.charCodeAt(w + 2)] << 6) |
            t[d.charCodeAt(w + 3)]),
            (T[E++] = (h >> 16) & 255),
            (T[E++] = (h >> 8) & 255),
            (T[E++] = h & 255)
        return (
          A === 2 && ((h = (t[d.charCodeAt(w)] << 2) | (t[d.charCodeAt(w + 1)] >> 4)), (T[E++] = h & 255)),
          A === 1 &&
            ((h = (t[d.charCodeAt(w)] << 10) | (t[d.charCodeAt(w + 1)] << 4) | (t[d.charCodeAt(w + 2)] >> 2)),
            (T[E++] = (h >> 8) & 255),
            (T[E++] = h & 255)),
          T
        )
      }
      function f(d) {
        return r[(d >> 18) & 63] + r[(d >> 12) & 63] + r[(d >> 6) & 63] + r[d & 63]
      }
      function p(d, h, m) {
        for (var _, A = [], T = h; T < m; T += 3)
          (_ = ((d[T] << 16) & 16711680) + ((d[T + 1] << 8) & 65280) + (d[T + 2] & 255)), A.push(f(_))
        return A.join('')
      }
      function y(d) {
        for (var h, m = d.length, _ = m % 3, A = [], T = 16383, E = 0, k = m - _; E < k; E += T)
          A.push(p(d, E, E + T > k ? k : E + T))
        return (
          _ === 1
            ? ((h = d[m - 1]), A.push(r[h >> 2] + r[(h << 4) & 63] + '=='))
            : _ === 2 &&
              ((h = (d[m - 2] << 8) + d[m - 1]), A.push(r[h >> 10] + r[(h >> 4) & 63] + r[(h << 2) & 63] + '=')),
          A.join('')
        )
      }
    }
  }),
  Zv = te({
    'node_modules/ieee754/index.js'(e) {
      V(),
        F(),
        (e.read = function (r, t, n, i, s) {
          var u,
            o,
            l = s * 8 - i - 1,
            a = (1 << l) - 1,
            c = a >> 1,
            f = -7,
            p = n ? s - 1 : 0,
            y = n ? -1 : 1,
            d = r[t + p]
          for (p += y, u = d & ((1 << -f) - 1), d >>= -f, f += l; f > 0; u = u * 256 + r[t + p], p += y, f -= 8);
          for (o = u & ((1 << -f) - 1), u >>= -f, f += i; f > 0; o = o * 256 + r[t + p], p += y, f -= 8);
          if (u === 0) u = 1 - c
          else {
            if (u === a) return o ? NaN : (d ? -1 : 1) * (1 / 0)
            ;(o = o + Math.pow(2, i)), (u = u - c)
          }
          return (d ? -1 : 1) * o * Math.pow(2, u - i)
        }),
        (e.write = function (r, t, n, i, s, u) {
          var o,
            l,
            a,
            c = u * 8 - s - 1,
            f = (1 << c) - 1,
            p = f >> 1,
            y = s === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
            d = i ? 0 : u - 1,
            h = i ? 1 : -1,
            m = t < 0 || (t === 0 && 1 / t < 0) ? 1 : 0
          for (
            t = Math.abs(t),
              isNaN(t) || t === 1 / 0
                ? ((l = isNaN(t) ? 1 : 0), (o = f))
                : ((o = Math.floor(Math.log(t) / Math.LN2)),
                  t * (a = Math.pow(2, -o)) < 1 && (o--, (a *= 2)),
                  o + p >= 1 ? (t += y / a) : (t += y * Math.pow(2, 1 - p)),
                  t * a >= 2 && (o++, (a /= 2)),
                  o + p >= f
                    ? ((l = 0), (o = f))
                    : o + p >= 1
                    ? ((l = (t * a - 1) * Math.pow(2, s)), (o = o + p))
                    : ((l = t * Math.pow(2, p - 1) * Math.pow(2, s)), (o = 0)));
            s >= 8;
            r[n + d] = l & 255, d += h, l /= 256, s -= 8
          );
          for (o = (o << s) | l, c += s; c > 0; r[n + d] = o & 255, d += h, o /= 256, c -= 8);
          r[n + d - h] |= m * 128
        })
    }
  }),
  $r = te({
    'node_modules/buffer/index.js'(e) {
      V(), F()
      var r = Yv(),
        t = Zv(),
        n =
          typeof Symbol == 'function' && typeof Symbol.for == 'function'
            ? Symbol.for('nodejs.util.inspect.custom')
            : null
      ;(e.Buffer = o), (e.SlowBuffer = A), (e.INSPECT_MAX_BYTES = 50)
      var i = 2147483647
      ;(e.kMaxLength = i),
        (o.TYPED_ARRAY_SUPPORT = s()),
        !o.TYPED_ARRAY_SUPPORT &&
          typeof console != 'undefined' &&
          typeof console.error == 'function' &&
          console.error(
            'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
          )
      function s() {
        try {
          let Y = new Uint8Array(1),
            z = {
              foo: function () {
                return 42
              }
            }
          return Object.setPrototypeOf(z, Uint8Array.prototype), Object.setPrototypeOf(Y, z), Y.foo() === 42
        } catch (Y) {
          return !1
        }
      }
      Object.defineProperty(o.prototype, 'parent', {
        enumerable: !0,
        get: function () {
          if (!!o.isBuffer(this)) return this.buffer
        }
      }),
        Object.defineProperty(o.prototype, 'offset', {
          enumerable: !0,
          get: function () {
            if (!!o.isBuffer(this)) return this.byteOffset
          }
        })
      function u(Y) {
        if (Y > i) throw new RangeError('The value "' + Y + '" is invalid for option "size"')
        let z = new Uint8Array(Y)
        return Object.setPrototypeOf(z, o.prototype), z
      }
      function o(Y, z, H) {
        if (typeof Y == 'number') {
          if (typeof z == 'string')
            throw new TypeError('The "string" argument must be of type string. Received type number')
          return f(Y)
        }
        return l(Y, z, H)
      }
      o.poolSize = 8192
      function l(Y, z, H) {
        if (typeof Y == 'string') return p(Y, z)
        if (ArrayBuffer.isView(Y)) return d(Y)
        if (Y == null)
          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
              typeof Y
          )
        if (
          U(Y, ArrayBuffer) ||
          (Y && U(Y.buffer, ArrayBuffer)) ||
          (typeof SharedArrayBuffer != 'undefined' &&
            (U(Y, SharedArrayBuffer) || (Y && U(Y.buffer, SharedArrayBuffer))))
        )
          return h(Y, z, H)
        if (typeof Y == 'number')
          throw new TypeError('The "value" argument must not be of type number. Received type number')
        let se = Y.valueOf && Y.valueOf()
        if (se != null && se !== Y) return o.from(se, z, H)
        let me = m(Y)
        if (me) return me
        if (typeof Symbol != 'undefined' && Symbol.toPrimitive != null && typeof Y[Symbol.toPrimitive] == 'function')
          return o.from(Y[Symbol.toPrimitive]('string'), z, H)
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
            typeof Y
        )
      }
      ;(o.from = function (Y, z, H) {
        return l(Y, z, H)
      }),
        Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(o, Uint8Array)
      function a(Y) {
        if (typeof Y != 'number') throw new TypeError('"size" argument must be of type number')
        if (Y < 0) throw new RangeError('The value "' + Y + '" is invalid for option "size"')
      }
      function c(Y, z, H) {
        return a(Y), Y <= 0 ? u(Y) : z !== void 0 ? (typeof H == 'string' ? u(Y).fill(z, H) : u(Y).fill(z)) : u(Y)
      }
      o.alloc = function (Y, z, H) {
        return c(Y, z, H)
      }
      function f(Y) {
        return a(Y), u(Y < 0 ? 0 : _(Y) | 0)
      }
      ;(o.allocUnsafe = function (Y) {
        return f(Y)
      }),
        (o.allocUnsafeSlow = function (Y) {
          return f(Y)
        })
      function p(Y, z) {
        if (((typeof z != 'string' || z === '') && (z = 'utf8'), !o.isEncoding(z)))
          throw new TypeError('Unknown encoding: ' + z)
        let H = T(Y, z) | 0,
          se = u(H),
          me = se.write(Y, z)
        return me !== H && (se = se.slice(0, me)), se
      }
      function y(Y) {
        let z = Y.length < 0 ? 0 : _(Y.length) | 0,
          H = u(z)
        for (let se = 0; se < z; se += 1) H[se] = Y[se] & 255
        return H
      }
      function d(Y) {
        if (U(Y, Uint8Array)) {
          let z = new Uint8Array(Y)
          return h(z.buffer, z.byteOffset, z.byteLength)
        }
        return y(Y)
      }
      function h(Y, z, H) {
        if (z < 0 || Y.byteLength < z) throw new RangeError('"offset" is outside of buffer bounds')
        if (Y.byteLength < z + (H || 0)) throw new RangeError('"length" is outside of buffer bounds')
        let se
        return (
          z === void 0 && H === void 0
            ? (se = new Uint8Array(Y))
            : H === void 0
            ? (se = new Uint8Array(Y, z))
            : (se = new Uint8Array(Y, z, H)),
          Object.setPrototypeOf(se, o.prototype),
          se
        )
      }
      function m(Y) {
        if (o.isBuffer(Y)) {
          let z = _(Y.length) | 0,
            H = u(z)
          return H.length === 0 || Y.copy(H, 0, 0, z), H
        }
        if (Y.length !== void 0) return typeof Y.length != 'number' || X(Y.length) ? u(0) : y(Y)
        if (Y.type === 'Buffer' && Array.isArray(Y.data)) return y(Y.data)
      }
      function _(Y) {
        if (Y >= i)
          throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + i.toString(16) + ' bytes')
        return Y | 0
      }
      function A(Y) {
        return +Y != Y && (Y = 0), o.alloc(+Y)
      }
      ;(o.isBuffer = function (z) {
        return z != null && z._isBuffer === !0 && z !== o.prototype
      }),
        (o.compare = function (z, H) {
          if (
            (U(z, Uint8Array) && (z = o.from(z, z.offset, z.byteLength)),
            U(H, Uint8Array) && (H = o.from(H, H.offset, H.byteLength)),
            !o.isBuffer(z) || !o.isBuffer(H))
          )
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array')
          if (z === H) return 0
          let se = z.length,
            me = H.length
          for (let we = 0, Ee = Math.min(se, me); we < Ee; ++we)
            if (z[we] !== H[we]) {
              ;(se = z[we]), (me = H[we])
              break
            }
          return se < me ? -1 : me < se ? 1 : 0
        }),
        (o.isEncoding = function (z) {
          switch (String(z).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return !0
            default:
              return !1
          }
        }),
        (o.concat = function (z, H) {
          if (!Array.isArray(z)) throw new TypeError('"list" argument must be an Array of Buffers')
          if (z.length === 0) return o.alloc(0)
          let se
          if (H === void 0) for (H = 0, se = 0; se < z.length; ++se) H += z[se].length
          let me = o.allocUnsafe(H),
            we = 0
          for (se = 0; se < z.length; ++se) {
            let Ee = z[se]
            if (U(Ee, Uint8Array))
              we + Ee.length > me.length
                ? (o.isBuffer(Ee) || (Ee = o.from(Ee)), Ee.copy(me, we))
                : Uint8Array.prototype.set.call(me, Ee, we)
            else if (o.isBuffer(Ee)) Ee.copy(me, we)
            else throw new TypeError('"list" argument must be an Array of Buffers')
            we += Ee.length
          }
          return me
        })
      function T(Y, z) {
        if (o.isBuffer(Y)) return Y.length
        if (ArrayBuffer.isView(Y) || U(Y, ArrayBuffer)) return Y.byteLength
        if (typeof Y != 'string')
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof Y
          )
        let H = Y.length,
          se = arguments.length > 2 && arguments[2] === !0
        if (!se && H === 0) return 0
        let me = !1
        for (;;)
          switch (z) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return H
            case 'utf8':
            case 'utf-8':
              return B(Y).length
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return H * 2
            case 'hex':
              return H >>> 1
            case 'base64':
              return g(Y).length
            default:
              if (me) return se ? -1 : B(Y).length
              ;(z = ('' + z).toLowerCase()), (me = !0)
          }
      }
      o.byteLength = T
      function E(Y, z, H) {
        let se = !1
        if (
          ((z === void 0 || z < 0) && (z = 0),
          z > this.length ||
            ((H === void 0 || H > this.length) && (H = this.length), H <= 0) ||
            ((H >>>= 0), (z >>>= 0), H <= z))
        )
          return ''
        for (Y || (Y = 'utf8'); ; )
          switch (Y) {
            case 'hex':
              return fe(this, z, H)
            case 'utf8':
            case 'utf-8':
              return L(this, z, H)
            case 'ascii':
              return Z(this, z, H)
            case 'latin1':
            case 'binary':
              return Q(this, z, H)
            case 'base64':
              return x(this, z, H)
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ie(this, z, H)
            default:
              if (se) throw new TypeError('Unknown encoding: ' + Y)
              ;(Y = (Y + '').toLowerCase()), (se = !0)
          }
      }
      o.prototype._isBuffer = !0
      function k(Y, z, H) {
        let se = Y[z]
        ;(Y[z] = Y[H]), (Y[H] = se)
      }
      ;(o.prototype.swap16 = function () {
        let z = this.length
        if (z % 2 != 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
        for (let H = 0; H < z; H += 2) k(this, H, H + 1)
        return this
      }),
        (o.prototype.swap32 = function () {
          let z = this.length
          if (z % 4 != 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
          for (let H = 0; H < z; H += 4) k(this, H, H + 3), k(this, H + 1, H + 2)
          return this
        }),
        (o.prototype.swap64 = function () {
          let z = this.length
          if (z % 8 != 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
          for (let H = 0; H < z; H += 8)
            k(this, H, H + 7), k(this, H + 1, H + 6), k(this, H + 2, H + 5), k(this, H + 3, H + 4)
          return this
        }),
        (o.prototype.toString = function () {
          let z = this.length
          return z === 0 ? '' : arguments.length === 0 ? L(this, 0, z) : E.apply(this, arguments)
        }),
        (o.prototype.toLocaleString = o.prototype.toString),
        (o.prototype.equals = function (z) {
          if (!o.isBuffer(z)) throw new TypeError('Argument must be a Buffer')
          return this === z ? !0 : o.compare(this, z) === 0
        }),
        (o.prototype.inspect = function () {
          let z = '',
            H = e.INSPECT_MAX_BYTES
          return (
            (z = this.toString('hex', 0, H)
              .replace(/(.{2})/g, '$1 ')
              .trim()),
            this.length > H && (z += ' ... '),
            '<Buffer ' + z + '>'
          )
        }),
        n && (o.prototype[n] = o.prototype.inspect),
        (o.prototype.compare = function (z, H, se, me, we) {
          if ((U(z, Uint8Array) && (z = o.from(z, z.offset, z.byteLength)), !o.isBuffer(z)))
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof z
            )
          if (
            (H === void 0 && (H = 0),
            se === void 0 && (se = z ? z.length : 0),
            me === void 0 && (me = 0),
            we === void 0 && (we = this.length),
            H < 0 || se > z.length || me < 0 || we > this.length)
          )
            throw new RangeError('out of range index')
          if (me >= we && H >= se) return 0
          if (me >= we) return -1
          if (H >= se) return 1
          if (((H >>>= 0), (se >>>= 0), (me >>>= 0), (we >>>= 0), this === z)) return 0
          let Ee = we - me,
            Me = se - H,
            Be = Math.min(Ee, Me),
            je = this.slice(me, we),
            Pe = z.slice(H, se)
          for (let Oe = 0; Oe < Be; ++Oe)
            if (je[Oe] !== Pe[Oe]) {
              ;(Ee = je[Oe]), (Me = Pe[Oe])
              break
            }
          return Ee < Me ? -1 : Me < Ee ? 1 : 0
        })
      function w(Y, z, H, se, me) {
        if (Y.length === 0) return -1
        if (
          (typeof H == 'string'
            ? ((se = H), (H = 0))
            : H > 2147483647
            ? (H = 2147483647)
            : H < -2147483648 && (H = -2147483648),
          (H = +H),
          X(H) && (H = me ? 0 : Y.length - 1),
          H < 0 && (H = Y.length + H),
          H >= Y.length)
        ) {
          if (me) return -1
          H = Y.length - 1
        } else if (H < 0)
          if (me) H = 0
          else return -1
        if ((typeof z == 'string' && (z = o.from(z, se)), o.isBuffer(z)))
          return z.length === 0 ? -1 : v(Y, z, H, se, me)
        if (typeof z == 'number')
          return (
            (z = z & 255),
            typeof Uint8Array.prototype.indexOf == 'function'
              ? me
                ? Uint8Array.prototype.indexOf.call(Y, z, H)
                : Uint8Array.prototype.lastIndexOf.call(Y, z, H)
              : v(Y, [z], H, se, me)
          )
        throw new TypeError('val must be string, number or Buffer')
      }
      function v(Y, z, H, se, me) {
        let we = 1,
          Ee = Y.length,
          Me = z.length
        if (
          se !== void 0 &&
          ((se = String(se).toLowerCase()), se === 'ucs2' || se === 'ucs-2' || se === 'utf16le' || se === 'utf-16le')
        ) {
          if (Y.length < 2 || z.length < 2) return -1
          ;(we = 2), (Ee /= 2), (Me /= 2), (H /= 2)
        }
        function Be(Pe, Oe) {
          return we === 1 ? Pe[Oe] : Pe.readUInt16BE(Oe * we)
        }
        let je
        if (me) {
          let Pe = -1
          for (je = H; je < Ee; je++)
            if (Be(Y, je) === Be(z, Pe === -1 ? 0 : je - Pe)) {
              if ((Pe === -1 && (Pe = je), je - Pe + 1 === Me)) return Pe * we
            } else Pe !== -1 && (je -= je - Pe), (Pe = -1)
        } else
          for (H + Me > Ee && (H = Ee - Me), je = H; je >= 0; je--) {
            let Pe = !0
            for (let Oe = 0; Oe < Me; Oe++)
              if (Be(Y, je + Oe) !== Be(z, Oe)) {
                Pe = !1
                break
              }
            if (Pe) return je
          }
        return -1
      }
      ;(o.prototype.includes = function (z, H, se) {
        return this.indexOf(z, H, se) !== -1
      }),
        (o.prototype.indexOf = function (z, H, se) {
          return w(this, z, H, se, !0)
        }),
        (o.prototype.lastIndexOf = function (z, H, se) {
          return w(this, z, H, se, !1)
        })
      function I(Y, z, H, se) {
        H = Number(H) || 0
        let me = Y.length - H
        se ? ((se = Number(se)), se > me && (se = me)) : (se = me)
        let we = z.length
        se > we / 2 && (se = we / 2)
        let Ee
        for (Ee = 0; Ee < se; ++Ee) {
          let Me = parseInt(z.substr(Ee * 2, 2), 16)
          if (X(Me)) return Ee
          Y[H + Ee] = Me
        }
        return Ee
      }
      function M(Y, z, H, se) {
        return N(B(z, Y.length - H), Y, H, se)
      }
      function q(Y, z, H, se) {
        return N(D(z), Y, H, se)
      }
      function G(Y, z, H, se) {
        return N(g(z), Y, H, se)
      }
      function O(Y, z, H, se) {
        return N($(z, Y.length - H), Y, H, se)
      }
      ;(o.prototype.write = function (z, H, se, me) {
        if (H === void 0) (me = 'utf8'), (se = this.length), (H = 0)
        else if (se === void 0 && typeof H == 'string') (me = H), (se = this.length), (H = 0)
        else if (isFinite(H))
          (H = H >>> 0), isFinite(se) ? ((se = se >>> 0), me === void 0 && (me = 'utf8')) : ((me = se), (se = void 0))
        else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported')
        let we = this.length - H
        if (((se === void 0 || se > we) && (se = we), (z.length > 0 && (se < 0 || H < 0)) || H > this.length))
          throw new RangeError('Attempt to write outside buffer bounds')
        me || (me = 'utf8')
        let Ee = !1
        for (;;)
          switch (me) {
            case 'hex':
              return I(this, z, H, se)
            case 'utf8':
            case 'utf-8':
              return M(this, z, H, se)
            case 'ascii':
            case 'latin1':
            case 'binary':
              return q(this, z, H, se)
            case 'base64':
              return G(this, z, H, se)
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return O(this, z, H, se)
            default:
              if (Ee) throw new TypeError('Unknown encoding: ' + me)
              ;(me = ('' + me).toLowerCase()), (Ee = !0)
          }
      }),
        (o.prototype.toJSON = function () {
          return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
        })
      function x(Y, z, H) {
        return z === 0 && H === Y.length ? r.fromByteArray(Y) : r.fromByteArray(Y.slice(z, H))
      }
      function L(Y, z, H) {
        H = Math.min(Y.length, H)
        let se = [],
          me = z
        for (; me < H; ) {
          let we = Y[me],
            Ee = null,
            Me = we > 239 ? 4 : we > 223 ? 3 : we > 191 ? 2 : 1
          if (me + Me <= H) {
            let Be, je, Pe, Oe
            switch (Me) {
              case 1:
                we < 128 && (Ee = we)
                break
              case 2:
                ;(Be = Y[me + 1]), (Be & 192) == 128 && ((Oe = ((we & 31) << 6) | (Be & 63)), Oe > 127 && (Ee = Oe))
                break
              case 3:
                ;(Be = Y[me + 1]),
                  (je = Y[me + 2]),
                  (Be & 192) == 128 &&
                    (je & 192) == 128 &&
                    ((Oe = ((we & 15) << 12) | ((Be & 63) << 6) | (je & 63)),
                    Oe > 2047 && (Oe < 55296 || Oe > 57343) && (Ee = Oe))
                break
              case 4:
                ;(Be = Y[me + 1]),
                  (je = Y[me + 2]),
                  (Pe = Y[me + 3]),
                  (Be & 192) == 128 &&
                    (je & 192) == 128 &&
                    (Pe & 192) == 128 &&
                    ((Oe = ((we & 15) << 18) | ((Be & 63) << 12) | ((je & 63) << 6) | (Pe & 63)),
                    Oe > 65535 && Oe < 1114112 && (Ee = Oe))
            }
          }
          Ee === null
            ? ((Ee = 65533), (Me = 1))
            : Ee > 65535 && ((Ee -= 65536), se.push(((Ee >>> 10) & 1023) | 55296), (Ee = 56320 | (Ee & 1023))),
            se.push(Ee),
            (me += Me)
        }
        return J(se)
      }
      var K = 4096
      function J(Y) {
        let z = Y.length
        if (z <= K) return String.fromCharCode.apply(String, Y)
        let H = '',
          se = 0
        for (; se < z; ) H += String.fromCharCode.apply(String, Y.slice(se, (se += K)))
        return H
      }
      function Z(Y, z, H) {
        let se = ''
        H = Math.min(Y.length, H)
        for (let me = z; me < H; ++me) se += String.fromCharCode(Y[me] & 127)
        return se
      }
      function Q(Y, z, H) {
        let se = ''
        H = Math.min(Y.length, H)
        for (let me = z; me < H; ++me) se += String.fromCharCode(Y[me])
        return se
      }
      function fe(Y, z, H) {
        let se = Y.length
        ;(!z || z < 0) && (z = 0), (!H || H < 0 || H > se) && (H = se)
        let me = ''
        for (let we = z; we < H; ++we) me += ne[Y[we]]
        return me
      }
      function ie(Y, z, H) {
        let se = Y.slice(z, H),
          me = ''
        for (let we = 0; we < se.length - 1; we += 2) me += String.fromCharCode(se[we] + se[we + 1] * 256)
        return me
      }
      o.prototype.slice = function (z, H) {
        let se = this.length
        ;(z = ~~z),
          (H = H === void 0 ? se : ~~H),
          z < 0 ? ((z += se), z < 0 && (z = 0)) : z > se && (z = se),
          H < 0 ? ((H += se), H < 0 && (H = 0)) : H > se && (H = se),
          H < z && (H = z)
        let me = this.subarray(z, H)
        return Object.setPrototypeOf(me, o.prototype), me
      }
      function W(Y, z, H) {
        if (Y % 1 != 0 || Y < 0) throw new RangeError('offset is not uint')
        if (Y + z > H) throw new RangeError('Trying to access beyond buffer length')
      }
      ;(o.prototype.readUintLE = o.prototype.readUIntLE =
        function (z, H, se) {
          ;(z = z >>> 0), (H = H >>> 0), se || W(z, H, this.length)
          let me = this[z],
            we = 1,
            Ee = 0
          for (; ++Ee < H && (we *= 256); ) me += this[z + Ee] * we
          return me
        }),
        (o.prototype.readUintBE = o.prototype.readUIntBE =
          function (z, H, se) {
            ;(z = z >>> 0), (H = H >>> 0), se || W(z, H, this.length)
            let me = this[z + --H],
              we = 1
            for (; H > 0 && (we *= 256); ) me += this[z + --H] * we
            return me
          }),
        (o.prototype.readUint8 = o.prototype.readUInt8 =
          function (z, H) {
            return (z = z >>> 0), H || W(z, 1, this.length), this[z]
          }),
        (o.prototype.readUint16LE = o.prototype.readUInt16LE =
          function (z, H) {
            return (z = z >>> 0), H || W(z, 2, this.length), this[z] | (this[z + 1] << 8)
          }),
        (o.prototype.readUint16BE = o.prototype.readUInt16BE =
          function (z, H) {
            return (z = z >>> 0), H || W(z, 2, this.length), (this[z] << 8) | this[z + 1]
          }),
        (o.prototype.readUint32LE = o.prototype.readUInt32LE =
          function (z, H) {
            return (
              (z = z >>> 0),
              H || W(z, 4, this.length),
              (this[z] | (this[z + 1] << 8) | (this[z + 2] << 16)) + this[z + 3] * 16777216
            )
          }),
        (o.prototype.readUint32BE = o.prototype.readUInt32BE =
          function (z, H) {
            return (
              (z = z >>> 0),
              H || W(z, 4, this.length),
              this[z] * 16777216 + ((this[z + 1] << 16) | (this[z + 2] << 8) | this[z + 3])
            )
          }),
        (o.prototype.readBigUInt64LE = ee(function (z) {
          ;(z = z >>> 0), C(z, 'offset')
          let H = this[z],
            se = this[z + 7]
          ;(H === void 0 || se === void 0) && S(z, this.length - 8)
          let me = H + this[++z] * 2 ** 8 + this[++z] * 2 ** 16 + this[++z] * 2 ** 24,
            we = this[++z] + this[++z] * 2 ** 8 + this[++z] * 2 ** 16 + se * 2 ** 24
          return BigInt(me) + (BigInt(we) << BigInt(32))
        })),
        (o.prototype.readBigUInt64BE = ee(function (z) {
          ;(z = z >>> 0), C(z, 'offset')
          let H = this[z],
            se = this[z + 7]
          ;(H === void 0 || se === void 0) && S(z, this.length - 8)
          let me = H * 2 ** 24 + this[++z] * 2 ** 16 + this[++z] * 2 ** 8 + this[++z],
            we = this[++z] * 2 ** 24 + this[++z] * 2 ** 16 + this[++z] * 2 ** 8 + se
          return (BigInt(me) << BigInt(32)) + BigInt(we)
        })),
        (o.prototype.readIntLE = function (z, H, se) {
          ;(z = z >>> 0), (H = H >>> 0), se || W(z, H, this.length)
          let me = this[z],
            we = 1,
            Ee = 0
          for (; ++Ee < H && (we *= 256); ) me += this[z + Ee] * we
          return (we *= 128), me >= we && (me -= Math.pow(2, 8 * H)), me
        }),
        (o.prototype.readIntBE = function (z, H, se) {
          ;(z = z >>> 0), (H = H >>> 0), se || W(z, H, this.length)
          let me = H,
            we = 1,
            Ee = this[z + --me]
          for (; me > 0 && (we *= 256); ) Ee += this[z + --me] * we
          return (we *= 128), Ee >= we && (Ee -= Math.pow(2, 8 * H)), Ee
        }),
        (o.prototype.readInt8 = function (z, H) {
          return (z = z >>> 0), H || W(z, 1, this.length), this[z] & 128 ? (255 - this[z] + 1) * -1 : this[z]
        }),
        (o.prototype.readInt16LE = function (z, H) {
          ;(z = z >>> 0), H || W(z, 2, this.length)
          let se = this[z] | (this[z + 1] << 8)
          return se & 32768 ? se | 4294901760 : se
        }),
        (o.prototype.readInt16BE = function (z, H) {
          ;(z = z >>> 0), H || W(z, 2, this.length)
          let se = this[z + 1] | (this[z] << 8)
          return se & 32768 ? se | 4294901760 : se
        }),
        (o.prototype.readInt32LE = function (z, H) {
          return (
            (z = z >>> 0),
            H || W(z, 4, this.length),
            this[z] | (this[z + 1] << 8) | (this[z + 2] << 16) | (this[z + 3] << 24)
          )
        }),
        (o.prototype.readInt32BE = function (z, H) {
          return (
            (z = z >>> 0),
            H || W(z, 4, this.length),
            (this[z] << 24) | (this[z + 1] << 16) | (this[z + 2] << 8) | this[z + 3]
          )
        }),
        (o.prototype.readBigInt64LE = ee(function (z) {
          ;(z = z >>> 0), C(z, 'offset')
          let H = this[z],
            se = this[z + 7]
          ;(H === void 0 || se === void 0) && S(z, this.length - 8)
          let me = this[z + 4] + this[z + 5] * 2 ** 8 + this[z + 6] * 2 ** 16 + (se << 24)
          return (BigInt(me) << BigInt(32)) + BigInt(H + this[++z] * 2 ** 8 + this[++z] * 2 ** 16 + this[++z] * 2 ** 24)
        })),
        (o.prototype.readBigInt64BE = ee(function (z) {
          ;(z = z >>> 0), C(z, 'offset')
          let H = this[z],
            se = this[z + 7]
          ;(H === void 0 || se === void 0) && S(z, this.length - 8)
          let me = (H << 24) + this[++z] * 2 ** 16 + this[++z] * 2 ** 8 + this[++z]
          return (
            (BigInt(me) << BigInt(32)) + BigInt(this[++z] * 2 ** 24 + this[++z] * 2 ** 16 + this[++z] * 2 ** 8 + se)
          )
        })),
        (o.prototype.readFloatLE = function (z, H) {
          return (z = z >>> 0), H || W(z, 4, this.length), t.read(this, z, !0, 23, 4)
        }),
        (o.prototype.readFloatBE = function (z, H) {
          return (z = z >>> 0), H || W(z, 4, this.length), t.read(this, z, !1, 23, 4)
        }),
        (o.prototype.readDoubleLE = function (z, H) {
          return (z = z >>> 0), H || W(z, 8, this.length), t.read(this, z, !0, 52, 8)
        }),
        (o.prototype.readDoubleBE = function (z, H) {
          return (z = z >>> 0), H || W(z, 8, this.length), t.read(this, z, !1, 52, 8)
        })
      function le(Y, z, H, se, me, we) {
        if (!o.isBuffer(Y)) throw new TypeError('"buffer" argument must be a Buffer instance')
        if (z > me || z < we) throw new RangeError('"value" argument is out of bounds')
        if (H + se > Y.length) throw new RangeError('Index out of range')
      }
      ;(o.prototype.writeUintLE = o.prototype.writeUIntLE =
        function (z, H, se, me) {
          if (((z = +z), (H = H >>> 0), (se = se >>> 0), !me)) {
            let Me = Math.pow(2, 8 * se) - 1
            le(this, z, H, se, Me, 0)
          }
          let we = 1,
            Ee = 0
          for (this[H] = z & 255; ++Ee < se && (we *= 256); ) this[H + Ee] = (z / we) & 255
          return H + se
        }),
        (o.prototype.writeUintBE = o.prototype.writeUIntBE =
          function (z, H, se, me) {
            if (((z = +z), (H = H >>> 0), (se = se >>> 0), !me)) {
              let Me = Math.pow(2, 8 * se) - 1
              le(this, z, H, se, Me, 0)
            }
            let we = se - 1,
              Ee = 1
            for (this[H + we] = z & 255; --we >= 0 && (Ee *= 256); ) this[H + we] = (z / Ee) & 255
            return H + se
          }),
        (o.prototype.writeUint8 = o.prototype.writeUInt8 =
          function (z, H, se) {
            return (z = +z), (H = H >>> 0), se || le(this, z, H, 1, 255, 0), (this[H] = z & 255), H + 1
          }),
        (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
          function (z, H, se) {
            return (
              (z = +z),
              (H = H >>> 0),
              se || le(this, z, H, 2, 65535, 0),
              (this[H] = z & 255),
              (this[H + 1] = z >>> 8),
              H + 2
            )
          }),
        (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
          function (z, H, se) {
            return (
              (z = +z),
              (H = H >>> 0),
              se || le(this, z, H, 2, 65535, 0),
              (this[H] = z >>> 8),
              (this[H + 1] = z & 255),
              H + 2
            )
          }),
        (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
          function (z, H, se) {
            return (
              (z = +z),
              (H = H >>> 0),
              se || le(this, z, H, 4, 4294967295, 0),
              (this[H + 3] = z >>> 24),
              (this[H + 2] = z >>> 16),
              (this[H + 1] = z >>> 8),
              (this[H] = z & 255),
              H + 4
            )
          }),
        (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
          function (z, H, se) {
            return (
              (z = +z),
              (H = H >>> 0),
              se || le(this, z, H, 4, 4294967295, 0),
              (this[H] = z >>> 24),
              (this[H + 1] = z >>> 16),
              (this[H + 2] = z >>> 8),
              (this[H + 3] = z & 255),
              H + 4
            )
          })
      function xe(Y, z, H, se, me) {
        b(z, se, me, Y, H, 7)
        let we = Number(z & BigInt(4294967295))
        ;(Y[H++] = we), (we = we >> 8), (Y[H++] = we), (we = we >> 8), (Y[H++] = we), (we = we >> 8), (Y[H++] = we)
        let Ee = Number((z >> BigInt(32)) & BigInt(4294967295))
        return (
          (Y[H++] = Ee), (Ee = Ee >> 8), (Y[H++] = Ee), (Ee = Ee >> 8), (Y[H++] = Ee), (Ee = Ee >> 8), (Y[H++] = Ee), H
        )
      }
      function _e(Y, z, H, se, me) {
        b(z, se, me, Y, H, 7)
        let we = Number(z & BigInt(4294967295))
        ;(Y[H + 7] = we),
          (we = we >> 8),
          (Y[H + 6] = we),
          (we = we >> 8),
          (Y[H + 5] = we),
          (we = we >> 8),
          (Y[H + 4] = we)
        let Ee = Number((z >> BigInt(32)) & BigInt(4294967295))
        return (
          (Y[H + 3] = Ee),
          (Ee = Ee >> 8),
          (Y[H + 2] = Ee),
          (Ee = Ee >> 8),
          (Y[H + 1] = Ee),
          (Ee = Ee >> 8),
          (Y[H] = Ee),
          H + 8
        )
      }
      ;(o.prototype.writeBigUInt64LE = ee(function (z, H = 0) {
        return xe(this, z, H, BigInt(0), BigInt('0xffffffffffffffff'))
      })),
        (o.prototype.writeBigUInt64BE = ee(function (z, H = 0) {
          return _e(this, z, H, BigInt(0), BigInt('0xffffffffffffffff'))
        })),
        (o.prototype.writeIntLE = function (z, H, se, me) {
          if (((z = +z), (H = H >>> 0), !me)) {
            let Be = Math.pow(2, 8 * se - 1)
            le(this, z, H, se, Be - 1, -Be)
          }
          let we = 0,
            Ee = 1,
            Me = 0
          for (this[H] = z & 255; ++we < se && (Ee *= 256); )
            z < 0 && Me === 0 && this[H + we - 1] !== 0 && (Me = 1), (this[H + we] = (((z / Ee) >> 0) - Me) & 255)
          return H + se
        }),
        (o.prototype.writeIntBE = function (z, H, se, me) {
          if (((z = +z), (H = H >>> 0), !me)) {
            let Be = Math.pow(2, 8 * se - 1)
            le(this, z, H, se, Be - 1, -Be)
          }
          let we = se - 1,
            Ee = 1,
            Me = 0
          for (this[H + we] = z & 255; --we >= 0 && (Ee *= 256); )
            z < 0 && Me === 0 && this[H + we + 1] !== 0 && (Me = 1), (this[H + we] = (((z / Ee) >> 0) - Me) & 255)
          return H + se
        }),
        (o.prototype.writeInt8 = function (z, H, se) {
          return (
            (z = +z),
            (H = H >>> 0),
            se || le(this, z, H, 1, 127, -128),
            z < 0 && (z = 255 + z + 1),
            (this[H] = z & 255),
            H + 1
          )
        }),
        (o.prototype.writeInt16LE = function (z, H, se) {
          return (
            (z = +z),
            (H = H >>> 0),
            se || le(this, z, H, 2, 32767, -32768),
            (this[H] = z & 255),
            (this[H + 1] = z >>> 8),
            H + 2
          )
        }),
        (o.prototype.writeInt16BE = function (z, H, se) {
          return (
            (z = +z),
            (H = H >>> 0),
            se || le(this, z, H, 2, 32767, -32768),
            (this[H] = z >>> 8),
            (this[H + 1] = z & 255),
            H + 2
          )
        }),
        (o.prototype.writeInt32LE = function (z, H, se) {
          return (
            (z = +z),
            (H = H >>> 0),
            se || le(this, z, H, 4, 2147483647, -2147483648),
            (this[H] = z & 255),
            (this[H + 1] = z >>> 8),
            (this[H + 2] = z >>> 16),
            (this[H + 3] = z >>> 24),
            H + 4
          )
        }),
        (o.prototype.writeInt32BE = function (z, H, se) {
          return (
            (z = +z),
            (H = H >>> 0),
            se || le(this, z, H, 4, 2147483647, -2147483648),
            z < 0 && (z = 4294967295 + z + 1),
            (this[H] = z >>> 24),
            (this[H + 1] = z >>> 16),
            (this[H + 2] = z >>> 8),
            (this[H + 3] = z & 255),
            H + 4
          )
        }),
        (o.prototype.writeBigInt64LE = ee(function (z, H = 0) {
          return xe(this, z, H, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
        })),
        (o.prototype.writeBigInt64BE = ee(function (z, H = 0) {
          return _e(this, z, H, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
        }))
      function Ne(Y, z, H, se, me, we) {
        if (H + se > Y.length) throw new RangeError('Index out of range')
        if (H < 0) throw new RangeError('Index out of range')
      }
      function ke(Y, z, H, se, me) {
        return (
          (z = +z),
          (H = H >>> 0),
          me || Ne(Y, z, H, 4, 34028234663852886e22, -34028234663852886e22),
          t.write(Y, z, H, se, 23, 4),
          H + 4
        )
      }
      ;(o.prototype.writeFloatLE = function (z, H, se) {
        return ke(this, z, H, !0, se)
      }),
        (o.prototype.writeFloatBE = function (z, H, se) {
          return ke(this, z, H, !1, se)
        })
      function oe(Y, z, H, se, me) {
        return (
          (z = +z),
          (H = H >>> 0),
          me || Ne(Y, z, H, 8, 17976931348623157e292, -17976931348623157e292),
          t.write(Y, z, H, se, 52, 8),
          H + 8
        )
      }
      ;(o.prototype.writeDoubleLE = function (z, H, se) {
        return oe(this, z, H, !0, se)
      }),
        (o.prototype.writeDoubleBE = function (z, H, se) {
          return oe(this, z, H, !1, se)
        }),
        (o.prototype.copy = function (z, H, se, me) {
          if (!o.isBuffer(z)) throw new TypeError('argument should be a Buffer')
          if (
            (se || (se = 0),
            !me && me !== 0 && (me = this.length),
            H >= z.length && (H = z.length),
            H || (H = 0),
            me > 0 && me < se && (me = se),
            me === se || z.length === 0 || this.length === 0)
          )
            return 0
          if (H < 0) throw new RangeError('targetStart out of bounds')
          if (se < 0 || se >= this.length) throw new RangeError('Index out of range')
          if (me < 0) throw new RangeError('sourceEnd out of bounds')
          me > this.length && (me = this.length), z.length - H < me - se && (me = z.length - H + se)
          let we = me - se
          return (
            this === z && typeof Uint8Array.prototype.copyWithin == 'function'
              ? this.copyWithin(H, se, me)
              : Uint8Array.prototype.set.call(z, this.subarray(se, me), H),
            we
          )
        }),
        (o.prototype.fill = function (z, H, se, me) {
          if (typeof z == 'string') {
            if (
              (typeof H == 'string'
                ? ((me = H), (H = 0), (se = this.length))
                : typeof se == 'string' && ((me = se), (se = this.length)),
              me !== void 0 && typeof me != 'string')
            )
              throw new TypeError('encoding must be a string')
            if (typeof me == 'string' && !o.isEncoding(me)) throw new TypeError('Unknown encoding: ' + me)
            if (z.length === 1) {
              let Ee = z.charCodeAt(0)
              ;((me === 'utf8' && Ee < 128) || me === 'latin1') && (z = Ee)
            }
          } else typeof z == 'number' ? (z = z & 255) : typeof z == 'boolean' && (z = Number(z))
          if (H < 0 || this.length < H || this.length < se) throw new RangeError('Out of range index')
          if (se <= H) return this
          ;(H = H >>> 0), (se = se === void 0 ? this.length : se >>> 0), z || (z = 0)
          let we
          if (typeof z == 'number') for (we = H; we < se; ++we) this[we] = z
          else {
            let Ee = o.isBuffer(z) ? z : o.from(z, me),
              Me = Ee.length
            if (Me === 0) throw new TypeError('The value "' + z + '" is invalid for argument "value"')
            for (we = 0; we < se - H; ++we) this[we + H] = Ee[we % Me]
          }
          return this
        })
      var be = {}
      function ge(Y, z, H) {
        be[Y] = class extends H {
          constructor() {
            super()
            Object.defineProperty(this, 'message', { value: z.apply(this, arguments), writable: !0, configurable: !0 }),
              (this.name = `${this.name} [${Y}]`),
              this.stack,
              delete this.name
          }
          get code() {
            return Y
          }
          set code(me) {
            Object.defineProperty(this, 'code', { configurable: !0, enumerable: !0, value: me, writable: !0 })
          }
          toString() {
            return `${this.name} [${Y}]: ${this.message}`
          }
        }
      }
      ge(
        'ERR_BUFFER_OUT_OF_BOUNDS',
        function (Y) {
          return Y ? `${Y} is outside of buffer bounds` : 'Attempt to access memory outside buffer bounds'
        },
        RangeError
      ),
        ge(
          'ERR_INVALID_ARG_TYPE',
          function (Y, z) {
            return `The "${Y}" argument must be of type number. Received type ${typeof z}`
          },
          TypeError
        ),
        ge(
          'ERR_OUT_OF_RANGE',
          function (Y, z, H) {
            let se = `The value of "${Y}" is out of range.`,
              me = H
            return (
              Number.isInteger(H) && Math.abs(H) > 2 ** 32
                ? (me = re(String(H)))
                : typeof H == 'bigint' &&
                  ((me = String(H)),
                  (H > BigInt(2) ** BigInt(32) || H < -(BigInt(2) ** BigInt(32))) && (me = re(me)),
                  (me += 'n')),
              (se += ` It must be ${z}. Received ${me}`),
              se
            )
          },
          RangeError
        )
      function re(Y) {
        let z = '',
          H = Y.length,
          se = Y[0] === '-' ? 1 : 0
        for (; H >= se + 4; H -= 3) z = `_${Y.slice(H - 3, H)}${z}`
        return `${Y.slice(0, H)}${z}`
      }
      function j(Y, z, H) {
        C(z, 'offset'), (Y[z] === void 0 || Y[z + H] === void 0) && S(z, Y.length - (H + 1))
      }
      function b(Y, z, H, se, me, we) {
        if (Y > H || Y < z) {
          let Ee = typeof z == 'bigint' ? 'n' : '',
            Me
          throw (
            (we > 3
              ? z === 0 || z === BigInt(0)
                ? (Me = `>= 0${Ee} and < 2${Ee} ** ${(we + 1) * 8}${Ee}`)
                : (Me = `>= -(2${Ee} ** ${(we + 1) * 8 - 1}${Ee}) and < 2 ** ${(we + 1) * 8 - 1}${Ee}`)
              : (Me = `>= ${z}${Ee} and <= ${H}${Ee}`),
            new be.ERR_OUT_OF_RANGE('value', Me, Y))
          )
        }
        j(se, me, we)
      }
      function C(Y, z) {
        if (typeof Y != 'number') throw new be.ERR_INVALID_ARG_TYPE(z, 'number', Y)
      }
      function S(Y, z, H) {
        throw Math.floor(Y) !== Y
          ? (C(Y, H), new be.ERR_OUT_OF_RANGE(H || 'offset', 'an integer', Y))
          : z < 0
          ? new be.ERR_BUFFER_OUT_OF_BOUNDS()
          : new be.ERR_OUT_OF_RANGE(H || 'offset', `>= ${H ? 1 : 0} and <= ${z}`, Y)
      }
      var R = /[^+/0-9A-Za-z-_]/g
      function P(Y) {
        if (((Y = Y.split('=')[0]), (Y = Y.trim().replace(R, '')), Y.length < 2)) return ''
        for (; Y.length % 4 != 0; ) Y = Y + '='
        return Y
      }
      function B(Y, z) {
        z = z || 1 / 0
        let H,
          se = Y.length,
          me = null,
          we = []
        for (let Ee = 0; Ee < se; ++Ee) {
          if (((H = Y.charCodeAt(Ee)), H > 55295 && H < 57344)) {
            if (!me) {
              if (H > 56319) {
                ;(z -= 3) > -1 && we.push(239, 191, 189)
                continue
              } else if (Ee + 1 === se) {
                ;(z -= 3) > -1 && we.push(239, 191, 189)
                continue
              }
              me = H
              continue
            }
            if (H < 56320) {
              ;(z -= 3) > -1 && we.push(239, 191, 189), (me = H)
              continue
            }
            H = (((me - 55296) << 10) | (H - 56320)) + 65536
          } else me && (z -= 3) > -1 && we.push(239, 191, 189)
          if (((me = null), H < 128)) {
            if ((z -= 1) < 0) break
            we.push(H)
          } else if (H < 2048) {
            if ((z -= 2) < 0) break
            we.push((H >> 6) | 192, (H & 63) | 128)
          } else if (H < 65536) {
            if ((z -= 3) < 0) break
            we.push((H >> 12) | 224, ((H >> 6) & 63) | 128, (H & 63) | 128)
          } else if (H < 1114112) {
            if ((z -= 4) < 0) break
            we.push((H >> 18) | 240, ((H >> 12) & 63) | 128, ((H >> 6) & 63) | 128, (H & 63) | 128)
          } else throw new Error('Invalid code point')
        }
        return we
      }
      function D(Y) {
        let z = []
        for (let H = 0; H < Y.length; ++H) z.push(Y.charCodeAt(H) & 255)
        return z
      }
      function $(Y, z) {
        let H,
          se,
          me,
          we = []
        for (let Ee = 0; Ee < Y.length && !((z -= 2) < 0); ++Ee)
          (H = Y.charCodeAt(Ee)), (se = H >> 8), (me = H % 256), we.push(me), we.push(se)
        return we
      }
      function g(Y) {
        return r.toByteArray(P(Y))
      }
      function N(Y, z, H, se) {
        let me
        for (me = 0; me < se && !(me + H >= z.length || me >= Y.length); ++me) z[me + H] = Y[me]
        return me
      }
      function U(Y, z) {
        return (
          Y instanceof z ||
          (Y != null && Y.constructor != null && Y.constructor.name != null && Y.constructor.name === z.name)
        )
      }
      function X(Y) {
        return Y !== Y
      }
      var ne = (function () {
        let Y = '0123456789abcdef',
          z = new Array(256)
        for (let H = 0; H < 16; ++H) {
          let se = H * 16
          for (let me = 0; me < 16; ++me) z[se + me] = Y[H] + Y[me]
        }
        return z
      })()
      function ee(Y) {
        return typeof BigInt == 'undefined' ? ae : Y
      }
      function ae() {
        throw new Error('BigInt not supported')
      }
    }
  }),
  Ve,
  V = Ie({
    'scripts/node-globals.js'() {
      Ve = Yr($r())
    }
  }),
  Ol = te({
    '../protocols/node_modules/it-pipe/index.js'(e, r) {
      V(), F()
      var t = (...o) => {
          let l
          for (; o.length; ) l = o.shift()(l)
          return l
        },
        n = (o) =>
          o &&
          (typeof o[Symbol.asyncIterator] == 'function' ||
            typeof o[Symbol.iterator] == 'function' ||
            typeof o.next == 'function'),
        i = (o) => o && typeof o.sink == 'function' && n(o.source),
        s = (o) => (l) => o.sink(l), o.source,
        u = (...o) => {
          if (i(o[0])) {
            let l = o[0]
            o[0] = () => l.source
          } else if (n(o[0])) {
            let l = o[0]
            o[0] = () => l
          }
          if ((o.length > 1 && i(o[o.length - 1]) && (o[o.length - 1] = o[o.length - 1].sink), o.length > 2))
            for (let l = 1; l < o.length - 1; l++) i(o[l]) && (o[l] = s(o[l]))
          return t(...o)
        }
      ;(r.exports = u),
        (r.exports.pipe = u),
        (r.exports.rawPipe = t),
        (r.exports.isIterable = n),
        (r.exports.isDuplex = i)
    }
  }),
  RR = te({
    '../protocols/node_modules/tslib/tslib.js'(e, r) {
      V(), F()
      var t, n, i, s, u, o, l, a, c, f, p, y, d, h, m, _, A, T, E, k, w, v, I, M
      ;(function (q) {
        var G =
          typeof globalThis == 'object'
            ? globalThis
            : typeof self == 'object'
            ? self
            : typeof this == 'object'
            ? this
            : {}
        typeof define == 'function' && define.amd
          ? define('tslib', ['exports'], function (x) {
              q(O(G, O(x)))
            })
          : typeof r == 'object' && typeof r.exports == 'object'
          ? q(O(G, O(r.exports)))
          : q(O(G))
        function O(x, L) {
          return (
            x !== G &&
              (typeof Object.create == 'function'
                ? Object.defineProperty(x, '__esModule', { value: !0 })
                : (x.__esModule = !0)),
            function (K, J) {
              return (x[K] = L ? L(K, J) : J)
            }
          )
        }
      })(function (q) {
        var G =
          Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array &&
            function (x, L) {
              x.__proto__ = L
            }) ||
          function (x, L) {
            for (var K in L) Object.prototype.hasOwnProperty.call(L, K) && (x[K] = L[K])
          }
        ;(t = function (x, L) {
          if (typeof L != 'function' && L !== null)
            throw new TypeError('Class extends value ' + String(L) + ' is not a constructor or null')
          G(x, L)
          function K() {
            this.constructor = x
          }
          x.prototype = L === null ? Object.create(L) : ((K.prototype = L.prototype), new K())
        }),
          (n =
            Object.assign ||
            function (x) {
              for (var L, K = 1, J = arguments.length; K < J; K++) {
                L = arguments[K]
                for (var Z in L) Object.prototype.hasOwnProperty.call(L, Z) && (x[Z] = L[Z])
              }
              return x
            }),
          (i = function (x, L) {
            var K = {}
            for (var J in x) Object.prototype.hasOwnProperty.call(x, J) && L.indexOf(J) < 0 && (K[J] = x[J])
            if (x != null && typeof Object.getOwnPropertySymbols == 'function')
              for (var Z = 0, J = Object.getOwnPropertySymbols(x); Z < J.length; Z++)
                L.indexOf(J[Z]) < 0 && Object.prototype.propertyIsEnumerable.call(x, J[Z]) && (K[J[Z]] = x[J[Z]])
            return K
          }),
          (s = function (x, L, K, J) {
            var Z = arguments.length,
              Q = Z < 3 ? L : J === null ? (J = Object.getOwnPropertyDescriptor(L, K)) : J,
              fe
            if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') Q = Reflect.decorate(x, L, K, J)
            else
              for (var ie = x.length - 1; ie >= 0; ie--)
                (fe = x[ie]) && (Q = (Z < 3 ? fe(Q) : Z > 3 ? fe(L, K, Q) : fe(L, K)) || Q)
            return Z > 3 && Q && Object.defineProperty(L, K, Q), Q
          }),
          (u = function (x, L) {
            return function (K, J) {
              L(K, J, x)
            }
          }),
          (o = function (x, L) {
            if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function') return Reflect.metadata(x, L)
          }),
          (l = function (x, L, K, J) {
            function Z(Q) {
              return Q instanceof K
                ? Q
                : new K(function (fe) {
                    fe(Q)
                  })
            }
            return new (K || (K = Promise))(function (Q, fe) {
              function ie(xe) {
                try {
                  le(J.next(xe))
                } catch (_e) {
                  fe(_e)
                }
              }
              function W(xe) {
                try {
                  le(J.throw(xe))
                } catch (_e) {
                  fe(_e)
                }
              }
              function le(xe) {
                xe.done ? Q(xe.value) : Z(xe.value).then(ie, W)
              }
              le((J = J.apply(x, L || [])).next())
            })
          }),
          (a = function (x, L) {
            var K = {
                label: 0,
                sent: function () {
                  if (Q[0] & 1) throw Q[1]
                  return Q[1]
                },
                trys: [],
                ops: []
              },
              J,
              Z,
              Q,
              fe
            return (
              (fe = { next: ie(0), throw: ie(1), return: ie(2) }),
              typeof Symbol == 'function' &&
                (fe[Symbol.iterator] = function () {
                  return this
                }),
              fe
            )
            function ie(le) {
              return function (xe) {
                return W([le, xe])
              }
            }
            function W(le) {
              if (J) throw new TypeError('Generator is already executing.')
              for (; K; )
                try {
                  if (
                    ((J = 1),
                    Z &&
                      (Q = le[0] & 2 ? Z.return : le[0] ? Z.throw || ((Q = Z.return) && Q.call(Z), 0) : Z.next) &&
                      !(Q = Q.call(Z, le[1])).done)
                  )
                    return Q
                  switch (((Z = 0), Q && (le = [le[0] & 2, Q.value]), le[0])) {
                    case 0:
                    case 1:
                      Q = le
                      break
                    case 4:
                      return K.label++, { value: le[1], done: !1 }
                    case 5:
                      K.label++, (Z = le[1]), (le = [0])
                      continue
                    case 7:
                      ;(le = K.ops.pop()), K.trys.pop()
                      continue
                    default:
                      if (((Q = K.trys), !(Q = Q.length > 0 && Q[Q.length - 1]) && (le[0] === 6 || le[0] === 2))) {
                        K = 0
                        continue
                      }
                      if (le[0] === 3 && (!Q || (le[1] > Q[0] && le[1] < Q[3]))) {
                        K.label = le[1]
                        break
                      }
                      if (le[0] === 6 && K.label < Q[1]) {
                        ;(K.label = Q[1]), (Q = le)
                        break
                      }
                      if (Q && K.label < Q[2]) {
                        ;(K.label = Q[2]), K.ops.push(le)
                        break
                      }
                      Q[2] && K.ops.pop(), K.trys.pop()
                      continue
                  }
                  le = L.call(x, K)
                } catch (xe) {
                  ;(le = [6, xe]), (Z = 0)
                } finally {
                  J = Q = 0
                }
              if (le[0] & 5) throw le[1]
              return { value: le[0] ? le[1] : void 0, done: !0 }
            }
          }),
          (c = function (x, L) {
            for (var K in x) K !== 'default' && !Object.prototype.hasOwnProperty.call(L, K) && M(L, x, K)
          }),
          (M = Object.create
            ? function (x, L, K, J) {
                J === void 0 && (J = K),
                  Object.defineProperty(x, J, {
                    enumerable: !0,
                    get: function () {
                      return L[K]
                    }
                  })
              }
            : function (x, L, K, J) {
                J === void 0 && (J = K), (x[J] = L[K])
              }),
          (f = function (x) {
            var L = typeof Symbol == 'function' && Symbol.iterator,
              K = L && x[L],
              J = 0
            if (K) return K.call(x)
            if (x && typeof x.length == 'number')
              return {
                next: function () {
                  return x && J >= x.length && (x = void 0), { value: x && x[J++], done: !x }
                }
              }
            throw new TypeError(L ? 'Object is not iterable.' : 'Symbol.iterator is not defined.')
          }),
          (p = function (x, L) {
            var K = typeof Symbol == 'function' && x[Symbol.iterator]
            if (!K) return x
            var J = K.call(x),
              Z,
              Q = [],
              fe
            try {
              for (; (L === void 0 || L-- > 0) && !(Z = J.next()).done; ) Q.push(Z.value)
            } catch (ie) {
              fe = { error: ie }
            } finally {
              try {
                Z && !Z.done && (K = J.return) && K.call(J)
              } finally {
                if (fe) throw fe.error
              }
            }
            return Q
          }),
          (y = function () {
            for (var x = [], L = 0; L < arguments.length; L++) x = x.concat(p(arguments[L]))
            return x
          }),
          (d = function () {
            for (var x = 0, L = 0, K = arguments.length; L < K; L++) x += arguments[L].length
            for (var J = Array(x), Z = 0, L = 0; L < K; L++)
              for (var Q = arguments[L], fe = 0, ie = Q.length; fe < ie; fe++, Z++) J[Z] = Q[fe]
            return J
          }),
          (h = function (x, L) {
            for (var K = 0, J = L.length, Z = x.length; K < J; K++, Z++) x[Z] = L[K]
            return x
          }),
          (m = function (x) {
            return this instanceof m ? ((this.v = x), this) : new m(x)
          }),
          (_ = function (x, L, K) {
            if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
            var J = K.apply(x, L || []),
              Z,
              Q = []
            return (
              (Z = {}),
              fe('next'),
              fe('throw'),
              fe('return'),
              (Z[Symbol.asyncIterator] = function () {
                return this
              }),
              Z
            )
            function fe(Ne) {
              J[Ne] &&
                (Z[Ne] = function (ke) {
                  return new Promise(function (oe, be) {
                    Q.push([Ne, ke, oe, be]) > 1 || ie(Ne, ke)
                  })
                })
            }
            function ie(Ne, ke) {
              try {
                W(J[Ne](ke))
              } catch (oe) {
                _e(Q[0][3], oe)
              }
            }
            function W(Ne) {
              Ne.value instanceof m ? Promise.resolve(Ne.value.v).then(le, xe) : _e(Q[0][2], Ne)
            }
            function le(Ne) {
              ie('next', Ne)
            }
            function xe(Ne) {
              ie('throw', Ne)
            }
            function _e(Ne, ke) {
              Ne(ke), Q.shift(), Q.length && ie(Q[0][0], Q[0][1])
            }
          }),
          (A = function (x) {
            var L, K
            return (
              (L = {}),
              J('next'),
              J('throw', function (Z) {
                throw Z
              }),
              J('return'),
              (L[Symbol.iterator] = function () {
                return this
              }),
              L
            )
            function J(Z, Q) {
              L[Z] = x[Z]
                ? function (fe) {
                    return (K = !K) ? { value: m(x[Z](fe)), done: Z === 'return' } : Q ? Q(fe) : fe
                  }
                : Q
            }
          }),
          (T = function (x) {
            if (!Symbol.asyncIterator) throw new TypeError('Symbol.asyncIterator is not defined.')
            var L = x[Symbol.asyncIterator],
              K
            return L
              ? L.call(x)
              : ((x = typeof f == 'function' ? f(x) : x[Symbol.iterator]()),
                (K = {}),
                J('next'),
                J('throw'),
                J('return'),
                (K[Symbol.asyncIterator] = function () {
                  return this
                }),
                K)
            function J(Q) {
              K[Q] =
                x[Q] &&
                function (fe) {
                  return new Promise(function (ie, W) {
                    ;(fe = x[Q](fe)), Z(ie, W, fe.done, fe.value)
                  })
                }
            }
            function Z(Q, fe, ie, W) {
              Promise.resolve(W).then(function (le) {
                Q({ value: le, done: ie })
              }, fe)
            }
          }),
          (E = function (x, L) {
            return Object.defineProperty ? Object.defineProperty(x, 'raw', { value: L }) : (x.raw = L), x
          })
        var O = Object.create
          ? function (x, L) {
              Object.defineProperty(x, 'default', { enumerable: !0, value: L })
            }
          : function (x, L) {
              x.default = L
            }
        ;(k = function (x) {
          if (x && x.__esModule) return x
          var L = {}
          if (x != null) for (var K in x) K !== 'default' && Object.prototype.hasOwnProperty.call(x, K) && M(L, x, K)
          return O(L, x), L
        }),
          (w = function (x) {
            return x && x.__esModule ? x : { default: x }
          }),
          (v = function (x, L) {
            if (!L.has(x)) throw new TypeError('attempted to get private field on non-instance')
            return L.get(x)
          }),
          (I = function (x, L, K) {
            if (!L.has(x)) throw new TypeError('attempted to set private field on non-instance')
            return L.set(x, K), K
          }),
          q('__extends', t),
          q('__assign', n),
          q('__rest', i),
          q('__decorate', s),
          q('__param', u),
          q('__metadata', o),
          q('__awaiter', l),
          q('__generator', a),
          q('__exportStar', c),
          q('__createBinding', M),
          q('__values', f),
          q('__read', p),
          q('__spread', y),
          q('__spreadArrays', d),
          q('__spreadArray', h),
          q('__await', m),
          q('__asyncGenerator', _),
          q('__asyncDelegator', A),
          q('__asyncValues', T),
          q('__makeTemplateObject', E),
          q('__importStar', k),
          q('__importDefault', w),
          q('__classPrivateFieldGet', v),
          q('__classPrivateFieldSet', I)
      })
    }
  }),
  BR = te({
    '(disabled):node_modules/ws/browser.js'() {
      V(), F()
    }
  }),
  NR = te({
    'node_modules/it-ws/web-socket.js'(e, r) {
      V(), F(), (r.exports = typeof WebSocket == 'undefined' ? BR() : WebSocket)
    }
  }),
  PR = te({
    'node_modules/event-iterator/lib/event-iterator.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 })
      var r = class {
          constructor() {
            ;(this.pullQueue = []),
              (this.pushQueue = []),
              (this.eventHandlers = {}),
              (this.isPaused = !1),
              (this.isStopped = !1)
          }
          push(n) {
            if (this.isStopped) return
            let i = { value: n, done: !1 }
            if (this.pullQueue.length) {
              let s = this.pullQueue.shift()
              s && s.resolve(i)
            } else
              this.pushQueue.push(Promise.resolve(i)),
                this.highWaterMark !== void 0 &&
                  this.pushQueue.length >= this.highWaterMark &&
                  !this.isPaused &&
                  ((this.isPaused = !0),
                  this.eventHandlers.highWater
                    ? this.eventHandlers.highWater()
                    : console && console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))
          }
          stop() {
            if (!this.isStopped) {
              ;(this.isStopped = !0), this.remove()
              for (let n of this.pullQueue) n.resolve({ value: void 0, done: !0 })
              this.pullQueue.length = 0
            }
          }
          fail(n) {
            if (!this.isStopped)
              if (((this.isStopped = !0), this.remove(), this.pullQueue.length)) {
                for (let i of this.pullQueue) i.reject(n)
                this.pullQueue.length = 0
              } else {
                let i = Promise.reject(n)
                i.catch(() => {}), this.pushQueue.push(i)
              }
          }
          remove() {
            Promise.resolve().then(() => {
              this.removeCallback && this.removeCallback()
            })
          }
          [Symbol.asyncIterator]() {
            return {
              next: (n) => {
                let i = this.pushQueue.shift()
                return i
                  ? (this.lowWaterMark !== void 0 &&
                      this.pushQueue.length <= this.lowWaterMark &&
                      this.isPaused &&
                      ((this.isPaused = !1), this.eventHandlers.lowWater && this.eventHandlers.lowWater()),
                    i)
                  : this.isStopped
                  ? Promise.resolve({ value: void 0, done: !0 })
                  : new Promise((s, u) => {
                      this.pullQueue.push({ resolve: s, reject: u })
                    })
              },
              return: () => (
                (this.isStopped = !0),
                (this.pushQueue.length = 0),
                this.remove(),
                Promise.resolve({ value: void 0, done: !0 })
              )
            }
          }
        },
        t = class {
          constructor(n, { highWaterMark: i = 100, lowWaterMark: s = 1 } = {}) {
            let u = new r()
            ;(u.highWaterMark = i),
              (u.lowWaterMark = s),
              (u.removeCallback =
                n({
                  push: (o) => u.push(o),
                  stop: () => u.stop(),
                  fail: (o) => u.fail(o),
                  on: (o, l) => {
                    u.eventHandlers[o] = l
                  }
                }) || (() => {})),
              (this[Symbol.asyncIterator] = () => u[Symbol.asyncIterator]()),
              Object.freeze(this)
          }
        }
      ;(e.EventIterator = t), (e.default = t)
    }
  }),
  OR = te({
    'node_modules/event-iterator/lib/dom.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 })
      var r = PR()
      e.EventIterator = r.EventIterator
      function t(n, i, s) {
        return new r.EventIterator(
          ({ push: u }) => (this.addEventListener(n, u, i), () => this.removeEventListener(n, u, i)),
          s
        )
      }
      ;(e.subscribe = t), (e.default = r.EventIterator)
    }
  }),
  DR = te({
    'node_modules/it-ws/source.js'(e, r) {
      V(), F()
      var { Buffer: t } = $r(),
        { EventIterator: n } = OR()
      function i(s) {
        return (
          s instanceof ArrayBuffer ||
          (s != null &&
            s.constructor != null &&
            s.constructor.name === 'ArrayBuffer' &&
            typeof s.byteLength == 'number')
        )
      }
      r.exports = (s) => {
        let u = s.removeEventListener || s.removeListener,
          o = (async function* () {
            let c = new n(
              ({ push: f, stop: p, fail: y }) => (
                s.addEventListener('message', f),
                s.addEventListener('error', y),
                s.addEventListener('close', p),
                () => {
                  u.call(s, 'message', f), u.call(s, 'error', y), u.call(s, 'close', p)
                }
              ),
              { highWaterMark: 1 / 0 }
            )
            for await (let { data: f } of c) yield i(f) ? t.from(f) : f
          })(),
          l = s.readyState === 1,
          a
        return (
          s.addEventListener('open', () => {
            ;(l = !0), (a = null)
          }),
          s.addEventListener('close', () => {
            ;(l = !1), (a = null)
          }),
          s.addEventListener('error', (c) => {
            l || (a = c)
          }),
          (o.connected = () =>
            new Promise((c, f) => {
              if (l) return c()
              if (a) return f(a)
              let p = (h) => {
                  u.call(s, 'open', y), u.call(s, 'error', d), h()
                },
                y = () => p(c),
                d = (h) => p(() => f(h))
              s.addEventListener('open', y), s.addEventListener('error', d)
            })),
          o
        )
      }
    }
  }),
  LR = te({
    'node_modules/it-ws/ready.js'(e, r) {
      V(),
        F(),
        (r.exports = async (t) => {
          if (t.readyState >= 2) throw new Error('socket closed')
          if (t.readyState !== 1)
            return new Promise((n, i) => {
              let s = t && (t.removeEventListener || t.removeListener)
              function u() {
                typeof s == 'function' && (s.call(t, 'open', o), s.call(t, 'error', l))
              }
              function o() {
                u(), n()
              }
              function l(a) {
                u(), i(a)
              }
              t.addEventListener('open', o), t.addEventListener('error', l)
            })
        })
    }
  }),
  UR = te({
    'node_modules/it-ws/sink.js'(e, r) {
      V(), F()
      var t = LR()
      r.exports = (n, i) => (
        (i = i || {}),
        (i.closeOnEnd = i.closeOnEnd !== !1),
        async (s) => {
          for await (let u of s) {
            try {
              await t(n)
            } catch (o) {
              if (o.message === 'socket closed') break
              throw o
            }
            n.send(u)
          }
          if (i.closeOnEnd && n.readyState <= 1)
            return new Promise((u, o) => {
              n.addEventListener('close', (l) => {
                if (l.wasClean || l.code === 1006) u()
                else {
                  let a = Object.assign(new Error('ws error'), { event: l })
                  o(a)
                }
              }),
                setTimeout(() => n.close())
            })
        }
      )
    }
  }),
  qR = te({
    'node_modules/it-ws/duplex.js'(e, r) {
      V(), F()
      var t = DR(),
        n = UR()
      r.exports = (i, s) => {
        ;(s = s || {}), s.binaryType ? (i.binaryType = s.binaryType) : s.binary && (i.binaryType = 'arraybuffer')
        let u = { sink: n(i, s), source: t(i, s), connected: () => u.source.connected() }
        return u
      }
    }
  }),
  Qv = te({
    'node_modules/iso-url/src/url-browser.js'(e, r) {
      V(), F()
      var t = typeof navigator != 'undefined' && navigator.product === 'ReactNative'
      function n() {
        return t ? 'http://localhost' : self.location.protocol + '//' + self.location.host
      }
      var i = self.URL,
        s = n(),
        u = class {
          constructor(l = '', a = s) {
            ;(this.super = new i(l, a)),
              (this.path = this.pathname + this.search),
              (this.auth = this.username && this.password ? this.username + ':' + this.password : null),
              (this.query = this.search && this.search.startsWith('?') ? this.search.slice(1) : null)
          }
          get hash() {
            return this.super.hash
          }
          get host() {
            return this.super.host
          }
          get hostname() {
            return this.super.hostname
          }
          get href() {
            return this.super.href
          }
          get origin() {
            return this.super.origin
          }
          get password() {
            return this.super.password
          }
          get pathname() {
            return this.super.pathname
          }
          get port() {
            return this.super.port
          }
          get protocol() {
            return this.super.protocol
          }
          get search() {
            return this.super.search
          }
          get searchParams() {
            return this.super.searchParams
          }
          get username() {
            return this.super.username
          }
          set hash(l) {
            this.super.hash = l
          }
          set host(l) {
            this.super.host = l
          }
          set hostname(l) {
            this.super.hostname = l
          }
          set href(l) {
            this.super.href = l
          }
          set password(l) {
            this.super.password = l
          }
          set pathname(l) {
            this.super.pathname = l
          }
          set port(l) {
            this.super.port = l
          }
          set protocol(l) {
            this.super.protocol = l
          }
          set search(l) {
            this.super.search = l
          }
          set username(l) {
            this.super.username = l
          }
          static createObjectURL(l) {
            return i.createObjectURL(l)
          }
          static revokeObjectURL(l) {
            i.revokeObjectURL(l)
          }
          toJSON() {
            return this.super.toJSON()
          }
          toString() {
            return this.super.toString()
          }
          format() {
            return this.toString()
          }
        }
      function o(l) {
        if (typeof l == 'string') return new i(l).toString()
        if (!(l instanceof i)) {
          let a = l.username && l.password ? `${l.username}:${l.password}@` : '',
            c = l.auth ? l.auth + '@' : '',
            f = l.port ? ':' + l.port : '',
            p = l.protocol ? l.protocol + '//' : '',
            y = l.host || '',
            d = l.hostname || '',
            h = l.search || (l.query ? '?' + l.query : ''),
            m = l.hash || '',
            _ = l.pathname || '',
            A = l.path || _ + h
          return `${p}${a || c}${y || d + f}${A}${m}`
        }
      }
      r.exports = { URLWithLegacySupport: u, URLSearchParams: self.URLSearchParams, defaultBase: s, format: o }
    }
  }),
  jR = te({
    'node_modules/iso-url/src/relative.js'(e, r) {
      V(), F()
      var { URLWithLegacySupport: t, format: n } = Qv()
      r.exports = (i, s = {}, u = {}, o) => {
        let l = s.protocol ? s.protocol.replace(':', '') : 'http'
        l = (u[l] || o || l) + ':'
        let a
        try {
          a = new t(i)
        } catch (f) {
          a = {}
        }
        let c = Object.assign({}, s, { protocol: l || a.protocol, host: s.host || a.host })
        return new t(i, n(c)).toString()
      }
    }
  }),
  zR = te({
    'node_modules/iso-url/index.js'(e, r) {
      V(), F()
      var { URLWithLegacySupport: t, format: n, URLSearchParams: i, defaultBase: s } = Qv(),
        u = jR()
      r.exports = { URL: t, URLSearchParams: i, format: n, relative: u, defaultBase: s }
    }
  }),
  KR = te({
    'node_modules/it-ws/ws-url.js'(e, r) {
      V(), F()
      var { relative: t } = zR(),
        n = { http: 'ws', https: 'wss' },
        i = 'ws'
      r.exports = (s, u) => t(s, u, n, i)
    }
  }),
  FR = te({
    'node_modules/it-ws/client.js'(e, r) {
      V(), F()
      var t = NR(),
        n = qR(),
        i = KR()
      ;(r.exports = function (s, u = {}) {
        let o = typeof window == 'undefined' ? {} : window.location,
          l = i(s, o),
          a = new t(l, u.websocket),
          c = n(a, u)
        return (
          (c.remoteAddress = l),
          (c.close = () =>
            new Promise((f, p) => {
              a.addEventListener('close', f), a.close()
            })),
          (c.destroy = () => {
            a.terminate ? a.terminate() : a.close()
          }),
          (c.socket = a),
          c
        )
      }),
        (r.exports.connect = r.exports)
    }
  }),
  l0 = te({
    'node_modules/class-is/index.js'(e, r) {
      V(), F()
      function t(i, { className: s, symbolName: u }) {
        let o = Symbol.for(u),
          l = {
            [s]: class extends i {
              constructor(...a) {
                super(...a)
                Object.defineProperty(this, o, { value: !0 })
              }
              get [Symbol.toStringTag]() {
                return s
              }
            }
          }[s]
        return (l[`is${s}`] = (a) => !!(a && a[o])), l
      }
      function n(i, { className: s, symbolName: u, withoutNew: o }) {
        let l = Symbol.for(u),
          a = {
            [s]: function (...c) {
              if (o && !(this instanceof a)) return new a(...c)
              let f = i.call(this, ...c) || this
              return f && !f[l] && Object.defineProperty(f, l, { value: !0 }), f
            }
          }[s]
        return (
          (a.prototype = Object.create(i.prototype)),
          (a.prototype.constructor = a),
          Object.defineProperty(a.prototype, Symbol.toStringTag, {
            get() {
              return s
            }
          }),
          (a[`is${s}`] = (c) => !!(c && c[l])),
          a
        )
      }
      ;(r.exports = t), (r.exports.proto = n)
    }
  }),
  eg = te({
    'node_modules/ip-regex/index.js'(e, r) {
      V(), F()
      var t = '[a-fA-F\\d:]',
        n = (f) => (f && f.includeBoundaries ? `(?:(?<=\\s|^)(?=${t})|(?<=${t})(?=\\s|$))` : ''),
        i = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}',
        s = '[a-fA-F\\d]{1,4}',
        u = `
(?:
(?:${s}:){7}(?:${s}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${s}:){6}(?:${i}|:${s}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${s}:){5}(?::${i}|(?::${s}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${s}:){4}(?:(?::${s}){0,1}:${i}|(?::${s}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${s}:){3}(?:(?::${s}){0,2}:${i}|(?::${s}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${s}:){2}(?:(?::${s}){0,3}:${i}|(?::${s}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${s}:){1}(?:(?::${s}){0,4}:${i}|(?::${s}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${s}){0,5}:${i}|(?::${s}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`
          .replace(/\s*\/\/.*$/gm, '')
          .replace(/\n/g, '')
          .trim(),
        o = new RegExp(`(?:^${i}$)|(?:^${u}$)`),
        l = new RegExp(`^${i}$`),
        a = new RegExp(`^${u}$`),
        c = (f) => (f && f.exact ? o : new RegExp(`(?:${n(f)}${i}${n(f)})|(?:${n(f)}${u}${n(f)})`, 'g'))
      ;(c.v4 = (f) => (f && f.exact ? l : new RegExp(`${n(f)}${i}${n(f)}`, 'g'))),
        (c.v6 = (f) => (f && f.exact ? a : new RegExp(`${n(f)}${u}${n(f)}`, 'g'))),
        (r.exports = c)
    }
  }),
  yo = te({
    'node_modules/is-ip/index.js'(e, r) {
      V(), F()
      var t = eg(),
        n = (i) => t({ exact: !0 }).test(i)
      ;(n.v4 = (i) => t.v4({ exact: !0 }).test(i)),
        (n.v6 = (i) => t.v6({ exact: !0 }).test(i)),
        (n.version = (i) => (n(i) ? (n.v4(i) ? 4 : 6) : void 0)),
        (r.exports = n)
    }
  })
function VR(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var tg,
  rg,
  ng,
  HR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (tg = VR), (rg = tg), (ng = rg)
    }
  }),
  ig = {}
Re(ig, {
  coerce: () => ls,
  empty: () => f0,
  equals: () => d0,
  fromHex: () => og,
  fromString: () => h0,
  isBinary: () => ag,
  toHex: () => sg,
  toString: () => p0
})
var f0,
  sg,
  og,
  d0,
  ls,
  ag,
  h0,
  p0,
  fs = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (f0 = new Uint8Array(0)),
        (sg = (e) => e.reduce((r, t) => r + t.toString(16).padStart(2, '0'), '')),
        (og = (e) => {
          let r = e.match(/../g)
          return r ? new Uint8Array(r.map((t) => parseInt(t, 16))) : f0
        }),
        (d0 = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (ls = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (ag = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e)),
        (h0 = (e) => new TextEncoder().encode(e)),
        (p0 = (e) => new TextDecoder().decode(e))
    }
  }),
  cg,
  ug,
  m0,
  lg,
  Dl,
  vo,
  fg,
  dg,
  ur,
  ei = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        HR(),
        fs(),
        (cg = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (ug = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new m0(r)
          }
        }),
        (m0 = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new m0({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (lg = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new cg(e, r, t)),
              (this.decoder = new ug(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (Dl = ({ name: e, prefix: r, encode: t, decode: n }) => new lg(e, r, t, n)),
        (vo = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = ng(t, r)
          return Dl({ prefix: e, name: r, encode: n, decode: (s) => ls(i(s)) })
        }),
        (fg = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (dg = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (ur = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          Dl({
            prefix: r,
            name: e,
            encode(i) {
              return dg(i, n, t)
            },
            decode(i) {
              return fg(i, n, t, e)
            }
          }))
    }
  }),
  hg = {}
Re(hg, { identity: () => pg })
var pg,
  $R = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), ei(), fs(), (pg = Dl({ prefix: '\0', name: 'identity', encode: (e) => p0(e), decode: (e) => h0(e) }))
    }
  }),
  mg = {}
Re(mg, { base2: () => bg })
var bg,
  GR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), ei(), (bg = ur({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  yg = {}
Re(yg, { base8: () => vg })
var vg,
  WR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), ei(), (vg = ur({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  gg = {}
Re(gg, { base10: () => wg })
var wg,
  JR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), ei(), (wg = vo({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  _g = {}
Re(_g, { base16: () => Eg, base16upper: () => Sg })
var Eg,
  Sg,
  XR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        ei(),
        (Eg = ur({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (Sg = ur({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  Ag = {}
Re(Ag, {
  base32: () => go,
  base32hex: () => kg,
  base32hexpad: () => xg,
  base32hexpadupper: () => Rg,
  base32hexupper: () => Mg,
  base32pad: () => Tg,
  base32padupper: () => Cg,
  base32upper: () => Ig,
  base32z: () => Bg
})
var go,
  Ig,
  Tg,
  Cg,
  kg,
  Mg,
  xg,
  Rg,
  Bg,
  Ng = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        ei(),
        (go = ur({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (Ig = ur({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (Tg = ur({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (Cg = ur({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (kg = ur({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        (Mg = ur({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (xg = ur({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (Rg = ur({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (Bg = ur({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  Pg = {}
Re(Pg, { base36: () => Og, base36upper: () => Dg })
var Og,
  Dg,
  YR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        ei(),
        (Og = vo({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (Dg = vo({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  Lg = {}
Re(Lg, { base58btc: () => Nn, base58flickr: () => Ug })
var Nn,
  Ug,
  qg = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        ei(),
        (Nn = vo({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (Ug = vo({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  jg = {}
Re(jg, { base64: () => zg, base64pad: () => Kg, base64url: () => Fg, base64urlpad: () => Vg })
var zg,
  Kg,
  Fg,
  Vg,
  ZR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        ei(),
        (zg = ur({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (Kg = ur({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (Fg = ur({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (Vg = ur({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function Hg(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= Jg; ) (r[t++] = (e & 255) | y0), (e /= 128)
  for (; e & Wg; ) (r[t++] = (e & 255) | y0), (e >>>= 7)
  return (r[t] = e | 0), (Hg.bytes = t - n + 1), r
}
function b0(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((b0.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & v0) << n : (s & v0) * Math.pow(2, n)), (n += 7)
  } while (s >= Yg)
  return (b0.bytes = i - r), t
}
var $g,
  y0,
  Gg,
  Wg,
  Jg,
  Xg,
  Yg,
  v0,
  Zg,
  Qg,
  e6,
  t6,
  r6,
  n6,
  i6,
  s6,
  o6,
  a6,
  c6,
  u6,
  ac,
  QR = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        ($g = Hg),
        (y0 = 128),
        (Gg = 127),
        (Wg = ~Gg),
        (Jg = Math.pow(2, 31)),
        (Xg = b0),
        (Yg = 128),
        (v0 = 127),
        (Zg = Math.pow(2, 7)),
        (Qg = Math.pow(2, 14)),
        (e6 = Math.pow(2, 21)),
        (t6 = Math.pow(2, 28)),
        (r6 = Math.pow(2, 35)),
        (n6 = Math.pow(2, 42)),
        (i6 = Math.pow(2, 49)),
        (s6 = Math.pow(2, 56)),
        (o6 = Math.pow(2, 63)),
        (a6 = function (e) {
          return e < Zg
            ? 1
            : e < Qg
            ? 2
            : e < e6
            ? 3
            : e < t6
            ? 4
            : e < r6
            ? 5
            : e < n6
            ? 6
            : e < i6
            ? 7
            : e < s6
            ? 8
            : e < o6
            ? 9
            : 10
        }),
        (c6 = { encode: $g, decode: Xg, encodingLength: a6 }),
        (u6 = c6),
        (ac = u6)
    }
  }),
  l6 = {}
Re(l6, { decode: () => cc, encodeTo: () => wo, encodingLength: () => _o })
var cc,
  wo,
  _o,
  g0 = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        QR(),
        (cc = (e) => [ac.decode(e), ac.decode.bytes]),
        (wo = (e, r, t = 0) => (ac.encode(e, r, t), r)),
        (_o = (e) => ac.encodingLength(e))
    }
  }),
  f6 = {}
Re(f6, { Digest: () => uc, create: () => Ll, decode: () => w0, equals: () => _0 })
var Ll,
  w0,
  _0,
  uc,
  E0 = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        fs(),
        g0(),
        (Ll = (e, r) => {
          let t = r.byteLength,
            n = _o(e),
            i = n + _o(t),
            s = new Uint8Array(i + t)
          return wo(e, s, 0), wo(t, s, n), s.set(r, i), new uc(e, t, r, s)
        }),
        (w0 = (e) => {
          let r = ls(e),
            [t, n] = cc(r),
            [i, s] = cc(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new uc(t, i, u, r)
        }),
        (_0 = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && d0(e.bytes, r.bytes))),
        (uc = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  d6 = {}
Re(d6, { Hasher: () => S0, from: () => lc })
var lc,
  S0,
  A0 = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        E0(),
        (lc = ({ name: e, code: r, encode: t }) => new S0(e, r, t)),
        (S0 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return Ll(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  h6 = {}
Re(h6, { sha256: () => p6, sha512: () => m6 })
var I0,
  p6,
  m6,
  eB = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        A0(),
        (I0 = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (p6 = lc({ name: 'sha2-256', code: 18, encode: I0('SHA-256') })),
        (m6 = lc({ name: 'sha2-512', code: 19, encode: I0('SHA-512') }))
    }
  }),
  b6 = {}
Re(b6, { identity: () => y6 })
var y6,
  tB = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), A0(), fs(), (y6 = lc({ name: 'identity', code: 0, encode: (e) => ls(e) }))
    }
  }),
  v6 = {}
Re(v6, { code: () => w6, decode: () => E6, encode: () => _6, name: () => g6 })
var T0,
  g6,
  w6,
  _6,
  E6,
  rB = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(),
        F(),
        fs(),
        (T0 = (e) => ls(e)),
        ({ name: g6, code: w6, encode: _6, decode: E6 } = { name: 'raw', code: 85, decode: T0, encode: T0 })
    }
  }),
  S6 = {}
Re(S6, { code: () => I6, decode: () => C6, encode: () => T6, name: () => A6 })
var A6,
  I6,
  T6,
  C6,
  nB = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(),
        F(),
        ({
          name: A6,
          code: I6,
          encode: T6,
          decode: C6
        } = {
          name: 'json',
          code: 512,
          encode: (e) => new TextEncoder().encode(JSON.stringify(e)),
          decode: (e) => JSON.parse(new TextDecoder().decode(e))
        })
    }
  }),
  kr,
  k6,
  M6,
  x6,
  Eo,
  R6,
  C0,
  k0,
  fc,
  dc,
  B6,
  N6,
  P6,
  iB = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        g0(),
        E0(),
        qg(),
        Ng(),
        fs(),
        (kr = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: dc,
                byteLength: dc,
                code: fc,
                version: fc,
                multihash: fc,
                bytes: fc,
                _baseCache: dc,
                asCID: dc
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== Eo) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== R6) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return kr.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = Ll(e, r)
                return kr.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && _0(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return M6(r, n, e || Nn.encoder)
              default:
                return x6(r, n, e || go.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return N6(/^0\.0/, P6), !!(e && (e[k0] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof kr) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new kr(r, t, n, i || C0(r, t, n.bytes))
            } else if (e != null && e[k0] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = w0(t)
              return kr.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== Eo) throw new Error(`Version 0 CID must use dag-pb (code: ${Eo}) block encoding`)
                return new kr(e, r, t, t.bytes)
              }
              case 1: {
                let n = C0(e, r, t.bytes)
                return new kr(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return kr.create(0, Eo, e)
          }
          static createV1(e, r) {
            return kr.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = kr.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = kr.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = ls(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new uc(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? kr.createV0(s) : kr.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = cc(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = Eo
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = k6(e, r),
              i = kr.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (k6 = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || Nn
              return [Nn.prefix, t.decode(`${Nn.prefix}${e}`)]
            }
            case Nn.prefix: {
              let t = r || Nn
              return [Nn.prefix, t.decode(e)]
            }
            case go.prefix: {
              let t = r || go
              return [go.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        (M6 = (e, r, t) => {
          let { prefix: n } = t
          if (n !== Nn.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (x6 = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (Eo = 112),
        (R6 = 18),
        (C0 = (e, r, t) => {
          let n = _o(e),
            i = n + _o(r),
            s = new Uint8Array(i + t.byteLength)
          return wo(e, s, 0), wo(r, s, n), s.set(t, i), s
        }),
        (k0 = Symbol.for('@ipld/js-cid/CID')),
        (fc = { writable: !1, configurable: !1, enumerable: !0 }),
        (dc = { writable: !1, enumerable: !1, configurable: !1 }),
        (B6 = '0.0.0-dev'),
        (N6 = (e, r) => {
          if (e.test(B6)) console.warn(r)
          else throw new Error(r)
        }),
        (P6 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  sB = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), iB(), g0(), fs(), A0(), E0()
    }
  }),
  O6 = {}
Re(O6, {
  CID: () => kr,
  bases: () => D6,
  bytes: () => ig,
  codecs: () => U6,
  digest: () => f6,
  hasher: () => d6,
  hashes: () => L6,
  varint: () => l6
})
var D6,
  L6,
  U6,
  oB = Ie({
    'node_modules/multiaddr-to-uri/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        $R(),
        GR(),
        WR(),
        JR(),
        XR(),
        Ng(),
        YR(),
        qg(),
        ZR(),
        eB(),
        tB(),
        rB(),
        nB(),
        sB(),
        (D6 = { ...hg, ...mg, ...yg, ...gg, ..._g, ...Ag, ...Pg, ...Lg, ...jg }),
        (L6 = { ...h6, ...b6 }),
        (U6 = { raw: v6, json: S6 })
    }
  }),
  q6 = te({
    'node_modules/multiaddr-to-uri/node_modules/uint8arrays/util/bases.js'(e, r) {
      V(), F()
      var { bases: t } = (oB(), O6)
      function n(o, l, a, c) {
        return { name: o, prefix: l, encoder: { name: o, prefix: l, encode: a }, decoder: { decode: c } }
      }
      var i = n(
          'utf8',
          'u',
          (o) => {
            let l = new TextDecoder('utf8')
            return 'u' + l.decode(o)
          },
          (o) => new TextEncoder().encode(o.substring(1))
        ),
        s = n(
          'ascii',
          'a',
          (o) => {
            let l = 'a'
            for (let a = 0; a < o.length; a++) l += String.fromCharCode(o[a])
            return l
          },
          (o) => {
            o = o.substring(1)
            let l = new Uint8Array(o.length)
            for (let a = 0; a < o.length; a++) l[a] = o.charCodeAt(a)
            return l
          }
        ),
        u = { utf8: i, 'utf-8': i, hex: t.base16, latin1: s, ascii: s, binary: s, ...t }
      r.exports = u
    }
  }),
  Ul = te({
    'node_modules/multiaddr-to-uri/node_modules/uint8arrays/to-string.js'(e, r) {
      V(), F()
      var t = q6()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.encoder.encode(i).substring(1)
      }
      r.exports = n
    }
  }),
  aB = te({
    'node_modules/multiaddr-to-uri/node_modules/multiaddr/src/ip.js'(e, r) {
      V(), F()
      var t = yo(),
        n = Ul(),
        i = t,
        s = t.v4,
        u = t.v6,
        o = function (a, c, f) {
          f = ~~f
          let p
          if (s(a))
            (p = c || new Uint8Array(f + 4)),
              a.split(/\./g).map(function (d) {
                p[f++] = parseInt(d, 10) & 255
              })
          else if (u(a)) {
            let d = a.split(':', 8),
              h
            for (h = 0; h < d.length; h++) {
              let m = s(d[h])
              var y
              m && ((y = o(d[h])), (d[h] = n(y.slice(0, 2), 'base16'))),
                y && ++h < 8 && d.splice(h, 0, n(y.slice(2, 4), 'base16'))
            }
            if (d[0] === '') for (; d.length < 8; ) d.unshift('0')
            else if (d[d.length - 1] === '') for (; d.length < 8; ) d.push('0')
            else if (d.length < 8) {
              for (h = 0; h < d.length && d[h] !== ''; h++);
              let m = [h, '1']
              for (h = 9 - d.length; h > 0; h--) m.push('0')
              d.splice.apply(d, m)
            }
            for (p = c || new Uint8Array(f + 16), h = 0; h < d.length; h++) {
              let m = parseInt(d[h], 16)
              ;(p[f++] = (m >> 8) & 255), (p[f++] = m & 255)
            }
          }
          if (!p) throw Error('Invalid ip address: ' + a)
          return p
        },
        l = function (a, c, f) {
          ;(c = ~~c), (f = f || a.length - c)
          let p = [],
            y,
            d = new DataView(a.buffer)
          if (f === 4) {
            for (let h = 0; h < f; h++) p.push(a[c + h])
            y = p.join('.')
          } else if (f === 16) {
            for (let h = 0; h < f; h += 2) p.push(d.getUint16(c + h).toString(16))
            ;(y = p.join(':')), (y = y.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')), (y = y.replace(/:{3,4}/, '::'))
          }
          return y
        }
      r.exports = { isIP: i, isV4: s, isV6: u, toBytes: o, toString: l }
    }
  }),
  M0 = te({
    'node_modules/multiaddr-to-uri/node_modules/multiaddr/src/protocols-table.js'(e, r) {
      V(), F()
      function t(s) {
        if (typeof s == 'number') {
          if (t.codes[s]) return t.codes[s]
          throw new Error('no protocol with code: ' + s)
        } else if (typeof s == 'string') {
          if (t.names[s]) return t.names[s]
          throw new Error('no protocol with name: ' + s)
        }
        throw new Error('invalid protocol id type: ' + s)
      }
      var n = -1
      ;(t.lengthPrefixedVarSize = n),
        (t.V = n),
        (t.table = [
          [4, 32, 'ip4'],
          [6, 16, 'tcp'],
          [33, 16, 'dccp'],
          [41, 128, 'ip6'],
          [42, n, 'ip6zone'],
          [53, n, 'dns', 'resolvable'],
          [54, n, 'dns4', 'resolvable'],
          [55, n, 'dns6', 'resolvable'],
          [56, n, 'dnsaddr', 'resolvable'],
          [132, 16, 'sctp'],
          [273, 16, 'udp'],
          [275, 0, 'p2p-webrtc-star'],
          [276, 0, 'p2p-webrtc-direct'],
          [277, 0, 'p2p-stardust'],
          [290, 0, 'p2p-circuit'],
          [301, 0, 'udt'],
          [302, 0, 'utp'],
          [400, n, 'unix', !1, 'path'],
          [421, n, 'ipfs'],
          [421, n, 'p2p'],
          [443, 0, 'https'],
          [444, 96, 'onion'],
          [445, 296, 'onion3'],
          [446, n, 'garlic64'],
          [460, 0, 'quic'],
          [477, 0, 'ws'],
          [478, 0, 'wss'],
          [479, 0, 'p2p-websocket-star'],
          [480, 0, 'http'],
          [777, n, 'memory']
        ]),
        (t.names = {}),
        (t.codes = {}),
        t.table.map((s) => {
          let u = i.apply(null, s)
          return (t.codes[u.code] = u), (t.names[u.name] = u), null
        }),
        (t.object = i)
      function i(s, u, o, l, a) {
        return { code: s, size: u, name: o, resolvable: Boolean(l), path: Boolean(a) }
      }
      r.exports = t
    }
  }),
  cB = te({
    'node_modules/@multiformats/base-x/src/index.js'(e, r) {
      V(), F()
      function t(n) {
        if (n.length >= 255) throw new TypeError('Alphabet too long')
        for (var i = new Uint8Array(256), s = 0; s < i.length; s++) i[s] = 255
        for (var u = 0; u < n.length; u++) {
          var o = n.charAt(u),
            l = o.charCodeAt(0)
          if (i[l] !== 255) throw new TypeError(o + ' is ambiguous')
          i[l] = u
        }
        var a = n.length,
          c = n.charAt(0),
          f = Math.log(a) / Math.log(256),
          p = Math.log(256) / Math.log(a)
        function y(m) {
          if (
            (m instanceof Uint8Array ||
              (ArrayBuffer.isView(m)
                ? (m = new Uint8Array(m.buffer, m.byteOffset, m.byteLength))
                : Array.isArray(m) && (m = Uint8Array.from(m))),
            !(m instanceof Uint8Array))
          )
            throw new TypeError('Expected Uint8Array')
          if (m.length === 0) return ''
          for (var _ = 0, A = 0, T = 0, E = m.length; T !== E && m[T] === 0; ) T++, _++
          for (var k = ((E - T) * p + 1) >>> 0, w = new Uint8Array(k); T !== E; ) {
            for (var v = m[T], I = 0, M = k - 1; (v !== 0 || I < A) && M !== -1; M--, I++)
              (v += (256 * w[M]) >>> 0), (w[M] = v % a >>> 0), (v = (v / a) >>> 0)
            if (v !== 0) throw new Error('Non-zero carry')
            ;(A = I), T++
          }
          for (var q = k - A; q !== k && w[q] === 0; ) q++
          for (var G = c.repeat(_); q < k; ++q) G += n.charAt(w[q])
          return G
        }
        function d(m) {
          if (typeof m != 'string') throw new TypeError('Expected String')
          if (m.length === 0) return new Uint8Array()
          var _ = 0
          if (m[_] !== ' ') {
            for (var A = 0, T = 0; m[_] === c; ) A++, _++
            for (var E = ((m.length - _) * f + 1) >>> 0, k = new Uint8Array(E); m[_]; ) {
              var w = i[m.charCodeAt(_)]
              if (w === 255) return
              for (var v = 0, I = E - 1; (w !== 0 || v < T) && I !== -1; I--, v++)
                (w += (a * k[I]) >>> 0), (k[I] = w % 256 >>> 0), (w = (w / 256) >>> 0)
              if (w !== 0) throw new Error('Non-zero carry')
              ;(T = v), _++
            }
            if (m[_] !== ' ') {
              for (var M = E - T; M !== E && k[M] === 0; ) M++
              for (var q = new Uint8Array(A + (E - M)), G = A; M !== E; ) q[G++] = k[M++]
              return q
            }
          }
        }
        function h(m) {
          var _ = d(m)
          if (_) return _
          throw new Error('Non-base' + a + ' character')
        }
        return { encode: y, decodeUnsafe: d, decode: h }
      }
      r.exports = t
    }
  }),
  x0 = te({
    'node_modules/multibase/src/util.js'(e, r) {
      V(), F()
      var t = new TextDecoder(),
        n = (o) => t.decode(o),
        i = new TextEncoder(),
        s = (o) => i.encode(o)
      function u(o, l) {
        let a = new Uint8Array(l),
          c = 0
        for (let f of o) a.set(f, c), (c += f.length)
        return a
      }
      r.exports = { decodeText: n, encodeText: s, concat: u }
    }
  }),
  uB = te({
    'node_modules/multibase/src/base.js'(e, r) {
      V(), F()
      var { encodeText: t } = x0(),
        n = class {
          constructor(i, s, u, o) {
            ;(this.name = i), (this.code = s), (this.codeBuf = t(this.code)), (this.alphabet = o), (this.codec = u(o))
          }
          encode(i) {
            return this.codec.encode(i)
          }
          decode(i) {
            for (let s of i)
              if (this.alphabet && this.alphabet.indexOf(s) < 0) throw new Error(`invalid character '${s}' in '${i}'`)
            return this.codec.decode(i)
          }
        }
      r.exports = n
    }
  }),
  lB = te({
    'node_modules/multibase/src/rfc4648.js'(e, r) {
      V(), F()
      var t = (s, u, o) => {
          let l = {}
          for (let d = 0; d < u.length; ++d) l[u[d]] = d
          let a = s.length
          for (; s[a - 1] === '='; ) --a
          let c = new Uint8Array(((a * o) / 8) | 0),
            f = 0,
            p = 0,
            y = 0
          for (let d = 0; d < a; ++d) {
            let h = l[s[d]]
            if (h === void 0) throw new SyntaxError('Invalid character ' + s[d])
            ;(p = (p << o) | h), (f += o), f >= 8 && ((f -= 8), (c[y++] = 255 & (p >> f)))
          }
          if (f >= o || 255 & (p << (8 - f))) throw new SyntaxError('Unexpected end of data')
          return c
        },
        n = (s, u, o) => {
          let l = u[u.length - 1] === '=',
            a = (1 << o) - 1,
            c = '',
            f = 0,
            p = 0
          for (let y = 0; y < s.length; ++y) for (p = (p << 8) | s[y], f += 8; f > o; ) (f -= o), (c += u[a & (p >> f)])
          if ((f && (c += u[a & (p << (o - f))]), l)) for (; (c.length * o) & 7; ) c += '='
          return c
        },
        i = (s) => (u) => ({
          encode(o) {
            return n(o, u, s)
          },
          decode(o) {
            return t(o, u, s)
          }
        })
      r.exports = { rfc4648: i }
    }
  }),
  fB = te({
    'node_modules/multibase/src/constants.js'(e, r) {
      V(), F()
      var t = cB(),
        n = uB(),
        { rfc4648: i } = lB(),
        { decodeText: s, encodeText: u } = x0(),
        o = () => ({ encode: s, decode: u }),
        l = [
          ['identity', '\0', o, ''],
          ['base2', '0', i(1), '01'],
          ['base8', '7', i(3), '01234567'],
          ['base10', '9', t, '0123456789'],
          ['base16', 'f', i(4), '0123456789abcdef'],
          ['base16upper', 'F', i(4), '0123456789ABCDEF'],
          ['base32hex', 'v', i(5), '0123456789abcdefghijklmnopqrstuv'],
          ['base32hexupper', 'V', i(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
          ['base32hexpad', 't', i(5), '0123456789abcdefghijklmnopqrstuv='],
          ['base32hexpadupper', 'T', i(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
          ['base32', 'b', i(5), 'abcdefghijklmnopqrstuvwxyz234567'],
          ['base32upper', 'B', i(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
          ['base32pad', 'c', i(5), 'abcdefghijklmnopqrstuvwxyz234567='],
          ['base32padupper', 'C', i(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
          ['base32z', 'h', i(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
          ['base36', 'k', t, '0123456789abcdefghijklmnopqrstuvwxyz'],
          ['base36upper', 'K', t, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
          ['base58btc', 'z', t, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
          ['base58flickr', 'Z', t, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
          ['base64', 'm', i(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
          ['base64pad', 'M', i(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
          ['base64url', 'u', i(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
          ['base64urlpad', 'U', i(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
        ],
        a = l.reduce((f, p) => ((f[p[0]] = new n(p[0], p[1], p[2], p[3])), f), {}),
        c = l.reduce((f, p) => ((f[p[1]] = a[p[0]]), f), {})
      r.exports = { names: a, codes: c }
    }
  }),
  Di = te({
    'node_modules/multibase/src/index.js'(e, r) {
      V(), F()
      var t = fB(),
        { encodeText: n, decodeText: i, concat: s } = x0()
      function u(h, m) {
        if (!m) throw new Error('requires an encoded Uint8Array')
        let { name: _, codeBuf: A } = f(h)
        return c(_, m), s([A, m], A.length + m.length)
      }
      function o(h, m) {
        let _ = f(h),
          A = n(_.encode(m))
        return s([_.codeBuf, A], _.codeBuf.length + A.length)
      }
      function l(h) {
        h instanceof Uint8Array && (h = i(h))
        let m = h[0]
        return (
          ['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(m) && (h = h.toLowerCase()),
          f(h[0]).decode(h.substring(1))
        )
      }
      function a(h) {
        if ((h instanceof Uint8Array && (h = i(h)), Object.prototype.toString.call(h) !== '[object String]')) return !1
        try {
          return f(h[0]).name
        } catch (m) {
          return !1
        }
      }
      function c(h, m) {
        f(h).decode(i(m))
      }
      function f(h) {
        if (Object.prototype.hasOwnProperty.call(t.names, h)) return t.names[h]
        if (Object.prototype.hasOwnProperty.call(t.codes, h)) return t.codes[h]
        throw new Error(`Unsupported encoding: ${h}`)
      }
      function p(h) {
        return h instanceof Uint8Array && (h = i(h)), f(h[0])
      }
      ;(e = r.exports = u),
        (e.encode = o),
        (e.decode = l),
        (e.isEncoded = a),
        (e.encoding = f),
        (e.encodingFromData = p)
      var y = Object.freeze(t.names),
        d = Object.freeze(t.codes)
      ;(e.names = y), (e.codes = d)
    }
  }),
  dB = te({
    'node_modules/multihashes/node_modules/varint/encode.js'(e, r) {
      V(), F(), (r.exports = u)
      var t = 128,
        n = 127,
        i = ~n,
        s = Math.pow(2, 31)
      function u(o, l, a) {
        ;(l = l || []), (a = a || 0)
        for (var c = a; o >= s; ) (l[a++] = (o & 255) | t), (o /= 128)
        for (; o & i; ) (l[a++] = (o & 255) | t), (o >>>= 7)
        return (l[a] = o | 0), (u.bytes = a - c + 1), l
      }
    }
  }),
  hB = te({
    'node_modules/multihashes/node_modules/varint/decode.js'(e, r) {
      V(), F(), (r.exports = i)
      var t = 128,
        n = 127
      function i(s, u) {
        var o = 0,
          u = u || 0,
          l = 0,
          a = u,
          c,
          f = s.length
        do {
          if (a >= f) throw ((i.bytes = 0), new RangeError('Could not decode varint'))
          ;(c = s[a++]), (o += l < 28 ? (c & n) << l : (c & n) * Math.pow(2, l)), (l += 7)
        } while (c >= t)
        return (i.bytes = a - u), o
      }
    }
  }),
  pB = te({
    'node_modules/multihashes/node_modules/varint/length.js'(e, r) {
      V(), F()
      var t = Math.pow(2, 7),
        n = Math.pow(2, 14),
        i = Math.pow(2, 21),
        s = Math.pow(2, 28),
        u = Math.pow(2, 35),
        o = Math.pow(2, 42),
        l = Math.pow(2, 49),
        a = Math.pow(2, 56),
        c = Math.pow(2, 63)
      r.exports = function (f) {
        return f < t
          ? 1
          : f < n
          ? 2
          : f < i
          ? 3
          : f < s
          ? 4
          : f < u
          ? 5
          : f < o
          ? 6
          : f < l
          ? 7
          : f < a
          ? 8
          : f < c
          ? 9
          : 10
      }
    }
  }),
  mB = te({
    'node_modules/multihashes/node_modules/varint/index.js'(e, r) {
      V(), F(), (r.exports = { encode: dB(), decode: hB(), encodingLength: pB() })
    }
  }),
  bB = te({
    'node_modules/multihashes/src/constants.js'(e, r) {
      V(), F()
      var t = Object.freeze({
        identity: 0,
        sha1: 17,
        'sha2-256': 18,
        'sha2-512': 19,
        'sha3-512': 20,
        'sha3-384': 21,
        'sha3-256': 22,
        'sha3-224': 23,
        'shake-128': 24,
        'shake-256': 25,
        'keccak-224': 26,
        'keccak-256': 27,
        'keccak-384': 28,
        'keccak-512': 29,
        blake3: 30,
        'murmur3-128': 34,
        'murmur3-32': 35,
        'dbl-sha2-256': 86,
        md4: 212,
        md5: 213,
        bmt: 214,
        'sha2-256-trunc254-padded': 4114,
        'ripemd-128': 4178,
        'ripemd-160': 4179,
        'ripemd-256': 4180,
        'ripemd-320': 4181,
        x11: 4352,
        kangarootwelve: 7425,
        'sm3-256': 21325,
        'blake2b-8': 45569,
        'blake2b-16': 45570,
        'blake2b-24': 45571,
        'blake2b-32': 45572,
        'blake2b-40': 45573,
        'blake2b-48': 45574,
        'blake2b-56': 45575,
        'blake2b-64': 45576,
        'blake2b-72': 45577,
        'blake2b-80': 45578,
        'blake2b-88': 45579,
        'blake2b-96': 45580,
        'blake2b-104': 45581,
        'blake2b-112': 45582,
        'blake2b-120': 45583,
        'blake2b-128': 45584,
        'blake2b-136': 45585,
        'blake2b-144': 45586,
        'blake2b-152': 45587,
        'blake2b-160': 45588,
        'blake2b-168': 45589,
        'blake2b-176': 45590,
        'blake2b-184': 45591,
        'blake2b-192': 45592,
        'blake2b-200': 45593,
        'blake2b-208': 45594,
        'blake2b-216': 45595,
        'blake2b-224': 45596,
        'blake2b-232': 45597,
        'blake2b-240': 45598,
        'blake2b-248': 45599,
        'blake2b-256': 45600,
        'blake2b-264': 45601,
        'blake2b-272': 45602,
        'blake2b-280': 45603,
        'blake2b-288': 45604,
        'blake2b-296': 45605,
        'blake2b-304': 45606,
        'blake2b-312': 45607,
        'blake2b-320': 45608,
        'blake2b-328': 45609,
        'blake2b-336': 45610,
        'blake2b-344': 45611,
        'blake2b-352': 45612,
        'blake2b-360': 45613,
        'blake2b-368': 45614,
        'blake2b-376': 45615,
        'blake2b-384': 45616,
        'blake2b-392': 45617,
        'blake2b-400': 45618,
        'blake2b-408': 45619,
        'blake2b-416': 45620,
        'blake2b-424': 45621,
        'blake2b-432': 45622,
        'blake2b-440': 45623,
        'blake2b-448': 45624,
        'blake2b-456': 45625,
        'blake2b-464': 45626,
        'blake2b-472': 45627,
        'blake2b-480': 45628,
        'blake2b-488': 45629,
        'blake2b-496': 45630,
        'blake2b-504': 45631,
        'blake2b-512': 45632,
        'blake2s-8': 45633,
        'blake2s-16': 45634,
        'blake2s-24': 45635,
        'blake2s-32': 45636,
        'blake2s-40': 45637,
        'blake2s-48': 45638,
        'blake2s-56': 45639,
        'blake2s-64': 45640,
        'blake2s-72': 45641,
        'blake2s-80': 45642,
        'blake2s-88': 45643,
        'blake2s-96': 45644,
        'blake2s-104': 45645,
        'blake2s-112': 45646,
        'blake2s-120': 45647,
        'blake2s-128': 45648,
        'blake2s-136': 45649,
        'blake2s-144': 45650,
        'blake2s-152': 45651,
        'blake2s-160': 45652,
        'blake2s-168': 45653,
        'blake2s-176': 45654,
        'blake2s-184': 45655,
        'blake2s-192': 45656,
        'blake2s-200': 45657,
        'blake2s-208': 45658,
        'blake2s-216': 45659,
        'blake2s-224': 45660,
        'blake2s-232': 45661,
        'blake2s-240': 45662,
        'blake2s-248': 45663,
        'blake2s-256': 45664,
        'skein256-8': 45825,
        'skein256-16': 45826,
        'skein256-24': 45827,
        'skein256-32': 45828,
        'skein256-40': 45829,
        'skein256-48': 45830,
        'skein256-56': 45831,
        'skein256-64': 45832,
        'skein256-72': 45833,
        'skein256-80': 45834,
        'skein256-88': 45835,
        'skein256-96': 45836,
        'skein256-104': 45837,
        'skein256-112': 45838,
        'skein256-120': 45839,
        'skein256-128': 45840,
        'skein256-136': 45841,
        'skein256-144': 45842,
        'skein256-152': 45843,
        'skein256-160': 45844,
        'skein256-168': 45845,
        'skein256-176': 45846,
        'skein256-184': 45847,
        'skein256-192': 45848,
        'skein256-200': 45849,
        'skein256-208': 45850,
        'skein256-216': 45851,
        'skein256-224': 45852,
        'skein256-232': 45853,
        'skein256-240': 45854,
        'skein256-248': 45855,
        'skein256-256': 45856,
        'skein512-8': 45857,
        'skein512-16': 45858,
        'skein512-24': 45859,
        'skein512-32': 45860,
        'skein512-40': 45861,
        'skein512-48': 45862,
        'skein512-56': 45863,
        'skein512-64': 45864,
        'skein512-72': 45865,
        'skein512-80': 45866,
        'skein512-88': 45867,
        'skein512-96': 45868,
        'skein512-104': 45869,
        'skein512-112': 45870,
        'skein512-120': 45871,
        'skein512-128': 45872,
        'skein512-136': 45873,
        'skein512-144': 45874,
        'skein512-152': 45875,
        'skein512-160': 45876,
        'skein512-168': 45877,
        'skein512-176': 45878,
        'skein512-184': 45879,
        'skein512-192': 45880,
        'skein512-200': 45881,
        'skein512-208': 45882,
        'skein512-216': 45883,
        'skein512-224': 45884,
        'skein512-232': 45885,
        'skein512-240': 45886,
        'skein512-248': 45887,
        'skein512-256': 45888,
        'skein512-264': 45889,
        'skein512-272': 45890,
        'skein512-280': 45891,
        'skein512-288': 45892,
        'skein512-296': 45893,
        'skein512-304': 45894,
        'skein512-312': 45895,
        'skein512-320': 45896,
        'skein512-328': 45897,
        'skein512-336': 45898,
        'skein512-344': 45899,
        'skein512-352': 45900,
        'skein512-360': 45901,
        'skein512-368': 45902,
        'skein512-376': 45903,
        'skein512-384': 45904,
        'skein512-392': 45905,
        'skein512-400': 45906,
        'skein512-408': 45907,
        'skein512-416': 45908,
        'skein512-424': 45909,
        'skein512-432': 45910,
        'skein512-440': 45911,
        'skein512-448': 45912,
        'skein512-456': 45913,
        'skein512-464': 45914,
        'skein512-472': 45915,
        'skein512-480': 45916,
        'skein512-488': 45917,
        'skein512-496': 45918,
        'skein512-504': 45919,
        'skein512-512': 45920,
        'skein1024-8': 45921,
        'skein1024-16': 45922,
        'skein1024-24': 45923,
        'skein1024-32': 45924,
        'skein1024-40': 45925,
        'skein1024-48': 45926,
        'skein1024-56': 45927,
        'skein1024-64': 45928,
        'skein1024-72': 45929,
        'skein1024-80': 45930,
        'skein1024-88': 45931,
        'skein1024-96': 45932,
        'skein1024-104': 45933,
        'skein1024-112': 45934,
        'skein1024-120': 45935,
        'skein1024-128': 45936,
        'skein1024-136': 45937,
        'skein1024-144': 45938,
        'skein1024-152': 45939,
        'skein1024-160': 45940,
        'skein1024-168': 45941,
        'skein1024-176': 45942,
        'skein1024-184': 45943,
        'skein1024-192': 45944,
        'skein1024-200': 45945,
        'skein1024-208': 45946,
        'skein1024-216': 45947,
        'skein1024-224': 45948,
        'skein1024-232': 45949,
        'skein1024-240': 45950,
        'skein1024-248': 45951,
        'skein1024-256': 45952,
        'skein1024-264': 45953,
        'skein1024-272': 45954,
        'skein1024-280': 45955,
        'skein1024-288': 45956,
        'skein1024-296': 45957,
        'skein1024-304': 45958,
        'skein1024-312': 45959,
        'skein1024-320': 45960,
        'skein1024-328': 45961,
        'skein1024-336': 45962,
        'skein1024-344': 45963,
        'skein1024-352': 45964,
        'skein1024-360': 45965,
        'skein1024-368': 45966,
        'skein1024-376': 45967,
        'skein1024-384': 45968,
        'skein1024-392': 45969,
        'skein1024-400': 45970,
        'skein1024-408': 45971,
        'skein1024-416': 45972,
        'skein1024-424': 45973,
        'skein1024-432': 45974,
        'skein1024-440': 45975,
        'skein1024-448': 45976,
        'skein1024-456': 45977,
        'skein1024-464': 45978,
        'skein1024-472': 45979,
        'skein1024-480': 45980,
        'skein1024-488': 45981,
        'skein1024-496': 45982,
        'skein1024-504': 45983,
        'skein1024-512': 45984,
        'skein1024-520': 45985,
        'skein1024-528': 45986,
        'skein1024-536': 45987,
        'skein1024-544': 45988,
        'skein1024-552': 45989,
        'skein1024-560': 45990,
        'skein1024-568': 45991,
        'skein1024-576': 45992,
        'skein1024-584': 45993,
        'skein1024-592': 45994,
        'skein1024-600': 45995,
        'skein1024-608': 45996,
        'skein1024-616': 45997,
        'skein1024-624': 45998,
        'skein1024-632': 45999,
        'skein1024-640': 46e3,
        'skein1024-648': 46001,
        'skein1024-656': 46002,
        'skein1024-664': 46003,
        'skein1024-672': 46004,
        'skein1024-680': 46005,
        'skein1024-688': 46006,
        'skein1024-696': 46007,
        'skein1024-704': 46008,
        'skein1024-712': 46009,
        'skein1024-720': 46010,
        'skein1024-728': 46011,
        'skein1024-736': 46012,
        'skein1024-744': 46013,
        'skein1024-752': 46014,
        'skein1024-760': 46015,
        'skein1024-768': 46016,
        'skein1024-776': 46017,
        'skein1024-784': 46018,
        'skein1024-792': 46019,
        'skein1024-800': 46020,
        'skein1024-808': 46021,
        'skein1024-816': 46022,
        'skein1024-824': 46023,
        'skein1024-832': 46024,
        'skein1024-840': 46025,
        'skein1024-848': 46026,
        'skein1024-856': 46027,
        'skein1024-864': 46028,
        'skein1024-872': 46029,
        'skein1024-880': 46030,
        'skein1024-888': 46031,
        'skein1024-896': 46032,
        'skein1024-904': 46033,
        'skein1024-912': 46034,
        'skein1024-920': 46035,
        'skein1024-928': 46036,
        'skein1024-936': 46037,
        'skein1024-944': 46038,
        'skein1024-952': 46039,
        'skein1024-960': 46040,
        'skein1024-968': 46041,
        'skein1024-976': 46042,
        'skein1024-984': 46043,
        'skein1024-992': 46044,
        'skein1024-1000': 46045,
        'skein1024-1008': 46046,
        'skein1024-1016': 46047,
        'skein1024-1024': 46048,
        'poseidon-bls12_381-a2-fc1': 46081,
        'poseidon-bls12_381-a2-fc1-sc': 46082
      })
      r.exports = { names: t }
    }
  })
function yB(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var j6,
  z6,
  K6,
  vB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (j6 = yB), (z6 = j6), (K6 = z6)
    }
  }),
  gB,
  F6,
  hc,
  V6,
  H6,
  ds = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (gB = new Uint8Array(0)),
        (F6 = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (hc = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (V6 = (e) => new TextEncoder().encode(e)),
        (H6 = (e) => new TextDecoder().decode(e))
    }
  }),
  $6,
  G6,
  R0,
  W6,
  ql,
  So,
  J6,
  X6,
  lr,
  ti = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        vB(),
        ds(),
        ($6 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (G6 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new R0(r)
          }
        }),
        (R0 = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new R0({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (W6 = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new $6(e, r, t)),
              (this.decoder = new G6(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (ql = ({ name: e, prefix: r, encode: t, decode: n }) => new W6(e, r, t, n)),
        (So = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = K6(t, r)
          return ql({ prefix: e, name: r, encode: n, decode: (s) => hc(i(s)) })
        }),
        (J6 = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (X6 = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (lr = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          ql({
            prefix: r,
            name: e,
            encode(i) {
              return X6(i, n, t)
            },
            decode(i) {
              return J6(i, n, t, e)
            }
          }))
    }
  }),
  Y6 = {}
Re(Y6, { identity: () => Z6 })
var Z6,
  wB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), ti(), ds(), (Z6 = ql({ prefix: '\0', name: 'identity', encode: (e) => H6(e), decode: (e) => V6(e) }))
    }
  }),
  Q6 = {}
Re(Q6, { base2: () => e4 })
var e4,
  _B = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), ti(), (e4 = lr({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  t4 = {}
Re(t4, { base8: () => r4 })
var r4,
  EB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), ti(), (r4 = lr({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  n4 = {}
Re(n4, { base10: () => i4 })
var i4,
  SB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), ti(), (i4 = So({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  s4 = {}
Re(s4, { base16: () => o4, base16upper: () => a4 })
var o4,
  a4,
  AB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        ti(),
        (o4 = lr({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (a4 = lr({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  c4 = {}
Re(c4, {
  base32: () => Ao,
  base32hex: () => d4,
  base32hexpad: () => p4,
  base32hexpadupper: () => m4,
  base32hexupper: () => h4,
  base32pad: () => l4,
  base32padupper: () => f4,
  base32upper: () => u4,
  base32z: () => b4
})
var Ao,
  u4,
  l4,
  f4,
  d4,
  h4,
  p4,
  m4,
  b4,
  y4 = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        ti(),
        (Ao = lr({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (u4 = lr({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (l4 = lr({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (f4 = lr({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (d4 = lr({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        (h4 = lr({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (p4 = lr({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (m4 = lr({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (b4 = lr({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  v4 = {}
Re(v4, { base36: () => g4, base36upper: () => w4 })
var g4,
  w4,
  IB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        ti(),
        (g4 = So({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (w4 = So({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  _4 = {}
Re(_4, { base58btc: () => Pn, base58flickr: () => E4 })
var Pn,
  E4,
  S4 = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        ti(),
        (Pn = So({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (E4 = So({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  A4 = {}
Re(A4, { base64: () => I4, base64pad: () => T4, base64url: () => C4, base64urlpad: () => k4 })
var I4,
  T4,
  C4,
  k4,
  TB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        ti(),
        (I4 = lr({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (T4 = lr({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (C4 = lr({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (k4 = lr({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function M4(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= N4; ) (r[t++] = (e & 255) | N0), (e /= 128)
  for (; e & B4; ) (r[t++] = (e & 255) | N0), (e >>>= 7)
  return (r[t] = e | 0), (M4.bytes = t - n + 1), r
}
function B0(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((B0.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & P0) << n : (s & P0) * Math.pow(2, n)), (n += 7)
  } while (s >= O4)
  return (B0.bytes = i - r), t
}
var x4,
  N0,
  R4,
  B4,
  N4,
  P4,
  O4,
  P0,
  D4,
  L4,
  U4,
  q4,
  j4,
  z4,
  K4,
  F4,
  V4,
  H4,
  $4,
  G4,
  pc,
  CB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        (x4 = M4),
        (N0 = 128),
        (R4 = 127),
        (B4 = ~R4),
        (N4 = Math.pow(2, 31)),
        (P4 = B0),
        (O4 = 128),
        (P0 = 127),
        (D4 = Math.pow(2, 7)),
        (L4 = Math.pow(2, 14)),
        (U4 = Math.pow(2, 21)),
        (q4 = Math.pow(2, 28)),
        (j4 = Math.pow(2, 35)),
        (z4 = Math.pow(2, 42)),
        (K4 = Math.pow(2, 49)),
        (F4 = Math.pow(2, 56)),
        (V4 = Math.pow(2, 63)),
        (H4 = function (e) {
          return e < D4
            ? 1
            : e < L4
            ? 2
            : e < U4
            ? 3
            : e < q4
            ? 4
            : e < j4
            ? 5
            : e < z4
            ? 6
            : e < K4
            ? 7
            : e < F4
            ? 8
            : e < V4
            ? 9
            : 10
        }),
        ($4 = { encode: x4, decode: P4, encodingLength: H4 }),
        (G4 = $4),
        (pc = G4)
    }
  }),
  jl,
  mc,
  bc,
  O0 = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        CB(),
        (jl = (e) => [pc.decode(e), pc.decode.bytes]),
        (mc = (e, r, t = 0) => (pc.encode(e, r, t), r)),
        (bc = (e) => pc.encodingLength(e))
    }
  }),
  D0,
  W4,
  J4,
  zl,
  L0 = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        ds(),
        O0(),
        (D0 = (e, r) => {
          let t = r.byteLength,
            n = bc(e),
            i = n + bc(t),
            s = new Uint8Array(i + t)
          return mc(e, s, 0), mc(t, s, n), s.set(r, i), new zl(e, t, r, s)
        }),
        (W4 = (e) => {
          let r = hc(e),
            [t, n] = jl(r),
            [i, s] = jl(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new zl(t, i, u, r)
        }),
        (J4 = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && F6(e.bytes, r.bytes))),
        (zl = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  Kl,
  X4,
  U0 = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        L0(),
        (Kl = ({ name: e, code: r, encode: t }) => new X4(e, r, t)),
        (X4 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return D0(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  Y4 = {}
Re(Y4, { sha256: () => Z4, sha512: () => Q4 })
var q0,
  Z4,
  Q4,
  kB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        U0(),
        (q0 = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (Z4 = Kl({ name: 'sha2-256', code: 18, encode: q0('SHA-256') })),
        (Q4 = Kl({ name: 'sha2-512', code: 19, encode: q0('SHA-512') }))
    }
  }),
  e3 = {}
Re(e3, { identity: () => t3 })
var t3,
  MB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), U0(), ds(), (t3 = Kl({ name: 'identity', code: 0, encode: (e) => hc(e) }))
    }
  }),
  xB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(), F(), ds()
    }
  }),
  RB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(), F()
    }
  }),
  jr,
  r3,
  n3,
  i3,
  Io,
  s3,
  j0,
  z0,
  yc,
  vc,
  o3,
  a3,
  c3,
  BB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        O0(),
        L0(),
        S4(),
        y4(),
        ds(),
        (jr = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: vc,
                byteLength: vc,
                code: yc,
                version: yc,
                multihash: yc,
                bytes: yc,
                _baseCache: vc,
                asCID: vc
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== Io) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== s3) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return jr.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = D0(e, r)
                return jr.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && J4(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return n3(r, n, e || Pn.encoder)
              default:
                return i3(r, n, e || Ao.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return a3(/^0\.0/, c3), !!(e && (e[z0] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof jr) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new jr(r, t, n, i || j0(r, t, n.bytes))
            } else if (e != null && e[z0] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = W4(t)
              return jr.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== Io) throw new Error(`Version 0 CID must use dag-pb (code: ${Io}) block encoding`)
                return new jr(e, r, t, t.bytes)
              }
              case 1: {
                let n = j0(e, r, t.bytes)
                return new jr(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return jr.create(0, Io, e)
          }
          static createV1(e, r) {
            return jr.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = jr.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = jr.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = hc(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new zl(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? jr.createV0(s) : jr.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = jl(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = Io
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = r3(e, r),
              i = jr.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (r3 = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || Pn
              return [Pn.prefix, t.decode(`${Pn.prefix}${e}`)]
            }
            case Pn.prefix: {
              let t = r || Pn
              return [Pn.prefix, t.decode(e)]
            }
            case Ao.prefix: {
              let t = r || Ao
              return [Ao.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        (n3 = (e, r, t) => {
          let { prefix: n } = t
          if (n !== Pn.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (i3 = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (Io = 112),
        (s3 = 18),
        (j0 = (e, r, t) => {
          let n = bc(e),
            i = n + bc(r),
            s = new Uint8Array(i + t.byteLength)
          return mc(e, s, 0), mc(r, s, n), s.set(t, i), s
        }),
        (z0 = Symbol.for('@ipld/js-cid/CID')),
        (yc = { writable: !1, configurable: !1, enumerable: !0 }),
        (vc = { writable: !1, enumerable: !1, configurable: !1 }),
        (o3 = '0.0.0-dev'),
        (a3 = (e, r) => {
          if (e.test(o3)) console.warn(r)
          else throw new Error(r)
        }),
        (c3 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  NB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), BB(), O0(), ds(), U0(), L0()
    }
  }),
  K0,
  PB,
  OB = Ie({
    'node_modules/uint8arrays/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        wB(),
        _B(),
        EB(),
        SB(),
        AB(),
        y4(),
        IB(),
        S4(),
        TB(),
        kB(),
        MB(),
        xB(),
        RB(),
        NB(),
        (K0 = { ...Y6, ...Q6, ...t4, ...n4, ...s4, ...c4, ...v4, ..._4, ...A4 }),
        (PB = { ...Y4, ...e3 })
    }
  })
function u3(e, r, t, n) {
  return { name: e, prefix: r, encoder: { name: e, prefix: r, encode: t }, decoder: { decode: n } }
}
var F0,
  Fl,
  l3,
  V0,
  f3 = Ie({
    'node_modules/uint8arrays/esm/src/util/bases.js'() {
      V(),
        F(),
        OB(),
        (F0 = u3(
          'utf8',
          'u',
          (e) => {
            let r = new TextDecoder('utf8')
            return 'u' + r.decode(e)
          },
          (e) => new TextEncoder().encode(e.substring(1))
        )),
        (Fl = u3(
          'ascii',
          'a',
          (e) => {
            let r = 'a'
            for (let t = 0; t < e.length; t++) r += String.fromCharCode(e[t])
            return r
          },
          (e) => {
            e = e.substring(1)
            let r = new Uint8Array(e.length)
            for (let t = 0; t < e.length; t++) r[t] = e.charCodeAt(t)
            return r
          }
        )),
        (l3 = { utf8: F0, 'utf-8': F0, hex: K0.base16, latin1: Fl, ascii: Fl, binary: Fl, ...K0 }),
        (V0 = l3)
    }
  }),
  vn = {}
Re(vn, { toString: () => DB })
function DB(e, r = 'utf8') {
  let t = V0[r]
  if (!t) throw new Error(`Unsupported encoding "${r}"`)
  return t.encoder.encode(e).substring(1)
}
var On = Ie({
    'node_modules/uint8arrays/esm/src/to-string.js'() {
      V(), F(), f3()
    }
  }),
  un = {}
Re(un, { fromString: () => LB })
function LB(e, r = 'utf8') {
  let t = V0[r]
  if (!t) throw new Error(`Unsupported encoding "${r}"`)
  return t.decoder.decode(`${t.prefix}${e}`)
}
var gn = Ie({
    'node_modules/uint8arrays/esm/src/from-string.js'() {
      V(), F(), f3()
    }
  }),
  Li = {}
Re(Li, { concat: () => UB })
function UB(e, r) {
  r || (r = e.reduce((i, s) => i + s.length, 0))
  let t = new Uint8Array(r),
    n = 0
  for (let i of e) t.set(i, n), (n += i.length)
  return t
}
var hs = Ie({
    'node_modules/uint8arrays/esm/src/concat.js'() {
      V(), F()
    }
  }),
  gc = te({
    'node_modules/multihashes/src/index.js'(e, r) {
      V(), F()
      var t = Di(),
        n = mB(),
        { names: i } = bB(),
        { toString: s } = (On(), vn),
        { fromString: u } = (gn(), un),
        { concat: o } = (hs(), Li),
        l = {}
      for (let E in i) {
        let k = E
        l[i[k]] = k
      }
      Object.freeze(l)
      function a(E) {
        if (!(E instanceof Uint8Array)) throw new Error('must be passed a Uint8Array')
        return s(E, 'base16')
      }
      function c(E) {
        return u(E, 'base16')
      }
      function f(E) {
        if (!(E instanceof Uint8Array)) throw new Error('must be passed a Uint8Array')
        return s(t.encode('base58btc', E)).slice(1)
      }
      function p(E) {
        let k = E instanceof Uint8Array ? s(E) : E
        return t.decode('z' + k)
      }
      function y(E) {
        if (!(E instanceof Uint8Array)) throw new Error('multihash must be a Uint8Array')
        if (E.length < 2) throw new Error('multihash too short. must be > 2 bytes.')
        let k = n.decode(E)
        if (!_(k)) throw new Error(`multihash unknown function code: 0x${k.toString(16)}`)
        E = E.slice(n.decode.bytes)
        let w = n.decode(E)
        if (w < 0) throw new Error(`multihash invalid length: ${w}`)
        if (((E = E.slice(n.decode.bytes)), E.length !== w))
          throw new Error(`multihash length inconsistent: 0x${s(E, 'base16')}`)
        return { code: k, name: l[k], length: w, digest: E }
      }
      function d(E, k, w) {
        if (!E || k === void 0) throw new Error('multihash encode requires at least two args: digest, code')
        let v = h(k)
        if (!(E instanceof Uint8Array)) throw new Error('digest should be a Uint8Array')
        if ((w == null && (w = E.length), w && E.length !== w))
          throw new Error('digest length should be equal to specified length.')
        let I = n.encode(v),
          M = n.encode(w)
        return o([I, M, E], I.length + M.length + E.length)
      }
      function h(E) {
        let k = E
        if (typeof E == 'string') {
          if (i[E] === void 0) throw new Error(`Unrecognized hash function named: ${E}`)
          k = i[E]
        }
        if (typeof k != 'number') throw new Error(`Hash function code should be a number. Got: ${k}`)
        if (l[k] === void 0 && !m(k)) throw new Error(`Unrecognized function code: ${k}`)
        return k
      }
      function m(E) {
        return E > 0 && E < 16
      }
      function _(E) {
        return !!(m(E) || l[E])
      }
      function A(E) {
        y(E)
      }
      function T(E) {
        return A(E), E.subarray(0, 2)
      }
      r.exports = {
        names: i,
        codes: l,
        toHexString: a,
        fromHexString: c,
        toB58String: f,
        fromB58String: p,
        decode: y,
        encode: d,
        coerceCode: h,
        isAppCode: m,
        validate: A,
        prefix: T,
        isValidCode: _
      }
    }
  }),
  qB = te({
    'node_modules/varint/encode.js'(e, r) {
      V(), F(), (r.exports = u)
      var t = 128,
        n = 127,
        i = ~n,
        s = Math.pow(2, 31)
      function u(o, l, a) {
        if (Number.MAX_SAFE_INTEGER && o > Number.MAX_SAFE_INTEGER)
          throw ((u.bytes = 0), new RangeError('Could not encode varint'))
        ;(l = l || []), (a = a || 0)
        for (var c = a; o >= s; ) (l[a++] = (o & 255) | t), (o /= 128)
        for (; o & i; ) (l[a++] = (o & 255) | t), (o >>>= 7)
        return (l[a] = o | 0), (u.bytes = a - c + 1), l
      }
    }
  }),
  jB = te({
    'node_modules/varint/decode.js'(e, r) {
      V(), F(), (r.exports = i)
      var t = 128,
        n = 127
      function i(s, u) {
        var o = 0,
          u = u || 0,
          l = 0,
          a = u,
          c,
          f = s.length
        do {
          if (a >= f || l > 49) throw ((i.bytes = 0), new RangeError('Could not decode varint'))
          ;(c = s[a++]), (o += l < 28 ? (c & n) << l : (c & n) * Math.pow(2, l)), (l += 7)
        } while (c >= t)
        return (i.bytes = a - u), o
      }
    }
  }),
  zB = te({
    'node_modules/varint/length.js'(e, r) {
      V(), F()
      var t = Math.pow(2, 7),
        n = Math.pow(2, 14),
        i = Math.pow(2, 21),
        s = Math.pow(2, 28),
        u = Math.pow(2, 35),
        o = Math.pow(2, 42),
        l = Math.pow(2, 49),
        a = Math.pow(2, 56),
        c = Math.pow(2, 63)
      r.exports = function (f) {
        return f < t
          ? 1
          : f < n
          ? 2
          : f < i
          ? 3
          : f < s
          ? 4
          : f < u
          ? 5
          : f < o
          ? 6
          : f < l
          ? 7
          : f < a
          ? 8
          : f < c
          ? 9
          : 10
      }
    }
  }),
  $t = te({
    'node_modules/varint/index.js'(e, r) {
      V(), F(), (r.exports = { encode: qB(), decode: jB(), encodingLength: zB() })
    }
  }),
  d3 = te({
    'node_modules/multicodec/src/util.js'(e, r) {
      V(), F()
      var t = $t(),
        { toString: n } = (On(), vn),
        { fromString: i } = (gn(), un)
      r.exports = { numberToUint8Array: u, uint8ArrayToNumber: s, varintUint8ArrayEncode: o, varintEncode: l }
      function s(a) {
        return parseInt(n(a, 'base16'), 16)
      }
      function u(a) {
        let c = a.toString(16)
        return c.length % 2 == 1 && (c = '0' + c), i(c, 'base16')
      }
      function o(a) {
        return Uint8Array.from(t.encode(s(a)))
      }
      function l(a) {
        return Uint8Array.from(t.encode(a))
      }
    }
  }),
  KB = te({
    'node_modules/multicodec/src/generated-table.js'(e, r) {
      V(), F()
      var t = Object.freeze({
        identity: 0,
        cidv1: 1,
        cidv2: 2,
        cidv3: 3,
        ip4: 4,
        tcp: 6,
        sha1: 17,
        'sha2-256': 18,
        'sha2-512': 19,
        'sha3-512': 20,
        'sha3-384': 21,
        'sha3-256': 22,
        'sha3-224': 23,
        'shake-128': 24,
        'shake-256': 25,
        'keccak-224': 26,
        'keccak-256': 27,
        'keccak-384': 28,
        'keccak-512': 29,
        blake3: 30,
        dccp: 33,
        'murmur3-128': 34,
        'murmur3-32': 35,
        ip6: 41,
        ip6zone: 42,
        path: 47,
        multicodec: 48,
        multihash: 49,
        multiaddr: 50,
        multibase: 51,
        dns: 53,
        dns4: 54,
        dns6: 55,
        dnsaddr: 56,
        protobuf: 80,
        cbor: 81,
        raw: 85,
        'dbl-sha2-256': 86,
        rlp: 96,
        bencode: 99,
        'dag-pb': 112,
        'dag-cbor': 113,
        'libp2p-key': 114,
        'git-raw': 120,
        'torrent-info': 123,
        'torrent-file': 124,
        'leofcoin-block': 129,
        'leofcoin-tx': 130,
        'leofcoin-pr': 131,
        sctp: 132,
        'dag-jose': 133,
        'dag-cose': 134,
        'eth-block': 144,
        'eth-block-list': 145,
        'eth-tx-trie': 146,
        'eth-tx': 147,
        'eth-tx-receipt-trie': 148,
        'eth-tx-receipt': 149,
        'eth-state-trie': 150,
        'eth-account-snapshot': 151,
        'eth-storage-trie': 152,
        'bitcoin-block': 176,
        'bitcoin-tx': 177,
        'bitcoin-witness-commitment': 178,
        'zcash-block': 192,
        'zcash-tx': 193,
        docid: 206,
        'stellar-block': 208,
        'stellar-tx': 209,
        md4: 212,
        md5: 213,
        bmt: 214,
        'decred-block': 224,
        'decred-tx': 225,
        'ipld-ns': 226,
        'ipfs-ns': 227,
        'swarm-ns': 228,
        'ipns-ns': 229,
        zeronet: 230,
        'secp256k1-pub': 231,
        'bls12_381-g1-pub': 234,
        'bls12_381-g2-pub': 235,
        'x25519-pub': 236,
        'ed25519-pub': 237,
        'bls12_381-g1g2-pub': 238,
        'dash-block': 240,
        'dash-tx': 241,
        'swarm-manifest': 250,
        'swarm-feed': 251,
        udp: 273,
        'p2p-webrtc-star': 275,
        'p2p-webrtc-direct': 276,
        'p2p-stardust': 277,
        'p2p-circuit': 290,
        'dag-json': 297,
        udt: 301,
        utp: 302,
        unix: 400,
        thread: 406,
        p2p: 421,
        ipfs: 421,
        https: 443,
        onion: 444,
        onion3: 445,
        garlic64: 446,
        garlic32: 447,
        tls: 448,
        quic: 460,
        ws: 477,
        wss: 478,
        'p2p-websocket-star': 479,
        http: 480,
        json: 512,
        messagepack: 513,
        'libp2p-peer-record': 769,
        'sha2-256-trunc254-padded': 4114,
        'ripemd-128': 4178,
        'ripemd-160': 4179,
        'ripemd-256': 4180,
        'ripemd-320': 4181,
        x11: 4352,
        'p256-pub': 4608,
        'p384-pub': 4609,
        'p521-pub': 4610,
        'ed448-pub': 4611,
        'x448-pub': 4612,
        'ed25519-priv': 4864,
        kangarootwelve: 7425,
        'sm3-256': 21325,
        'blake2b-8': 45569,
        'blake2b-16': 45570,
        'blake2b-24': 45571,
        'blake2b-32': 45572,
        'blake2b-40': 45573,
        'blake2b-48': 45574,
        'blake2b-56': 45575,
        'blake2b-64': 45576,
        'blake2b-72': 45577,
        'blake2b-80': 45578,
        'blake2b-88': 45579,
        'blake2b-96': 45580,
        'blake2b-104': 45581,
        'blake2b-112': 45582,
        'blake2b-120': 45583,
        'blake2b-128': 45584,
        'blake2b-136': 45585,
        'blake2b-144': 45586,
        'blake2b-152': 45587,
        'blake2b-160': 45588,
        'blake2b-168': 45589,
        'blake2b-176': 45590,
        'blake2b-184': 45591,
        'blake2b-192': 45592,
        'blake2b-200': 45593,
        'blake2b-208': 45594,
        'blake2b-216': 45595,
        'blake2b-224': 45596,
        'blake2b-232': 45597,
        'blake2b-240': 45598,
        'blake2b-248': 45599,
        'blake2b-256': 45600,
        'blake2b-264': 45601,
        'blake2b-272': 45602,
        'blake2b-280': 45603,
        'blake2b-288': 45604,
        'blake2b-296': 45605,
        'blake2b-304': 45606,
        'blake2b-312': 45607,
        'blake2b-320': 45608,
        'blake2b-328': 45609,
        'blake2b-336': 45610,
        'blake2b-344': 45611,
        'blake2b-352': 45612,
        'blake2b-360': 45613,
        'blake2b-368': 45614,
        'blake2b-376': 45615,
        'blake2b-384': 45616,
        'blake2b-392': 45617,
        'blake2b-400': 45618,
        'blake2b-408': 45619,
        'blake2b-416': 45620,
        'blake2b-424': 45621,
        'blake2b-432': 45622,
        'blake2b-440': 45623,
        'blake2b-448': 45624,
        'blake2b-456': 45625,
        'blake2b-464': 45626,
        'blake2b-472': 45627,
        'blake2b-480': 45628,
        'blake2b-488': 45629,
        'blake2b-496': 45630,
        'blake2b-504': 45631,
        'blake2b-512': 45632,
        'blake2s-8': 45633,
        'blake2s-16': 45634,
        'blake2s-24': 45635,
        'blake2s-32': 45636,
        'blake2s-40': 45637,
        'blake2s-48': 45638,
        'blake2s-56': 45639,
        'blake2s-64': 45640,
        'blake2s-72': 45641,
        'blake2s-80': 45642,
        'blake2s-88': 45643,
        'blake2s-96': 45644,
        'blake2s-104': 45645,
        'blake2s-112': 45646,
        'blake2s-120': 45647,
        'blake2s-128': 45648,
        'blake2s-136': 45649,
        'blake2s-144': 45650,
        'blake2s-152': 45651,
        'blake2s-160': 45652,
        'blake2s-168': 45653,
        'blake2s-176': 45654,
        'blake2s-184': 45655,
        'blake2s-192': 45656,
        'blake2s-200': 45657,
        'blake2s-208': 45658,
        'blake2s-216': 45659,
        'blake2s-224': 45660,
        'blake2s-232': 45661,
        'blake2s-240': 45662,
        'blake2s-248': 45663,
        'blake2s-256': 45664,
        'skein256-8': 45825,
        'skein256-16': 45826,
        'skein256-24': 45827,
        'skein256-32': 45828,
        'skein256-40': 45829,
        'skein256-48': 45830,
        'skein256-56': 45831,
        'skein256-64': 45832,
        'skein256-72': 45833,
        'skein256-80': 45834,
        'skein256-88': 45835,
        'skein256-96': 45836,
        'skein256-104': 45837,
        'skein256-112': 45838,
        'skein256-120': 45839,
        'skein256-128': 45840,
        'skein256-136': 45841,
        'skein256-144': 45842,
        'skein256-152': 45843,
        'skein256-160': 45844,
        'skein256-168': 45845,
        'skein256-176': 45846,
        'skein256-184': 45847,
        'skein256-192': 45848,
        'skein256-200': 45849,
        'skein256-208': 45850,
        'skein256-216': 45851,
        'skein256-224': 45852,
        'skein256-232': 45853,
        'skein256-240': 45854,
        'skein256-248': 45855,
        'skein256-256': 45856,
        'skein512-8': 45857,
        'skein512-16': 45858,
        'skein512-24': 45859,
        'skein512-32': 45860,
        'skein512-40': 45861,
        'skein512-48': 45862,
        'skein512-56': 45863,
        'skein512-64': 45864,
        'skein512-72': 45865,
        'skein512-80': 45866,
        'skein512-88': 45867,
        'skein512-96': 45868,
        'skein512-104': 45869,
        'skein512-112': 45870,
        'skein512-120': 45871,
        'skein512-128': 45872,
        'skein512-136': 45873,
        'skein512-144': 45874,
        'skein512-152': 45875,
        'skein512-160': 45876,
        'skein512-168': 45877,
        'skein512-176': 45878,
        'skein512-184': 45879,
        'skein512-192': 45880,
        'skein512-200': 45881,
        'skein512-208': 45882,
        'skein512-216': 45883,
        'skein512-224': 45884,
        'skein512-232': 45885,
        'skein512-240': 45886,
        'skein512-248': 45887,
        'skein512-256': 45888,
        'skein512-264': 45889,
        'skein512-272': 45890,
        'skein512-280': 45891,
        'skein512-288': 45892,
        'skein512-296': 45893,
        'skein512-304': 45894,
        'skein512-312': 45895,
        'skein512-320': 45896,
        'skein512-328': 45897,
        'skein512-336': 45898,
        'skein512-344': 45899,
        'skein512-352': 45900,
        'skein512-360': 45901,
        'skein512-368': 45902,
        'skein512-376': 45903,
        'skein512-384': 45904,
        'skein512-392': 45905,
        'skein512-400': 45906,
        'skein512-408': 45907,
        'skein512-416': 45908,
        'skein512-424': 45909,
        'skein512-432': 45910,
        'skein512-440': 45911,
        'skein512-448': 45912,
        'skein512-456': 45913,
        'skein512-464': 45914,
        'skein512-472': 45915,
        'skein512-480': 45916,
        'skein512-488': 45917,
        'skein512-496': 45918,
        'skein512-504': 45919,
        'skein512-512': 45920,
        'skein1024-8': 45921,
        'skein1024-16': 45922,
        'skein1024-24': 45923,
        'skein1024-32': 45924,
        'skein1024-40': 45925,
        'skein1024-48': 45926,
        'skein1024-56': 45927,
        'skein1024-64': 45928,
        'skein1024-72': 45929,
        'skein1024-80': 45930,
        'skein1024-88': 45931,
        'skein1024-96': 45932,
        'skein1024-104': 45933,
        'skein1024-112': 45934,
        'skein1024-120': 45935,
        'skein1024-128': 45936,
        'skein1024-136': 45937,
        'skein1024-144': 45938,
        'skein1024-152': 45939,
        'skein1024-160': 45940,
        'skein1024-168': 45941,
        'skein1024-176': 45942,
        'skein1024-184': 45943,
        'skein1024-192': 45944,
        'skein1024-200': 45945,
        'skein1024-208': 45946,
        'skein1024-216': 45947,
        'skein1024-224': 45948,
        'skein1024-232': 45949,
        'skein1024-240': 45950,
        'skein1024-248': 45951,
        'skein1024-256': 45952,
        'skein1024-264': 45953,
        'skein1024-272': 45954,
        'skein1024-280': 45955,
        'skein1024-288': 45956,
        'skein1024-296': 45957,
        'skein1024-304': 45958,
        'skein1024-312': 45959,
        'skein1024-320': 45960,
        'skein1024-328': 45961,
        'skein1024-336': 45962,
        'skein1024-344': 45963,
        'skein1024-352': 45964,
        'skein1024-360': 45965,
        'skein1024-368': 45966,
        'skein1024-376': 45967,
        'skein1024-384': 45968,
        'skein1024-392': 45969,
        'skein1024-400': 45970,
        'skein1024-408': 45971,
        'skein1024-416': 45972,
        'skein1024-424': 45973,
        'skein1024-432': 45974,
        'skein1024-440': 45975,
        'skein1024-448': 45976,
        'skein1024-456': 45977,
        'skein1024-464': 45978,
        'skein1024-472': 45979,
        'skein1024-480': 45980,
        'skein1024-488': 45981,
        'skein1024-496': 45982,
        'skein1024-504': 45983,
        'skein1024-512': 45984,
        'skein1024-520': 45985,
        'skein1024-528': 45986,
        'skein1024-536': 45987,
        'skein1024-544': 45988,
        'skein1024-552': 45989,
        'skein1024-560': 45990,
        'skein1024-568': 45991,
        'skein1024-576': 45992,
        'skein1024-584': 45993,
        'skein1024-592': 45994,
        'skein1024-600': 45995,
        'skein1024-608': 45996,
        'skein1024-616': 45997,
        'skein1024-624': 45998,
        'skein1024-632': 45999,
        'skein1024-640': 46e3,
        'skein1024-648': 46001,
        'skein1024-656': 46002,
        'skein1024-664': 46003,
        'skein1024-672': 46004,
        'skein1024-680': 46005,
        'skein1024-688': 46006,
        'skein1024-696': 46007,
        'skein1024-704': 46008,
        'skein1024-712': 46009,
        'skein1024-720': 46010,
        'skein1024-728': 46011,
        'skein1024-736': 46012,
        'skein1024-744': 46013,
        'skein1024-752': 46014,
        'skein1024-760': 46015,
        'skein1024-768': 46016,
        'skein1024-776': 46017,
        'skein1024-784': 46018,
        'skein1024-792': 46019,
        'skein1024-800': 46020,
        'skein1024-808': 46021,
        'skein1024-816': 46022,
        'skein1024-824': 46023,
        'skein1024-832': 46024,
        'skein1024-840': 46025,
        'skein1024-848': 46026,
        'skein1024-856': 46027,
        'skein1024-864': 46028,
        'skein1024-872': 46029,
        'skein1024-880': 46030,
        'skein1024-888': 46031,
        'skein1024-896': 46032,
        'skein1024-904': 46033,
        'skein1024-912': 46034,
        'skein1024-920': 46035,
        'skein1024-928': 46036,
        'skein1024-936': 46037,
        'skein1024-944': 46038,
        'skein1024-952': 46039,
        'skein1024-960': 46040,
        'skein1024-968': 46041,
        'skein1024-976': 46042,
        'skein1024-984': 46043,
        'skein1024-992': 46044,
        'skein1024-1000': 46045,
        'skein1024-1008': 46046,
        'skein1024-1016': 46047,
        'skein1024-1024': 46048,
        'poseidon-bls12_381-a2-fc1': 46081,
        'poseidon-bls12_381-a2-fc1-sc': 46082,
        'zeroxcert-imprint-256': 52753,
        'fil-commitment-unsealed': 61697,
        'fil-commitment-sealed': 61698,
        'holochain-adr-v0': 8417572,
        'holochain-adr-v1': 8483108,
        'holochain-key-v0': 9728292,
        'holochain-key-v1': 9793828,
        'holochain-sig-v0': 10645796,
        'holochain-sig-v1': 10711332,
        'skynet-ns': 11639056
      })
      r.exports = { baseTable: t }
    }
  }),
  FB = te({
    'node_modules/multicodec/src/maps.js'(e, r) {
      V(), F()
      var { baseTable: t } = KB(),
        n = d3().varintEncode,
        i = {},
        s = {},
        u = {}
      for (let l in t) {
        let a = l,
          c = t[a]
        i[a] = n(c)
        let f = a.toUpperCase().replace(/-/g, '_')
        ;(s[f] = c), u[c] || (u[c] = a)
      }
      Object.freeze(i), Object.freeze(s), Object.freeze(u)
      var o = Object.freeze(t)
      r.exports = { nameToVarint: i, constantToCode: s, nameToCode: o, codeToName: u }
    }
  }),
  h3 = te({
    'node_modules/multicodec/src/index.js'(e, r) {
      V(), F()
      var t = $t(),
        { concat: n } = (hs(), Li),
        i = d3(),
        { nameToVarint: s, constantToCode: u, nameToCode: o, codeToName: l } = FB()
      function a(v, I) {
        let M
        if (v instanceof Uint8Array) M = i.varintUint8ArrayEncode(v)
        else if (s[v]) M = s[v]
        else throw new Error('multicodec not recognized')
        return n([M, I], M.length + I.length)
      }
      function c(v) {
        return t.decode(v), v.slice(t.decode.bytes)
      }
      function f(v) {
        let I = t.decode(v),
          M = l[I]
        if (M === void 0) throw new Error(`Code "${I}" not found`)
        return M
      }
      function p(v) {
        return l[v]
      }
      function y(v) {
        let I = o[v]
        if (I === void 0) throw new Error(`Codec "${v}" not found`)
        return I
      }
      function d(v) {
        return t.decode(v)
      }
      function h(v) {
        let I = s[v]
        if (I === void 0) throw new Error(`Codec "${v}" not found`)
        return I
      }
      function m(v) {
        return i.varintEncode(v)
      }
      function _(v) {
        return f(v)
      }
      function A(v) {
        return p(v)
      }
      function T(v) {
        return y(v)
      }
      function E(v) {
        return d(v)
      }
      function k(v) {
        return h(v)
      }
      function w(v) {
        return Array.from(m(v))
      }
      r.exports = {
        addPrefix: a,
        rmPrefix: c,
        getNameFromData: f,
        getNameFromCode: p,
        getCodeFromName: y,
        getCodeFromData: d,
        getVarintFromName: h,
        getVarintFromCode: m,
        getCodec: _,
        getName: A,
        getNumber: T,
        getCode: E,
        getCodeVarint: k,
        getVarint: w,
        ...u,
        nameToVarint: s,
        nameToCode: o,
        codeToName: l
      }
    }
  }),
  VB = te({
    'node_modules/cids/src/cid-util.js'(e, r) {
      V(), F()
      var t = gc(),
        n = {
          checkCIDComponents: function (i) {
            if (i == null) return 'null values are not valid CIDs'
            if (!(i.version === 0 || i.version === 1)) return 'Invalid version, must be a number equal to 1 or 0'
            if (typeof i.codec != 'string') return 'codec must be string'
            if (i.version === 0) {
              if (i.codec !== 'dag-pb') return "codec must be 'dag-pb' for CIDv0"
              if (i.multibaseName !== 'base58btc') return "multibaseName must be 'base58btc' for CIDv0"
            }
            if (!(i.multihash instanceof Uint8Array)) return 'multihash must be a Uint8Array'
            try {
              t.validate(i.multihash)
            } catch (s) {
              let u = s.message
              return u || (u = 'Multihash validation failed'), u
            }
          }
        }
      r.exports = n
    }
  }),
  ps = {}
Re(ps, { equals: () => HB })
function HB(e, r) {
  if (e === r) return !0
  if (e.byteLength !== r.byteLength) return !1
  for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
  return !0
}
var To = Ie({
    'node_modules/uint8arrays/esm/src/equals.js'() {
      V(), F()
    }
  }),
  Gr = te({
    'node_modules/cids/src/index.js'(e, r) {
      V(), F()
      var t = gc(),
        n = Di(),
        i = h3(),
        s = VB(),
        { concat: u } = (hs(), Li),
        { toString: o } = (On(), vn),
        { equals: l } = (To(), ps),
        a = i.nameToCode,
        c = Object.keys(a).reduce((y, d) => ((y[a[d]] = d), y), {}),
        f = Symbol.for('@ipld/js-cid/CID'),
        p = class {
          constructor(y, d, h, m) {
            if ((this.version, this.codec, this.multihash, Object.defineProperty(this, f, { value: !0 }), p.isCID(y))) {
              let _ = y
              ;(this.version = _.version),
                (this.codec = _.codec),
                (this.multihash = _.multihash),
                (this.multibaseName = _.multibaseName || (_.version === 0 ? 'base58btc' : 'base32'))
              return
            }
            if (typeof y == 'string') {
              let _ = n.isEncoded(y)
              if (_) {
                let A = n.decode(y)
                ;(this.version = parseInt(A[0].toString(), 16)),
                  (this.codec = i.getCodec(A.slice(1))),
                  (this.multihash = i.rmPrefix(A.slice(1))),
                  (this.multibaseName = _)
              } else
                (this.version = 0),
                  (this.codec = 'dag-pb'),
                  (this.multihash = t.fromB58String(y)),
                  (this.multibaseName = 'base58btc')
              p.validateCID(this), Object.defineProperty(this, 'string', { value: y })
              return
            }
            if (y instanceof Uint8Array) {
              let _ = parseInt(y[0].toString(), 16)
              if (_ === 1) {
                let A = y
                ;(this.version = _),
                  (this.codec = i.getCodec(A.slice(1))),
                  (this.multihash = i.rmPrefix(A.slice(1))),
                  (this.multibaseName = 'base32')
              } else
                (this.version = 0), (this.codec = 'dag-pb'), (this.multihash = y), (this.multibaseName = 'base58btc')
              p.validateCID(this)
              return
            }
            ;(this.version = y),
              typeof d == 'number' && (d = c[d]),
              (this.codec = d),
              (this.multihash = h),
              (this.multibaseName = m || (y === 0 ? 'base58btc' : 'base32')),
              p.validateCID(this)
          }
          get bytes() {
            let y = this._bytes
            if (!y) {
              if (this.version === 0) y = this.multihash
              else if (this.version === 1) {
                let d = i.getCodeVarint(this.codec)
                y = u([[1], d, this.multihash], 1 + d.byteLength + this.multihash.byteLength)
              } else throw new Error('unsupported version')
              Object.defineProperty(this, '_bytes', { value: y })
            }
            return y
          }
          get prefix() {
            let y = i.getCodeVarint(this.codec),
              d = t.prefix(this.multihash)
            return u([[this.version], y, d], 1 + y.byteLength + d.byteLength)
          }
          get code() {
            return a[this.codec]
          }
          toV0() {
            if (this.codec !== 'dag-pb') throw new Error('Cannot convert a non dag-pb CID to CIDv0')
            let { name: y, length: d } = t.decode(this.multihash)
            if (y !== 'sha2-256') throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
            if (d !== 32) throw new Error('Cannot convert non 32 byte multihash CID to CIDv0')
            return new p(0, this.codec, this.multihash)
          }
          toV1() {
            return new p(1, this.codec, this.multihash, this.multibaseName)
          }
          toBaseEncodedString(y = this.multibaseName) {
            if (this.string && this.string.length !== 0 && y === this.multibaseName) return this.string
            let d
            if (this.version === 0) {
              if (y !== 'base58btc')
                throw new Error(
                  'not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()'
                )
              d = t.toB58String(this.multihash)
            } else if (this.version === 1) d = o(n.encode(y, this.bytes))
            else throw new Error('unsupported version')
            return y === this.multibaseName && Object.defineProperty(this, 'string', { value: d }), d
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          toString(y) {
            return this.toBaseEncodedString(y)
          }
          toJSON() {
            return { codec: this.codec, version: this.version, hash: this.multihash }
          }
          equals(y) {
            return this.codec === y.codec && this.version === y.version && l(this.multihash, y.multihash)
          }
          static validateCID(y) {
            let d = s.checkCIDComponents(y)
            if (d) throw new Error(d)
          }
          static isCID(y) {
            return y instanceof p || Boolean(y && y[f])
          }
        }
      ;(p.codecs = a), (r.exports = p)
    }
  }),
  $B = te({
    'node_modules/multiaddr-to-uri/node_modules/uint8arrays/from-string.js'(e, r) {
      V(), F()
      var t = q6()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.decoder.decode(`${u.prefix}${i}`)
      }
      r.exports = n
    }
  }),
  p3 = te({
    'node_modules/multiaddr-to-uri/node_modules/uint8arrays/concat.js'(e, r) {
      V(), F()
      function t(n, i) {
        i || (i = n.reduce((o, l) => o + l.length, 0))
        let s = new Uint8Array(i),
          u = 0
        for (let o of n) s.set(o, u), (u += o.length)
        return s
      }
      r.exports = t
    }
  }),
  GB = te({
    'node_modules/multiaddr-to-uri/node_modules/multiaddr/src/convert.js'(e, r) {
      V(), F()
      var t = aB(),
        n = M0(),
        i = Gr(),
        s = Di(),
        u = $t(),
        o = Ul(),
        l = $B(),
        a = p3()
      r.exports = c
      function c(w, v) {
        return v instanceof Uint8Array ? c.toString(w, v) : c.toBytes(w, v)
      }
      ;(c.toString = function (v, I) {
        switch (n(v).code) {
          case 4:
          case 41:
            return p(I)
          case 6:
          case 273:
          case 33:
          case 132:
            return d(I).toString()
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return m(I)
          case 421:
            return A(I)
          case 444:
            return k(I)
          case 445:
            return k(I)
          default:
            return o(I, 'base16')
        }
      }),
        (c.toBytes = function (v, I) {
          switch (n(v).code) {
            case 4:
              return f(I)
            case 41:
              return f(I)
            case 6:
            case 273:
            case 33:
            case 132:
              return y(parseInt(I, 10))
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return h(I)
            case 421:
              return _(I)
            case 444:
              return T(I)
            case 445:
              return E(I)
            default:
              return l(I, 'base16')
          }
        })
      function f(w) {
        if (!t.isIP(w)) throw new Error('invalid ip address')
        return t.toBytes(w)
      }
      function p(w) {
        let v = t.toString(w)
        if (!v || !t.isIP(v)) throw new Error('invalid ip address')
        return v
      }
      function y(w) {
        let v = new ArrayBuffer(2)
        return new DataView(v).setUint16(0, w), new Uint8Array(v)
      }
      function d(w) {
        return new DataView(w.buffer).getUint16(w.byteOffset)
      }
      function h(w) {
        let v = l(w),
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function m(w) {
        let v = u.decode(w)
        if (((w = w.slice(u.decode.bytes)), w.length !== v)) throw new Error('inconsistent lengths')
        return o(w)
      }
      function _(w) {
        let v = new i(w).multihash,
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function A(w) {
        let v = u.decode(w),
          I = w.slice(u.decode.bytes)
        if (I.length !== v) throw new Error('inconsistent lengths')
        return o(I, 'base58btc')
      }
      function T(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 16) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function E(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 56) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion3 address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function k(w) {
        let v = w.slice(0, w.length - 2),
          I = w.slice(w.length - 2),
          M = o(v, 'base32'),
          q = d(I)
        return M + ':' + q
      }
    }
  }),
  WB = te({
    'node_modules/multiaddr-to-uri/node_modules/multiaddr/src/codec.js'(e, r) {
      V(), F()
      var t = GB(),
        n = M0(),
        i = $t(),
        s = p3(),
        u = Ul()
      r.exports = {
        stringToStringTuples: o,
        stringTuplesToString: l,
        tuplesToStringTuples: c,
        stringTuplesToTuples: a,
        bytesToTuples: y,
        tuplesToBytes: f,
        bytesToString: d,
        stringToBytes: h,
        fromString: m,
        fromBytes: _,
        validateBytes: A,
        isValidBytes: T,
        cleanPath: E,
        ParseError: k,
        protoFromTuple: w,
        sizeForAddr: p
      }
      function o(v) {
        let I = [],
          M = v.split('/').slice(1)
        if (M.length === 1 && M[0] === '') return []
        for (let q = 0; q < M.length; q++) {
          let G = M[q],
            O = n(G)
          if (O.size === 0) {
            I.push([G])
            continue
          }
          if ((q++, q >= M.length)) throw k('invalid address: ' + v)
          if (O.path) {
            I.push([G, E(M.slice(q).join('/'))])
            break
          }
          I.push([G, M[q]])
        }
        return I
      }
      function l(v) {
        let I = []
        return (
          v.map((M) => {
            let q = w(M)
            return I.push(q.name), M.length > 1 && I.push(M[1]), null
          }),
          E(I.join('/'))
        )
      }
      function a(v) {
        return v.map((I) => {
          Array.isArray(I) || (I = [I])
          let M = w(I)
          return I.length > 1 ? [M.code, t.toBytes(M.code, I[1])] : [M.code]
        })
      }
      function c(v) {
        return v.map((I) => {
          let M = w(I)
          return I[1] ? [M.code, t.toString(M.code, I[1])] : [M.code]
        })
      }
      function f(v) {
        return _(
          s(
            v.map((I) => {
              let M = w(I),
                q = Uint8Array.from(i.encode(M.code))
              return I.length > 1 && (q = s([q, I[1]])), q
            })
          )
        )
      }
      function p(v, I) {
        return v.size > 0 ? v.size / 8 : v.size === 0 ? 0 : i.decode(I) + i.decode.bytes
      }
      function y(v) {
        let I = [],
          M = 0
        for (; M < v.length; ) {
          let q = i.decode(v, M),
            G = i.decode.bytes,
            O = n(q),
            x = p(O, v.slice(M + G))
          if (x === 0) {
            I.push([q]), (M += G)
            continue
          }
          let L = v.slice(M + G, M + G + x)
          if (((M += x + G), M > v.length)) throw k('Invalid address Uint8Array: ' + u(v, 'base16'))
          I.push([q, L])
        }
        return I
      }
      function d(v) {
        let I = y(v),
          M = c(I)
        return l(M)
      }
      function h(v) {
        v = E(v)
        let I = o(v),
          M = a(I)
        return f(M)
      }
      function m(v) {
        return h(v)
      }
      function _(v) {
        let I = A(v)
        if (I) throw I
        return Uint8Array.from(v)
      }
      function A(v) {
        try {
          y(v)
        } catch (I) {
          return I
        }
      }
      function T(v) {
        return A(v) === void 0
      }
      function E(v) {
        return (
          '/' +
          v
            .trim()
            .split('/')
            .filter((I) => I)
            .join('/')
        )
      }
      function k(v) {
        return new Error('Error parsing address: ' + v)
      }
      function w(v) {
        return n(v[0])
      }
    }
  }),
  pt = te({
    'node_modules/err-code/index.js'(e, r) {
      V(), F()
      function t(i, s) {
        for (let u in s) Object.defineProperty(i, u, { value: s[u], enumerable: !0, configurable: !0 })
        return i
      }
      function n(i, s, u) {
        if (!i || typeof i == 'string') throw new TypeError('Please pass an Error to err-code')
        u || (u = {}), typeof s == 'object' && ((u = s), (s = '')), s && (u.code = s)
        try {
          return t(i, u)
        } catch (o) {
          ;(u.message = i.message), (u.stack = i.stack)
          let l = function () {}
          return (l.prototype = Object.create(Object.getPrototypeOf(i))), t(new l(), u)
        }
      }
      r.exports = n
    }
  }),
  JB = te({
    'node_modules/multiaddr-to-uri/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  }),
  XB = te({
    'node_modules/multiaddr-to-uri/node_modules/multiaddr/src/index.js'(e, r) {
      V(), F()
      var t = WB(),
        n = M0(),
        i = $t(),
        s = Gr(),
        u = pt(),
        o = Symbol.for('nodejs.util.inspect.custom'),
        l = Ul(),
        a = JB(),
        c = new Map(),
        f = Symbol.for('@multiformats/js-multiaddr/multiaddr'),
        p = class {
          constructor(d) {
            if ((d == null && (d = ''), Object.defineProperty(this, f, { value: !0 }), d instanceof Uint8Array))
              this.bytes = t.fromBytes(d)
            else if (typeof d == 'string') {
              if (d.length > 0 && d.charAt(0) !== '/') throw new Error(`multiaddr "${d}" must start with a "/"`)
              this.bytes = t.fromString(d)
            } else if (p.isMultiaddr(d)) this.bytes = t.fromBytes(d.bytes)
            else throw new Error('addr must be a string, Buffer, or another Multiaddr')
          }
          toString() {
            return t.bytesToString(this.bytes)
          }
          toJSON() {
            return this.toString()
          }
          toOptions() {
            let d = {},
              h = this.toString().split('/')
            return (
              (d.family = h[1] === 'ip4' ? 4 : 6), (d.host = h[2]), (d.transport = h[3]), (d.port = parseInt(h[4])), d
            )
          }
          protos() {
            return this.protoCodes().map((d) => Object.assign({}, n(d)))
          }
          protoCodes() {
            let d = [],
              h = this.bytes,
              m = 0
            for (; m < h.length; ) {
              let _ = i.decode(h, m),
                A = i.decode.bytes,
                T = n(_)
              ;(m += t.sizeForAddr(T, h.slice(m + A)) + A), d.push(_)
            }
            return d
          }
          protoNames() {
            return this.protos().map((d) => d.name)
          }
          tuples() {
            return t.bytesToTuples(this.bytes)
          }
          stringTuples() {
            let d = t.bytesToTuples(this.bytes)
            return t.tuplesToStringTuples(d)
          }
          encapsulate(d) {
            return (d = new p(d)), new p(this.toString() + d.toString())
          }
          decapsulate(d) {
            let h = d.toString(),
              m = this.toString(),
              _ = m.lastIndexOf(h)
            if (_ < 0) throw new Error('Address ' + this + ' does not contain subaddress: ' + d)
            return new p(m.slice(0, _))
          }
          decapsulateCode(d) {
            let h = this.tuples()
            for (let m = h.length - 1; m >= 0; m--) if (h[m][0] === d) return new p(t.tuplesToBytes(h.slice(0, m)))
            return this
          }
          getPeerId() {
            try {
              let h = this.stringTuples()
                .filter((m) => m[0] === n.names.ipfs.code)
                .pop()
              return h && h[1] ? l(new s(h[1]).multihash, 'base58btc') : null
            } catch (d) {
              return null
            }
          }
          getPath() {
            let d = null
            try {
              ;(d = this.stringTuples().filter((h) => !!n(h[0]).path)[0][1]), d || (d = null)
            } catch (h) {
              d = null
            }
            return d
          }
          equals(d) {
            return a(this.bytes, d.bytes)
          }
          async resolve() {
            let d = this.protos().find((_) => _.resolvable)
            if (!d) return [this]
            let h = c.get(d.name)
            if (!h) throw u(new Error(`no available resolver for ${d.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
            return (await h(this)).map((_) => new p(_))
          }
          nodeAddress() {
            let d = this.protoCodes(),
              h = this.protoNames(),
              m = this.toString().split('/').slice(1)
            if (m.length < 4)
              throw new Error(
                'multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'
              )
            if (d[0] !== 4 && d[0] !== 41 && d[0] !== 54 && d[0] !== 55)
              throw new Error(
                `no protocol with name: "'${h[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`
              )
            if (m[2] !== 'tcp' && m[2] !== 'udp')
              throw new Error(`no protocol with name: "'${h[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
            return { family: d[0] === 41 || d[0] === 55 ? 6 : 4, address: m[1], port: parseInt(m[3]) }
          }
          isThinWaistAddress(d) {
            let h = (d || this).protos()
            return !(h.length !== 2 || (h[0].code !== 4 && h[0].code !== 41) || (h[1].code !== 6 && h[1].code !== 273))
          }
          static fromNodeAddress(d, h) {
            if (!d) throw new Error('requires node address object')
            if (!h) throw new Error('requires transport protocol')
            let m
            switch (d.family) {
              case 4:
                m = 'ip4'
                break
              case 6:
                m = 'ip6'
                break
              default:
                throw Error(`Invalid addr family. Got '${d.family}' instead of 4 or 6`)
            }
            return new p('/' + [m, d.address, h, d.port].join('/'))
          }
          static isName(d) {
            return p.isMultiaddr(d) ? d.protos().some((h) => h.resolvable) : !1
          }
          static isMultiaddr(d) {
            return d instanceof p || Boolean(d && d[f])
          }
          [o]() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
          inspect() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
        }
      ;(p.protocols = n), (p.resolvers = c)
      function y(d) {
        return new p(d)
      }
      r.exports = { Multiaddr: p, multiaddr: y, protocols: n, resolvers: c }
    }
  }),
  YB = te({
    'node_modules/multiaddr-to-uri/index.js'(e, r) {
      V(), F()
      var { Multiaddr: t } = XB(),
        n = (u, o) => o,
        i = (u, o, l, a) => {
          if (a && a.assumeHttp === !1) return `tcp://${u}:${o}`
          let c = 'tcp',
            f = `:${o}`
          return (
            l[l.length - 1].protocol === 'tcp' &&
              ((c = o === '443' ? 'https' : 'http'), (f = o === '443' || o === '80' ? '' : f)),
            `${c}://${u}${f}`
          )
        },
        s = {
          ip4: n,
          ip6: (u, o, l, a) => (a.length === 1 && a[0].protocol === 'ip6' ? o : `[${o}]`),
          tcp: (u, o, l, a, c) =>
            a.some((f) => ['http', 'https', 'ws', 'wss'].includes(f.protocol)) ? `${u}:${o}` : i(u, o, a, c),
          udp: (u, o) => `udp://${u}:${o}`,
          dnsaddr: n,
          dns4: n,
          dns6: n,
          ipfs: (u, o) => `${u}/ipfs/${o}`,
          p2p: (u, o) => `${u}/p2p/${o}`,
          http: (u) => `http://${u}`,
          https: (u) => `https://${u}`,
          ws: (u) => `ws://${u}`,
          wss: (u) => `wss://${u}`,
          'p2p-websocket-star': (u) => `${u}/p2p-websocket-star`,
          'p2p-webrtc-star': (u) => `${u}/p2p-webrtc-star`,
          'p2p-webrtc-direct': (u) => `${u}/p2p-webrtc-direct`
        }
      r.exports = (u, o) => {
        let l = new t(u),
          a = u.toString().split('/').slice(1)
        return l
          .tuples()
          .map((c) => ({ protocol: a.shift(), content: c[1] ? a.shift() : null }))
          .reduce((c, f, p, y) => {
            let d = s[f.protocol]
            if (!d) throw new Error(`Unsupported protocol ${f.protocol}`)
            return d(c, f.content, p, y, o)
          }, '')
      }
    }
  }),
  H0 = te({
    'node_modules/get-iterator/index.js'(e, r) {
      V(),
        F(),
        (r.exports = function (n) {
          if (n) {
            if (typeof n[Symbol.iterator] == 'function') return n[Symbol.iterator]()
            if (typeof n[Symbol.asyncIterator] == 'function') return n[Symbol.asyncIterator]()
            if (typeof n.next == 'function') return n
          }
          throw new Error('argument is not an iterator or iterable')
        })
    }
  }),
  ZB = te({
    'node_modules/abortable-iterator/AbortError.js'(e, r) {
      V(),
        F(),
        (r.exports = class extends Error {
          constructor(n, i) {
            super(n || 'The operation was aborted')
            ;(this.type = 'aborted'), (this.code = i || 'ABORT_ERR')
          }
        })
    }
  }),
  Ui = te({
    'node_modules/abortable-iterator/index.js'(e, r) {
      V(), F()
      var t = H0(),
        n = ZB(),
        i = (c, f, p) => s(c, Array.isArray(f) ? f : [{ signal: f, options: p }]),
        s = (c, f) => {
          ;(c = t(c)), (f = f.map(({ signal: y, options: d }) => ({ signal: y, options: d || {} })))
          async function* p() {
            let y,
              d = () => {
                y && y()
              }
            for (let { signal: h } of f) h.addEventListener('abort', d)
            for (;;) {
              let h
              try {
                for (let { signal: _, options: A } of f)
                  if (_.aborted) {
                    let { abortMessage: T, abortCode: E } = A
                    throw new n(T, E)
                  }
                let m = new Promise((_, A) => {
                  y = () => {
                    let { options: T } = f.find(({ signal: w }) => w.aborted),
                      { abortMessage: E, abortCode: k } = T
                    A(new n(E, k))
                  }
                })
                ;(h = await Promise.race([m, c.next()])), (y = null)
              } catch (m) {
                for (let { signal: T } of f) T.removeEventListener('abort', d)
                let _ = f.find(({ signal: T }) => T.aborted),
                  A = m.type === 'aborted' && _
                if (
                  (A && _.options.onAbort && (await _.options.onAbort(c)),
                  typeof c.return == 'function' && (await c.return()),
                  A && _.options.returnOnAbort)
                )
                  return
                throw m
              }
              if (h.done) break
              yield h.value
            }
            for (let { signal: h } of f) h.removeEventListener('abort', d)
          }
          return p()
        },
        u = (c, f, p) => o(c, Array.isArray(f) ? f : [{ signal: f, options: p }]),
        o = (c, f) => (p) => c(s(p, f)),
        l = (c, f, p) => a(c, Array.isArray(f) ? f : [{ signal: f, options: p }]),
        a = (c, f) => ({ sink: o(c.sink, f), source: s(c.source, f) })
      ;(r.exports = i),
        (r.exports.AbortError = n),
        (r.exports.source = i),
        (r.exports.sink = u),
        (r.exports.transform = u),
        (r.exports.duplex = l)
    }
  }),
  Vl = te({
    'node_modules/p-defer/index.js'(e, r) {
      V(), F()
      var t = () => {
        let n = {}
        return (
          (n.promise = new Promise((i, s) => {
            ;(n.resolve = i), (n.reject = s)
          })),
          n
        )
      }
      r.exports = t
    }
  }),
  m3 = te({
    'node_modules/ms/index.js'(e, r) {
      V(), F()
      var t = 1e3,
        n = t * 60,
        i = n * 60,
        s = i * 24,
        u = s * 7,
        o = s * 365.25
      r.exports = function (p, y) {
        y = y || {}
        var d = typeof p
        if (d === 'string' && p.length > 0) return l(p)
        if (d === 'number' && isFinite(p)) return y.long ? c(p) : a(p)
        throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(p))
      }
      function l(p) {
        if (((p = String(p)), !(p.length > 100))) {
          var y =
            /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              p
            )
          if (!!y) {
            var d = parseFloat(y[1]),
              h = (y[2] || 'ms').toLowerCase()
            switch (h) {
              case 'years':
              case 'year':
              case 'yrs':
              case 'yr':
              case 'y':
                return d * o
              case 'weeks':
              case 'week':
              case 'w':
                return d * u
              case 'days':
              case 'day':
              case 'd':
                return d * s
              case 'hours':
              case 'hour':
              case 'hrs':
              case 'hr':
              case 'h':
                return d * i
              case 'minutes':
              case 'minute':
              case 'mins':
              case 'min':
              case 'm':
                return d * n
              case 'seconds':
              case 'second':
              case 'secs':
              case 'sec':
              case 's':
                return d * t
              case 'milliseconds':
              case 'millisecond':
              case 'msecs':
              case 'msec':
              case 'ms':
                return d
              default:
                return
            }
          }
        }
      }
      function a(p) {
        var y = Math.abs(p)
        return y >= s
          ? Math.round(p / s) + 'd'
          : y >= i
          ? Math.round(p / i) + 'h'
          : y >= n
          ? Math.round(p / n) + 'm'
          : y >= t
          ? Math.round(p / t) + 's'
          : p + 'ms'
      }
      function c(p) {
        var y = Math.abs(p)
        return y >= s
          ? f(p, y, s, 'day')
          : y >= i
          ? f(p, y, i, 'hour')
          : y >= n
          ? f(p, y, n, 'minute')
          : y >= t
          ? f(p, y, t, 'second')
          : p + ' ms'
      }
      function f(p, y, d, h) {
        var m = y >= d * 1.5
        return Math.round(p / d) + ' ' + h + (m ? 's' : '')
      }
    }
  }),
  QB = te({
    'node_modules/debug/src/common.js'(e, r) {
      V(), F()
      function t(n) {
        ;(s.debug = s),
          (s.default = s),
          (s.coerce = f),
          (s.disable = l),
          (s.enable = o),
          (s.enabled = a),
          (s.humanize = m3()),
          (s.destroy = p),
          Object.keys(n).forEach((y) => {
            s[y] = n[y]
          }),
          (s.names = []),
          (s.skips = []),
          (s.formatters = {})
        function i(y) {
          let d = 0
          for (let h = 0; h < y.length; h++) (d = (d << 5) - d + y.charCodeAt(h)), (d |= 0)
          return s.colors[Math.abs(d) % s.colors.length]
        }
        s.selectColor = i
        function s(y) {
          let d,
            h = null,
            m,
            _
          function A(...T) {
            if (!A.enabled) return
            let E = A,
              k = Number(new Date()),
              w = k - (d || k)
            ;(E.diff = w),
              (E.prev = d),
              (E.curr = k),
              (d = k),
              (T[0] = s.coerce(T[0])),
              typeof T[0] != 'string' && T.unshift('%O')
            let v = 0
            ;(T[0] = T[0].replace(/%([a-zA-Z%])/g, (M, q) => {
              if (M === '%%') return '%'
              v++
              let G = s.formatters[q]
              if (typeof G == 'function') {
                let O = T[v]
                ;(M = G.call(E, O)), T.splice(v, 1), v--
              }
              return M
            })),
              s.formatArgs.call(E, T),
              (E.log || s.log).apply(E, T)
          }
          return (
            (A.namespace = y),
            (A.useColors = s.useColors()),
            (A.color = s.selectColor(y)),
            (A.extend = u),
            (A.destroy = s.destroy),
            Object.defineProperty(A, 'enabled', {
              enumerable: !0,
              configurable: !1,
              get: () => (h !== null ? h : (m !== s.namespaces && ((m = s.namespaces), (_ = s.enabled(y))), _)),
              set: (T) => {
                h = T
              }
            }),
            typeof s.init == 'function' && s.init(A),
            A
          )
        }
        function u(y, d) {
          let h = s(this.namespace + (typeof d == 'undefined' ? ':' : d) + y)
          return (h.log = this.log), h
        }
        function o(y) {
          s.save(y), (s.namespaces = y), (s.names = []), (s.skips = [])
          let d,
            h = (typeof y == 'string' ? y : '').split(/[\s,]+/),
            m = h.length
          for (d = 0; d < m; d++)
            !h[d] ||
              ((y = h[d].replace(/\*/g, '.*?')),
              y[0] === '-'
                ? s.skips.push(new RegExp('^' + y.substr(1) + '$'))
                : s.names.push(new RegExp('^' + y + '$')))
        }
        function l() {
          let y = [...s.names.map(c), ...s.skips.map(c).map((d) => '-' + d)].join(',')
          return s.enable(''), y
        }
        function a(y) {
          if (y[y.length - 1] === '*') return !0
          let d, h
          for (d = 0, h = s.skips.length; d < h; d++) if (s.skips[d].test(y)) return !1
          for (d = 0, h = s.names.length; d < h; d++) if (s.names[d].test(y)) return !0
          return !1
        }
        function c(y) {
          return y
            .toString()
            .substring(2, y.toString().length - 2)
            .replace(/\.\*\?$/, '*')
        }
        function f(y) {
          return y instanceof Error ? y.stack || y.message : y
        }
        function p() {
          console.warn(
            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
          )
        }
        return s.enable(s.load()), s
      }
      r.exports = t
    }
  }),
  mt = te({
    'node_modules/debug/src/browser.js'(e, r) {
      V(),
        F(),
        (e.formatArgs = n),
        (e.save = i),
        (e.load = s),
        (e.useColors = t),
        (e.storage = u()),
        (e.destroy = (() => {
          let l = !1
          return () => {
            l ||
              ((l = !0),
              console.warn(
                'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
              ))
          }
        })()),
        (e.colors = [
          '#0000CC',
          '#0000FF',
          '#0033CC',
          '#0033FF',
          '#0066CC',
          '#0066FF',
          '#0099CC',
          '#0099FF',
          '#00CC00',
          '#00CC33',
          '#00CC66',
          '#00CC99',
          '#00CCCC',
          '#00CCFF',
          '#3300CC',
          '#3300FF',
          '#3333CC',
          '#3333FF',
          '#3366CC',
          '#3366FF',
          '#3399CC',
          '#3399FF',
          '#33CC00',
          '#33CC33',
          '#33CC66',
          '#33CC99',
          '#33CCCC',
          '#33CCFF',
          '#6600CC',
          '#6600FF',
          '#6633CC',
          '#6633FF',
          '#66CC00',
          '#66CC33',
          '#9900CC',
          '#9900FF',
          '#9933CC',
          '#9933FF',
          '#99CC00',
          '#99CC33',
          '#CC0000',
          '#CC0033',
          '#CC0066',
          '#CC0099',
          '#CC00CC',
          '#CC00FF',
          '#CC3300',
          '#CC3333',
          '#CC3366',
          '#CC3399',
          '#CC33CC',
          '#CC33FF',
          '#CC6600',
          '#CC6633',
          '#CC9900',
          '#CC9933',
          '#CCCC00',
          '#CCCC33',
          '#FF0000',
          '#FF0033',
          '#FF0066',
          '#FF0099',
          '#FF00CC',
          '#FF00FF',
          '#FF3300',
          '#FF3333',
          '#FF3366',
          '#FF3399',
          '#FF33CC',
          '#FF33FF',
          '#FF6600',
          '#FF6633',
          '#FF9900',
          '#FF9933',
          '#FFCC00',
          '#FFCC33'
        ])
      function t() {
        return typeof window != 'undefined' &&
          window.process &&
          (window.process.type === 'renderer' || window.process.__nwjs)
          ? !0
          : typeof navigator != 'undefined' &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
          ? !1
          : (typeof document != 'undefined' &&
              document.documentElement &&
              document.documentElement.style &&
              document.documentElement.style.WebkitAppearance) ||
            (typeof window != 'undefined' &&
              window.console &&
              (window.console.firebug || (window.console.exception && window.console.table))) ||
            (typeof navigator != 'undefined' &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &&
              parseInt(RegExp.$1, 10) >= 31) ||
            (typeof navigator != 'undefined' &&
              navigator.userAgent &&
              navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      }
      function n(l) {
        if (
          ((l[0] =
            (this.useColors ? '%c' : '') +
            this.namespace +
            (this.useColors ? ' %c' : ' ') +
            l[0] +
            (this.useColors ? '%c ' : ' ') +
            '+' +
            r.exports.humanize(this.diff)),
          !this.useColors)
        )
          return
        let a = 'color: ' + this.color
        l.splice(1, 0, a, 'color: inherit')
        let c = 0,
          f = 0
        l[0].replace(/%[a-zA-Z%]/g, (p) => {
          p !== '%%' && (c++, p === '%c' && (f = c))
        }),
          l.splice(f, 0, a)
      }
      e.log = console.debug || console.log || (() => {})
      function i(l) {
        try {
          l ? e.storage.setItem('debug', l) : e.storage.removeItem('debug')
        } catch (a) {}
      }
      function s() {
        let l
        try {
          l = e.storage.getItem('debug')
        } catch (a) {}
        return !l && typeof lt != 'undefined' && 'env' in lt && (l = lt.env.DEBUG), l
      }
      function u() {
        try {
          return localStorage
        } catch (l) {}
      }
      r.exports = QB()(e)
      var { formatters: o } = r.exports
      o.j = function (l) {
        try {
          return JSON.stringify(l)
        } catch (a) {
          return '[UnexpectedJSONParseError]: ' + a.message
        }
      }
    }
  }),
  b3 = te({
    'node_modules/is-electron/index.js'(e, r) {
      V(), F()
      function t() {
        return (
          (typeof window != 'undefined' && typeof window.process == 'object' && window.process.type === 'renderer') ||
          (typeof lt != 'undefined' && typeof lt.versions == 'object' && !!lt.versions.electron) ||
          (typeof navigator == 'object' &&
            typeof navigator.userAgent == 'string' &&
            navigator.userAgent.indexOf('Electron') >= 0)
        )
      }
      r.exports = t
    }
  }),
  eN = te({
    'node_modules/ipfs-utils/src/env.js'(e, r) {
      V(), F()
      var t = b3(),
        n = typeof window == 'object' && typeof document == 'object' && document.nodeType === 9,
        i = t(),
        s = n && !i,
        u = i && !n,
        o = i && n,
        l =
          typeof c0 == 'function' &&
          typeof lt != 'undefined' &&
          typeof lt.release != 'undefined' &&
          lt.release.name === 'node' &&
          !i,
        a =
          typeof importScripts == 'function' &&
          typeof self != 'undefined' &&
          typeof WorkerGlobalScope != 'undefined' &&
          self instanceof WorkerGlobalScope,
        c = typeof lt != 'undefined' && typeof lt.env != 'undefined' && !1,
        f = typeof navigator != 'undefined' && navigator.product === 'ReactNative'
      r.exports = {
        isTest: c,
        isElectron: i,
        isElectronMain: u,
        isElectronRenderer: o,
        isNode: l,
        isBrowser: s,
        isWebWorker: a,
        isEnvWithDom: n,
        isReactNative: f
      }
    }
  }),
  tN = te({
    'node_modules/libp2p-websockets/src/listener.browser.js'(e, r) {
      V(),
        F(),
        (r.exports = function () {
          throw new Error('WebSocket Servers can not be created in the browser!')
        })
    }
  }),
  y3 = te({
    'node_modules/libp2p-websockets/src/constants.js'(e) {
      V(),
        F(),
        (e.CODE_P2P = 421),
        (e.CODE_CIRCUIT = 290),
        (e.CODE_TCP = 6),
        (e.CODE_WS = 477),
        (e.CODE_WSS = 478),
        (e.CLOSE_TIMEOUT = 2e3)
    }
  })
function rN(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var v3,
  g3,
  w3,
  nN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (v3 = rN), (g3 = v3), (w3 = g3)
    }
  }),
  _3 = {}
Re(_3, {
  coerce: () => ms,
  empty: () => $0,
  equals: () => G0,
  fromHex: () => S3,
  fromString: () => W0,
  isBinary: () => A3,
  toHex: () => E3,
  toString: () => J0
})
var $0,
  E3,
  S3,
  G0,
  ms,
  A3,
  W0,
  J0,
  bs = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        ($0 = new Uint8Array(0)),
        (E3 = (e) => e.reduce((r, t) => r + t.toString(16).padStart(2, '0'), '')),
        (S3 = (e) => {
          let r = e.match(/../g)
          return r ? new Uint8Array(r.map((t) => parseInt(t, 16))) : $0
        }),
        (G0 = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (ms = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (A3 = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e)),
        (W0 = (e) => new TextEncoder().encode(e)),
        (J0 = (e) => new TextDecoder().decode(e))
    }
  }),
  I3,
  T3,
  X0,
  C3,
  Hl,
  Co,
  k3,
  M3,
  fr,
  ri = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        nN(),
        bs(),
        (I3 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (T3 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new X0(r)
          }
        }),
        (X0 = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new X0({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (C3 = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new I3(e, r, t)),
              (this.decoder = new T3(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (Hl = ({ name: e, prefix: r, encode: t, decode: n }) => new C3(e, r, t, n)),
        (Co = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = w3(t, r)
          return Hl({ prefix: e, name: r, encode: n, decode: (s) => ms(i(s)) })
        }),
        (k3 = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (M3 = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (fr = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          Hl({
            prefix: r,
            name: e,
            encode(i) {
              return M3(i, n, t)
            },
            decode(i) {
              return k3(i, n, t, e)
            }
          }))
    }
  }),
  x3 = {}
Re(x3, { identity: () => R3 })
var R3,
  iN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), ri(), bs(), (R3 = Hl({ prefix: '\0', name: 'identity', encode: (e) => J0(e), decode: (e) => W0(e) }))
    }
  }),
  B3 = {}
Re(B3, { base2: () => N3 })
var N3,
  sN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), ri(), (N3 = fr({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  P3 = {}
Re(P3, { base8: () => O3 })
var O3,
  oN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), ri(), (O3 = fr({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  D3 = {}
Re(D3, { base10: () => L3 })
var L3,
  aN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), ri(), (L3 = Co({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  U3 = {}
Re(U3, { base16: () => q3, base16upper: () => j3 })
var q3,
  j3,
  cN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        ri(),
        (q3 = fr({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (j3 = fr({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  z3 = {}
Re(z3, {
  base32: () => ko,
  base32hex: () => H3,
  base32hexpad: () => G3,
  base32hexpadupper: () => W3,
  base32hexupper: () => $3,
  base32pad: () => F3,
  base32padupper: () => V3,
  base32upper: () => K3,
  base32z: () => J3
})
var ko,
  K3,
  F3,
  V3,
  H3,
  $3,
  G3,
  W3,
  J3,
  X3 = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        ri(),
        (ko = fr({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (K3 = fr({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (F3 = fr({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (V3 = fr({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (H3 = fr({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        ($3 = fr({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (G3 = fr({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (W3 = fr({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (J3 = fr({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  Y3 = {}
Re(Y3, { base36: () => Z3, base36upper: () => Q3 })
var Z3,
  Q3,
  uN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        ri(),
        (Z3 = Co({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (Q3 = Co({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  e5 = {}
Re(e5, { base58btc: () => Dn, base58flickr: () => t5 })
var Dn,
  t5,
  r5 = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        ri(),
        (Dn = Co({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (t5 = Co({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  n5 = {}
Re(n5, { base64: () => i5, base64pad: () => s5, base64url: () => o5, base64urlpad: () => a5 })
var i5,
  s5,
  o5,
  a5,
  lN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        ri(),
        (i5 = fr({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (s5 = fr({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (o5 = fr({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (a5 = fr({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function c5(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= d5; ) (r[t++] = (e & 255) | Z0), (e /= 128)
  for (; e & f5; ) (r[t++] = (e & 255) | Z0), (e >>>= 7)
  return (r[t] = e | 0), (c5.bytes = t - n + 1), r
}
function Y0(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((Y0.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & Q0) << n : (s & Q0) * Math.pow(2, n)), (n += 7)
  } while (s >= p5)
  return (Y0.bytes = i - r), t
}
var u5,
  Z0,
  l5,
  f5,
  d5,
  h5,
  p5,
  Q0,
  m5,
  b5,
  y5,
  v5,
  g5,
  w5,
  _5,
  E5,
  S5,
  A5,
  I5,
  T5,
  wc,
  fN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        (u5 = c5),
        (Z0 = 128),
        (l5 = 127),
        (f5 = ~l5),
        (d5 = Math.pow(2, 31)),
        (h5 = Y0),
        (p5 = 128),
        (Q0 = 127),
        (m5 = Math.pow(2, 7)),
        (b5 = Math.pow(2, 14)),
        (y5 = Math.pow(2, 21)),
        (v5 = Math.pow(2, 28)),
        (g5 = Math.pow(2, 35)),
        (w5 = Math.pow(2, 42)),
        (_5 = Math.pow(2, 49)),
        (E5 = Math.pow(2, 56)),
        (S5 = Math.pow(2, 63)),
        (A5 = function (e) {
          return e < m5
            ? 1
            : e < b5
            ? 2
            : e < y5
            ? 3
            : e < v5
            ? 4
            : e < g5
            ? 5
            : e < w5
            ? 6
            : e < _5
            ? 7
            : e < E5
            ? 8
            : e < S5
            ? 9
            : 10
        }),
        (I5 = { encode: u5, decode: h5, encodingLength: A5 }),
        (T5 = I5),
        (wc = T5)
    }
  }),
  C5 = {}
Re(C5, { decode: () => _c, encodeTo: () => Mo, encodingLength: () => xo })
var _c,
  Mo,
  xo,
  ep = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        fN(),
        (_c = (e) => [wc.decode(e), wc.decode.bytes]),
        (Mo = (e, r, t = 0) => (wc.encode(e, r, t), r)),
        (xo = (e) => wc.encodingLength(e))
    }
  }),
  k5 = {}
Re(k5, { Digest: () => Ec, create: () => $l, decode: () => tp, equals: () => rp })
var $l,
  tp,
  rp,
  Ec,
  np = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        bs(),
        ep(),
        ($l = (e, r) => {
          let t = r.byteLength,
            n = xo(e),
            i = n + xo(t),
            s = new Uint8Array(i + t)
          return Mo(e, s, 0), Mo(t, s, n), s.set(r, i), new Ec(e, t, r, s)
        }),
        (tp = (e) => {
          let r = ms(e),
            [t, n] = _c(r),
            [i, s] = _c(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new Ec(t, i, u, r)
        }),
        (rp = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && G0(e.bytes, r.bytes))),
        (Ec = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  M5 = {}
Re(M5, { Hasher: () => ip, from: () => Sc })
var Sc,
  ip,
  sp = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        np(),
        (Sc = ({ name: e, code: r, encode: t }) => new ip(e, r, t)),
        (ip = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return $l(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  x5 = {}
Re(x5, { sha256: () => R5, sha512: () => B5 })
var op,
  R5,
  B5,
  dN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        sp(),
        (op = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (R5 = Sc({ name: 'sha2-256', code: 18, encode: op('SHA-256') })),
        (B5 = Sc({ name: 'sha2-512', code: 19, encode: op('SHA-512') }))
    }
  }),
  N5 = {}
Re(N5, { identity: () => P5 })
var P5,
  hN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), sp(), bs(), (P5 = Sc({ name: 'identity', code: 0, encode: (e) => ms(e) }))
    }
  }),
  O5 = {}
Re(O5, { code: () => L5, decode: () => q5, encode: () => U5, name: () => D5 })
var ap,
  D5,
  L5,
  U5,
  q5,
  pN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(),
        F(),
        bs(),
        (ap = (e) => ms(e)),
        ({ name: D5, code: L5, encode: U5, decode: q5 } = { name: 'raw', code: 85, decode: ap, encode: ap })
    }
  }),
  j5 = {}
Re(j5, { code: () => K5, decode: () => V5, encode: () => F5, name: () => z5 })
var z5,
  K5,
  F5,
  V5,
  mN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(),
        F(),
        ({
          name: z5,
          code: K5,
          encode: F5,
          decode: V5
        } = {
          name: 'json',
          code: 512,
          encode: (e) => new TextEncoder().encode(JSON.stringify(e)),
          decode: (e) => JSON.parse(new TextDecoder().decode(e))
        })
    }
  }),
  Mr,
  H5,
  $5,
  G5,
  Ro,
  W5,
  cp,
  up,
  Ac,
  Ic,
  J5,
  X5,
  Y5,
  bN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        ep(),
        np(),
        r5(),
        X3(),
        bs(),
        (Mr = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: Ic,
                byteLength: Ic,
                code: Ac,
                version: Ac,
                multihash: Ac,
                bytes: Ac,
                _baseCache: Ic,
                asCID: Ic
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== Ro) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== W5) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return Mr.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = $l(e, r)
                return Mr.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && rp(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return $5(r, n, e || Dn.encoder)
              default:
                return G5(r, n, e || ko.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return X5(/^0\.0/, Y5), !!(e && (e[up] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof Mr) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new Mr(r, t, n, i || cp(r, t, n.bytes))
            } else if (e != null && e[up] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = tp(t)
              return Mr.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== Ro) throw new Error(`Version 0 CID must use dag-pb (code: ${Ro}) block encoding`)
                return new Mr(e, r, t, t.bytes)
              }
              case 1: {
                let n = cp(e, r, t.bytes)
                return new Mr(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return Mr.create(0, Ro, e)
          }
          static createV1(e, r) {
            return Mr.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = Mr.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = Mr.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = ms(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new Ec(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? Mr.createV0(s) : Mr.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = _c(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = Ro
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = H5(e, r),
              i = Mr.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (H5 = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || Dn
              return [Dn.prefix, t.decode(`${Dn.prefix}${e}`)]
            }
            case Dn.prefix: {
              let t = r || Dn
              return [Dn.prefix, t.decode(e)]
            }
            case ko.prefix: {
              let t = r || ko
              return [ko.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        ($5 = (e, r, t) => {
          let { prefix: n } = t
          if (n !== Dn.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (G5 = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (Ro = 112),
        (W5 = 18),
        (cp = (e, r, t) => {
          let n = xo(e),
            i = n + xo(r),
            s = new Uint8Array(i + t.byteLength)
          return Mo(e, s, 0), Mo(r, s, n), s.set(t, i), s
        }),
        (up = Symbol.for('@ipld/js-cid/CID')),
        (Ac = { writable: !1, configurable: !1, enumerable: !0 }),
        (Ic = { writable: !1, enumerable: !1, configurable: !1 }),
        (J5 = '0.0.0-dev'),
        (X5 = (e, r) => {
          if (e.test(J5)) console.warn(r)
          else throw new Error(r)
        }),
        (Y5 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  yN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), bN(), ep(), bs(), sp(), np()
    }
  }),
  Z5 = {}
Re(Z5, {
  CID: () => Mr,
  bases: () => Q5,
  bytes: () => _3,
  codecs: () => tw,
  digest: () => k5,
  hasher: () => M5,
  hashes: () => ew,
  varint: () => C5
})
var Q5,
  ew,
  tw,
  vN = Ie({
    'node_modules/libp2p-utils/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        iN(),
        sN(),
        oN(),
        aN(),
        cN(),
        X3(),
        uN(),
        r5(),
        lN(),
        dN(),
        hN(),
        pN(),
        mN(),
        yN(),
        (Q5 = { ...x3, ...B3, ...P3, ...D3, ...U3, ...z3, ...Y3, ...e5, ...n5 }),
        (ew = { ...x5, ...N5 }),
        (tw = { raw: O5, json: j5 })
    }
  }),
  rw = te({
    'node_modules/libp2p-utils/node_modules/uint8arrays/util/bases.js'(e, r) {
      V(), F()
      var { bases: t } = (vN(), Z5)
      function n(o, l, a, c) {
        return { name: o, prefix: l, encoder: { name: o, prefix: l, encode: a }, decoder: { decode: c } }
      }
      var i = n(
          'utf8',
          'u',
          (o) => {
            let l = new TextDecoder('utf8')
            return 'u' + l.decode(o)
          },
          (o) => new TextEncoder().encode(o.substring(1))
        ),
        s = n(
          'ascii',
          'a',
          (o) => {
            let l = 'a'
            for (let a = 0; a < o.length; a++) l += String.fromCharCode(o[a])
            return l
          },
          (o) => {
            o = o.substring(1)
            let l = new Uint8Array(o.length)
            for (let a = 0; a < o.length; a++) l[a] = o.charCodeAt(a)
            return l
          }
        ),
        u = { utf8: i, 'utf-8': i, hex: t.base16, latin1: s, ascii: s, binary: s, ...t }
      r.exports = u
    }
  }),
  Gl = te({
    'node_modules/libp2p-utils/node_modules/uint8arrays/to-string.js'(e, r) {
      V(), F()
      var t = rw()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.encoder.encode(i).substring(1)
      }
      r.exports = n
    }
  }),
  gN = te({
    'node_modules/libp2p-utils/node_modules/multiaddr/src/ip.js'(e, r) {
      V(), F()
      var t = yo(),
        n = Gl(),
        i = t,
        s = t.v4,
        u = t.v6,
        o = function (a, c, f) {
          f = ~~f
          let p
          if (s(a))
            (p = c || new Uint8Array(f + 4)),
              a.split(/\./g).map(function (d) {
                p[f++] = parseInt(d, 10) & 255
              })
          else if (u(a)) {
            let d = a.split(':', 8),
              h
            for (h = 0; h < d.length; h++) {
              let m = s(d[h])
              var y
              m && ((y = o(d[h])), (d[h] = n(y.slice(0, 2), 'base16'))),
                y && ++h < 8 && d.splice(h, 0, n(y.slice(2, 4), 'base16'))
            }
            if (d[0] === '') for (; d.length < 8; ) d.unshift('0')
            else if (d[d.length - 1] === '') for (; d.length < 8; ) d.push('0')
            else if (d.length < 8) {
              for (h = 0; h < d.length && d[h] !== ''; h++);
              let m = [h, '1']
              for (h = 9 - d.length; h > 0; h--) m.push('0')
              d.splice.apply(d, m)
            }
            for (p = c || new Uint8Array(f + 16), h = 0; h < d.length; h++) {
              let m = parseInt(d[h], 16)
              ;(p[f++] = (m >> 8) & 255), (p[f++] = m & 255)
            }
          }
          if (!p) throw Error('Invalid ip address: ' + a)
          return p
        },
        l = function (a, c, f) {
          ;(c = ~~c), (f = f || a.length - c)
          let p = [],
            y,
            d = new DataView(a.buffer)
          if (f === 4) {
            for (let h = 0; h < f; h++) p.push(a[c + h])
            y = p.join('.')
          } else if (f === 16) {
            for (let h = 0; h < f; h += 2) p.push(d.getUint16(c + h).toString(16))
            ;(y = p.join(':')), (y = y.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')), (y = y.replace(/:{3,4}/, '::'))
          }
          return y
        }
      r.exports = { isIP: i, isV4: s, isV6: u, toBytes: o, toString: l }
    }
  }),
  lp = te({
    'node_modules/libp2p-utils/node_modules/multiaddr/src/protocols-table.js'(e, r) {
      V(), F()
      function t(s) {
        if (typeof s == 'number') {
          if (t.codes[s]) return t.codes[s]
          throw new Error('no protocol with code: ' + s)
        } else if (typeof s == 'string') {
          if (t.names[s]) return t.names[s]
          throw new Error('no protocol with name: ' + s)
        }
        throw new Error('invalid protocol id type: ' + s)
      }
      var n = -1
      ;(t.lengthPrefixedVarSize = n),
        (t.V = n),
        (t.table = [
          [4, 32, 'ip4'],
          [6, 16, 'tcp'],
          [33, 16, 'dccp'],
          [41, 128, 'ip6'],
          [42, n, 'ip6zone'],
          [53, n, 'dns', 'resolvable'],
          [54, n, 'dns4', 'resolvable'],
          [55, n, 'dns6', 'resolvable'],
          [56, n, 'dnsaddr', 'resolvable'],
          [132, 16, 'sctp'],
          [273, 16, 'udp'],
          [275, 0, 'p2p-webrtc-star'],
          [276, 0, 'p2p-webrtc-direct'],
          [277, 0, 'p2p-stardust'],
          [290, 0, 'p2p-circuit'],
          [301, 0, 'udt'],
          [302, 0, 'utp'],
          [400, n, 'unix', !1, 'path'],
          [421, n, 'ipfs'],
          [421, n, 'p2p'],
          [443, 0, 'https'],
          [444, 96, 'onion'],
          [445, 296, 'onion3'],
          [446, n, 'garlic64'],
          [460, 0, 'quic'],
          [477, 0, 'ws'],
          [478, 0, 'wss'],
          [479, 0, 'p2p-websocket-star'],
          [480, 0, 'http'],
          [777, n, 'memory']
        ]),
        (t.names = {}),
        (t.codes = {}),
        t.table.map((s) => {
          let u = i.apply(null, s)
          return (t.codes[u.code] = u), (t.names[u.name] = u), null
        }),
        (t.object = i)
      function i(s, u, o, l, a) {
        return { code: s, size: u, name: o, resolvable: Boolean(l), path: Boolean(a) }
      }
      r.exports = t
    }
  }),
  wN = te({
    'node_modules/libp2p-utils/node_modules/uint8arrays/from-string.js'(e, r) {
      V(), F()
      var t = rw()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.decoder.decode(`${u.prefix}${i}`)
      }
      r.exports = n
    }
  }),
  nw = te({
    'node_modules/libp2p-utils/node_modules/uint8arrays/concat.js'(e, r) {
      V(), F()
      function t(n, i) {
        i || (i = n.reduce((o, l) => o + l.length, 0))
        let s = new Uint8Array(i),
          u = 0
        for (let o of n) s.set(o, u), (u += o.length)
        return s
      }
      r.exports = t
    }
  }),
  _N = te({
    'node_modules/libp2p-utils/node_modules/multiaddr/src/convert.js'(e, r) {
      V(), F()
      var t = gN(),
        n = lp(),
        i = Gr(),
        s = Di(),
        u = $t(),
        o = Gl(),
        l = wN(),
        a = nw()
      r.exports = c
      function c(w, v) {
        return v instanceof Uint8Array ? c.toString(w, v) : c.toBytes(w, v)
      }
      ;(c.toString = function (v, I) {
        switch (n(v).code) {
          case 4:
          case 41:
            return p(I)
          case 6:
          case 273:
          case 33:
          case 132:
            return d(I).toString()
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return m(I)
          case 421:
            return A(I)
          case 444:
            return k(I)
          case 445:
            return k(I)
          default:
            return o(I, 'base16')
        }
      }),
        (c.toBytes = function (v, I) {
          switch (n(v).code) {
            case 4:
              return f(I)
            case 41:
              return f(I)
            case 6:
            case 273:
            case 33:
            case 132:
              return y(parseInt(I, 10))
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return h(I)
            case 421:
              return _(I)
            case 444:
              return T(I)
            case 445:
              return E(I)
            default:
              return l(I, 'base16')
          }
        })
      function f(w) {
        if (!t.isIP(w)) throw new Error('invalid ip address')
        return t.toBytes(w)
      }
      function p(w) {
        let v = t.toString(w)
        if (!v || !t.isIP(v)) throw new Error('invalid ip address')
        return v
      }
      function y(w) {
        let v = new ArrayBuffer(2)
        return new DataView(v).setUint16(0, w), new Uint8Array(v)
      }
      function d(w) {
        return new DataView(w.buffer).getUint16(w.byteOffset)
      }
      function h(w) {
        let v = l(w),
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function m(w) {
        let v = u.decode(w)
        if (((w = w.slice(u.decode.bytes)), w.length !== v)) throw new Error('inconsistent lengths')
        return o(w)
      }
      function _(w) {
        let v = new i(w).multihash,
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function A(w) {
        let v = u.decode(w),
          I = w.slice(u.decode.bytes)
        if (I.length !== v) throw new Error('inconsistent lengths')
        return o(I, 'base58btc')
      }
      function T(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 16) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function E(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 56) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion3 address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function k(w) {
        let v = w.slice(0, w.length - 2),
          I = w.slice(w.length - 2),
          M = o(v, 'base32'),
          q = d(I)
        return M + ':' + q
      }
    }
  }),
  EN = te({
    'node_modules/libp2p-utils/node_modules/multiaddr/src/codec.js'(e, r) {
      V(), F()
      var t = _N(),
        n = lp(),
        i = $t(),
        s = nw(),
        u = Gl()
      r.exports = {
        stringToStringTuples: o,
        stringTuplesToString: l,
        tuplesToStringTuples: c,
        stringTuplesToTuples: a,
        bytesToTuples: y,
        tuplesToBytes: f,
        bytesToString: d,
        stringToBytes: h,
        fromString: m,
        fromBytes: _,
        validateBytes: A,
        isValidBytes: T,
        cleanPath: E,
        ParseError: k,
        protoFromTuple: w,
        sizeForAddr: p
      }
      function o(v) {
        let I = [],
          M = v.split('/').slice(1)
        if (M.length === 1 && M[0] === '') return []
        for (let q = 0; q < M.length; q++) {
          let G = M[q],
            O = n(G)
          if (O.size === 0) {
            I.push([G])
            continue
          }
          if ((q++, q >= M.length)) throw k('invalid address: ' + v)
          if (O.path) {
            I.push([G, E(M.slice(q).join('/'))])
            break
          }
          I.push([G, M[q]])
        }
        return I
      }
      function l(v) {
        let I = []
        return (
          v.map((M) => {
            let q = w(M)
            return I.push(q.name), M.length > 1 && I.push(M[1]), null
          }),
          E(I.join('/'))
        )
      }
      function a(v) {
        return v.map((I) => {
          Array.isArray(I) || (I = [I])
          let M = w(I)
          return I.length > 1 ? [M.code, t.toBytes(M.code, I[1])] : [M.code]
        })
      }
      function c(v) {
        return v.map((I) => {
          let M = w(I)
          return I[1] ? [M.code, t.toString(M.code, I[1])] : [M.code]
        })
      }
      function f(v) {
        return _(
          s(
            v.map((I) => {
              let M = w(I),
                q = Uint8Array.from(i.encode(M.code))
              return I.length > 1 && (q = s([q, I[1]])), q
            })
          )
        )
      }
      function p(v, I) {
        return v.size > 0 ? v.size / 8 : v.size === 0 ? 0 : i.decode(I) + i.decode.bytes
      }
      function y(v) {
        let I = [],
          M = 0
        for (; M < v.length; ) {
          let q = i.decode(v, M),
            G = i.decode.bytes,
            O = n(q),
            x = p(O, v.slice(M + G))
          if (x === 0) {
            I.push([q]), (M += G)
            continue
          }
          let L = v.slice(M + G, M + G + x)
          if (((M += x + G), M > v.length)) throw k('Invalid address Uint8Array: ' + u(v, 'base16'))
          I.push([q, L])
        }
        return I
      }
      function d(v) {
        let I = y(v),
          M = c(I)
        return l(M)
      }
      function h(v) {
        v = E(v)
        let I = o(v),
          M = a(I)
        return f(M)
      }
      function m(v) {
        return h(v)
      }
      function _(v) {
        let I = A(v)
        if (I) throw I
        return Uint8Array.from(v)
      }
      function A(v) {
        try {
          y(v)
        } catch (I) {
          return I
        }
      }
      function T(v) {
        return A(v) === void 0
      }
      function E(v) {
        return (
          '/' +
          v
            .trim()
            .split('/')
            .filter((I) => I)
            .join('/')
        )
      }
      function k(v) {
        return new Error('Error parsing address: ' + v)
      }
      function w(v) {
        return n(v[0])
      }
    }
  }),
  SN = te({
    'node_modules/libp2p-utils/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  }),
  AN = te({
    'node_modules/libp2p-utils/node_modules/multiaddr/src/index.js'(e, r) {
      V(), F()
      var t = EN(),
        n = lp(),
        i = $t(),
        s = Gr(),
        u = pt(),
        o = Symbol.for('nodejs.util.inspect.custom'),
        l = Gl(),
        a = SN(),
        c = new Map(),
        f = Symbol.for('@multiformats/js-multiaddr/multiaddr'),
        p = class {
          constructor(d) {
            if ((d == null && (d = ''), Object.defineProperty(this, f, { value: !0 }), d instanceof Uint8Array))
              this.bytes = t.fromBytes(d)
            else if (typeof d == 'string') {
              if (d.length > 0 && d.charAt(0) !== '/') throw new Error(`multiaddr "${d}" must start with a "/"`)
              this.bytes = t.fromString(d)
            } else if (p.isMultiaddr(d)) this.bytes = t.fromBytes(d.bytes)
            else throw new Error('addr must be a string, Buffer, or another Multiaddr')
          }
          toString() {
            return t.bytesToString(this.bytes)
          }
          toJSON() {
            return this.toString()
          }
          toOptions() {
            let d = {},
              h = this.toString().split('/')
            return (
              (d.family = h[1] === 'ip4' ? 4 : 6), (d.host = h[2]), (d.transport = h[3]), (d.port = parseInt(h[4])), d
            )
          }
          protos() {
            return this.protoCodes().map((d) => Object.assign({}, n(d)))
          }
          protoCodes() {
            let d = [],
              h = this.bytes,
              m = 0
            for (; m < h.length; ) {
              let _ = i.decode(h, m),
                A = i.decode.bytes,
                T = n(_)
              ;(m += t.sizeForAddr(T, h.slice(m + A)) + A), d.push(_)
            }
            return d
          }
          protoNames() {
            return this.protos().map((d) => d.name)
          }
          tuples() {
            return t.bytesToTuples(this.bytes)
          }
          stringTuples() {
            let d = t.bytesToTuples(this.bytes)
            return t.tuplesToStringTuples(d)
          }
          encapsulate(d) {
            return (d = new p(d)), new p(this.toString() + d.toString())
          }
          decapsulate(d) {
            let h = d.toString(),
              m = this.toString(),
              _ = m.lastIndexOf(h)
            if (_ < 0) throw new Error('Address ' + this + ' does not contain subaddress: ' + d)
            return new p(m.slice(0, _))
          }
          decapsulateCode(d) {
            let h = this.tuples()
            for (let m = h.length - 1; m >= 0; m--) if (h[m][0] === d) return new p(t.tuplesToBytes(h.slice(0, m)))
            return this
          }
          getPeerId() {
            try {
              let h = this.stringTuples()
                .filter((m) => m[0] === n.names.ipfs.code)
                .pop()
              return h && h[1] ? l(new s(h[1]).multihash, 'base58btc') : null
            } catch (d) {
              return null
            }
          }
          getPath() {
            let d = null
            try {
              ;(d = this.stringTuples().filter((h) => !!n(h[0]).path)[0][1]), d || (d = null)
            } catch (h) {
              d = null
            }
            return d
          }
          equals(d) {
            return a(this.bytes, d.bytes)
          }
          async resolve() {
            let d = this.protos().find((_) => _.resolvable)
            if (!d) return [this]
            let h = c.get(d.name)
            if (!h) throw u(new Error(`no available resolver for ${d.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
            return (await h(this)).map((_) => new p(_))
          }
          nodeAddress() {
            let d = this.protoCodes(),
              h = this.protoNames(),
              m = this.toString().split('/').slice(1)
            if (m.length < 4)
              throw new Error(
                'multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'
              )
            if (d[0] !== 4 && d[0] !== 41 && d[0] !== 54 && d[0] !== 55)
              throw new Error(
                `no protocol with name: "'${h[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`
              )
            if (m[2] !== 'tcp' && m[2] !== 'udp')
              throw new Error(`no protocol with name: "'${h[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
            return { family: d[0] === 41 || d[0] === 55 ? 6 : 4, address: m[1], port: parseInt(m[3]) }
          }
          isThinWaistAddress(d) {
            let h = (d || this).protos()
            return !(h.length !== 2 || (h[0].code !== 4 && h[0].code !== 41) || (h[1].code !== 6 && h[1].code !== 273))
          }
          static fromNodeAddress(d, h) {
            if (!d) throw new Error('requires node address object')
            if (!h) throw new Error('requires transport protocol')
            let m
            switch (d.family) {
              case 4:
                m = 'ip4'
                break
              case 6:
                m = 'ip6'
                break
              default:
                throw Error(`Invalid addr family. Got '${d.family}' instead of 4 or 6`)
            }
            return new p('/' + [m, d.address, h, d.port].join('/'))
          }
          static isName(d) {
            return p.isMultiaddr(d) ? d.protos().some((h) => h.resolvable) : !1
          }
          static isMultiaddr(d) {
            return d instanceof p || Boolean(d && d[f])
          }
          [o]() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
          inspect() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
        }
      ;(p.protocols = n), (p.resolvers = c)
      function y(d) {
        return new p(d)
      }
      r.exports = { Multiaddr: p, multiaddr: y, protocols: n, resolvers: c }
    }
  }),
  iw = te({
    'node_modules/ip-address/dist/lib/common.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.isCorrect = e.isInSubnet = void 0)
      function r(n) {
        return this.subnetMask < n.subnetMask ? !1 : this.mask(n.subnetMask) === n.mask()
      }
      e.isInSubnet = r
      function t(n) {
        return function () {
          return this.addressMinusSuffix !== this.correctForm()
            ? !1
            : this.subnetMask === n && !this.parsedSubnet
            ? !0
            : this.parsedSubnet === String(this.subnetMask)
        }
      }
      e.isCorrect = t
    }
  }),
  sw = te({
    'node_modules/ip-address/dist/lib/v4/constants.js'(e) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.RE_SUBNET_STRING = e.RE_ADDRESS = e.GROUPS = e.BITS = void 0),
        (e.BITS = 32),
        (e.GROUPS = 4),
        (e.RE_ADDRESS =
          /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g),
        (e.RE_SUBNET_STRING = /\/\d{1,2}$/)
    }
  }),
  ow = te({
    'node_modules/ip-address/dist/lib/address-error.js'(e) {
      V(), F()
      var r =
        (e && e.__extends) ||
        (function () {
          var n = function (i, s) {
            return (
              (n =
                Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array &&
                  function (u, o) {
                    u.__proto__ = o
                  }) ||
                function (u, o) {
                  for (var l in o) Object.prototype.hasOwnProperty.call(o, l) && (u[l] = o[l])
                }),
              n(i, s)
            )
          }
          return function (i, s) {
            n(i, s)
            function u() {
              this.constructor = i
            }
            i.prototype = s === null ? Object.create(s) : ((u.prototype = s.prototype), new u())
          }
        })()
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.AddressError = void 0)
      var t = (function (n) {
        r(i, n)
        function i(s, u) {
          var o = n.call(this, s) || this
          return (o.name = 'AddressError'), u !== null && (o.parseMessage = u), o
        }
        return i
      })(Error)
      e.AddressError = t
    }
  }),
  aw = te({
    'node_modules/ip-address/node_modules/jsbn/index.js'(e, r) {
      V(),
        F(),
        function () {
          var t,
            n = 244837814094590,
            i = (n & 16777215) == 15715070
          function s(ce, he, ve) {
            ce != null &&
              (typeof ce == 'number'
                ? this.fromNumber(ce, he, ve)
                : he == null && typeof ce != 'string'
                ? this.fromString(ce, 256)
                : this.fromString(ce, he))
          }
          function u() {
            return new s(null)
          }
          function o(ce, he, ve, Ce, qe, ze) {
            for (; --ze >= 0; ) {
              var Je = he * this[ce++] + ve[Ce] + qe
              ;(qe = Math.floor(Je / 67108864)), (ve[Ce++] = Je & 67108863)
            }
            return qe
          }
          function l(ce, he, ve, Ce, qe, ze) {
            for (var Je = he & 32767, rt = he >> 15; --ze >= 0; ) {
              var Ft = this[ce] & 32767,
                ar = this[ce++] >> 15,
                Qr = rt * Ft + ar * Je
              ;(Ft = Je * Ft + ((Qr & 32767) << 15) + ve[Ce] + (qe & 1073741823)),
                (qe = (Ft >>> 30) + (Qr >>> 15) + rt * ar + (qe >>> 30)),
                (ve[Ce++] = Ft & 1073741823)
            }
            return qe
          }
          function a(ce, he, ve, Ce, qe, ze) {
            for (var Je = he & 16383, rt = he >> 14; --ze >= 0; ) {
              var Ft = this[ce] & 16383,
                ar = this[ce++] >> 14,
                Qr = rt * Ft + ar * Je
              ;(Ft = Je * Ft + ((Qr & 16383) << 14) + ve[Ce] + qe),
                (qe = (Ft >> 28) + (Qr >> 14) + rt * ar),
                (ve[Ce++] = Ft & 268435455)
            }
            return qe
          }
          var c = typeof navigator != 'undefined'
          c && i && navigator.appName == 'Microsoft Internet Explorer'
            ? ((s.prototype.am = l), (t = 30))
            : c && i && navigator.appName != 'Netscape'
            ? ((s.prototype.am = o), (t = 26))
            : ((s.prototype.am = a), (t = 28)),
            (s.prototype.DB = t),
            (s.prototype.DM = (1 << t) - 1),
            (s.prototype.DV = 1 << t)
          var f = 52
          ;(s.prototype.FV = Math.pow(2, f)), (s.prototype.F1 = f - t), (s.prototype.F2 = 2 * t - f)
          var p = '0123456789abcdefghijklmnopqrstuvwxyz',
            y = new Array(),
            d,
            h
          for (d = '0'.charCodeAt(0), h = 0; h <= 9; ++h) y[d++] = h
          for (d = 'a'.charCodeAt(0), h = 10; h < 36; ++h) y[d++] = h
          for (d = 'A'.charCodeAt(0), h = 10; h < 36; ++h) y[d++] = h
          function m(ce) {
            return p.charAt(ce)
          }
          function _(ce, he) {
            var ve = y[ce.charCodeAt(he)]
            return ve ?? -1
          }
          function A(ce) {
            for (var he = this.t - 1; he >= 0; --he) ce[he] = this[he]
            ;(ce.t = this.t), (ce.s = this.s)
          }
          function T(ce) {
            ;(this.t = 1),
              (this.s = ce < 0 ? -1 : 0),
              ce > 0 ? (this[0] = ce) : ce < -1 ? (this[0] = ce + this.DV) : (this.t = 0)
          }
          function E(ce) {
            var he = u()
            return he.fromInt(ce), he
          }
          function k(ce, he) {
            var ve
            if (he == 16) ve = 4
            else if (he == 8) ve = 3
            else if (he == 256) ve = 8
            else if (he == 2) ve = 1
            else if (he == 32) ve = 5
            else if (he == 4) ve = 2
            else {
              this.fromRadix(ce, he)
              return
            }
            ;(this.t = 0), (this.s = 0)
            for (var Ce = ce.length, qe = !1, ze = 0; --Ce >= 0; ) {
              var Je = ve == 8 ? ce[Ce] & 255 : _(ce, Ce)
              if (Je < 0) {
                ce.charAt(Ce) == '-' && (qe = !0)
                continue
              }
              ;(qe = !1),
                ze == 0
                  ? (this[this.t++] = Je)
                  : ze + ve > this.DB
                  ? ((this[this.t - 1] |= (Je & ((1 << (this.DB - ze)) - 1)) << ze),
                    (this[this.t++] = Je >> (this.DB - ze)))
                  : (this[this.t - 1] |= Je << ze),
                (ze += ve),
                ze >= this.DB && (ze -= this.DB)
            }
            ve == 8 &&
              (ce[0] & 128) != 0 &&
              ((this.s = -1), ze > 0 && (this[this.t - 1] |= ((1 << (this.DB - ze)) - 1) << ze)),
              this.clamp(),
              qe && s.ZERO.subTo(this, this)
          }
          function w() {
            for (var ce = this.s & this.DM; this.t > 0 && this[this.t - 1] == ce; ) --this.t
          }
          function v(ce) {
            if (this.s < 0) return '-' + this.negate().toString(ce)
            var he
            if (ce == 16) he = 4
            else if (ce == 8) he = 3
            else if (ce == 2) he = 1
            else if (ce == 32) he = 5
            else if (ce == 4) he = 2
            else return this.toRadix(ce)
            var ve = (1 << he) - 1,
              Ce,
              qe = !1,
              ze = '',
              Je = this.t,
              rt = this.DB - ((Je * this.DB) % he)
            if (Je-- > 0)
              for (rt < this.DB && (Ce = this[Je] >> rt) > 0 && ((qe = !0), (ze = m(Ce))); Je >= 0; )
                rt < he
                  ? ((Ce = (this[Je] & ((1 << rt) - 1)) << (he - rt)), (Ce |= this[--Je] >> (rt += this.DB - he)))
                  : ((Ce = (this[Je] >> (rt -= he)) & ve), rt <= 0 && ((rt += this.DB), --Je)),
                  Ce > 0 && (qe = !0),
                  qe && (ze += m(Ce))
            return qe ? ze : '0'
          }
          function I() {
            var ce = u()
            return s.ZERO.subTo(this, ce), ce
          }
          function M() {
            return this.s < 0 ? this.negate() : this
          }
          function q(ce) {
            var he = this.s - ce.s
            if (he != 0) return he
            var ve = this.t
            if (((he = ve - ce.t), he != 0)) return this.s < 0 ? -he : he
            for (; --ve >= 0; ) if ((he = this[ve] - ce[ve]) != 0) return he
            return 0
          }
          function G(ce) {
            var he = 1,
              ve
            return (
              (ve = ce >>> 16) != 0 && ((ce = ve), (he += 16)),
              (ve = ce >> 8) != 0 && ((ce = ve), (he += 8)),
              (ve = ce >> 4) != 0 && ((ce = ve), (he += 4)),
              (ve = ce >> 2) != 0 && ((ce = ve), (he += 2)),
              (ve = ce >> 1) != 0 && ((ce = ve), (he += 1)),
              he
            )
          }
          function O() {
            return this.t <= 0 ? 0 : this.DB * (this.t - 1) + G(this[this.t - 1] ^ (this.s & this.DM))
          }
          function x(ce, he) {
            var ve
            for (ve = this.t - 1; ve >= 0; --ve) he[ve + ce] = this[ve]
            for (ve = ce - 1; ve >= 0; --ve) he[ve] = 0
            ;(he.t = this.t + ce), (he.s = this.s)
          }
          function L(ce, he) {
            for (var ve = ce; ve < this.t; ++ve) he[ve - ce] = this[ve]
            ;(he.t = Math.max(this.t - ce, 0)), (he.s = this.s)
          }
          function K(ce, he) {
            var ve = ce % this.DB,
              Ce = this.DB - ve,
              qe = (1 << Ce) - 1,
              ze = Math.floor(ce / this.DB),
              Je = (this.s << ve) & this.DM,
              rt
            for (rt = this.t - 1; rt >= 0; --rt) (he[rt + ze + 1] = (this[rt] >> Ce) | Je), (Je = (this[rt] & qe) << ve)
            for (rt = ze - 1; rt >= 0; --rt) he[rt] = 0
            ;(he[ze] = Je), (he.t = this.t + ze + 1), (he.s = this.s), he.clamp()
          }
          function J(ce, he) {
            he.s = this.s
            var ve = Math.floor(ce / this.DB)
            if (ve >= this.t) {
              he.t = 0
              return
            }
            var Ce = ce % this.DB,
              qe = this.DB - Ce,
              ze = (1 << Ce) - 1
            he[0] = this[ve] >> Ce
            for (var Je = ve + 1; Je < this.t; ++Je)
              (he[Je - ve - 1] |= (this[Je] & ze) << qe), (he[Je - ve] = this[Je] >> Ce)
            Ce > 0 && (he[this.t - ve - 1] |= (this.s & ze) << qe), (he.t = this.t - ve), he.clamp()
          }
          function Z(ce, he) {
            for (var ve = 0, Ce = 0, qe = Math.min(ce.t, this.t); ve < qe; )
              (Ce += this[ve] - ce[ve]), (he[ve++] = Ce & this.DM), (Ce >>= this.DB)
            if (ce.t < this.t) {
              for (Ce -= ce.s; ve < this.t; ) (Ce += this[ve]), (he[ve++] = Ce & this.DM), (Ce >>= this.DB)
              Ce += this.s
            } else {
              for (Ce += this.s; ve < ce.t; ) (Ce -= ce[ve]), (he[ve++] = Ce & this.DM), (Ce >>= this.DB)
              Ce -= ce.s
            }
            ;(he.s = Ce < 0 ? -1 : 0),
              Ce < -1 ? (he[ve++] = this.DV + Ce) : Ce > 0 && (he[ve++] = Ce),
              (he.t = ve),
              he.clamp()
          }
          function Q(ce, he) {
            var ve = this.abs(),
              Ce = ce.abs(),
              qe = ve.t
            for (he.t = qe + Ce.t; --qe >= 0; ) he[qe] = 0
            for (qe = 0; qe < Ce.t; ++qe) he[qe + ve.t] = ve.am(0, Ce[qe], he, qe, 0, ve.t)
            ;(he.s = 0), he.clamp(), this.s != ce.s && s.ZERO.subTo(he, he)
          }
          function fe(ce) {
            for (var he = this.abs(), ve = (ce.t = 2 * he.t); --ve >= 0; ) ce[ve] = 0
            for (ve = 0; ve < he.t - 1; ++ve) {
              var Ce = he.am(ve, he[ve], ce, 2 * ve, 0, 1)
              ;(ce[ve + he.t] += he.am(ve + 1, 2 * he[ve], ce, 2 * ve + 1, Ce, he.t - ve - 1)) >= he.DV &&
                ((ce[ve + he.t] -= he.DV), (ce[ve + he.t + 1] = 1))
            }
            ce.t > 0 && (ce[ce.t - 1] += he.am(ve, he[ve], ce, 2 * ve, 0, 1)), (ce.s = 0), ce.clamp()
          }
          function ie(ce, he, ve) {
            var Ce = ce.abs()
            if (!(Ce.t <= 0)) {
              var qe = this.abs()
              if (qe.t < Ce.t) {
                he != null && he.fromInt(0), ve != null && this.copyTo(ve)
                return
              }
              ve == null && (ve = u())
              var ze = u(),
                Je = this.s,
                rt = ce.s,
                Ft = this.DB - G(Ce[Ce.t - 1])
              Ft > 0 ? (Ce.lShiftTo(Ft, ze), qe.lShiftTo(Ft, ve)) : (Ce.copyTo(ze), qe.copyTo(ve))
              var ar = ze.t,
                Qr = ze[ar - 1]
              if (Qr != 0) {
                var Wr = Qr * (1 << this.F1) + (ar > 1 ? ze[ar - 2] >> this.F2 : 0),
                  Vn = this.FV / Wr,
                  mu = (1 << this.F1) / Wr,
                  hn = 1 << this.F2,
                  pn = ve.t,
                  bu = pn - ar,
                  pi = he ?? u()
                for (
                  ze.dlShiftTo(bu, pi),
                    ve.compareTo(pi) >= 0 && ((ve[ve.t++] = 1), ve.subTo(pi, ve)),
                    s.ONE.dlShiftTo(ar, pi),
                    pi.subTo(ze, ze);
                  ze.t < ar;

                )
                  ze[ze.t++] = 0
                for (; --bu >= 0; ) {
                  var Ff = ve[--pn] == Qr ? this.DM : Math.floor(ve[pn] * Vn + (ve[pn - 1] + hn) * mu)
                  if ((ve[pn] += ze.am(0, Ff, ve, bu, 0, ar)) < Ff)
                    for (ze.dlShiftTo(bu, pi), ve.subTo(pi, ve); ve[pn] < --Ff; ) ve.subTo(pi, ve)
                }
                he != null && (ve.drShiftTo(ar, he), Je != rt && s.ZERO.subTo(he, he)),
                  (ve.t = ar),
                  ve.clamp(),
                  Ft > 0 && ve.rShiftTo(Ft, ve),
                  Je < 0 && s.ZERO.subTo(ve, ve)
              }
            }
          }
          function W(ce) {
            var he = u()
            return this.abs().divRemTo(ce, null, he), this.s < 0 && he.compareTo(s.ZERO) > 0 && ce.subTo(he, he), he
          }
          function le(ce) {
            this.m = ce
          }
          function xe(ce) {
            return ce.s < 0 || ce.compareTo(this.m) >= 0 ? ce.mod(this.m) : ce
          }
          function _e(ce) {
            return ce
          }
          function Ne(ce) {
            ce.divRemTo(this.m, null, ce)
          }
          function ke(ce, he, ve) {
            ce.multiplyTo(he, ve), this.reduce(ve)
          }
          function oe(ce, he) {
            ce.squareTo(he), this.reduce(he)
          }
          ;(le.prototype.convert = xe),
            (le.prototype.revert = _e),
            (le.prototype.reduce = Ne),
            (le.prototype.mulTo = ke),
            (le.prototype.sqrTo = oe)
          function be() {
            if (this.t < 1) return 0
            var ce = this[0]
            if ((ce & 1) == 0) return 0
            var he = ce & 3
            return (
              (he = (he * (2 - (ce & 15) * he)) & 15),
              (he = (he * (2 - (ce & 255) * he)) & 255),
              (he = (he * (2 - (((ce & 65535) * he) & 65535))) & 65535),
              (he = (he * (2 - ((ce * he) % this.DV))) % this.DV),
              he > 0 ? this.DV - he : -he
            )
          }
          function ge(ce) {
            ;(this.m = ce),
              (this.mp = ce.invDigit()),
              (this.mpl = this.mp & 32767),
              (this.mph = this.mp >> 15),
              (this.um = (1 << (ce.DB - 15)) - 1),
              (this.mt2 = 2 * ce.t)
          }
          function re(ce) {
            var he = u()
            return (
              ce.abs().dlShiftTo(this.m.t, he),
              he.divRemTo(this.m, null, he),
              ce.s < 0 && he.compareTo(s.ZERO) > 0 && this.m.subTo(he, he),
              he
            )
          }
          function j(ce) {
            var he = u()
            return ce.copyTo(he), this.reduce(he), he
          }
          function b(ce) {
            for (; ce.t <= this.mt2; ) ce[ce.t++] = 0
            for (var he = 0; he < this.m.t; ++he) {
              var ve = ce[he] & 32767,
                Ce = (ve * this.mpl + (((ve * this.mph + (ce[he] >> 15) * this.mpl) & this.um) << 15)) & ce.DM
              for (ve = he + this.m.t, ce[ve] += this.m.am(0, Ce, ce, he, 0, this.m.t); ce[ve] >= ce.DV; )
                (ce[ve] -= ce.DV), ce[++ve]++
            }
            ce.clamp(), ce.drShiftTo(this.m.t, ce), ce.compareTo(this.m) >= 0 && ce.subTo(this.m, ce)
          }
          function C(ce, he) {
            ce.squareTo(he), this.reduce(he)
          }
          function S(ce, he, ve) {
            ce.multiplyTo(he, ve), this.reduce(ve)
          }
          ;(ge.prototype.convert = re),
            (ge.prototype.revert = j),
            (ge.prototype.reduce = b),
            (ge.prototype.mulTo = S),
            (ge.prototype.sqrTo = C)
          function R() {
            return (this.t > 0 ? this[0] & 1 : this.s) == 0
          }
          function P(ce, he) {
            if (ce > 4294967295 || ce < 1) return s.ONE
            var ve = u(),
              Ce = u(),
              qe = he.convert(this),
              ze = G(ce) - 1
            for (qe.copyTo(ve); --ze >= 0; )
              if ((he.sqrTo(ve, Ce), (ce & (1 << ze)) > 0)) he.mulTo(Ce, qe, ve)
              else {
                var Je = ve
                ;(ve = Ce), (Ce = Je)
              }
            return he.revert(ve)
          }
          function B(ce, he) {
            var ve
            return ce < 256 || he.isEven() ? (ve = new le(he)) : (ve = new ge(he)), this.exp(ce, ve)
          }
          ;(s.prototype.copyTo = A),
            (s.prototype.fromInt = T),
            (s.prototype.fromString = k),
            (s.prototype.clamp = w),
            (s.prototype.dlShiftTo = x),
            (s.prototype.drShiftTo = L),
            (s.prototype.lShiftTo = K),
            (s.prototype.rShiftTo = J),
            (s.prototype.subTo = Z),
            (s.prototype.multiplyTo = Q),
            (s.prototype.squareTo = fe),
            (s.prototype.divRemTo = ie),
            (s.prototype.invDigit = be),
            (s.prototype.isEven = R),
            (s.prototype.exp = P),
            (s.prototype.toString = v),
            (s.prototype.negate = I),
            (s.prototype.abs = M),
            (s.prototype.compareTo = q),
            (s.prototype.bitLength = O),
            (s.prototype.mod = W),
            (s.prototype.modPowInt = B),
            (s.ZERO = E(0)),
            (s.ONE = E(1))
          function D() {
            var ce = u()
            return this.copyTo(ce), ce
          }
          function $() {
            if (this.s < 0) {
              if (this.t == 1) return this[0] - this.DV
              if (this.t == 0) return -1
            } else {
              if (this.t == 1) return this[0]
              if (this.t == 0) return 0
            }
            return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0]
          }
          function g() {
            return this.t == 0 ? this.s : (this[0] << 24) >> 24
          }
          function N() {
            return this.t == 0 ? this.s : (this[0] << 16) >> 16
          }
          function U(ce) {
            return Math.floor((Math.LN2 * this.DB) / Math.log(ce))
          }
          function X() {
            return this.s < 0 ? -1 : this.t <= 0 || (this.t == 1 && this[0] <= 0) ? 0 : 1
          }
          function ne(ce) {
            if ((ce == null && (ce = 10), this.signum() == 0 || ce < 2 || ce > 36)) return '0'
            var he = this.chunkSize(ce),
              ve = Math.pow(ce, he),
              Ce = E(ve),
              qe = u(),
              ze = u(),
              Je = ''
            for (this.divRemTo(Ce, qe, ze); qe.signum() > 0; )
              (Je = (ve + ze.intValue()).toString(ce).substr(1) + Je), qe.divRemTo(Ce, qe, ze)
            return ze.intValue().toString(ce) + Je
          }
          function ee(ce, he) {
            this.fromInt(0), he == null && (he = 10)
            for (
              var ve = this.chunkSize(he), Ce = Math.pow(he, ve), qe = !1, ze = 0, Je = 0, rt = 0;
              rt < ce.length;
              ++rt
            ) {
              var Ft = _(ce, rt)
              if (Ft < 0) {
                ce.charAt(rt) == '-' && this.signum() == 0 && (qe = !0)
                continue
              }
              ;(Je = he * Je + Ft), ++ze >= ve && (this.dMultiply(Ce), this.dAddOffset(Je, 0), (ze = 0), (Je = 0))
            }
            ze > 0 && (this.dMultiply(Math.pow(he, ze)), this.dAddOffset(Je, 0)), qe && s.ZERO.subTo(this, this)
          }
          function ae(ce, he, ve) {
            if (typeof he == 'number')
              if (ce < 2) this.fromInt(1)
              else
                for (
                  this.fromNumber(ce, ve),
                    this.testBit(ce - 1) || this.bitwiseTo(s.ONE.shiftLeft(ce - 1), Me, this),
                    this.isEven() && this.dAddOffset(1, 0);
                  !this.isProbablePrime(he);

                )
                  this.dAddOffset(2, 0), this.bitLength() > ce && this.subTo(s.ONE.shiftLeft(ce - 1), this)
            else {
              var Ce = new Array(),
                qe = ce & 7
              ;(Ce.length = (ce >> 3) + 1),
                he.nextBytes(Ce),
                qe > 0 ? (Ce[0] &= (1 << qe) - 1) : (Ce[0] = 0),
                this.fromString(Ce, 256)
            }
          }
          function Y() {
            var ce = this.t,
              he = new Array()
            he[0] = this.s
            var ve = this.DB - ((ce * this.DB) % 8),
              Ce,
              qe = 0
            if (ce-- > 0)
              for (
                ve < this.DB &&
                (Ce = this[ce] >> ve) != (this.s & this.DM) >> ve &&
                (he[qe++] = Ce | (this.s << (this.DB - ve)));
                ce >= 0;

              )
                ve < 8
                  ? ((Ce = (this[ce] & ((1 << ve) - 1)) << (8 - ve)), (Ce |= this[--ce] >> (ve += this.DB - 8)))
                  : ((Ce = (this[ce] >> (ve -= 8)) & 255), ve <= 0 && ((ve += this.DB), --ce)),
                  (Ce & 128) != 0 && (Ce |= -256),
                  qe == 0 && (this.s & 128) != (Ce & 128) && ++qe,
                  (qe > 0 || Ce != this.s) && (he[qe++] = Ce)
            return he
          }
          function z(ce) {
            return this.compareTo(ce) == 0
          }
          function H(ce) {
            return this.compareTo(ce) < 0 ? this : ce
          }
          function se(ce) {
            return this.compareTo(ce) > 0 ? this : ce
          }
          function me(ce, he, ve) {
            var Ce,
              qe,
              ze = Math.min(ce.t, this.t)
            for (Ce = 0; Ce < ze; ++Ce) ve[Ce] = he(this[Ce], ce[Ce])
            if (ce.t < this.t) {
              for (qe = ce.s & this.DM, Ce = ze; Ce < this.t; ++Ce) ve[Ce] = he(this[Ce], qe)
              ve.t = this.t
            } else {
              for (qe = this.s & this.DM, Ce = ze; Ce < ce.t; ++Ce) ve[Ce] = he(qe, ce[Ce])
              ve.t = ce.t
            }
            ;(ve.s = he(this.s, ce.s)), ve.clamp()
          }
          function we(ce, he) {
            return ce & he
          }
          function Ee(ce) {
            var he = u()
            return this.bitwiseTo(ce, we, he), he
          }
          function Me(ce, he) {
            return ce | he
          }
          function Be(ce) {
            var he = u()
            return this.bitwiseTo(ce, Me, he), he
          }
          function je(ce, he) {
            return ce ^ he
          }
          function Pe(ce) {
            var he = u()
            return this.bitwiseTo(ce, je, he), he
          }
          function Oe(ce, he) {
            return ce & ~he
          }
          function ht(ce) {
            var he = u()
            return this.bitwiseTo(ce, Oe, he), he
          }
          function Qe() {
            for (var ce = u(), he = 0; he < this.t; ++he) ce[he] = this.DM & ~this[he]
            return (ce.t = this.t), (ce.s = ~this.s), ce
          }
          function et(ce) {
            var he = u()
            return ce < 0 ? this.rShiftTo(-ce, he) : this.lShiftTo(ce, he), he
          }
          function Mt(ce) {
            var he = u()
            return ce < 0 ? this.lShiftTo(-ce, he) : this.rShiftTo(ce, he), he
          }
          function ut(ce) {
            if (ce == 0) return -1
            var he = 0
            return (
              (ce & 65535) == 0 && ((ce >>= 16), (he += 16)),
              (ce & 255) == 0 && ((ce >>= 8), (he += 8)),
              (ce & 15) == 0 && ((ce >>= 4), (he += 4)),
              (ce & 3) == 0 && ((ce >>= 2), (he += 2)),
              (ce & 1) == 0 && ++he,
              he
            )
          }
          function at() {
            for (var ce = 0; ce < this.t; ++ce) if (this[ce] != 0) return ce * this.DB + ut(this[ce])
            return this.s < 0 ? this.t * this.DB : -1
          }
          function Pt(ce) {
            for (var he = 0; ce != 0; ) (ce &= ce - 1), ++he
            return he
          }
          function ft() {
            for (var ce = 0, he = this.s & this.DM, ve = 0; ve < this.t; ++ve) ce += Pt(this[ve] ^ he)
            return ce
          }
          function We(ce) {
            var he = Math.floor(ce / this.DB)
            return he >= this.t ? this.s != 0 : (this[he] & (1 << ce % this.DB)) != 0
          }
          function gt(ce, he) {
            var ve = s.ONE.shiftLeft(ce)
            return this.bitwiseTo(ve, he, ve), ve
          }
          function Ge(ce) {
            return this.changeBit(ce, Me)
          }
          function He(ce) {
            return this.changeBit(ce, Oe)
          }
          function wt(ce) {
            return this.changeBit(ce, je)
          }
          function tt(ce, he) {
            for (var ve = 0, Ce = 0, qe = Math.min(ce.t, this.t); ve < qe; )
              (Ce += this[ve] + ce[ve]), (he[ve++] = Ce & this.DM), (Ce >>= this.DB)
            if (ce.t < this.t) {
              for (Ce += ce.s; ve < this.t; ) (Ce += this[ve]), (he[ve++] = Ce & this.DM), (Ce >>= this.DB)
              Ce += this.s
            } else {
              for (Ce += this.s; ve < ce.t; ) (Ce += ce[ve]), (he[ve++] = Ce & this.DM), (Ce >>= this.DB)
              Ce += ce.s
            }
            ;(he.s = Ce < 0 ? -1 : 0),
              Ce > 0 ? (he[ve++] = Ce) : Ce < -1 && (he[ve++] = this.DV + Ce),
              (he.t = ve),
              he.clamp()
          }
          function Xe(ce) {
            var he = u()
            return this.addTo(ce, he), he
          }
          function _t(ce) {
            var he = u()
            return this.subTo(ce, he), he
          }
          function nt(ce) {
            var he = u()
            return this.multiplyTo(ce, he), he
          }
          function it() {
            var ce = u()
            return this.squareTo(ce), ce
          }
          function xt(ce) {
            var he = u()
            return this.divRemTo(ce, he, null), he
          }
          function st(ce) {
            var he = u()
            return this.divRemTo(ce, null, he), he
          }
          function ot(ce) {
            var he = u(),
              ve = u()
            return this.divRemTo(ce, he, ve), new Array(he, ve)
          }
          function Rt(ce) {
            ;(this[this.t] = this.am(0, ce - 1, this, 0, 0, this.t)), ++this.t, this.clamp()
          }
          function Ze(ce, he) {
            if (ce != 0) {
              for (; this.t <= he; ) this[this.t++] = 0
              for (this[he] += ce; this[he] >= this.DV; )
                (this[he] -= this.DV), ++he >= this.t && (this[this.t++] = 0), ++this[he]
            }
          }
          function Ye() {}
          function Er(ce) {
            return ce
          }
          function Et(ce, he, ve) {
            ce.multiplyTo(he, ve)
          }
          function St(ce, he) {
            ce.squareTo(he)
          }
          ;(Ye.prototype.convert = Er), (Ye.prototype.revert = Er), (Ye.prototype.mulTo = Et), (Ye.prototype.sqrTo = St)
          function Dr(ce) {
            return this.exp(ce, new Ye())
          }
          function At(ce, he, ve) {
            var Ce = Math.min(this.t + ce.t, he)
            for (ve.s = 0, ve.t = Ce; Ce > 0; ) ve[--Ce] = 0
            var qe
            for (qe = ve.t - this.t; Ce < qe; ++Ce) ve[Ce + this.t] = this.am(0, ce[Ce], ve, Ce, 0, this.t)
            for (qe = Math.min(ce.t, he); Ce < qe; ++Ce) this.am(0, ce[Ce], ve, Ce, 0, he - Ce)
            ve.clamp()
          }
          function vt(ce, he, ve) {
            --he
            var Ce = (ve.t = this.t + ce.t - he)
            for (ve.s = 0; --Ce >= 0; ) ve[Ce] = 0
            for (Ce = Math.max(he - this.t, 0); Ce < ce.t; ++Ce)
              ve[this.t + Ce - he] = this.am(he - Ce, ce[Ce], ve, 0, 0, this.t + Ce - he)
            ve.clamp(), ve.drShiftTo(1, ve)
          }
          function Yt(ce) {
            ;(this.r2 = u()),
              (this.q3 = u()),
              s.ONE.dlShiftTo(2 * ce.t, this.r2),
              (this.mu = this.r2.divide(ce)),
              (this.m = ce)
          }
          function It(ce) {
            if (ce.s < 0 || ce.t > 2 * this.m.t) return ce.mod(this.m)
            if (ce.compareTo(this.m) < 0) return ce
            var he = u()
            return ce.copyTo(he), this.reduce(he), he
          }
          function Ot(ce) {
            return ce
          }
          function En(ce) {
            for (
              ce.drShiftTo(this.m.t - 1, this.r2),
                ce.t > this.m.t + 1 && ((ce.t = this.m.t + 1), ce.clamp()),
                this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
                this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
              ce.compareTo(this.r2) < 0;

            )
              ce.dAddOffset(1, this.m.t + 1)
            for (ce.subTo(this.r2, ce); ce.compareTo(this.m) >= 0; ) ce.subTo(this.m, ce)
          }
          function Dt(ce, he) {
            ce.squareTo(he), this.reduce(he)
          }
          function Lt(ce, he, ve) {
            ce.multiplyTo(he, ve), this.reduce(ve)
          }
          ;(Yt.prototype.convert = It),
            (Yt.prototype.revert = Ot),
            (Yt.prototype.reduce = En),
            (Yt.prototype.mulTo = Lt),
            (Yt.prototype.sqrTo = Dt)
          function Sn(ce, he) {
            var ve = ce.bitLength(),
              Ce,
              qe = E(1),
              ze
            if (ve <= 0) return qe
            ve < 18 ? (Ce = 1) : ve < 48 ? (Ce = 3) : ve < 144 ? (Ce = 4) : ve < 768 ? (Ce = 5) : (Ce = 6),
              ve < 8 ? (ze = new le(he)) : he.isEven() ? (ze = new Yt(he)) : (ze = new ge(he))
            var Je = new Array(),
              rt = 3,
              Ft = Ce - 1,
              ar = (1 << Ce) - 1
            if (((Je[1] = ze.convert(this)), Ce > 1)) {
              var Qr = u()
              for (ze.sqrTo(Je[1], Qr); rt <= ar; ) (Je[rt] = u()), ze.mulTo(Qr, Je[rt - 2], Je[rt]), (rt += 2)
            }
            var Wr = ce.t - 1,
              Vn,
              mu = !0,
              hn = u(),
              pn
            for (ve = G(ce[Wr]) - 1; Wr >= 0; ) {
              for (
                ve >= Ft
                  ? (Vn = (ce[Wr] >> (ve - Ft)) & ar)
                  : ((Vn = (ce[Wr] & ((1 << (ve + 1)) - 1)) << (Ft - ve)),
                    Wr > 0 && (Vn |= ce[Wr - 1] >> (this.DB + ve - Ft))),
                  rt = Ce;
                (Vn & 1) == 0;

              )
                (Vn >>= 1), --rt
              if (((ve -= rt) < 0 && ((ve += this.DB), --Wr), mu)) Je[Vn].copyTo(qe), (mu = !1)
              else {
                for (; rt > 1; ) ze.sqrTo(qe, hn), ze.sqrTo(hn, qe), (rt -= 2)
                rt > 0 ? ze.sqrTo(qe, hn) : ((pn = qe), (qe = hn), (hn = pn)), ze.mulTo(hn, Je[Vn], qe)
              }
              for (; Wr >= 0 && (ce[Wr] & (1 << ve)) == 0; )
                ze.sqrTo(qe, hn), (pn = qe), (qe = hn), (hn = pn), --ve < 0 && ((ve = this.DB - 1), --Wr)
            }
            return ze.revert(qe)
          }
          function Ut(ce) {
            var he = this.s < 0 ? this.negate() : this.clone(),
              ve = ce.s < 0 ? ce.negate() : ce.clone()
            if (he.compareTo(ve) < 0) {
              var Ce = he
              ;(he = ve), (ve = Ce)
            }
            var qe = he.getLowestSetBit(),
              ze = ve.getLowestSetBit()
            if (ze < 0) return he
            for (qe < ze && (ze = qe), ze > 0 && (he.rShiftTo(ze, he), ve.rShiftTo(ze, ve)); he.signum() > 0; )
              (qe = he.getLowestSetBit()) > 0 && he.rShiftTo(qe, he),
                (qe = ve.getLowestSetBit()) > 0 && ve.rShiftTo(qe, ve),
                he.compareTo(ve) >= 0 ? (he.subTo(ve, he), he.rShiftTo(1, he)) : (ve.subTo(he, ve), ve.rShiftTo(1, ve))
            return ze > 0 && ve.lShiftTo(ze, ve), ve
          }
          function qt(ce) {
            if (ce <= 0) return 0
            var he = this.DV % ce,
              ve = this.s < 0 ? ce - 1 : 0
            if (this.t > 0)
              if (he == 0) ve = this[0] % ce
              else for (var Ce = this.t - 1; Ce >= 0; --Ce) ve = (he * ve + this[Ce]) % ce
            return ve
          }
          function dt(ce) {
            var he = ce.isEven()
            if ((this.isEven() && he) || ce.signum() == 0) return s.ZERO
            for (
              var ve = ce.clone(), Ce = this.clone(), qe = E(1), ze = E(0), Je = E(0), rt = E(1);
              ve.signum() != 0;

            ) {
              for (; ve.isEven(); )
                ve.rShiftTo(1, ve),
                  he
                    ? ((!qe.isEven() || !ze.isEven()) && (qe.addTo(this, qe), ze.subTo(ce, ze)), qe.rShiftTo(1, qe))
                    : ze.isEven() || ze.subTo(ce, ze),
                  ze.rShiftTo(1, ze)
              for (; Ce.isEven(); )
                Ce.rShiftTo(1, Ce),
                  he
                    ? ((!Je.isEven() || !rt.isEven()) && (Je.addTo(this, Je), rt.subTo(ce, rt)), Je.rShiftTo(1, Je))
                    : rt.isEven() || rt.subTo(ce, rt),
                  rt.rShiftTo(1, rt)
              ve.compareTo(Ce) >= 0
                ? (ve.subTo(Ce, ve), he && qe.subTo(Je, qe), ze.subTo(rt, ze))
                : (Ce.subTo(ve, Ce), he && Je.subTo(qe, Je), rt.subTo(ze, rt))
            }
            if (Ce.compareTo(s.ONE) != 0) return s.ZERO
            if (rt.compareTo(ce) >= 0) return rt.subtract(ce)
            if (rt.signum() < 0) rt.addTo(ce, rt)
            else return rt
            return rt.signum() < 0 ? rt.add(ce) : rt
          }
          var Se = [
              2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103,
              107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223,
              227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347,
              349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,
              467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
              613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743,
              751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883,
              887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997
            ],
            ue = (1 << 26) / Se[Se.length - 1]
          function Ae(ce) {
            var he,
              ve = this.abs()
            if (ve.t == 1 && ve[0] <= Se[Se.length - 1]) {
              for (he = 0; he < Se.length; ++he) if (ve[0] == Se[he]) return !0
              return !1
            }
            if (ve.isEven()) return !1
            for (he = 1; he < Se.length; ) {
              for (var Ce = Se[he], qe = he + 1; qe < Se.length && Ce < ue; ) Ce *= Se[qe++]
              for (Ce = ve.modInt(Ce); he < qe; ) if (Ce % Se[he++] == 0) return !1
            }
            return ve.millerRabin(ce)
          }
          function Fi(ce) {
            var he = this.subtract(s.ONE),
              ve = he.getLowestSetBit()
            if (ve <= 0) return !1
            var Ce = he.shiftRight(ve)
            ;(ce = (ce + 1) >> 1), ce > Se.length && (ce = Se.length)
            for (var qe = u(), ze = 0; ze < ce; ++ze) {
              qe.fromInt(Se[Math.floor(Math.random() * Se.length)])
              var Je = qe.modPow(Ce, this)
              if (Je.compareTo(s.ONE) != 0 && Je.compareTo(he) != 0) {
                for (var rt = 1; rt++ < ve && Je.compareTo(he) != 0; )
                  if (((Je = Je.modPowInt(2, this)), Je.compareTo(s.ONE) == 0)) return !1
                if (Je.compareTo(he) != 0) return !1
              }
            }
            return !0
          }
          ;(s.prototype.chunkSize = U),
            (s.prototype.toRadix = ne),
            (s.prototype.fromRadix = ee),
            (s.prototype.fromNumber = ae),
            (s.prototype.bitwiseTo = me),
            (s.prototype.changeBit = gt),
            (s.prototype.addTo = tt),
            (s.prototype.dMultiply = Rt),
            (s.prototype.dAddOffset = Ze),
            (s.prototype.multiplyLowerTo = At),
            (s.prototype.multiplyUpperTo = vt),
            (s.prototype.modInt = qt),
            (s.prototype.millerRabin = Fi),
            (s.prototype.clone = D),
            (s.prototype.intValue = $),
            (s.prototype.byteValue = g),
            (s.prototype.shortValue = N),
            (s.prototype.signum = X),
            (s.prototype.toByteArray = Y),
            (s.prototype.equals = z),
            (s.prototype.min = H),
            (s.prototype.max = se),
            (s.prototype.and = Ee),
            (s.prototype.or = Be),
            (s.prototype.xor = Pe),
            (s.prototype.andNot = ht),
            (s.prototype.not = Qe),
            (s.prototype.shiftLeft = et),
            (s.prototype.shiftRight = Mt),
            (s.prototype.getLowestSetBit = at),
            (s.prototype.bitCount = ft),
            (s.prototype.testBit = We),
            (s.prototype.setBit = Ge),
            (s.prototype.clearBit = He),
            (s.prototype.flipBit = wt),
            (s.prototype.add = Xe),
            (s.prototype.subtract = _t),
            (s.prototype.multiply = nt),
            (s.prototype.divide = xt),
            (s.prototype.remainder = st),
            (s.prototype.divideAndRemainder = ot),
            (s.prototype.modPow = Sn),
            (s.prototype.modInverse = dt),
            (s.prototype.pow = Dr),
            (s.prototype.gcd = Ut),
            (s.prototype.isProbablePrime = Ae),
            (s.prototype.square = it),
            (s.prototype.Barrett = Yt)
          var de, pe, ye
          function Te(ce) {
            ;(pe[ye++] ^= ce & 255),
              (pe[ye++] ^= (ce >> 8) & 255),
              (pe[ye++] ^= (ce >> 16) & 255),
              (pe[ye++] ^= (ce >> 24) & 255),
              ye >= nr && (ye -= nr)
          }
          function De() {
            Te(new Date().getTime())
          }
          if (pe == null) {
            ;(pe = new Array()), (ye = 0)
            var Le
            if (typeof window != 'undefined' && window.crypto) {
              if (window.crypto.getRandomValues) {
                var $e = new Uint8Array(32)
                for (window.crypto.getRandomValues($e), Le = 0; Le < 32; ++Le) pe[ye++] = $e[Le]
              } else if (navigator.appName == 'Netscape' && navigator.appVersion < '5') {
                var Fe = window.crypto.random(32)
                for (Le = 0; Le < Fe.length; ++Le) pe[ye++] = Fe.charCodeAt(Le) & 255
              }
            }
            for (; ye < nr; ) (Le = Math.floor(65536 * Math.random())), (pe[ye++] = Le >>> 8), (pe[ye++] = Le & 255)
            ;(ye = 0), De()
          }
          function Tt() {
            if (de == null) {
              for (De(), de = yr(), de.init(pe), ye = 0; ye < pe.length; ++ye) pe[ye] = 0
              ye = 0
            }
            return de.next()
          }
          function Gt(ce) {
            var he
            for (he = 0; he < ce.length; ++he) ce[he] = Tt()
          }
          function tr() {}
          tr.prototype.nextBytes = Gt
          function Zt() {
            ;(this.i = 0), (this.j = 0), (this.S = new Array())
          }
          function Lr(ce) {
            var he, ve, Ce
            for (he = 0; he < 256; ++he) this.S[he] = he
            for (ve = 0, he = 0; he < 256; ++he)
              (ve = (ve + this.S[he] + ce[he % ce.length]) & 255),
                (Ce = this.S[he]),
                (this.S[he] = this.S[ve]),
                (this.S[ve] = Ce)
            ;(this.i = 0), (this.j = 0)
          }
          function An() {
            var ce
            return (
              (this.i = (this.i + 1) & 255),
              (this.j = (this.j + this.S[this.i]) & 255),
              (ce = this.S[this.i]),
              (this.S[this.i] = this.S[this.j]),
              (this.S[this.j] = ce),
              this.S[(ce + this.S[this.i]) & 255]
            )
          }
          ;(Zt.prototype.init = Lr), (Zt.prototype.next = An)
          function yr() {
            return new Zt()
          }
          var nr = 256
          typeof e != 'undefined'
            ? (e = r.exports = { default: s, BigInteger: s, SecureRandom: tr })
            : (this.jsbn = { BigInteger: s, SecureRandom: tr })
        }.call(e)
    }
  }),
  Wl = te({
    'node_modules/sprintf-js/src/sprintf.js'(e) {
      V(),
        F(),
        (function () {
          'use strict'
          var r = {
            not_string: /[^s]/,
            not_bool: /[^t]/,
            not_type: /[^T]/,
            not_primitive: /[^v]/,
            number: /[diefg]/,
            numeric_arg: /[bcdiefguxX]/,
            json: /[j]/,
            not_json: /[^j]/,
            text: /^[^\x25]+/,
            modulo: /^\x25{2}/,
            placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
            key: /^([a-z_][a-z_\d]*)/i,
            key_access: /^\.([a-z_][a-z_\d]*)/i,
            index_access: /^\[(\d+)\]/,
            sign: /^[+-]/
          }
          function t(o) {
            return i(u(o), arguments)
          }
          function n(o, l) {
            return t.apply(null, [o].concat(l || []))
          }
          function i(o, l) {
            var a = 1,
              c = o.length,
              f,
              p = '',
              y,
              d,
              h,
              m,
              _,
              A,
              T,
              E
            for (y = 0; y < c; y++)
              if (typeof o[y] == 'string') p += o[y]
              else if (typeof o[y] == 'object') {
                if (((h = o[y]), h.keys))
                  for (f = l[a], d = 0; d < h.keys.length; d++) {
                    if (f == null)
                      throw new Error(
                        t('[sprintf] Cannot access property "%s" of undefined value "%s"', h.keys[d], h.keys[d - 1])
                      )
                    f = f[h.keys[d]]
                  }
                else h.param_no ? (f = l[h.param_no]) : (f = l[a++])
                if (
                  (r.not_type.test(h.type) && r.not_primitive.test(h.type) && f instanceof Function && (f = f()),
                  r.numeric_arg.test(h.type) && typeof f != 'number' && isNaN(f))
                )
                  throw new TypeError(t('[sprintf] expecting number but found %T', f))
                switch ((r.number.test(h.type) && (T = f >= 0), h.type)) {
                  case 'b':
                    f = parseInt(f, 10).toString(2)
                    break
                  case 'c':
                    f = String.fromCharCode(parseInt(f, 10))
                    break
                  case 'd':
                  case 'i':
                    f = parseInt(f, 10)
                    break
                  case 'j':
                    f = JSON.stringify(f, null, h.width ? parseInt(h.width) : 0)
                    break
                  case 'e':
                    f = h.precision ? parseFloat(f).toExponential(h.precision) : parseFloat(f).toExponential()
                    break
                  case 'f':
                    f = h.precision ? parseFloat(f).toFixed(h.precision) : parseFloat(f)
                    break
                  case 'g':
                    f = h.precision ? String(Number(f.toPrecision(h.precision))) : parseFloat(f)
                    break
                  case 'o':
                    f = (parseInt(f, 10) >>> 0).toString(8)
                    break
                  case 's':
                    ;(f = String(f)), (f = h.precision ? f.substring(0, h.precision) : f)
                    break
                  case 't':
                    ;(f = String(!!f)), (f = h.precision ? f.substring(0, h.precision) : f)
                    break
                  case 'T':
                    ;(f = Object.prototype.toString.call(f).slice(8, -1).toLowerCase()),
                      (f = h.precision ? f.substring(0, h.precision) : f)
                    break
                  case 'u':
                    f = parseInt(f, 10) >>> 0
                    break
                  case 'v':
                    ;(f = f.valueOf()), (f = h.precision ? f.substring(0, h.precision) : f)
                    break
                  case 'x':
                    f = (parseInt(f, 10) >>> 0).toString(16)
                    break
                  case 'X':
                    f = (parseInt(f, 10) >>> 0).toString(16).toUpperCase()
                    break
                }
                r.json.test(h.type)
                  ? (p += f)
                  : (r.number.test(h.type) && (!T || h.sign)
                      ? ((E = T ? '+' : '-'), (f = f.toString().replace(r.sign, '')))
                      : (E = ''),
                    (_ = h.pad_char ? (h.pad_char === '0' ? '0' : h.pad_char.charAt(1)) : ' '),
                    (A = h.width - (E + f).length),
                    (m = h.width && A > 0 ? _.repeat(A) : ''),
                    (p += h.align ? E + f + m : _ === '0' ? E + m + f : m + E + f))
              }
            return p
          }
          var s = Object.create(null)
          function u(o) {
            if (s[o]) return s[o]
            for (var l = o, a, c = [], f = 0; l; ) {
              if ((a = r.text.exec(l)) !== null) c.push(a[0])
              else if ((a = r.modulo.exec(l)) !== null) c.push('%')
              else if ((a = r.placeholder.exec(l)) !== null) {
                if (a[2]) {
                  f |= 1
                  var p = [],
                    y = a[2],
                    d = []
                  if ((d = r.key.exec(y)) !== null)
                    for (p.push(d[1]); (y = y.substring(d[0].length)) !== ''; )
                      if ((d = r.key_access.exec(y)) !== null) p.push(d[1])
                      else if ((d = r.index_access.exec(y)) !== null) p.push(d[1])
                      else throw new SyntaxError('[sprintf] failed to parse named argument key')
                  else throw new SyntaxError('[sprintf] failed to parse named argument key')
                  a[2] = p
                } else f |= 2
                if (f === 3)
                  throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported')
                c.push({
                  placeholder: a[0],
                  param_no: a[1],
                  keys: a[2],
                  sign: a[3],
                  pad_char: a[4],
                  align: a[5],
                  width: a[6],
                  precision: a[7],
                  type: a[8]
                })
              } else throw new SyntaxError('[sprintf] unexpected placeholder')
              l = l.substring(a[0].length)
            }
            return (s[o] = c)
          }
          typeof e != 'undefined' && ((e.sprintf = t), (e.vsprintf = n)),
            typeof window != 'undefined' &&
              ((window.sprintf = t),
              (window.vsprintf = n),
              typeof define == 'function' &&
                define.amd &&
                define(function () {
                  return { sprintf: t, vsprintf: n }
                }))
        })()
    }
  }),
  cw = te({
    'node_modules/ip-address/dist/lib/ipv4.js'(e) {
      V(), F()
      var r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (c, f, p, y) {
                y === void 0 && (y = p),
                  Object.defineProperty(c, y, {
                    enumerable: !0,
                    get: function () {
                      return f[p]
                    }
                  })
              }
            : function (c, f, p, y) {
                y === void 0 && (y = p), (c[y] = f[p])
              }),
        t =
          (e && e.__setModuleDefault) ||
          (Object.create
            ? function (c, f) {
                Object.defineProperty(c, 'default', { enumerable: !0, value: f })
              }
            : function (c, f) {
                c.default = f
              }),
        n =
          (e && e.__importStar) ||
          function (c) {
            if (c && c.__esModule) return c
            var f = {}
            if (c != null) for (var p in c) p !== 'default' && Object.prototype.hasOwnProperty.call(c, p) && r(f, c, p)
            return t(f, c), f
          }
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.Address4 = void 0)
      var i = n(iw()),
        s = n(sw()),
        u = ow(),
        o = aw(),
        l = Wl(),
        a = (function () {
          function c(f) {
            ;(this.groups = s.GROUPS),
              (this.parsedAddress = []),
              (this.parsedSubnet = ''),
              (this.subnet = '/32'),
              (this.subnetMask = 32),
              (this.v4 = !0),
              (this.isCorrect = i.isCorrect(s.BITS)),
              (this.isInSubnet = i.isInSubnet),
              (this.address = f)
            var p = s.RE_SUBNET_STRING.exec(f)
            if (p) {
              if (
                ((this.parsedSubnet = p[0].replace('/', '')),
                (this.subnetMask = parseInt(this.parsedSubnet, 10)),
                (this.subnet = '/' + this.subnetMask),
                this.subnetMask < 0 || this.subnetMask > s.BITS)
              )
                throw new u.AddressError('Invalid subnet mask.')
              f = f.replace(s.RE_SUBNET_STRING, '')
            }
            ;(this.addressMinusSuffix = f), (this.parsedAddress = this.parse(f))
          }
          return (
            (c.isValid = function (f) {
              try {
                return new c(f), !0
              } catch (p) {
                return !1
              }
            }),
            (c.prototype.parse = function (f) {
              var p = f.split('.')
              if (!f.match(s.RE_ADDRESS)) throw new u.AddressError('Invalid IPv4 address.')
              return p
            }),
            (c.prototype.correctForm = function () {
              return this.parsedAddress
                .map(function (f) {
                  return parseInt(f, 10)
                })
                .join('.')
            }),
            (c.fromHex = function (f) {
              var p = f.replace(/:/g, '').padStart(8, '0'),
                y = [],
                d
              for (d = 0; d < 8; d += 2) {
                var h = p.slice(d, d + 2)
                y.push(parseInt(h, 16))
              }
              return new c(y.join('.'))
            }),
            (c.fromInteger = function (f) {
              return c.fromHex(f.toString(16))
            }),
            (c.prototype.toHex = function () {
              return this.parsedAddress
                .map(function (f) {
                  return l.sprintf('%02x', parseInt(f, 10))
                })
                .join(':')
            }),
            (c.prototype.toArray = function () {
              return this.parsedAddress.map(function (f) {
                return parseInt(f, 10)
              })
            }),
            (c.prototype.toGroup6 = function () {
              var f = [],
                p
              for (p = 0; p < s.GROUPS; p += 2) {
                var y = l.sprintf(
                  '%02x%02x',
                  parseInt(this.parsedAddress[p], 10),
                  parseInt(this.parsedAddress[p + 1], 10)
                )
                f.push(l.sprintf('%x', parseInt(y, 16)))
              }
              return f.join(':')
            }),
            (c.prototype.bigInteger = function () {
              return new o.BigInteger(
                this.parsedAddress
                  .map(function (f) {
                    return l.sprintf('%02x', parseInt(f, 10))
                  })
                  .join(''),
                16
              )
            }),
            (c.prototype._startAddress = function () {
              return new o.BigInteger(this.mask() + '0'.repeat(s.BITS - this.subnetMask), 2)
            }),
            (c.prototype.startAddress = function () {
              return c.fromBigInteger(this._startAddress())
            }),
            (c.prototype.startAddressExclusive = function () {
              var f = new o.BigInteger('1')
              return c.fromBigInteger(this._startAddress().add(f))
            }),
            (c.prototype._endAddress = function () {
              return new o.BigInteger(this.mask() + '1'.repeat(s.BITS - this.subnetMask), 2)
            }),
            (c.prototype.endAddress = function () {
              return c.fromBigInteger(this._endAddress())
            }),
            (c.prototype.endAddressExclusive = function () {
              var f = new o.BigInteger('1')
              return c.fromBigInteger(this._endAddress().subtract(f))
            }),
            (c.fromBigInteger = function (f) {
              return c.fromInteger(parseInt(f.toString(), 10))
            }),
            (c.prototype.mask = function (f) {
              return f === void 0 && (f = this.subnetMask), this.getBitsBase2(0, f)
            }),
            (c.prototype.getBitsBase2 = function (f, p) {
              return this.binaryZeroPad().slice(f, p)
            }),
            (c.prototype.isMulticast = function () {
              return this.isInSubnet(new c('224.0.0.0/4'))
            }),
            (c.prototype.binaryZeroPad = function () {
              return this.bigInteger().toString(2).padStart(s.BITS, '0')
            }),
            (c.prototype.groupForV6 = function () {
              var f = this.parsedAddress
              return this.address.replace(
                s.RE_ADDRESS,
                l.sprintf(
                  '<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>',
                  f.slice(0, 2).join('.'),
                  f.slice(2, 4).join('.')
                )
              )
            }),
            c
          )
        })()
      e.Address4 = a
    }
  }),
  uw = te({
    'node_modules/ip-address/dist/lib/v6/constants.js'(e) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.RE_URL_WITH_PORT =
          e.RE_URL =
          e.RE_ZONE_STRING =
          e.RE_SUBNET_STRING =
          e.RE_BAD_ADDRESS =
          e.RE_BAD_CHARACTERS =
          e.TYPES =
          e.SCOPES =
          e.GROUPS =
          e.BITS =
            void 0),
        (e.BITS = 128),
        (e.GROUPS = 8),
        (e.SCOPES = {
          0: 'Reserved',
          1: 'Interface local',
          2: 'Link local',
          4: 'Admin local',
          5: 'Site local',
          8: 'Organization local',
          14: 'Global',
          15: 'Reserved'
        }),
        (e.TYPES = {
          'ff01::1/128': 'Multicast (All nodes on this interface)',
          'ff01::2/128': 'Multicast (All routers on this interface)',
          'ff02::1/128': 'Multicast (All nodes on this link)',
          'ff02::2/128': 'Multicast (All routers on this link)',
          'ff05::2/128': 'Multicast (All routers in this site)',
          'ff02::5/128': 'Multicast (OSPFv3 AllSPF routers)',
          'ff02::6/128': 'Multicast (OSPFv3 AllDR routers)',
          'ff02::9/128': 'Multicast (RIP routers)',
          'ff02::a/128': 'Multicast (EIGRP routers)',
          'ff02::d/128': 'Multicast (PIM routers)',
          'ff02::16/128': 'Multicast (MLDv2 reports)',
          'ff01::fb/128': 'Multicast (mDNSv6)',
          'ff02::fb/128': 'Multicast (mDNSv6)',
          'ff05::fb/128': 'Multicast (mDNSv6)',
          'ff02::1:2/128': 'Multicast (All DHCP servers and relay agents on this link)',
          'ff05::1:2/128': 'Multicast (All DHCP servers and relay agents in this site)',
          'ff02::1:3/128': 'Multicast (All DHCP servers on this link)',
          'ff05::1:3/128': 'Multicast (All DHCP servers in this site)',
          '::/128': 'Unspecified',
          '::1/128': 'Loopback',
          'ff00::/8': 'Multicast',
          'fe80::/10': 'Link-local unicast'
        }),
        (e.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi),
        (e.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi),
        (e.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/),
        (e.RE_ZONE_STRING = /%.*$/),
        (e.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/)),
        (e.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/))
    }
  }),
  lw = te({
    'node_modules/ip-address/dist/lib/v6/helpers.js'(e) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.simpleGroup = e.spanLeadingZeroes = e.spanAll = e.spanAllZeroes = void 0)
      var r = Wl()
      function t(o) {
        return o.replace(/(0+)/g, '<span class="zero">$1</span>')
      }
      e.spanAllZeroes = t
      function n(o, l) {
        l === void 0 && (l = 0)
        var a = o.split('')
        return a
          .map(function (c, f) {
            return r.sprintf('<span class="digit value-%s position-%d">%s</span>', c, f + l, t(c))
          })
          .join('')
      }
      e.spanAll = n
      function i(o) {
        return o.replace(/^(0+)/, '<span class="zero">$1</span>')
      }
      function s(o) {
        var l = o.split(':')
        return l
          .map(function (a) {
            return i(a)
          })
          .join(':')
      }
      e.spanLeadingZeroes = s
      function u(o, l) {
        l === void 0 && (l = 0)
        var a = o.split(':')
        return a.map(function (c, f) {
          return /group-v4/.test(c) ? c : r.sprintf('<span class="hover-group group-%d">%s</span>', f + l, i(c))
        })
      }
      e.simpleGroup = u
    }
  }),
  IN = te({
    'node_modules/ip-address/dist/lib/v6/regular-expressions.js'(e) {
      V(), F()
      var r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (c, f, p, y) {
                y === void 0 && (y = p),
                  Object.defineProperty(c, y, {
                    enumerable: !0,
                    get: function () {
                      return f[p]
                    }
                  })
              }
            : function (c, f, p, y) {
                y === void 0 && (y = p), (c[y] = f[p])
              }),
        t =
          (e && e.__setModuleDefault) ||
          (Object.create
            ? function (c, f) {
                Object.defineProperty(c, 'default', { enumerable: !0, value: f })
              }
            : function (c, f) {
                c.default = f
              }),
        n =
          (e && e.__importStar) ||
          function (c) {
            if (c && c.__esModule) return c
            var f = {}
            if (c != null) for (var p in c) p !== 'default' && Object.prototype.hasOwnProperty.call(c, p) && r(f, c, p)
            return t(f, c), f
          }
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.possibleElisions =
          e.simpleRegularExpression =
          e.ADDRESS_BOUNDARY =
          e.padGroup =
          e.groupPossibilities =
            void 0)
      var i = n(uw()),
        s = Wl()
      function u(c) {
        return s.sprintf('(%s)', c.join('|'))
      }
      e.groupPossibilities = u
      function o(c) {
        return c.length < 4 ? s.sprintf('0{0,%d}%s', 4 - c.length, c) : c
      }
      ;(e.padGroup = o), (e.ADDRESS_BOUNDARY = '[^A-Fa-f0-9:]')
      function l(c) {
        var f = []
        c.forEach(function (y, d) {
          var h = parseInt(y, 16)
          h === 0 && f.push(d)
        })
        var p = f.map(function (y) {
          return c
            .map(function (d, h) {
              if (h === y) {
                var m = h === 0 || h === i.GROUPS - 1 ? ':' : ''
                return u([o(d), m])
              }
              return o(d)
            })
            .join(':')
        })
        return p.push(c.map(o).join(':')), u(p)
      }
      e.simpleRegularExpression = l
      function a(c, f, p) {
        var y = f ? '' : ':',
          d = p ? '' : ':',
          h = []
        !f && !p && h.push('::'),
          f && p && h.push(''),
          ((p && !f) || (!p && f)) && h.push(':'),
          h.push(s.sprintf('%s(:0{1,4}){1,%d}', y, c - 1)),
          h.push(s.sprintf('(0{1,4}:){1,%d}%s', c - 1, d)),
          h.push(s.sprintf('(0{1,4}:){%d}0{1,4}', c - 1))
        for (var m = 1; m < c - 1; m++)
          for (var _ = 1; _ < c - m; _++) h.push(s.sprintf('(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}', _, c - _ - m - 1))
        return u(h)
      }
      e.possibleElisions = a
    }
  }),
  TN = te({
    'node_modules/ip-address/dist/lib/ipv6.js'(e) {
      V(), F()
      var r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (k, w, v, I) {
                I === void 0 && (I = v),
                  Object.defineProperty(k, I, {
                    enumerable: !0,
                    get: function () {
                      return w[v]
                    }
                  })
              }
            : function (k, w, v, I) {
                I === void 0 && (I = v), (k[I] = w[v])
              }),
        t =
          (e && e.__setModuleDefault) ||
          (Object.create
            ? function (k, w) {
                Object.defineProperty(k, 'default', { enumerable: !0, value: w })
              }
            : function (k, w) {
                k.default = w
              }),
        n =
          (e && e.__importStar) ||
          function (k) {
            if (k && k.__esModule) return k
            var w = {}
            if (k != null) for (var v in k) v !== 'default' && Object.prototype.hasOwnProperty.call(k, v) && r(w, k, v)
            return t(w, k), w
          },
        i =
          (e && e.__spreadArrays) ||
          function () {
            for (var k = 0, w = 0, v = arguments.length; w < v; w++) k += arguments[w].length
            for (var I = Array(k), M = 0, w = 0; w < v; w++)
              for (var q = arguments[w], G = 0, O = q.length; G < O; G++, M++) I[M] = q[G]
            return I
          }
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.Address6 = void 0)
      var s = n(iw()),
        u = n(sw()),
        o = n(uw()),
        l = n(lw()),
        a = cw(),
        c = IN(),
        f = ow(),
        p = aw(),
        y = Wl()
      function d(k) {
        if (!k) throw new Error('Assertion failed.')
      }
      function h(k) {
        for (var w = /(\d+)(\d{3})/; w.test(k); ) k = k.replace(w, '$1,$2')
        return k
      }
      function m(k) {
        return (
          (k = k.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2')),
          (k = k.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2')),
          k
        )
      }
      function _(k, w) {
        var v = [],
          I = [],
          M
        for (M = 0; M < k.length; M++) M < w[0] ? v.push(k[M]) : M > w[1] && I.push(k[M])
        return v.concat(['compact']).concat(I)
      }
      function A(k) {
        return y.sprintf('%04x', parseInt(k, 16))
      }
      function T(k) {
        return k & 255
      }
      var E = (function () {
        function k(w, v) {
          ;(this.addressMinusSuffix = ''),
            (this.parsedSubnet = ''),
            (this.subnet = '/128'),
            (this.subnetMask = 128),
            (this.v4 = !1),
            (this.zone = ''),
            (this.isInSubnet = s.isInSubnet),
            (this.isCorrect = s.isCorrect(o.BITS)),
            v === void 0 ? (this.groups = o.GROUPS) : (this.groups = v),
            (this.address = w)
          var I = o.RE_SUBNET_STRING.exec(w)
          if (I) {
            if (
              ((this.parsedSubnet = I[0].replace('/', '')),
              (this.subnetMask = parseInt(this.parsedSubnet, 10)),
              (this.subnet = '/' + this.subnetMask),
              Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > o.BITS)
            )
              throw new f.AddressError('Invalid subnet mask.')
            w = w.replace(o.RE_SUBNET_STRING, '')
          } else if (/\//.test(w)) throw new f.AddressError('Invalid subnet mask.')
          var M = o.RE_ZONE_STRING.exec(w)
          M && ((this.zone = M[0]), (w = w.replace(o.RE_ZONE_STRING, ''))),
            (this.addressMinusSuffix = w),
            (this.parsedAddress = this.parse(this.addressMinusSuffix))
        }
        return (
          (k.isValid = function (w) {
            try {
              return new k(w), !0
            } catch (v) {
              return !1
            }
          }),
          (k.fromBigInteger = function (w) {
            var v = w.toString(16).padStart(32, '0'),
              I = [],
              M
            for (M = 0; M < o.GROUPS; M++) I.push(v.slice(M * 4, (M + 1) * 4))
            return new k(I.join(':'))
          }),
          (k.fromURL = function (w) {
            var v,
              I = null,
              M
            if (w.indexOf('[') !== -1 && w.indexOf(']:') !== -1) {
              if (((M = o.RE_URL_WITH_PORT.exec(w)), M === null))
                return { error: 'failed to parse address with port', address: null, port: null }
              ;(v = M[1]), (I = M[2])
            } else if (w.indexOf('/') !== -1) {
              if (((w = w.replace(/^[a-z0-9]+:\/\//, '')), (M = o.RE_URL.exec(w)), M === null))
                return { error: 'failed to parse address from URL', address: null, port: null }
              v = M[1]
            } else v = w
            return (
              I ? ((I = parseInt(I, 10)), (I < 0 || I > 65536) && (I = null)) : (I = null),
              { address: new k(v), port: I }
            )
          }),
          (k.fromAddress4 = function (w) {
            var v = new a.Address4(w),
              I = o.BITS - (u.BITS - v.subnetMask)
            return new k('::ffff:' + v.correctForm() + '/' + I)
          }),
          (k.fromArpa = function (w) {
            var v = w.replace(/(\.ip6\.arpa)?\.$/, ''),
              I = 7
            if (v.length !== 63) throw new f.AddressError("Invalid 'ip6.arpa' form.")
            for (var M = v.split('.').reverse(), q = I; q > 0; q--) {
              var G = q * 4
              M.splice(G, 0, ':')
            }
            return (v = M.join('')), new k(v)
          }),
          (k.prototype.microsoftTranscription = function () {
            return y.sprintf('%s.ipv6-literal.net', this.correctForm().replace(/:/g, '-'))
          }),
          (k.prototype.mask = function (w) {
            return w === void 0 && (w = this.subnetMask), this.getBitsBase2(0, w)
          }),
          (k.prototype.possibleSubnets = function (w) {
            w === void 0 && (w = 128)
            var v = o.BITS - this.subnetMask,
              I = Math.abs(w - o.BITS),
              M = v - I
            return M < 0 ? '0' : h(new p.BigInteger('2', 10).pow(M).toString(10))
          }),
          (k.prototype._startAddress = function () {
            return new p.BigInteger(this.mask() + '0'.repeat(o.BITS - this.subnetMask), 2)
          }),
          (k.prototype.startAddress = function () {
            return k.fromBigInteger(this._startAddress())
          }),
          (k.prototype.startAddressExclusive = function () {
            var w = new p.BigInteger('1')
            return k.fromBigInteger(this._startAddress().add(w))
          }),
          (k.prototype._endAddress = function () {
            return new p.BigInteger(this.mask() + '1'.repeat(o.BITS - this.subnetMask), 2)
          }),
          (k.prototype.endAddress = function () {
            return k.fromBigInteger(this._endAddress())
          }),
          (k.prototype.endAddressExclusive = function () {
            var w = new p.BigInteger('1')
            return k.fromBigInteger(this._endAddress().subtract(w))
          }),
          (k.prototype.getScope = function () {
            var w = o.SCOPES[this.getBits(12, 16).intValue()]
            return this.getType() === 'Global unicast' && w !== 'Link local' && (w = 'Global'), w || 'Unknown'
          }),
          (k.prototype.getType = function () {
            for (var w = 0, v = Object.keys(o.TYPES); w < v.length; w++) {
              var I = v[w]
              if (this.isInSubnet(new k(I))) return o.TYPES[I]
            }
            return 'Global unicast'
          }),
          (k.prototype.getBits = function (w, v) {
            return new p.BigInteger(this.getBitsBase2(w, v), 2)
          }),
          (k.prototype.getBitsBase2 = function (w, v) {
            return this.binaryZeroPad().slice(w, v)
          }),
          (k.prototype.getBitsBase16 = function (w, v) {
            var I = v - w
            if (I % 4 != 0) throw new Error('Length of bits to retrieve must be divisible by four')
            return this.getBits(w, v)
              .toString(16)
              .padStart(I / 4, '0')
          }),
          (k.prototype.getBitsPastSubnet = function () {
            return this.getBitsBase2(this.subnetMask, o.BITS)
          }),
          (k.prototype.reverseForm = function (w) {
            w || (w = {})
            var v = Math.floor(this.subnetMask / 4),
              I = this.canonicalForm().replace(/:/g, '').split('').slice(0, v).reverse().join('.')
            return v > 0 ? (w.omitSuffix ? I : y.sprintf('%s.ip6.arpa.', I)) : w.omitSuffix ? '' : 'ip6.arpa.'
          }),
          (k.prototype.correctForm = function () {
            var w,
              v = [],
              I = 0,
              M = []
            for (w = 0; w < this.parsedAddress.length; w++) {
              var q = parseInt(this.parsedAddress[w], 16)
              q === 0 && I++, q !== 0 && I > 0 && (I > 1 && M.push([w - I, w - 1]), (I = 0))
            }
            I > 1 && M.push([this.parsedAddress.length - I, this.parsedAddress.length - 1])
            var G = M.map(function (L) {
              return L[1] - L[0] + 1
            })
            if (M.length > 0) {
              var O = G.indexOf(Math.max.apply(Math, G))
              v = _(this.parsedAddress, M[O])
            } else v = this.parsedAddress
            for (w = 0; w < v.length; w++) v[w] !== 'compact' && (v[w] = parseInt(v[w], 16).toString(16))
            var x = v.join(':')
            return (
              (x = x.replace(/^compact$/, '::')),
              (x = x.replace(/^compact|compact$/, ':')),
              (x = x.replace(/compact/, '')),
              x
            )
          }),
          (k.prototype.binaryZeroPad = function () {
            return this.bigInteger().toString(2).padStart(o.BITS, '0')
          }),
          (k.prototype.parse4in6 = function (w) {
            var v = w.split(':'),
              I = v.slice(-1)[0],
              M = I.match(u.RE_ADDRESS)
            if (M) {
              ;(this.parsedAddress4 = M[0]), (this.address4 = new a.Address4(this.parsedAddress4))
              for (var q = 0; q < this.address4.groups; q++)
                if (/^0[0-9]+/.test(this.address4.parsedAddress[q]))
                  throw new f.AddressError(
                    "IPv4 addresses can't have leading zeroes.",
                    w.replace(u.RE_ADDRESS, this.address4.parsedAddress.map(m).join('.'))
                  )
              ;(this.v4 = !0), (v[v.length - 1] = this.address4.toGroup6()), (w = v.join(':'))
            }
            return w
          }),
          (k.prototype.parse = function (w) {
            w = this.parse4in6(w)
            var v = w.match(o.RE_BAD_CHARACTERS)
            if (v)
              throw new f.AddressError(
                y.sprintf('Bad character%s detected in address: %s', v.length > 1 ? 's' : '', v.join('')),
                w.replace(o.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>')
              )
            var I = w.match(o.RE_BAD_ADDRESS)
            if (I)
              throw new f.AddressError(
                y.sprintf('Address failed regex: %s', I.join('')),
                w.replace(o.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>')
              )
            var M = [],
              q = w.split('::')
            if (q.length === 2) {
              var G = q[0].split(':'),
                O = q[1].split(':')
              G.length === 1 && G[0] === '' && (G = []), O.length === 1 && O[0] === '' && (O = [])
              var x = this.groups - (G.length + O.length)
              if (!x) throw new f.AddressError('Error parsing groups')
              ;(this.elidedGroups = x),
                (this.elisionBegin = G.length),
                (this.elisionEnd = G.length + this.elidedGroups),
                (M = M.concat(G))
              for (var L = 0; L < x; L++) M.push('0')
              M = M.concat(O)
            } else if (q.length === 1) (M = w.split(':')), (this.elidedGroups = 0)
            else throw new f.AddressError('Too many :: groups found')
            if (
              ((M = M.map(function (K) {
                return y.sprintf('%x', parseInt(K, 16))
              })),
              M.length !== this.groups)
            )
              throw new f.AddressError('Incorrect number of groups found')
            return M
          }),
          (k.prototype.canonicalForm = function () {
            return this.parsedAddress.map(A).join(':')
          }),
          (k.prototype.decimal = function () {
            return this.parsedAddress
              .map(function (w) {
                return y.sprintf('%05d', parseInt(w, 16))
              })
              .join(':')
          }),
          (k.prototype.bigInteger = function () {
            return new p.BigInteger(this.parsedAddress.map(A).join(''), 16)
          }),
          (k.prototype.to4 = function () {
            var w = this.binaryZeroPad().split('')
            return a.Address4.fromHex(new p.BigInteger(w.slice(96, 128).join(''), 2).toString(16))
          }),
          (k.prototype.to4in6 = function () {
            var w = this.to4(),
              v = new k(this.parsedAddress.slice(0, 6).join(':'), 6),
              I = v.correctForm(),
              M = ''
            return /:$/.test(I) || (M = ':'), I + M + w.address
          }),
          (k.prototype.inspectTeredo = function () {
            var w = this.getBitsBase16(0, 32),
              v = this.getBits(80, 96).xor(new p.BigInteger('ffff', 16)).toString(),
              I = a.Address4.fromHex(this.getBitsBase16(32, 64)),
              M = a.Address4.fromHex(this.getBits(96, 128).xor(new p.BigInteger('ffffffff', 16)).toString(16)),
              q = this.getBits(64, 80),
              G = this.getBitsBase2(64, 80),
              O = q.testBit(15),
              x = q.testBit(14),
              L = q.testBit(8),
              K = q.testBit(9),
              J = new p.BigInteger(G.slice(2, 6) + G.slice(8, 16), 2).toString(10)
            return {
              prefix: y.sprintf('%s:%s', w.slice(0, 4), w.slice(4, 8)),
              server4: I.address,
              client4: M.address,
              flags: G,
              coneNat: O,
              microsoft: { reserved: x, universalLocal: K, groupIndividual: L, nonce: J },
              udpPort: v
            }
          }),
          (k.prototype.inspect6to4 = function () {
            var w = this.getBitsBase16(0, 16),
              v = a.Address4.fromHex(this.getBitsBase16(16, 48))
            return { prefix: y.sprintf('%s', w.slice(0, 4)), gateway: v.address }
          }),
          (k.prototype.to6to4 = function () {
            if (!this.is4()) return null
            var w = ['2002', this.getBitsBase16(96, 112), this.getBitsBase16(112, 128), '', '/16'].join(':')
            return new k(w)
          }),
          (k.prototype.toByteArray = function () {
            var w = this.bigInteger().toByteArray()
            return w.length === 17 && w[0] === 0 ? w.slice(1) : w
          }),
          (k.prototype.toUnsignedByteArray = function () {
            return this.toByteArray().map(T)
          }),
          (k.fromByteArray = function (w) {
            return this.fromUnsignedByteArray(w.map(T))
          }),
          (k.fromUnsignedByteArray = function (w) {
            for (
              var v = new p.BigInteger('256', 10),
                I = new p.BigInteger('0', 10),
                M = new p.BigInteger('1', 10),
                q = w.length - 1;
              q >= 0;
              q--
            )
              (I = I.add(M.multiply(new p.BigInteger(w[q].toString(10), 10)))), (M = M.multiply(v))
            return k.fromBigInteger(I)
          }),
          (k.prototype.isCanonical = function () {
            return this.addressMinusSuffix === this.canonicalForm()
          }),
          (k.prototype.isLinkLocal = function () {
            return this.getBitsBase2(0, 64) === '1111111010000000000000000000000000000000000000000000000000000000'
          }),
          (k.prototype.isMulticast = function () {
            return this.getType() === 'Multicast'
          }),
          (k.prototype.is4 = function () {
            return this.v4
          }),
          (k.prototype.isTeredo = function () {
            return this.isInSubnet(new k('2001::/32'))
          }),
          (k.prototype.is6to4 = function () {
            return this.isInSubnet(new k('2002::/16'))
          }),
          (k.prototype.isLoopback = function () {
            return this.getType() === 'Loopback'
          }),
          (k.prototype.href = function (w) {
            return (
              w === void 0 ? (w = '') : (w = y.sprintf(':%s', w)), y.sprintf('http://[%s]%s/', this.correctForm(), w)
            )
          }),
          (k.prototype.link = function (w) {
            w || (w = {}),
              w.className === void 0 && (w.className = ''),
              w.prefix === void 0 && (w.prefix = '/#address='),
              w.v4 === void 0 && (w.v4 = !1)
            var v = this.correctForm
            return (
              w.v4 && (v = this.to4in6),
              w.className
                ? y.sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>', w.prefix, v.call(this), w.className)
                : y.sprintf('<a href="%1$s%2$s">%2$s</a>', w.prefix, v.call(this))
            )
          }),
          (k.prototype.group = function () {
            if (this.elidedGroups === 0) return l.simpleGroup(this.address).join(':')
            d(typeof this.elidedGroups == 'number'), d(typeof this.elisionBegin == 'number')
            var w = [],
              v = this.address.split('::'),
              I = v[0],
              M = v[1]
            I.length ? w.push.apply(w, l.simpleGroup(I)) : w.push('')
            for (var q = ['hover-group'], G = this.elisionBegin; G < this.elisionBegin + this.elidedGroups; G++)
              q.push(y.sprintf('group-%d', G))
            return (
              w.push(y.sprintf('<span class="%s"></span>', q.join(' '))),
              M.length ? w.push.apply(w, l.simpleGroup(M, this.elisionEnd)) : w.push(''),
              this.is4() && (d(this.address4 instanceof a.Address4), w.pop(), w.push(this.address4.groupForV6())),
              w.join(':')
            )
          }),
          (k.prototype.regularExpressionString = function (w) {
            w === void 0 && (w = !1)
            var v = [],
              I = new k(this.correctForm())
            if (I.elidedGroups === 0) v.push(c.simpleRegularExpression(I.parsedAddress))
            else if (I.elidedGroups === o.GROUPS) v.push(c.possibleElisions(o.GROUPS))
            else {
              var M = I.address.split('::')
              M[0].length && v.push(c.simpleRegularExpression(M[0].split(':'))),
                d(typeof I.elidedGroups == 'number'),
                v.push(c.possibleElisions(I.elidedGroups, M[0].length !== 0, M[1].length !== 0)),
                M[1].length && v.push(c.simpleRegularExpression(M[1].split(':'))),
                (v = [v.join(':')])
            }
            return (
              w ||
                (v = i(['(?=^|', c.ADDRESS_BOUNDARY, '|[^\\w\\:])('], v, [
                  ')(?=[^\\w\\:]|',
                  c.ADDRESS_BOUNDARY,
                  '|$)'
                ])),
              v.join('')
            )
          }),
          (k.prototype.regularExpression = function (w) {
            return w === void 0 && (w = !1), new RegExp(this.regularExpressionString(w), 'i')
          }),
          k
        )
      })()
      e.Address6 = E
    }
  }),
  CN = te({
    'node_modules/ip-address/dist/ip-address.js'(e) {
      V(), F()
      var r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (o, l, a, c) {
                c === void 0 && (c = a),
                  Object.defineProperty(o, c, {
                    enumerable: !0,
                    get: function () {
                      return l[a]
                    }
                  })
              }
            : function (o, l, a, c) {
                c === void 0 && (c = a), (o[c] = l[a])
              }),
        t =
          (e && e.__setModuleDefault) ||
          (Object.create
            ? function (o, l) {
                Object.defineProperty(o, 'default', { enumerable: !0, value: l })
              }
            : function (o, l) {
                o.default = l
              }),
        n =
          (e && e.__importStar) ||
          function (o) {
            if (o && o.__esModule) return o
            var l = {}
            if (o != null) for (var a in o) a !== 'default' && Object.prototype.hasOwnProperty.call(o, a) && r(l, o, a)
            return t(l, o), l
          }
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.v6 = e.Address6 = e.Address4 = void 0)
      var i = cw()
      Object.defineProperty(e, 'Address4', {
        enumerable: !0,
        get: function () {
          return i.Address4
        }
      })
      var s = TN()
      Object.defineProperty(e, 'Address6', {
        enumerable: !0,
        get: function () {
          return s.Address6
        }
      })
      var u = n(lw())
      e.v6 = { helpers: u }
    }
  }),
  fw = te({
    'node_modules/libp2p-utils/src/ip-port-to-multiaddr.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:ip-port-to-multiaddr'), { error: t('libp2p:ip-port-to-multiaddr:err') }),
        { Multiaddr: i } = AN(),
        s = pt(),
        { Address4: u, Address6: o } = CN(),
        l = {
          ERR_INVALID_IP_PARAMETER: 'ERR_INVALID_IP_PARAMETER',
          ERR_INVALID_PORT_PARAMETER: 'ERR_INVALID_PORT_PARAMETER',
          ERR_INVALID_IP: 'ERR_INVALID_IP'
        }
      function a(c, f) {
        if (typeof c != 'string') throw s(new Error(`invalid ip provided: ${c}`), l.ERR_INVALID_IP_PARAMETER)
        if ((typeof f == 'string' && (f = parseInt(f)), isNaN(f)))
          throw s(new Error(`invalid port provided: ${f}`), l.ERR_INVALID_PORT_PARAMETER)
        try {
          return new u(c), new i(`/ip4/${c}/tcp/${f}`)
        } catch {}
        try {
          let p = new o(c)
          return p.is4() ? new i(`/ip4/${p.to4().correctForm()}/tcp/${f}`) : new i(`/ip6/${c}/tcp/${f}`)
        } catch (p) {
          let y = `invalid ip:port for creating a multiaddr: ${c}:${f}`
          throw (n.error(y), s(new Error(y), l.ERR_INVALID_IP))
        }
      }
      ;(r.exports = a), (r.exports.Errors = l)
    }
  }),
  kN = te({
    'node_modules/libp2p-websockets/node_modules/p-timeout/index.js'(e, r) {
      V(), F()
      var t = class extends Error {
          constructor(i) {
            super(i)
            this.name = 'TimeoutError'
          }
        },
        n = (i, s, u, o) => {
          let l,
            a = new Promise((c, f) => {
              if (typeof s != 'number' || s < 0) throw new TypeError('Expected `milliseconds` to be a positive number')
              if (s === 1 / 0) {
                c(i)
                return
              }
              ;(o = { customTimers: { setTimeout, clearTimeout }, ...o }),
                (l = o.customTimers.setTimeout.call(
                  void 0,
                  () => {
                    if (typeof u == 'function') {
                      try {
                        c(u())
                      } catch (d) {
                        f(d)
                      }
                      return
                    }
                    let p = typeof u == 'string' ? u : `Promise timed out after ${s} milliseconds`,
                      y = u instanceof Error ? u : new t(p)
                    typeof i.cancel == 'function' && i.cancel(), f(y)
                  },
                  s
                )),
                (async () => {
                  try {
                    c(await i)
                  } catch (p) {
                    f(p)
                  } finally {
                    o.customTimers.clearTimeout.call(void 0, l)
                  }
                })()
            })
          return (
            (a.clear = () => {
              clearTimeout(l), (l = void 0)
            }),
            a
          )
        }
      ;(r.exports = n), (r.exports.default = n), (r.exports.TimeoutError = t)
    }
  }),
  MN = te({
    'node_modules/libp2p-websockets/src/socket-to-conn.js'(e, r) {
      V(), F()
      var t = Ui(),
        { CLOSE_TIMEOUT: n } = y3(),
        i = fw(),
        s = kN(),
        u = mt(),
        o = u('libp2p:websockets:socket')
      ;(o.error = u('libp2p:websockets:socket:error')),
        (r.exports = (l, a = {}) => {
          let c = {
            async sink(f) {
              a.signal && (f = t(f, a.signal))
              try {
                await l.sink(
                  (async function* () {
                    for await (let p of f) yield p instanceof Uint8Array ? p : p.slice()
                  })()
                )
              } catch (p) {
                p.type !== 'aborted' && o.error(p)
              }
            },
            source: a.signal ? t(l.source, a.signal) : l.source,
            conn: l,
            localAddr: a.localAddr || (l.localAddress && l.localPort ? i(l.localAddress, l.localPort) : void 0),
            remoteAddr: a.remoteAddr || i(l.remoteAddress, l.remotePort),
            timeline: { open: Date.now() },
            async close() {
              let f = Date.now()
              try {
                await s(l.close(), n)
              } catch (p) {
                let { host: y, port: d } = c.remoteAddr.toOptions()
                o('timeout closing stream to %s:%s after %dms, destroying it manually', y, d, Date.now() - f),
                  l.destroy()
              } finally {
                c.timeline.close = Date.now()
              }
            }
          }
          return (
            l.socket.once &&
              l.socket.once('close', () => {
                c.timeline.close || (c.timeline.close = Date.now())
              }),
            c
          )
        })
    }
  })
function xN(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var dw,
  hw,
  pw,
  RN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (dw = xN), (hw = dw), (pw = hw)
    }
  }),
  mw = {}
Re(mw, {
  coerce: () => ys,
  empty: () => fp,
  equals: () => dp,
  fromHex: () => yw,
  fromString: () => hp,
  isBinary: () => vw,
  toHex: () => bw,
  toString: () => pp
})
var fp,
  bw,
  yw,
  dp,
  ys,
  vw,
  hp,
  pp,
  vs = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (fp = new Uint8Array(0)),
        (bw = (e) => e.reduce((r, t) => r + t.toString(16).padStart(2, '0'), '')),
        (yw = (e) => {
          let r = e.match(/../g)
          return r ? new Uint8Array(r.map((t) => parseInt(t, 16))) : fp
        }),
        (dp = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (ys = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (vw = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e)),
        (hp = (e) => new TextEncoder().encode(e)),
        (pp = (e) => new TextDecoder().decode(e))
    }
  }),
  gw,
  ww,
  mp,
  _w,
  Jl,
  Bo,
  Ew,
  Sw,
  dr,
  ni = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        RN(),
        vs(),
        (gw = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (ww = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new mp(r)
          }
        }),
        (mp = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new mp({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (_w = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new gw(e, r, t)),
              (this.decoder = new ww(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (Jl = ({ name: e, prefix: r, encode: t, decode: n }) => new _w(e, r, t, n)),
        (Bo = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = pw(t, r)
          return Jl({ prefix: e, name: r, encode: n, decode: (s) => ys(i(s)) })
        }),
        (Ew = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (Sw = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (dr = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          Jl({
            prefix: r,
            name: e,
            encode(i) {
              return Sw(i, n, t)
            },
            decode(i) {
              return Ew(i, n, t, e)
            }
          }))
    }
  }),
  Aw = {}
Re(Aw, { identity: () => Iw })
var Iw,
  BN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), ni(), vs(), (Iw = Jl({ prefix: '\0', name: 'identity', encode: (e) => pp(e), decode: (e) => hp(e) }))
    }
  }),
  Tw = {}
Re(Tw, { base2: () => Cw })
var Cw,
  NN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), ni(), (Cw = dr({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  kw = {}
Re(kw, { base8: () => Mw })
var Mw,
  PN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), ni(), (Mw = dr({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  xw = {}
Re(xw, { base10: () => Rw })
var Rw,
  ON = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), ni(), (Rw = Bo({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  Bw = {}
Re(Bw, { base16: () => Nw, base16upper: () => Pw })
var Nw,
  Pw,
  DN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        ni(),
        (Nw = dr({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (Pw = dr({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  Ow = {}
Re(Ow, {
  base32: () => No,
  base32hex: () => qw,
  base32hexpad: () => zw,
  base32hexpadupper: () => Kw,
  base32hexupper: () => jw,
  base32pad: () => Lw,
  base32padupper: () => Uw,
  base32upper: () => Dw,
  base32z: () => Fw
})
var No,
  Dw,
  Lw,
  Uw,
  qw,
  jw,
  zw,
  Kw,
  Fw,
  Vw = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        ni(),
        (No = dr({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (Dw = dr({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (Lw = dr({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (Uw = dr({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (qw = dr({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        (jw = dr({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (zw = dr({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (Kw = dr({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (Fw = dr({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  Hw = {}
Re(Hw, { base36: () => $w, base36upper: () => Gw })
var $w,
  Gw,
  LN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        ni(),
        ($w = Bo({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (Gw = Bo({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  Ww = {}
Re(Ww, { base58btc: () => Ln, base58flickr: () => Jw })
var Ln,
  Jw,
  Xw = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        ni(),
        (Ln = Bo({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (Jw = Bo({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  Yw = {}
Re(Yw, { base64: () => Zw, base64pad: () => Qw, base64url: () => e8, base64urlpad: () => t8 })
var Zw,
  Qw,
  e8,
  t8,
  UN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        ni(),
        (Zw = dr({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (Qw = dr({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (e8 = dr({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (t8 = dr({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function r8(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= o8; ) (r[t++] = (e & 255) | yp), (e /= 128)
  for (; e & s8; ) (r[t++] = (e & 255) | yp), (e >>>= 7)
  return (r[t] = e | 0), (r8.bytes = t - n + 1), r
}
function bp(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((bp.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & vp) << n : (s & vp) * Math.pow(2, n)), (n += 7)
  } while (s >= c8)
  return (bp.bytes = i - r), t
}
var n8,
  yp,
  i8,
  s8,
  o8,
  a8,
  c8,
  vp,
  u8,
  l8,
  f8,
  d8,
  h8,
  p8,
  m8,
  b8,
  y8,
  v8,
  g8,
  w8,
  Tc,
  qN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        (n8 = r8),
        (yp = 128),
        (i8 = 127),
        (s8 = ~i8),
        (o8 = Math.pow(2, 31)),
        (a8 = bp),
        (c8 = 128),
        (vp = 127),
        (u8 = Math.pow(2, 7)),
        (l8 = Math.pow(2, 14)),
        (f8 = Math.pow(2, 21)),
        (d8 = Math.pow(2, 28)),
        (h8 = Math.pow(2, 35)),
        (p8 = Math.pow(2, 42)),
        (m8 = Math.pow(2, 49)),
        (b8 = Math.pow(2, 56)),
        (y8 = Math.pow(2, 63)),
        (v8 = function (e) {
          return e < u8
            ? 1
            : e < l8
            ? 2
            : e < f8
            ? 3
            : e < d8
            ? 4
            : e < h8
            ? 5
            : e < p8
            ? 6
            : e < m8
            ? 7
            : e < b8
            ? 8
            : e < y8
            ? 9
            : 10
        }),
        (g8 = { encode: n8, decode: a8, encodingLength: v8 }),
        (w8 = g8),
        (Tc = w8)
    }
  }),
  _8 = {}
Re(_8, { decode: () => Cc, encodeTo: () => Po, encodingLength: () => Oo })
var Cc,
  Po,
  Oo,
  gp = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        qN(),
        (Cc = (e) => [Tc.decode(e), Tc.decode.bytes]),
        (Po = (e, r, t = 0) => (Tc.encode(e, r, t), r)),
        (Oo = (e) => Tc.encodingLength(e))
    }
  }),
  E8 = {}
Re(E8, { Digest: () => kc, create: () => Xl, decode: () => wp, equals: () => _p })
var Xl,
  wp,
  _p,
  kc,
  Ep = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        vs(),
        gp(),
        (Xl = (e, r) => {
          let t = r.byteLength,
            n = Oo(e),
            i = n + Oo(t),
            s = new Uint8Array(i + t)
          return Po(e, s, 0), Po(t, s, n), s.set(r, i), new kc(e, t, r, s)
        }),
        (wp = (e) => {
          let r = ys(e),
            [t, n] = Cc(r),
            [i, s] = Cc(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new kc(t, i, u, r)
        }),
        (_p = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && dp(e.bytes, r.bytes))),
        (kc = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  S8 = {}
Re(S8, { Hasher: () => Sp, from: () => Mc })
var Mc,
  Sp,
  Ap = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        Ep(),
        (Mc = ({ name: e, code: r, encode: t }) => new Sp(e, r, t)),
        (Sp = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return Xl(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  A8 = {}
Re(A8, { sha256: () => I8, sha512: () => T8 })
var Ip,
  I8,
  T8,
  jN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        Ap(),
        (Ip = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (I8 = Mc({ name: 'sha2-256', code: 18, encode: Ip('SHA-256') })),
        (T8 = Mc({ name: 'sha2-512', code: 19, encode: Ip('SHA-512') }))
    }
  }),
  C8 = {}
Re(C8, { identity: () => k8 })
var k8,
  zN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), Ap(), vs(), (k8 = Mc({ name: 'identity', code: 0, encode: (e) => ys(e) }))
    }
  }),
  M8 = {}
Re(M8, { code: () => R8, decode: () => N8, encode: () => B8, name: () => x8 })
var Tp,
  x8,
  R8,
  B8,
  N8,
  KN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(),
        F(),
        vs(),
        (Tp = (e) => ys(e)),
        ({ name: x8, code: R8, encode: B8, decode: N8 } = { name: 'raw', code: 85, decode: Tp, encode: Tp })
    }
  }),
  P8 = {}
Re(P8, { code: () => D8, decode: () => U8, encode: () => L8, name: () => O8 })
var O8,
  D8,
  L8,
  U8,
  FN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(),
        F(),
        ({
          name: O8,
          code: D8,
          encode: L8,
          decode: U8
        } = {
          name: 'json',
          code: 512,
          encode: (e) => new TextEncoder().encode(JSON.stringify(e)),
          decode: (e) => JSON.parse(new TextDecoder().decode(e))
        })
    }
  }),
  xr,
  q8,
  j8,
  z8,
  Do,
  K8,
  Cp,
  kp,
  xc,
  Rc,
  F8,
  V8,
  H8,
  VN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        gp(),
        Ep(),
        Xw(),
        Vw(),
        vs(),
        (xr = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: Rc,
                byteLength: Rc,
                code: xc,
                version: xc,
                multihash: xc,
                bytes: xc,
                _baseCache: Rc,
                asCID: Rc
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== Do) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== K8) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return xr.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = Xl(e, r)
                return xr.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && _p(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return j8(r, n, e || Ln.encoder)
              default:
                return z8(r, n, e || No.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return V8(/^0\.0/, H8), !!(e && (e[kp] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof xr) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new xr(r, t, n, i || Cp(r, t, n.bytes))
            } else if (e != null && e[kp] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = wp(t)
              return xr.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== Do) throw new Error(`Version 0 CID must use dag-pb (code: ${Do}) block encoding`)
                return new xr(e, r, t, t.bytes)
              }
              case 1: {
                let n = Cp(e, r, t.bytes)
                return new xr(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return xr.create(0, Do, e)
          }
          static createV1(e, r) {
            return xr.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = xr.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = xr.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = ys(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new kc(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? xr.createV0(s) : xr.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = Cc(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = Do
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = q8(e, r),
              i = xr.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (q8 = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || Ln
              return [Ln.prefix, t.decode(`${Ln.prefix}${e}`)]
            }
            case Ln.prefix: {
              let t = r || Ln
              return [Ln.prefix, t.decode(e)]
            }
            case No.prefix: {
              let t = r || No
              return [No.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        (j8 = (e, r, t) => {
          let { prefix: n } = t
          if (n !== Ln.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (z8 = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (Do = 112),
        (K8 = 18),
        (Cp = (e, r, t) => {
          let n = Oo(e),
            i = n + Oo(r),
            s = new Uint8Array(i + t.byteLength)
          return Po(e, s, 0), Po(r, s, n), s.set(t, i), s
        }),
        (kp = Symbol.for('@ipld/js-cid/CID')),
        (xc = { writable: !1, configurable: !1, enumerable: !0 }),
        (Rc = { writable: !1, enumerable: !1, configurable: !1 }),
        (F8 = '0.0.0-dev'),
        (V8 = (e, r) => {
          if (e.test(F8)) console.warn(r)
          else throw new Error(r)
        }),
        (H8 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  HN = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), VN(), gp(), vs(), Ap(), Ep()
    }
  }),
  $8 = {}
Re($8, {
  CID: () => xr,
  bases: () => G8,
  bytes: () => mw,
  codecs: () => J8,
  digest: () => E8,
  hasher: () => S8,
  hashes: () => W8,
  varint: () => _8
})
var G8,
  W8,
  J8,
  $N = Ie({
    'node_modules/mafmt/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        BN(),
        NN(),
        PN(),
        ON(),
        DN(),
        Vw(),
        LN(),
        Xw(),
        UN(),
        jN(),
        zN(),
        KN(),
        FN(),
        HN(),
        (G8 = { ...Aw, ...Tw, ...kw, ...xw, ...Bw, ...Ow, ...Hw, ...Ww, ...Yw }),
        (W8 = { ...A8, ...C8 }),
        (J8 = { raw: M8, json: P8 })
    }
  }),
  X8 = te({
    'node_modules/mafmt/node_modules/uint8arrays/util/bases.js'(e, r) {
      V(), F()
      var { bases: t } = ($N(), $8)
      function n(o, l, a, c) {
        return { name: o, prefix: l, encoder: { name: o, prefix: l, encode: a }, decoder: { decode: c } }
      }
      var i = n(
          'utf8',
          'u',
          (o) => {
            let l = new TextDecoder('utf8')
            return 'u' + l.decode(o)
          },
          (o) => new TextEncoder().encode(o.substring(1))
        ),
        s = n(
          'ascii',
          'a',
          (o) => {
            let l = 'a'
            for (let a = 0; a < o.length; a++) l += String.fromCharCode(o[a])
            return l
          },
          (o) => {
            o = o.substring(1)
            let l = new Uint8Array(o.length)
            for (let a = 0; a < o.length; a++) l[a] = o.charCodeAt(a)
            return l
          }
        ),
        u = { utf8: i, 'utf-8': i, hex: t.base16, latin1: s, ascii: s, binary: s, ...t }
      r.exports = u
    }
  }),
  Yl = te({
    'node_modules/mafmt/node_modules/uint8arrays/to-string.js'(e, r) {
      V(), F()
      var t = X8()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.encoder.encode(i).substring(1)
      }
      r.exports = n
    }
  }),
  GN = te({
    'node_modules/mafmt/node_modules/multiaddr/src/ip.js'(e, r) {
      V(), F()
      var t = yo(),
        n = Yl(),
        i = t,
        s = t.v4,
        u = t.v6,
        o = function (a, c, f) {
          f = ~~f
          let p
          if (s(a))
            (p = c || new Uint8Array(f + 4)),
              a.split(/\./g).map(function (d) {
                p[f++] = parseInt(d, 10) & 255
              })
          else if (u(a)) {
            let d = a.split(':', 8),
              h
            for (h = 0; h < d.length; h++) {
              let m = s(d[h])
              var y
              m && ((y = o(d[h])), (d[h] = n(y.slice(0, 2), 'base16'))),
                y && ++h < 8 && d.splice(h, 0, n(y.slice(2, 4), 'base16'))
            }
            if (d[0] === '') for (; d.length < 8; ) d.unshift('0')
            else if (d[d.length - 1] === '') for (; d.length < 8; ) d.push('0')
            else if (d.length < 8) {
              for (h = 0; h < d.length && d[h] !== ''; h++);
              let m = [h, '1']
              for (h = 9 - d.length; h > 0; h--) m.push('0')
              d.splice.apply(d, m)
            }
            for (p = c || new Uint8Array(f + 16), h = 0; h < d.length; h++) {
              let m = parseInt(d[h], 16)
              ;(p[f++] = (m >> 8) & 255), (p[f++] = m & 255)
            }
          }
          if (!p) throw Error('Invalid ip address: ' + a)
          return p
        },
        l = function (a, c, f) {
          ;(c = ~~c), (f = f || a.length - c)
          let p = [],
            y,
            d = new DataView(a.buffer)
          if (f === 4) {
            for (let h = 0; h < f; h++) p.push(a[c + h])
            y = p.join('.')
          } else if (f === 16) {
            for (let h = 0; h < f; h += 2) p.push(d.getUint16(c + h).toString(16))
            ;(y = p.join(':')), (y = y.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')), (y = y.replace(/:{3,4}/, '::'))
          }
          return y
        }
      r.exports = { isIP: i, isV4: s, isV6: u, toBytes: o, toString: l }
    }
  }),
  Mp = te({
    'node_modules/mafmt/node_modules/multiaddr/src/protocols-table.js'(e, r) {
      V(), F()
      function t(s) {
        if (typeof s == 'number') {
          if (t.codes[s]) return t.codes[s]
          throw new Error('no protocol with code: ' + s)
        } else if (typeof s == 'string') {
          if (t.names[s]) return t.names[s]
          throw new Error('no protocol with name: ' + s)
        }
        throw new Error('invalid protocol id type: ' + s)
      }
      var n = -1
      ;(t.lengthPrefixedVarSize = n),
        (t.V = n),
        (t.table = [
          [4, 32, 'ip4'],
          [6, 16, 'tcp'],
          [33, 16, 'dccp'],
          [41, 128, 'ip6'],
          [42, n, 'ip6zone'],
          [53, n, 'dns', 'resolvable'],
          [54, n, 'dns4', 'resolvable'],
          [55, n, 'dns6', 'resolvable'],
          [56, n, 'dnsaddr', 'resolvable'],
          [132, 16, 'sctp'],
          [273, 16, 'udp'],
          [275, 0, 'p2p-webrtc-star'],
          [276, 0, 'p2p-webrtc-direct'],
          [277, 0, 'p2p-stardust'],
          [290, 0, 'p2p-circuit'],
          [301, 0, 'udt'],
          [302, 0, 'utp'],
          [400, n, 'unix', !1, 'path'],
          [421, n, 'ipfs'],
          [421, n, 'p2p'],
          [443, 0, 'https'],
          [444, 96, 'onion'],
          [445, 296, 'onion3'],
          [446, n, 'garlic64'],
          [460, 0, 'quic'],
          [477, 0, 'ws'],
          [478, 0, 'wss'],
          [479, 0, 'p2p-websocket-star'],
          [480, 0, 'http'],
          [777, n, 'memory']
        ]),
        (t.names = {}),
        (t.codes = {}),
        t.table.map((s) => {
          let u = i.apply(null, s)
          return (t.codes[u.code] = u), (t.names[u.name] = u), null
        }),
        (t.object = i)
      function i(s, u, o, l, a) {
        return { code: s, size: u, name: o, resolvable: Boolean(l), path: Boolean(a) }
      }
      r.exports = t
    }
  }),
  WN = te({
    'node_modules/mafmt/node_modules/uint8arrays/from-string.js'(e, r) {
      V(), F()
      var t = X8()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.decoder.decode(`${u.prefix}${i}`)
      }
      r.exports = n
    }
  }),
  Y8 = te({
    'node_modules/mafmt/node_modules/uint8arrays/concat.js'(e, r) {
      V(), F()
      function t(n, i) {
        i || (i = n.reduce((o, l) => o + l.length, 0))
        let s = new Uint8Array(i),
          u = 0
        for (let o of n) s.set(o, u), (u += o.length)
        return s
      }
      r.exports = t
    }
  }),
  JN = te({
    'node_modules/mafmt/node_modules/multiaddr/src/convert.js'(e, r) {
      V(), F()
      var t = GN(),
        n = Mp(),
        i = Gr(),
        s = Di(),
        u = $t(),
        o = Yl(),
        l = WN(),
        a = Y8()
      r.exports = c
      function c(w, v) {
        return v instanceof Uint8Array ? c.toString(w, v) : c.toBytes(w, v)
      }
      ;(c.toString = function (v, I) {
        switch (n(v).code) {
          case 4:
          case 41:
            return p(I)
          case 6:
          case 273:
          case 33:
          case 132:
            return d(I).toString()
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return m(I)
          case 421:
            return A(I)
          case 444:
            return k(I)
          case 445:
            return k(I)
          default:
            return o(I, 'base16')
        }
      }),
        (c.toBytes = function (v, I) {
          switch (n(v).code) {
            case 4:
              return f(I)
            case 41:
              return f(I)
            case 6:
            case 273:
            case 33:
            case 132:
              return y(parseInt(I, 10))
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return h(I)
            case 421:
              return _(I)
            case 444:
              return T(I)
            case 445:
              return E(I)
            default:
              return l(I, 'base16')
          }
        })
      function f(w) {
        if (!t.isIP(w)) throw new Error('invalid ip address')
        return t.toBytes(w)
      }
      function p(w) {
        let v = t.toString(w)
        if (!v || !t.isIP(v)) throw new Error('invalid ip address')
        return v
      }
      function y(w) {
        let v = new ArrayBuffer(2)
        return new DataView(v).setUint16(0, w), new Uint8Array(v)
      }
      function d(w) {
        return new DataView(w.buffer).getUint16(w.byteOffset)
      }
      function h(w) {
        let v = l(w),
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function m(w) {
        let v = u.decode(w)
        if (((w = w.slice(u.decode.bytes)), w.length !== v)) throw new Error('inconsistent lengths')
        return o(w)
      }
      function _(w) {
        let v = new i(w).multihash,
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function A(w) {
        let v = u.decode(w),
          I = w.slice(u.decode.bytes)
        if (I.length !== v) throw new Error('inconsistent lengths')
        return o(I, 'base58btc')
      }
      function T(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 16) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function E(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 56) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion3 address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function k(w) {
        let v = w.slice(0, w.length - 2),
          I = w.slice(w.length - 2),
          M = o(v, 'base32'),
          q = d(I)
        return M + ':' + q
      }
    }
  }),
  XN = te({
    'node_modules/mafmt/node_modules/multiaddr/src/codec.js'(e, r) {
      V(), F()
      var t = JN(),
        n = Mp(),
        i = $t(),
        s = Y8(),
        u = Yl()
      r.exports = {
        stringToStringTuples: o,
        stringTuplesToString: l,
        tuplesToStringTuples: c,
        stringTuplesToTuples: a,
        bytesToTuples: y,
        tuplesToBytes: f,
        bytesToString: d,
        stringToBytes: h,
        fromString: m,
        fromBytes: _,
        validateBytes: A,
        isValidBytes: T,
        cleanPath: E,
        ParseError: k,
        protoFromTuple: w,
        sizeForAddr: p
      }
      function o(v) {
        let I = [],
          M = v.split('/').slice(1)
        if (M.length === 1 && M[0] === '') return []
        for (let q = 0; q < M.length; q++) {
          let G = M[q],
            O = n(G)
          if (O.size === 0) {
            I.push([G])
            continue
          }
          if ((q++, q >= M.length)) throw k('invalid address: ' + v)
          if (O.path) {
            I.push([G, E(M.slice(q).join('/'))])
            break
          }
          I.push([G, M[q]])
        }
        return I
      }
      function l(v) {
        let I = []
        return (
          v.map((M) => {
            let q = w(M)
            return I.push(q.name), M.length > 1 && I.push(M[1]), null
          }),
          E(I.join('/'))
        )
      }
      function a(v) {
        return v.map((I) => {
          Array.isArray(I) || (I = [I])
          let M = w(I)
          return I.length > 1 ? [M.code, t.toBytes(M.code, I[1])] : [M.code]
        })
      }
      function c(v) {
        return v.map((I) => {
          let M = w(I)
          return I[1] ? [M.code, t.toString(M.code, I[1])] : [M.code]
        })
      }
      function f(v) {
        return _(
          s(
            v.map((I) => {
              let M = w(I),
                q = Uint8Array.from(i.encode(M.code))
              return I.length > 1 && (q = s([q, I[1]])), q
            })
          )
        )
      }
      function p(v, I) {
        return v.size > 0 ? v.size / 8 : v.size === 0 ? 0 : i.decode(I) + i.decode.bytes
      }
      function y(v) {
        let I = [],
          M = 0
        for (; M < v.length; ) {
          let q = i.decode(v, M),
            G = i.decode.bytes,
            O = n(q),
            x = p(O, v.slice(M + G))
          if (x === 0) {
            I.push([q]), (M += G)
            continue
          }
          let L = v.slice(M + G, M + G + x)
          if (((M += x + G), M > v.length)) throw k('Invalid address Uint8Array: ' + u(v, 'base16'))
          I.push([q, L])
        }
        return I
      }
      function d(v) {
        let I = y(v),
          M = c(I)
        return l(M)
      }
      function h(v) {
        v = E(v)
        let I = o(v),
          M = a(I)
        return f(M)
      }
      function m(v) {
        return h(v)
      }
      function _(v) {
        let I = A(v)
        if (I) throw I
        return Uint8Array.from(v)
      }
      function A(v) {
        try {
          y(v)
        } catch (I) {
          return I
        }
      }
      function T(v) {
        return A(v) === void 0
      }
      function E(v) {
        return (
          '/' +
          v
            .trim()
            .split('/')
            .filter((I) => I)
            .join('/')
        )
      }
      function k(v) {
        return new Error('Error parsing address: ' + v)
      }
      function w(v) {
        return n(v[0])
      }
    }
  }),
  YN = te({
    'node_modules/mafmt/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  }),
  ZN = te({
    'node_modules/mafmt/node_modules/multiaddr/src/index.js'(e, r) {
      V(), F()
      var t = XN(),
        n = Mp(),
        i = $t(),
        s = Gr(),
        u = pt(),
        o = Symbol.for('nodejs.util.inspect.custom'),
        l = Yl(),
        a = YN(),
        c = new Map(),
        f = Symbol.for('@multiformats/js-multiaddr/multiaddr'),
        p = class {
          constructor(d) {
            if ((d == null && (d = ''), Object.defineProperty(this, f, { value: !0 }), d instanceof Uint8Array))
              this.bytes = t.fromBytes(d)
            else if (typeof d == 'string') {
              if (d.length > 0 && d.charAt(0) !== '/') throw new Error(`multiaddr "${d}" must start with a "/"`)
              this.bytes = t.fromString(d)
            } else if (p.isMultiaddr(d)) this.bytes = t.fromBytes(d.bytes)
            else throw new Error('addr must be a string, Buffer, or another Multiaddr')
          }
          toString() {
            return t.bytesToString(this.bytes)
          }
          toJSON() {
            return this.toString()
          }
          toOptions() {
            let d = {},
              h = this.toString().split('/')
            return (
              (d.family = h[1] === 'ip4' ? 4 : 6), (d.host = h[2]), (d.transport = h[3]), (d.port = parseInt(h[4])), d
            )
          }
          protos() {
            return this.protoCodes().map((d) => Object.assign({}, n(d)))
          }
          protoCodes() {
            let d = [],
              h = this.bytes,
              m = 0
            for (; m < h.length; ) {
              let _ = i.decode(h, m),
                A = i.decode.bytes,
                T = n(_)
              ;(m += t.sizeForAddr(T, h.slice(m + A)) + A), d.push(_)
            }
            return d
          }
          protoNames() {
            return this.protos().map((d) => d.name)
          }
          tuples() {
            return t.bytesToTuples(this.bytes)
          }
          stringTuples() {
            let d = t.bytesToTuples(this.bytes)
            return t.tuplesToStringTuples(d)
          }
          encapsulate(d) {
            return (d = new p(d)), new p(this.toString() + d.toString())
          }
          decapsulate(d) {
            let h = d.toString(),
              m = this.toString(),
              _ = m.lastIndexOf(h)
            if (_ < 0) throw new Error('Address ' + this + ' does not contain subaddress: ' + d)
            return new p(m.slice(0, _))
          }
          decapsulateCode(d) {
            let h = this.tuples()
            for (let m = h.length - 1; m >= 0; m--) if (h[m][0] === d) return new p(t.tuplesToBytes(h.slice(0, m)))
            return this
          }
          getPeerId() {
            try {
              let h = this.stringTuples()
                .filter((m) => m[0] === n.names.ipfs.code)
                .pop()
              return h && h[1] ? l(new s(h[1]).multihash, 'base58btc') : null
            } catch (d) {
              return null
            }
          }
          getPath() {
            let d = null
            try {
              ;(d = this.stringTuples().filter((h) => !!n(h[0]).path)[0][1]), d || (d = null)
            } catch (h) {
              d = null
            }
            return d
          }
          equals(d) {
            return a(this.bytes, d.bytes)
          }
          async resolve() {
            let d = this.protos().find((_) => _.resolvable)
            if (!d) return [this]
            let h = c.get(d.name)
            if (!h) throw u(new Error(`no available resolver for ${d.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
            return (await h(this)).map((_) => new p(_))
          }
          nodeAddress() {
            let d = this.protoCodes(),
              h = this.protoNames(),
              m = this.toString().split('/').slice(1)
            if (m.length < 4)
              throw new Error(
                'multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'
              )
            if (d[0] !== 4 && d[0] !== 41 && d[0] !== 54 && d[0] !== 55)
              throw new Error(
                `no protocol with name: "'${h[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`
              )
            if (m[2] !== 'tcp' && m[2] !== 'udp')
              throw new Error(`no protocol with name: "'${h[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
            return { family: d[0] === 41 || d[0] === 55 ? 6 : 4, address: m[1], port: parseInt(m[3]) }
          }
          isThinWaistAddress(d) {
            let h = (d || this).protos()
            return !(h.length !== 2 || (h[0].code !== 4 && h[0].code !== 41) || (h[1].code !== 6 && h[1].code !== 273))
          }
          static fromNodeAddress(d, h) {
            if (!d) throw new Error('requires node address object')
            if (!h) throw new Error('requires transport protocol')
            let m
            switch (d.family) {
              case 4:
                m = 'ip4'
                break
              case 6:
                m = 'ip6'
                break
              default:
                throw Error(`Invalid addr family. Got '${d.family}' instead of 4 or 6`)
            }
            return new p('/' + [m, d.address, h, d.port].join('/'))
          }
          static isName(d) {
            return p.isMultiaddr(d) ? d.protos().some((h) => h.resolvable) : !1
          }
          static isMultiaddr(d) {
            return d instanceof p || Boolean(d && d[f])
          }
          [o]() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
          inspect() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
        }
      ;(p.protocols = n), (p.resolvers = c)
      function y(d) {
        return new p(d)
      }
      r.exports = { Multiaddr: p, multiaddr: y, protocols: n, resolvers: c }
    }
  }),
  xp = te({
    'node_modules/mafmt/src/index.js'(e, r) {
      V(), F()
      var { Multiaddr: t } = ZN(),
        n = x('dns4'),
        i = x('dns6'),
        s = x('dnsaddr'),
        u = O(x('dns'), s, n, i),
        o = O(x('ip4'), x('ip6')),
        l = O(G(o, x('tcp')), G(u, x('tcp'))),
        a = G(o, x('udp')),
        c = G(a, x('utp')),
        f = G(a, x('quic')),
        p = O(G(l, x('ws')), G(u, x('ws'))),
        y = O(G(l, x('wss')), G(u, x('wss'))),
        d = O(G(l, x('http')), G(o, x('http')), G(u, x('http'))),
        h = O(G(l, x('https')), G(o, x('https')), G(u, x('https'))),
        m = O(
          G(p, x('p2p-webrtc-star'), x('p2p')),
          G(y, x('p2p-webrtc-star'), x('p2p')),
          G(p, x('p2p-webrtc-star')),
          G(y, x('p2p-webrtc-star'))
        ),
        _ = O(
          G(p, x('p2p-websocket-star'), x('p2p')),
          G(y, x('p2p-websocket-star'), x('p2p')),
          G(p, x('p2p-websocket-star')),
          G(y, x('p2p-websocket-star'))
        ),
        A = O(
          G(d, x('p2p-webrtc-direct'), x('p2p')),
          G(h, x('p2p-webrtc-direct'), x('p2p')),
          G(d, x('p2p-webrtc-direct')),
          G(h, x('p2p-webrtc-direct'))
        ),
        T = O(p, y, d, h, m, A, l, c, f, u),
        E = O(G(T, x('p2p-stardust'), x('p2p')), G(T, x('p2p-stardust'))),
        k = O(G(T, x('p2p')), m, A, x('p2p')),
        w = O(
          G(k, x('p2p-circuit'), k),
          G(k, x('p2p-circuit')),
          G(x('p2p-circuit'), k),
          G(T, x('p2p-circuit')),
          G(x('p2p-circuit'), T),
          x('p2p-circuit')
        ),
        v = () => O(G(w, v), w),
        I = v(),
        M = O(G(I, k, I), G(k, I), G(I, k), I, k)
      r.exports = {
        DNS: u,
        DNS4: n,
        DNS6: i,
        DNSADDR: s,
        IP: o,
        TCP: l,
        UDP: a,
        QUIC: f,
        UTP: c,
        HTTP: d,
        HTTPS: h,
        WebSockets: p,
        WebSocketsSecure: y,
        WebSocketStar: _,
        WebRTCStar: m,
        WebRTCDirect: A,
        Reliable: T,
        Stardust: E,
        Circuit: I,
        P2P: M,
        IPFS: M
      }
      function q(L) {
        function K(J) {
          if (!t.isMultiaddr(J))
            try {
              J = new t(J)
            } catch (Q) {
              return !1
            }
          let Z = L(J.protoNames())
          return Z === null ? !1 : Z === !0 || Z === !1 ? Z : Z.length === 0
        }
        return K
      }
      function G(...L) {
        function K(J) {
          if (J.length < L.length) return null
          let Z = J
          return (
            L.some(
              (Q) => (
                (Z = typeof Q == 'function' ? Q().partialMatch(J) : Q.partialMatch(J)),
                Array.isArray(Z) && (J = Z),
                Z === null
              )
            ),
            Z
          )
        }
        return {
          toString: function () {
            return '{ ' + L.join(' ') + ' }'
          },
          input: L,
          matches: q(K),
          partialMatch: K
        }
      }
      function O(...L) {
        function K(Z) {
          let Q = null
          return (
            L.some((fe) => {
              let ie = typeof fe == 'function' ? fe().partialMatch(Z) : fe.partialMatch(Z)
              return ie ? ((Q = ie), !0) : !1
            }),
            Q
          )
        }
        return {
          toString: function () {
            return '{ ' + L.join(' ') + ' }'
          },
          input: L,
          matches: q(K),
          partialMatch: K
        }
      }
      function x(L) {
        let K = L
        function J(Q) {
          if (typeof Q == 'string')
            try {
              Q = new t(Q)
            } catch (ie) {
              return !1
            }
          let fe = Q.protoNames()
          return fe.length === 1 && fe[0] === K
        }
        function Z(Q) {
          return Q.length === 0 ? null : Q[0] === K ? Q.slice(1) : null
        }
        return {
          toString: function () {
            return K
          },
          matches: J,
          partialMatch: Z
        }
      }
    }
  }),
  Z8 = te({
    'node_modules/libp2p-websockets/src/filters.js'(e, r) {
      V(), F()
      var t = xp(),
        { CODE_CIRCUIT: n, CODE_P2P: i, CODE_TCP: s, CODE_WS: u, CODE_WSS: o } = y3()
      r.exports = {
        all: (l) =>
          l.filter((a) => {
            if (a.protoCodes().includes(n)) return !1
            let c = a.decapsulateCode(i)
            return t.WebSockets.matches(c) || t.WebSocketsSecure.matches(c)
          }),
        dnsWss: (l) =>
          l.filter((a) => {
            if (a.protoCodes().includes(n)) return !1
            let c = a.decapsulateCode(i)
            return t.WebSocketsSecure.matches(c) && t.DNS.matches(c.decapsulateCode(s).decapsulateCode(o))
          }),
        dnsWsOrWss: (l) =>
          l.filter((a) => {
            if (a.protoCodes().includes(n)) return !1
            let c = a.decapsulateCode(i)
            return t.WebSockets.matches(c)
              ? t.DNS.matches(c.decapsulateCode(s).decapsulateCode(u))
              : t.WebSocketsSecure.matches(c) && t.DNS.matches(c.decapsulateCode(s).decapsulateCode(o))
          })
      }
    }
  }),
  QN = te({
    'node_modules/libp2p-websockets/src/index.js'(e, r) {
      V(), F()
      var t = FR(),
        n = l0(),
        i = YB(),
        { AbortError: s } = Ui(),
        u = Vl(),
        o = mt(),
        l = o('libp2p:websockets')
      l.error = o('libp2p:websockets:error')
      var a = eN(),
        c = tN(),
        f = MN(),
        p = Z8(),
        y = class {
          constructor({ upgrader: d, filter: h }) {
            if (!d)
              throw new Error(
                'An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.'
              )
            ;(this._upgrader = d), (this._filter = h)
          }
          async dial(d, h = {}) {
            l('dialing %s', d)
            let m = await this._connect(d, h),
              _ = f(m, { remoteAddr: d, signal: h.signal })
            l('new outbound connection %s', _.remoteAddr)
            let A = await this._upgrader.upgradeOutbound(_)
            return l('outbound connection %s upgraded', _.remoteAddr), A
          }
          async _connect(d, h = {}) {
            if (h.signal && h.signal.aborted) throw new s()
            let m = d.toOptions()
            l('dialing %s:%s', m.host, m.port)
            let _ = u(),
              A = (w) => {
                let v = `connection error: ${w.message}`
                l.error(v), _.reject(w)
              },
              T = t(i(d), Object.assign({ binary: !0 }, h))
            if ((T.socket.on ? T.socket.on('error', A) : (T.socket.onerror = A), !h.signal))
              return await Promise.race([T.connected(), _.promise]), l('connected %s', d), T
            let E,
              k = new Promise((w, v) => {
                if (
                  ((E = () => {
                    v(new s()),
                      setTimeout(() => {
                        T.close()
                      })
                  }),
                  h.signal.aborted)
                )
                  return E()
                h.signal.addEventListener('abort', E)
              })
            try {
              await Promise.race([k, _.promise, T.connected()])
            } finally {
              h.signal.removeEventListener('abort', E)
            }
            return l('connected %s', d), T
          }
          createListener(d = {}, h) {
            return typeof d == 'function' && ((h = d), (d = {})), c({ handler: h, upgrader: this._upgrader }, d)
          }
          filter(d) {
            return (
              (d = Array.isArray(d) ? d : [d]),
              this._filter ? this._filter(d) : a.isBrowser || a.isWebWorker ? p.dnsWss(d) : p.all(d)
            )
          }
        }
      r.exports = n(y, { className: 'WebSockets', symbolName: '@libp2p/js-libp2p-websockets/websockets' })
    }
  }),
  ln = te({
    'node_modules/events/events.js'(e, r) {
      V(), F()
      var t = typeof Reflect == 'object' ? Reflect : null,
        n =
          t && typeof t.apply == 'function'
            ? t.apply
            : function (v, I, M) {
                return Function.prototype.apply.call(v, I, M)
              },
        i
      t && typeof t.ownKeys == 'function'
        ? (i = t.ownKeys)
        : Object.getOwnPropertySymbols
        ? (i = function (v) {
            return Object.getOwnPropertyNames(v).concat(Object.getOwnPropertySymbols(v))
          })
        : (i = function (v) {
            return Object.getOwnPropertyNames(v)
          })
      function s(w) {
        console && console.warn && console.warn(w)
      }
      var u =
        Number.isNaN ||
        function (v) {
          return v !== v
        }
      function o() {
        o.init.call(this)
      }
      ;(r.exports = o),
        (r.exports.once = T),
        (o.EventEmitter = o),
        (o.prototype._events = void 0),
        (o.prototype._eventsCount = 0),
        (o.prototype._maxListeners = void 0)
      var l = 10
      function a(w) {
        if (typeof w != 'function')
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof w)
      }
      Object.defineProperty(o, 'defaultMaxListeners', {
        enumerable: !0,
        get: function () {
          return l
        },
        set: function (w) {
          if (typeof w != 'number' || w < 0 || u(w))
            throw new RangeError(
              'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
                w +
                '.'
            )
          l = w
        }
      }),
        (o.init = function () {
          ;(this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) &&
            ((this._events = Object.create(null)), (this._eventsCount = 0)),
            (this._maxListeners = this._maxListeners || void 0)
        }),
        (o.prototype.setMaxListeners = function (v) {
          if (typeof v != 'number' || v < 0 || u(v))
            throw new RangeError(
              'The value of "n" is out of range. It must be a non-negative number. Received ' + v + '.'
            )
          return (this._maxListeners = v), this
        })
      function c(w) {
        return w._maxListeners === void 0 ? o.defaultMaxListeners : w._maxListeners
      }
      ;(o.prototype.getMaxListeners = function () {
        return c(this)
      }),
        (o.prototype.emit = function (v) {
          for (var I = [], M = 1; M < arguments.length; M++) I.push(arguments[M])
          var q = v === 'error',
            G = this._events
          if (G !== void 0) q = q && G.error === void 0
          else if (!q) return !1
          if (q) {
            var O
            if ((I.length > 0 && (O = I[0]), O instanceof Error)) throw O
            var x = new Error('Unhandled error.' + (O ? ' (' + O.message + ')' : ''))
            throw ((x.context = O), x)
          }
          var L = G[v]
          if (L === void 0) return !1
          if (typeof L == 'function') n(L, this, I)
          else for (var K = L.length, J = m(L, K), M = 0; M < K; ++M) n(J[M], this, I)
          return !0
        })
      function f(w, v, I, M) {
        var q, G, O
        if (
          (a(I),
          (G = w._events),
          G === void 0
            ? ((G = w._events = Object.create(null)), (w._eventsCount = 0))
            : (G.newListener !== void 0 && (w.emit('newListener', v, I.listener ? I.listener : I), (G = w._events)),
              (O = G[v])),
          O === void 0)
        )
          (O = G[v] = I), ++w._eventsCount
        else if (
          (typeof O == 'function' ? (O = G[v] = M ? [I, O] : [O, I]) : M ? O.unshift(I) : O.push(I),
          (q = c(w)),
          q > 0 && O.length > q && !O.warned)
        ) {
          O.warned = !0
          var x = new Error(
            'Possible EventEmitter memory leak detected. ' +
              O.length +
              ' ' +
              String(v) +
              ' listeners added. Use emitter.setMaxListeners() to increase limit'
          )
          ;(x.name = 'MaxListenersExceededWarning'), (x.emitter = w), (x.type = v), (x.count = O.length), s(x)
        }
        return w
      }
      ;(o.prototype.addListener = function (v, I) {
        return f(this, v, I, !1)
      }),
        (o.prototype.on = o.prototype.addListener),
        (o.prototype.prependListener = function (v, I) {
          return f(this, v, I, !0)
        })
      function p() {
        if (!this.fired)
          return (
            this.target.removeListener(this.type, this.wrapFn),
            (this.fired = !0),
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
          )
      }
      function y(w, v, I) {
        var M = { fired: !1, wrapFn: void 0, target: w, type: v, listener: I },
          q = p.bind(M)
        return (q.listener = I), (M.wrapFn = q), q
      }
      ;(o.prototype.once = function (v, I) {
        return a(I), this.on(v, y(this, v, I)), this
      }),
        (o.prototype.prependOnceListener = function (v, I) {
          return a(I), this.prependListener(v, y(this, v, I)), this
        }),
        (o.prototype.removeListener = function (v, I) {
          var M, q, G, O, x
          if ((a(I), (q = this._events), q === void 0)) return this
          if (((M = q[v]), M === void 0)) return this
          if (M === I || M.listener === I)
            --this._eventsCount == 0
              ? (this._events = Object.create(null))
              : (delete q[v], q.removeListener && this.emit('removeListener', v, M.listener || I))
          else if (typeof M != 'function') {
            for (G = -1, O = M.length - 1; O >= 0; O--)
              if (M[O] === I || M[O].listener === I) {
                ;(x = M[O].listener), (G = O)
                break
              }
            if (G < 0) return this
            G === 0 ? M.shift() : _(M, G),
              M.length === 1 && (q[v] = M[0]),
              q.removeListener !== void 0 && this.emit('removeListener', v, x || I)
          }
          return this
        }),
        (o.prototype.off = o.prototype.removeListener),
        (o.prototype.removeAllListeners = function (v) {
          var I, M, q
          if (((M = this._events), M === void 0)) return this
          if (M.removeListener === void 0)
            return (
              arguments.length === 0
                ? ((this._events = Object.create(null)), (this._eventsCount = 0))
                : M[v] !== void 0 && (--this._eventsCount == 0 ? (this._events = Object.create(null)) : delete M[v]),
              this
            )
          if (arguments.length === 0) {
            var G = Object.keys(M),
              O
            for (q = 0; q < G.length; ++q) (O = G[q]), O !== 'removeListener' && this.removeAllListeners(O)
            return (
              this.removeAllListeners('removeListener'),
              (this._events = Object.create(null)),
              (this._eventsCount = 0),
              this
            )
          }
          if (((I = M[v]), typeof I == 'function')) this.removeListener(v, I)
          else if (I !== void 0) for (q = I.length - 1; q >= 0; q--) this.removeListener(v, I[q])
          return this
        })
      function d(w, v, I) {
        var M = w._events
        if (M === void 0) return []
        var q = M[v]
        return q === void 0 ? [] : typeof q == 'function' ? (I ? [q.listener || q] : [q]) : I ? A(q) : m(q, q.length)
      }
      ;(o.prototype.listeners = function (v) {
        return d(this, v, !0)
      }),
        (o.prototype.rawListeners = function (v) {
          return d(this, v, !1)
        }),
        (o.listenerCount = function (w, v) {
          return typeof w.listenerCount == 'function' ? w.listenerCount(v) : h.call(w, v)
        }),
        (o.prototype.listenerCount = h)
      function h(w) {
        var v = this._events
        if (v !== void 0) {
          var I = v[w]
          if (typeof I == 'function') return 1
          if (I !== void 0) return I.length
        }
        return 0
      }
      o.prototype.eventNames = function () {
        return this._eventsCount > 0 ? i(this._events) : []
      }
      function m(w, v) {
        for (var I = new Array(v), M = 0; M < v; ++M) I[M] = w[M]
        return I
      }
      function _(w, v) {
        for (; v + 1 < w.length; v++) w[v] = w[v + 1]
        w.pop()
      }
      function A(w) {
        for (var v = new Array(w.length), I = 0; I < v.length; ++I) v[I] = w[I].listener || w[I]
        return v
      }
      function T(w, v) {
        return new Promise(function (I, M) {
          function q(O) {
            w.removeListener(v, G), M(O)
          }
          function G() {
            typeof w.removeListener == 'function' && w.removeListener('error', q), I([].slice.call(arguments))
          }
          k(w, v, G, { once: !0 }), v !== 'error' && E(w, q, { once: !0 })
        })
      }
      function E(w, v, I) {
        typeof w.on == 'function' && k(w, 'error', v, I)
      }
      function k(w, v, I, M) {
        if (typeof w.on == 'function') M.once ? w.once(v, I) : w.on(v, I)
        else if (typeof w.addEventListener == 'function')
          w.addEventListener(v, function q(G) {
            M.once && w.removeEventListener(v, q), I(G)
          })
        else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof w)
      }
    }
  }),
  eP = te({
    'node_modules/get-browser-rtc/index.js'(e, r) {
      V(),
        F(),
        (r.exports = function () {
          if (typeof globalThis == 'undefined') return null
          var n = {
            RTCPeerConnection:
              globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
            RTCSessionDescription:
              globalThis.RTCSessionDescription ||
              globalThis.mozRTCSessionDescription ||
              globalThis.webkitRTCSessionDescription,
            RTCIceCandidate:
              globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
          }
          return n.RTCPeerConnection ? n : null
        })
    }
  }),
  Q8 = te({
    'node_modules/safe-buffer/index.js'(e, r) {
      V(), F()
      var t = $r(),
        n = t.Buffer
      function i(u, o) {
        for (var l in u) o[l] = u[l]
      }
      n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? (r.exports = t) : (i(t, e), (e.Buffer = s))
      function s(u, o, l) {
        return n(u, o, l)
      }
      ;(s.prototype = Object.create(n.prototype)),
        i(n, s),
        (s.from = function (u, o, l) {
          if (typeof u == 'number') throw new TypeError('Argument must not be a number')
          return n(u, o, l)
        }),
        (s.alloc = function (u, o, l) {
          if (typeof u != 'number') throw new TypeError('Argument must be a number')
          var a = n(u)
          return o !== void 0 ? (typeof l == 'string' ? a.fill(o, l) : a.fill(o)) : a.fill(0), a
        }),
        (s.allocUnsafe = function (u) {
          if (typeof u != 'number') throw new TypeError('Argument must be a number')
          return n(u)
        }),
        (s.allocUnsafeSlow = function (u) {
          if (typeof u != 'number') throw new TypeError('Argument must be a number')
          return t.SlowBuffer(u)
        })
    }
  }),
  tP = te({
    'node_modules/randombytes/browser.js'(e, r) {
      V(), F()
      var t = 65536,
        n = 4294967295
      function i() {
        throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`)
      }
      var s = Q8().Buffer,
        u = globalThis.crypto || globalThis.msCrypto
      u && u.getRandomValues ? (r.exports = o) : (r.exports = i)
      function o(l, a) {
        if (l > n) throw new RangeError('requested too many random bytes')
        var c = s.allocUnsafe(l)
        if (l > 0)
          if (l > t) for (var f = 0; f < l; f += t) u.getRandomValues(c.slice(f, f + t))
          else u.getRandomValues(c)
        return typeof a == 'function'
          ? lt.nextTick(function () {
              a(null, c)
            })
          : c
      }
    }
  }),
  e_ = te({
    'node_modules/readable-stream/lib/internal/streams/stream-browser.js'(e, r) {
      V(), F(), (r.exports = ln().EventEmitter)
    }
  }),
  t_ = te({
    '(disabled):util'() {
      V(), F()
    }
  }),
  rP = te({
    'node_modules/readable-stream/lib/internal/streams/buffer_list.js'(e, r) {
      V(), F()
      function t(d, h) {
        var m = Object.keys(d)
        if (Object.getOwnPropertySymbols) {
          var _ = Object.getOwnPropertySymbols(d)
          h &&
            (_ = _.filter(function (A) {
              return Object.getOwnPropertyDescriptor(d, A).enumerable
            })),
            m.push.apply(m, _)
        }
        return m
      }
      function n(d) {
        for (var h = 1; h < arguments.length; h++) {
          var m = arguments[h] != null ? arguments[h] : {}
          h % 2
            ? t(Object(m), !0).forEach(function (_) {
                i(d, _, m[_])
              })
            : Object.getOwnPropertyDescriptors
            ? Object.defineProperties(d, Object.getOwnPropertyDescriptors(m))
            : t(Object(m)).forEach(function (_) {
                Object.defineProperty(d, _, Object.getOwnPropertyDescriptor(m, _))
              })
        }
        return d
      }
      function i(d, h, m) {
        return (
          h in d
            ? Object.defineProperty(d, h, { value: m, enumerable: !0, configurable: !0, writable: !0 })
            : (d[h] = m),
          d
        )
      }
      function s(d, h) {
        if (!(d instanceof h)) throw new TypeError('Cannot call a class as a function')
      }
      function u(d, h) {
        for (var m = 0; m < h.length; m++) {
          var _ = h[m]
          ;(_.enumerable = _.enumerable || !1),
            (_.configurable = !0),
            'value' in _ && (_.writable = !0),
            Object.defineProperty(d, _.key, _)
        }
      }
      function o(d, h, m) {
        return h && u(d.prototype, h), m && u(d, m), d
      }
      var l = $r(),
        a = l.Buffer,
        c = t_(),
        f = c.inspect,
        p = (f && f.custom) || 'inspect'
      function y(d, h, m) {
        a.prototype.copy.call(d, h, m)
      }
      r.exports = (function () {
        function d() {
          s(this, d), (this.head = null), (this.tail = null), (this.length = 0)
        }
        return (
          o(d, [
            {
              key: 'push',
              value: function (m) {
                var _ = { data: m, next: null }
                this.length > 0 ? (this.tail.next = _) : (this.head = _), (this.tail = _), ++this.length
              }
            },
            {
              key: 'unshift',
              value: function (m) {
                var _ = { data: m, next: this.head }
                this.length === 0 && (this.tail = _), (this.head = _), ++this.length
              }
            },
            {
              key: 'shift',
              value: function () {
                if (this.length !== 0) {
                  var m = this.head.data
                  return (
                    this.length === 1 ? (this.head = this.tail = null) : (this.head = this.head.next), --this.length, m
                  )
                }
              }
            },
            {
              key: 'clear',
              value: function () {
                ;(this.head = this.tail = null), (this.length = 0)
              }
            },
            {
              key: 'join',
              value: function (m) {
                if (this.length === 0) return ''
                for (var _ = this.head, A = '' + _.data; (_ = _.next); ) A += m + _.data
                return A
              }
            },
            {
              key: 'concat',
              value: function (m) {
                if (this.length === 0) return a.alloc(0)
                for (var _ = a.allocUnsafe(m >>> 0), A = this.head, T = 0; A; )
                  y(A.data, _, T), (T += A.data.length), (A = A.next)
                return _
              }
            },
            {
              key: 'consume',
              value: function (m, _) {
                var A
                return (
                  m < this.head.data.length
                    ? ((A = this.head.data.slice(0, m)), (this.head.data = this.head.data.slice(m)))
                    : m === this.head.data.length
                    ? (A = this.shift())
                    : (A = _ ? this._getString(m) : this._getBuffer(m)),
                  A
                )
              }
            },
            {
              key: 'first',
              value: function () {
                return this.head.data
              }
            },
            {
              key: '_getString',
              value: function (m) {
                var _ = this.head,
                  A = 1,
                  T = _.data
                for (m -= T.length; (_ = _.next); ) {
                  var E = _.data,
                    k = m > E.length ? E.length : m
                  if ((k === E.length ? (T += E) : (T += E.slice(0, m)), (m -= k), m === 0)) {
                    k === E.length
                      ? (++A, _.next ? (this.head = _.next) : (this.head = this.tail = null))
                      : ((this.head = _), (_.data = E.slice(k)))
                    break
                  }
                  ++A
                }
                return (this.length -= A), T
              }
            },
            {
              key: '_getBuffer',
              value: function (m) {
                var _ = a.allocUnsafe(m),
                  A = this.head,
                  T = 1
                for (A.data.copy(_), m -= A.data.length; (A = A.next); ) {
                  var E = A.data,
                    k = m > E.length ? E.length : m
                  if ((E.copy(_, _.length - m, 0, k), (m -= k), m === 0)) {
                    k === E.length
                      ? (++T, A.next ? (this.head = A.next) : (this.head = this.tail = null))
                      : ((this.head = A), (A.data = E.slice(k)))
                    break
                  }
                  ++T
                }
                return (this.length -= T), _
              }
            },
            {
              key: p,
              value: function (m, _) {
                return f(this, n({}, _, { depth: 0, customInspect: !1 }))
              }
            }
          ]),
          d
        )
      })()
    }
  }),
  r_ = te({
    'node_modules/readable-stream/lib/internal/streams/destroy.js'(e, r) {
      V(), F()
      function t(l, a) {
        var c = this,
          f = this._readableState && this._readableState.destroyed,
          p = this._writableState && this._writableState.destroyed
        return f || p
          ? (a
              ? a(l)
              : l &&
                (this._writableState
                  ? this._writableState.errorEmitted ||
                    ((this._writableState.errorEmitted = !0), lt.nextTick(u, this, l))
                  : lt.nextTick(u, this, l)),
            this)
          : (this._readableState && (this._readableState.destroyed = !0),
            this._writableState && (this._writableState.destroyed = !0),
            this._destroy(l || null, function (y) {
              !a && y
                ? c._writableState
                  ? c._writableState.errorEmitted
                    ? lt.nextTick(i, c)
                    : ((c._writableState.errorEmitted = !0), lt.nextTick(n, c, y))
                  : lt.nextTick(n, c, y)
                : a
                ? (lt.nextTick(i, c), a(y))
                : lt.nextTick(i, c)
            }),
            this)
      }
      function n(l, a) {
        u(l, a), i(l)
      }
      function i(l) {
        ;(l._writableState && !l._writableState.emitClose) ||
          (l._readableState && !l._readableState.emitClose) ||
          l.emit('close')
      }
      function s() {
        this._readableState &&
          ((this._readableState.destroyed = !1),
          (this._readableState.reading = !1),
          (this._readableState.ended = !1),
          (this._readableState.endEmitted = !1)),
          this._writableState &&
            ((this._writableState.destroyed = !1),
            (this._writableState.ended = !1),
            (this._writableState.ending = !1),
            (this._writableState.finalCalled = !1),
            (this._writableState.prefinished = !1),
            (this._writableState.finished = !1),
            (this._writableState.errorEmitted = !1))
      }
      function u(l, a) {
        l.emit('error', a)
      }
      function o(l, a) {
        var c = l._readableState,
          f = l._writableState
        ;(c && c.autoDestroy) || (f && f.autoDestroy) ? l.destroy(a) : l.emit('error', a)
      }
      r.exports = { destroy: t, undestroy: s, errorOrDestroy: o }
    }
  }),
  Lo = te({
    'node_modules/readable-stream/errors-browser.js'(e, r) {
      V(), F()
      function t(a, c) {
        ;(a.prototype = Object.create(c.prototype)), (a.prototype.constructor = a), (a.__proto__ = c)
      }
      var n = {}
      function i(a, c, f) {
        f || (f = Error)
        function p(d, h, m) {
          return typeof c == 'string' ? c : c(d, h, m)
        }
        var y = (function (d) {
          t(h, d)
          function h(m, _, A) {
            return d.call(this, p(m, _, A)) || this
          }
          return h
        })(f)
        ;(y.prototype.name = f.name), (y.prototype.code = a), (n[a] = y)
      }
      function s(a, c) {
        if (Array.isArray(a)) {
          var f = a.length
          return (
            (a = a.map(function (p) {
              return String(p)
            })),
            f > 2
              ? 'one of '.concat(c, ' ').concat(a.slice(0, f - 1).join(', '), ', or ') + a[f - 1]
              : f === 2
              ? 'one of '.concat(c, ' ').concat(a[0], ' or ').concat(a[1])
              : 'of '.concat(c, ' ').concat(a[0])
          )
        } else return 'of '.concat(c, ' ').concat(String(a))
      }
      function u(a, c, f) {
        return a.substr(!f || f < 0 ? 0 : +f, c.length) === c
      }
      function o(a, c, f) {
        return (f === void 0 || f > a.length) && (f = a.length), a.substring(f - c.length, f) === c
      }
      function l(a, c, f) {
        return typeof f != 'number' && (f = 0), f + c.length > a.length ? !1 : a.indexOf(c, f) !== -1
      }
      i(
        'ERR_INVALID_OPT_VALUE',
        function (a, c) {
          return 'The value "' + c + '" is invalid for option "' + a + '"'
        },
        TypeError
      ),
        i(
          'ERR_INVALID_ARG_TYPE',
          function (a, c, f) {
            var p
            typeof c == 'string' && u(c, 'not ') ? ((p = 'must not be'), (c = c.replace(/^not /, ''))) : (p = 'must be')
            var y
            if (o(a, ' argument')) y = 'The '.concat(a, ' ').concat(p, ' ').concat(s(c, 'type'))
            else {
              var d = l(a, '.') ? 'property' : 'argument'
              y = 'The "'.concat(a, '" ').concat(d, ' ').concat(p, ' ').concat(s(c, 'type'))
            }
            return (y += '. Received type '.concat(typeof f)), y
          },
          TypeError
        ),
        i('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF'),
        i('ERR_METHOD_NOT_IMPLEMENTED', function (a) {
          return 'The ' + a + ' method is not implemented'
        }),
        i('ERR_STREAM_PREMATURE_CLOSE', 'Premature close'),
        i('ERR_STREAM_DESTROYED', function (a) {
          return 'Cannot call ' + a + ' after a stream was destroyed'
        }),
        i('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times'),
        i('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable'),
        i('ERR_STREAM_WRITE_AFTER_END', 'write after end'),
        i('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError),
        i(
          'ERR_UNKNOWN_ENCODING',
          function (a) {
            return 'Unknown encoding: ' + a
          },
          TypeError
        ),
        i('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event'),
        (r.exports.codes = n)
    }
  }),
  n_ = te({
    'node_modules/readable-stream/lib/internal/streams/state.js'(e, r) {
      V(), F()
      var t = Lo().codes.ERR_INVALID_OPT_VALUE
      function n(s, u, o) {
        return s.highWaterMark != null ? s.highWaterMark : u ? s[o] : null
      }
      function i(s, u, o, l) {
        var a = n(u, l, o)
        if (a != null) {
          if (!(isFinite(a) && Math.floor(a) === a) || a < 0) {
            var c = l ? o : 'highWaterMark'
            throw new t(c, a)
          }
          return Math.floor(a)
        }
        return s.objectMode ? 16 : 16 * 1024
      }
      r.exports = { getHighWaterMark: i }
    }
  }),
  ii = te({
    'node_modules/inherits/inherits_browser.js'(e, r) {
      V(),
        F(),
        typeof Object.create == 'function'
          ? (r.exports = function (n, i) {
              i &&
                ((n.super_ = i),
                (n.prototype = Object.create(i.prototype, {
                  constructor: { value: n, enumerable: !1, writable: !0, configurable: !0 }
                })))
            })
          : (r.exports = function (n, i) {
              if (i) {
                n.super_ = i
                var s = function () {}
                ;(s.prototype = i.prototype), (n.prototype = new s()), (n.prototype.constructor = n)
              }
            })
    }
  }),
  nP = te({
    'node_modules/util-deprecate/browser.js'(e, r) {
      V(), F(), (r.exports = t)
      function t(i, s) {
        if (n('noDeprecation')) return i
        var u = !1
        function o() {
          if (!u) {
            if (n('throwDeprecation')) throw new Error(s)
            n('traceDeprecation') ? console.trace(s) : console.warn(s), (u = !0)
          }
          return i.apply(this, arguments)
        }
        return o
      }
      function n(i) {
        try {
          if (!globalThis.localStorage) return !1
        } catch (u) {
          return !1
        }
        var s = globalThis.localStorage[i]
        return s == null ? !1 : String(s).toLowerCase() === 'true'
      }
    }
  }),
  i_ = te({
    'node_modules/readable-stream/lib/_stream_writable.js'(e, r) {
      V(), F(), (r.exports = q)
      function t(be) {
        var ge = this
        ;(this.next = null),
          (this.entry = null),
          (this.finish = function () {
            oe(ge, be)
          })
      }
      var n
      q.WritableState = I
      var i = { deprecate: nP() },
        s = e_(),
        u = $r().Buffer,
        o = globalThis.Uint8Array || function () {}
      function l(be) {
        return u.from(be)
      }
      function a(be) {
        return u.isBuffer(be) || be instanceof o
      }
      var c = r_(),
        f = n_(),
        p = f.getHighWaterMark,
        y = Lo().codes,
        d = y.ERR_INVALID_ARG_TYPE,
        h = y.ERR_METHOD_NOT_IMPLEMENTED,
        m = y.ERR_MULTIPLE_CALLBACK,
        _ = y.ERR_STREAM_CANNOT_PIPE,
        A = y.ERR_STREAM_DESTROYED,
        T = y.ERR_STREAM_NULL_VALUES,
        E = y.ERR_STREAM_WRITE_AFTER_END,
        k = y.ERR_UNKNOWN_ENCODING,
        w = c.errorOrDestroy
      ii()(q, s)
      function v() {}
      function I(be, ge, re) {
        ;(n = n || Uo()),
          (be = be || {}),
          typeof re != 'boolean' && (re = ge instanceof n),
          (this.objectMode = !!be.objectMode),
          re && (this.objectMode = this.objectMode || !!be.writableObjectMode),
          (this.highWaterMark = p(this, be, 'writableHighWaterMark', re)),
          (this.finalCalled = !1),
          (this.needDrain = !1),
          (this.ending = !1),
          (this.ended = !1),
          (this.finished = !1),
          (this.destroyed = !1)
        var j = be.decodeStrings === !1
        ;(this.decodeStrings = !j),
          (this.defaultEncoding = be.defaultEncoding || 'utf8'),
          (this.length = 0),
          (this.writing = !1),
          (this.corked = 0),
          (this.sync = !0),
          (this.bufferProcessing = !1),
          (this.onwrite = function (b) {
            Q(ge, b)
          }),
          (this.writecb = null),
          (this.writelen = 0),
          (this.bufferedRequest = null),
          (this.lastBufferedRequest = null),
          (this.pendingcb = 0),
          (this.prefinished = !1),
          (this.errorEmitted = !1),
          (this.emitClose = be.emitClose !== !1),
          (this.autoDestroy = !!be.autoDestroy),
          (this.bufferedRequestCount = 0),
          (this.corkedRequestsFree = new t(this))
      }
      ;(I.prototype.getBuffer = function () {
        for (var ge = this.bufferedRequest, re = []; ge; ) re.push(ge), (ge = ge.next)
        return re
      }),
        (function () {
          try {
            Object.defineProperty(I.prototype, 'buffer', {
              get: i.deprecate(
                function () {
                  return this.getBuffer()
                },
                '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
                'DEP0003'
              )
            })
          } catch (be) {}
        })()
      var M
      typeof Symbol == 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == 'function'
        ? ((M = Function.prototype[Symbol.hasInstance]),
          Object.defineProperty(q, Symbol.hasInstance, {
            value: function (ge) {
              return M.call(this, ge) ? !0 : this !== q ? !1 : ge && ge._writableState instanceof I
            }
          }))
        : (M = function (ge) {
            return ge instanceof this
          })
      function q(be) {
        n = n || Uo()
        var ge = this instanceof n
        if (!ge && !M.call(q, this)) return new q(be)
        ;(this._writableState = new I(be, this, ge)),
          (this.writable = !0),
          be &&
            (typeof be.write == 'function' && (this._write = be.write),
            typeof be.writev == 'function' && (this._writev = be.writev),
            typeof be.destroy == 'function' && (this._destroy = be.destroy),
            typeof be.final == 'function' && (this._final = be.final)),
          s.call(this)
      }
      q.prototype.pipe = function () {
        w(this, new _())
      }
      function G(be, ge) {
        var re = new E()
        w(be, re), lt.nextTick(ge, re)
      }
      function O(be, ge, re, j) {
        var b
        return (
          re === null
            ? (b = new T())
            : typeof re != 'string' && !ge.objectMode && (b = new d('chunk', ['string', 'Buffer'], re)),
          b ? (w(be, b), lt.nextTick(j, b), !1) : !0
        )
      }
      ;(q.prototype.write = function (be, ge, re) {
        var j = this._writableState,
          b = !1,
          C = !j.objectMode && a(be)
        return (
          C && !u.isBuffer(be) && (be = l(be)),
          typeof ge == 'function' && ((re = ge), (ge = null)),
          C ? (ge = 'buffer') : ge || (ge = j.defaultEncoding),
          typeof re != 'function' && (re = v),
          j.ending ? G(this, re) : (C || O(this, j, be, re)) && (j.pendingcb++, (b = L(this, j, C, be, ge, re))),
          b
        )
      }),
        (q.prototype.cork = function () {
          this._writableState.corked++
        }),
        (q.prototype.uncork = function () {
          var be = this._writableState
          be.corked &&
            (be.corked--, !be.writing && !be.corked && !be.bufferProcessing && be.bufferedRequest && W(this, be))
        }),
        (q.prototype.setDefaultEncoding = function (ge) {
          if (
            (typeof ge == 'string' && (ge = ge.toLowerCase()),
            !(
              [
                'hex',
                'utf8',
                'utf-8',
                'ascii',
                'binary',
                'base64',
                'ucs2',
                'ucs-2',
                'utf16le',
                'utf-16le',
                'raw'
              ].indexOf((ge + '').toLowerCase()) > -1
            ))
          )
            throw new k(ge)
          return (this._writableState.defaultEncoding = ge), this
        }),
        Object.defineProperty(q.prototype, 'writableBuffer', {
          enumerable: !1,
          get: function () {
            return this._writableState && this._writableState.getBuffer()
          }
        })
      function x(be, ge, re) {
        return !be.objectMode && be.decodeStrings !== !1 && typeof ge == 'string' && (ge = u.from(ge, re)), ge
      }
      Object.defineProperty(q.prototype, 'writableHighWaterMark', {
        enumerable: !1,
        get: function () {
          return this._writableState.highWaterMark
        }
      })
      function L(be, ge, re, j, b, C) {
        if (!re) {
          var S = x(ge, j, b)
          j !== S && ((re = !0), (b = 'buffer'), (j = S))
        }
        var R = ge.objectMode ? 1 : j.length
        ge.length += R
        var P = ge.length < ge.highWaterMark
        if ((P || (ge.needDrain = !0), ge.writing || ge.corked)) {
          var B = ge.lastBufferedRequest
          ;(ge.lastBufferedRequest = { chunk: j, encoding: b, isBuf: re, callback: C, next: null }),
            B ? (B.next = ge.lastBufferedRequest) : (ge.bufferedRequest = ge.lastBufferedRequest),
            (ge.bufferedRequestCount += 1)
        } else K(be, ge, !1, R, j, b, C)
        return P
      }
      function K(be, ge, re, j, b, C, S) {
        ;(ge.writelen = j),
          (ge.writecb = S),
          (ge.writing = !0),
          (ge.sync = !0),
          ge.destroyed ? ge.onwrite(new A('write')) : re ? be._writev(b, ge.onwrite) : be._write(b, C, ge.onwrite),
          (ge.sync = !1)
      }
      function J(be, ge, re, j, b) {
        --ge.pendingcb,
          re
            ? (lt.nextTick(b, j), lt.nextTick(Ne, be, ge), (be._writableState.errorEmitted = !0), w(be, j))
            : (b(j), (be._writableState.errorEmitted = !0), w(be, j), Ne(be, ge))
      }
      function Z(be) {
        ;(be.writing = !1), (be.writecb = null), (be.length -= be.writelen), (be.writelen = 0)
      }
      function Q(be, ge) {
        var re = be._writableState,
          j = re.sync,
          b = re.writecb
        if (typeof b != 'function') throw new m()
        if ((Z(re), ge)) J(be, re, j, ge, b)
        else {
          var C = le(re) || be.destroyed
          !C && !re.corked && !re.bufferProcessing && re.bufferedRequest && W(be, re),
            j ? lt.nextTick(fe, be, re, C, b) : fe(be, re, C, b)
        }
      }
      function fe(be, ge, re, j) {
        re || ie(be, ge), ge.pendingcb--, j(), Ne(be, ge)
      }
      function ie(be, ge) {
        ge.length === 0 && ge.needDrain && ((ge.needDrain = !1), be.emit('drain'))
      }
      function W(be, ge) {
        ge.bufferProcessing = !0
        var re = ge.bufferedRequest
        if (be._writev && re && re.next) {
          var j = ge.bufferedRequestCount,
            b = new Array(j),
            C = ge.corkedRequestsFree
          C.entry = re
          for (var S = 0, R = !0; re; ) (b[S] = re), re.isBuf || (R = !1), (re = re.next), (S += 1)
          ;(b.allBuffers = R),
            K(be, ge, !0, ge.length, b, '', C.finish),
            ge.pendingcb++,
            (ge.lastBufferedRequest = null),
            C.next ? ((ge.corkedRequestsFree = C.next), (C.next = null)) : (ge.corkedRequestsFree = new t(ge)),
            (ge.bufferedRequestCount = 0)
        } else {
          for (; re; ) {
            var P = re.chunk,
              B = re.encoding,
              D = re.callback,
              $ = ge.objectMode ? 1 : P.length
            if ((K(be, ge, !1, $, P, B, D), (re = re.next), ge.bufferedRequestCount--, ge.writing)) break
          }
          re === null && (ge.lastBufferedRequest = null)
        }
        ;(ge.bufferedRequest = re), (ge.bufferProcessing = !1)
      }
      ;(q.prototype._write = function (be, ge, re) {
        re(new h('_write()'))
      }),
        (q.prototype._writev = null),
        (q.prototype.end = function (be, ge, re) {
          var j = this._writableState
          return (
            typeof be == 'function'
              ? ((re = be), (be = null), (ge = null))
              : typeof ge == 'function' && ((re = ge), (ge = null)),
            be != null && this.write(be, ge),
            j.corked && ((j.corked = 1), this.uncork()),
            j.ending || ke(this, j, re),
            this
          )
        }),
        Object.defineProperty(q.prototype, 'writableLength', {
          enumerable: !1,
          get: function () {
            return this._writableState.length
          }
        })
      function le(be) {
        return be.ending && be.length === 0 && be.bufferedRequest === null && !be.finished && !be.writing
      }
      function xe(be, ge) {
        be._final(function (re) {
          ge.pendingcb--, re && w(be, re), (ge.prefinished = !0), be.emit('prefinish'), Ne(be, ge)
        })
      }
      function _e(be, ge) {
        !ge.prefinished &&
          !ge.finalCalled &&
          (typeof be._final == 'function' && !ge.destroyed
            ? (ge.pendingcb++, (ge.finalCalled = !0), lt.nextTick(xe, be, ge))
            : ((ge.prefinished = !0), be.emit('prefinish')))
      }
      function Ne(be, ge) {
        var re = le(ge)
        if (re && (_e(be, ge), ge.pendingcb === 0 && ((ge.finished = !0), be.emit('finish'), ge.autoDestroy))) {
          var j = be._readableState
          ;(!j || (j.autoDestroy && j.endEmitted)) && be.destroy()
        }
        return re
      }
      function ke(be, ge, re) {
        ;(ge.ending = !0),
          Ne(be, ge),
          re && (ge.finished ? lt.nextTick(re) : be.once('finish', re)),
          (ge.ended = !0),
          (be.writable = !1)
      }
      function oe(be, ge, re) {
        var j = be.entry
        for (be.entry = null; j; ) {
          var b = j.callback
          ge.pendingcb--, b(re), (j = j.next)
        }
        ge.corkedRequestsFree.next = be
      }
      Object.defineProperty(q.prototype, 'destroyed', {
        enumerable: !1,
        get: function () {
          return this._writableState === void 0 ? !1 : this._writableState.destroyed
        },
        set: function (ge) {
          !this._writableState || (this._writableState.destroyed = ge)
        }
      }),
        (q.prototype.destroy = c.destroy),
        (q.prototype._undestroy = c.undestroy),
        (q.prototype._destroy = function (be, ge) {
          ge(be)
        })
    }
  }),
  Uo = te({
    'node_modules/readable-stream/lib/_stream_duplex.js'(e, r) {
      V(), F()
      var t =
        Object.keys ||
        function (f) {
          var p = []
          for (var y in f) p.push(y)
          return p
        }
      r.exports = l
      var n = o_(),
        i = i_()
      for (ii()(l, n), s = t(i.prototype), o = 0; o < s.length; o++)
        (u = s[o]), l.prototype[u] || (l.prototype[u] = i.prototype[u])
      var s, u, o
      function l(f) {
        if (!(this instanceof l)) return new l(f)
        n.call(this, f),
          i.call(this, f),
          (this.allowHalfOpen = !0),
          f &&
            (f.readable === !1 && (this.readable = !1),
            f.writable === !1 && (this.writable = !1),
            f.allowHalfOpen === !1 && ((this.allowHalfOpen = !1), this.once('end', a)))
      }
      Object.defineProperty(l.prototype, 'writableHighWaterMark', {
        enumerable: !1,
        get: function () {
          return this._writableState.highWaterMark
        }
      }),
        Object.defineProperty(l.prototype, 'writableBuffer', {
          enumerable: !1,
          get: function () {
            return this._writableState && this._writableState.getBuffer()
          }
        }),
        Object.defineProperty(l.prototype, 'writableLength', {
          enumerable: !1,
          get: function () {
            return this._writableState.length
          }
        })
      function a() {
        this._writableState.ended || lt.nextTick(c, this)
      }
      function c(f) {
        f.end()
      }
      Object.defineProperty(l.prototype, 'destroyed', {
        enumerable: !1,
        get: function () {
          return this._readableState === void 0 || this._writableState === void 0
            ? !1
            : this._readableState.destroyed && this._writableState.destroyed
        },
        set: function (p) {
          this._readableState === void 0 ||
            this._writableState === void 0 ||
            ((this._readableState.destroyed = p), (this._writableState.destroyed = p))
        }
      })
    }
  }),
  s_ = te({
    'node_modules/string_decoder/lib/string_decoder.js'(e) {
      V(), F()
      var r = Q8().Buffer,
        t =
          r.isEncoding ||
          function (A) {
            switch (((A = '' + A), A && A.toLowerCase())) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
              case 'raw':
                return !0
              default:
                return !1
            }
          }
      function n(A) {
        if (!A) return 'utf8'
        for (var T; ; )
          switch (A) {
            case 'utf8':
            case 'utf-8':
              return 'utf8'
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 'utf16le'
            case 'latin1':
            case 'binary':
              return 'latin1'
            case 'base64':
            case 'ascii':
            case 'hex':
              return A
            default:
              if (T) return
              ;(A = ('' + A).toLowerCase()), (T = !0)
          }
      }
      function i(A) {
        var T = n(A)
        if (typeof T != 'string' && (r.isEncoding === t || !t(A))) throw new Error('Unknown encoding: ' + A)
        return T || A
      }
      e.StringDecoder = s
      function s(A) {
        this.encoding = i(A)
        var T
        switch (this.encoding) {
          case 'utf16le':
            ;(this.text = p), (this.end = y), (T = 4)
            break
          case 'utf8':
            ;(this.fillLast = a), (T = 4)
            break
          case 'base64':
            ;(this.text = d), (this.end = h), (T = 3)
            break
          default:
            ;(this.write = m), (this.end = _)
            return
        }
        ;(this.lastNeed = 0), (this.lastTotal = 0), (this.lastChar = r.allocUnsafe(T))
      }
      ;(s.prototype.write = function (A) {
        if (A.length === 0) return ''
        var T, E
        if (this.lastNeed) {
          if (((T = this.fillLast(A)), T === void 0)) return ''
          ;(E = this.lastNeed), (this.lastNeed = 0)
        } else E = 0
        return E < A.length ? (T ? T + this.text(A, E) : this.text(A, E)) : T || ''
      }),
        (s.prototype.end = f),
        (s.prototype.text = c),
        (s.prototype.fillLast = function (A) {
          if (this.lastNeed <= A.length)
            return (
              A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
              this.lastChar.toString(this.encoding, 0, this.lastTotal)
            )
          A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, A.length), (this.lastNeed -= A.length)
        })
      function u(A) {
        return A <= 127 ? 0 : A >> 5 == 6 ? 2 : A >> 4 == 14 ? 3 : A >> 3 == 30 ? 4 : A >> 6 == 2 ? -1 : -2
      }
      function o(A, T, E) {
        var k = T.length - 1
        if (k < E) return 0
        var w = u(T[k])
        return w >= 0
          ? (w > 0 && (A.lastNeed = w - 1), w)
          : --k < E || w === -2
          ? 0
          : ((w = u(T[k])),
            w >= 0
              ? (w > 0 && (A.lastNeed = w - 2), w)
              : --k < E || w === -2
              ? 0
              : ((w = u(T[k])), w >= 0 ? (w > 0 && (w === 2 ? (w = 0) : (A.lastNeed = w - 3)), w) : 0))
      }
      function l(A, T, E) {
        if ((T[0] & 192) != 128) return (A.lastNeed = 0), '\uFFFD'
        if (A.lastNeed > 1 && T.length > 1) {
          if ((T[1] & 192) != 128) return (A.lastNeed = 1), '\uFFFD'
          if (A.lastNeed > 2 && T.length > 2 && (T[2] & 192) != 128) return (A.lastNeed = 2), '\uFFFD'
        }
      }
      function a(A) {
        var T = this.lastTotal - this.lastNeed,
          E = l(this, A, T)
        if (E !== void 0) return E
        if (this.lastNeed <= A.length)
          return A.copy(this.lastChar, T, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)
        A.copy(this.lastChar, T, 0, A.length), (this.lastNeed -= A.length)
      }
      function c(A, T) {
        var E = o(this, A, T)
        if (!this.lastNeed) return A.toString('utf8', T)
        this.lastTotal = E
        var k = A.length - (E - this.lastNeed)
        return A.copy(this.lastChar, 0, k), A.toString('utf8', T, k)
      }
      function f(A) {
        var T = A && A.length ? this.write(A) : ''
        return this.lastNeed ? T + '\uFFFD' : T
      }
      function p(A, T) {
        if ((A.length - T) % 2 == 0) {
          var E = A.toString('utf16le', T)
          if (E) {
            var k = E.charCodeAt(E.length - 1)
            if (k >= 55296 && k <= 56319)
              return (
                (this.lastNeed = 2),
                (this.lastTotal = 4),
                (this.lastChar[0] = A[A.length - 2]),
                (this.lastChar[1] = A[A.length - 1]),
                E.slice(0, -1)
              )
          }
          return E
        }
        return (
          (this.lastNeed = 1),
          (this.lastTotal = 2),
          (this.lastChar[0] = A[A.length - 1]),
          A.toString('utf16le', T, A.length - 1)
        )
      }
      function y(A) {
        var T = A && A.length ? this.write(A) : ''
        if (this.lastNeed) {
          var E = this.lastTotal - this.lastNeed
          return T + this.lastChar.toString('utf16le', 0, E)
        }
        return T
      }
      function d(A, T) {
        var E = (A.length - T) % 3
        return E === 0
          ? A.toString('base64', T)
          : ((this.lastNeed = 3 - E),
            (this.lastTotal = 3),
            E === 1
              ? (this.lastChar[0] = A[A.length - 1])
              : ((this.lastChar[0] = A[A.length - 2]), (this.lastChar[1] = A[A.length - 1])),
            A.toString('base64', T, A.length - E))
      }
      function h(A) {
        var T = A && A.length ? this.write(A) : ''
        return this.lastNeed ? T + this.lastChar.toString('base64', 0, 3 - this.lastNeed) : T
      }
      function m(A) {
        return A.toString(this.encoding)
      }
      function _(A) {
        return A && A.length ? this.write(A) : ''
      }
    }
  }),
  Rp = te({
    'node_modules/readable-stream/lib/internal/streams/end-of-stream.js'(e, r) {
      V(), F()
      var t = Lo().codes.ERR_STREAM_PREMATURE_CLOSE
      function n(o) {
        var l = !1
        return function () {
          if (!l) {
            l = !0
            for (var a = arguments.length, c = new Array(a), f = 0; f < a; f++) c[f] = arguments[f]
            o.apply(this, c)
          }
        }
      }
      function i() {}
      function s(o) {
        return o.setHeader && typeof o.abort == 'function'
      }
      function u(o, l, a) {
        if (typeof l == 'function') return u(o, null, l)
        l || (l = {}), (a = n(a || i))
        var c = l.readable || (l.readable !== !1 && o.readable),
          f = l.writable || (l.writable !== !1 && o.writable),
          p = function () {
            o.writable || d()
          },
          y = o._writableState && o._writableState.finished,
          d = function () {
            ;(f = !1), (y = !0), c || a.call(o)
          },
          h = o._readableState && o._readableState.endEmitted,
          m = function () {
            ;(c = !1), (h = !0), f || a.call(o)
          },
          _ = function (k) {
            a.call(o, k)
          },
          A = function () {
            var k
            if (c && !h) return (!o._readableState || !o._readableState.ended) && (k = new t()), a.call(o, k)
            if (f && !y) return (!o._writableState || !o._writableState.ended) && (k = new t()), a.call(o, k)
          },
          T = function () {
            o.req.on('finish', d)
          }
        return (
          s(o)
            ? (o.on('complete', d), o.on('abort', A), o.req ? T() : o.on('request', T))
            : f && !o._writableState && (o.on('end', p), o.on('close', p)),
          o.on('end', m),
          o.on('finish', d),
          l.error !== !1 && o.on('error', _),
          o.on('close', A),
          function () {
            o.removeListener('complete', d),
              o.removeListener('abort', A),
              o.removeListener('request', T),
              o.req && o.req.removeListener('finish', d),
              o.removeListener('end', p),
              o.removeListener('close', p),
              o.removeListener('finish', d),
              o.removeListener('end', m),
              o.removeListener('error', _),
              o.removeListener('close', A)
          }
        )
      }
      r.exports = u
    }
  }),
  iP = te({
    'node_modules/readable-stream/lib/internal/streams/async_iterator.js'(e, r) {
      V(), F()
      var t
      function n(T, E, k) {
        return (
          E in T
            ? Object.defineProperty(T, E, { value: k, enumerable: !0, configurable: !0, writable: !0 })
            : (T[E] = k),
          T
        )
      }
      var i = Rp(),
        s = Symbol('lastResolve'),
        u = Symbol('lastReject'),
        o = Symbol('error'),
        l = Symbol('ended'),
        a = Symbol('lastPromise'),
        c = Symbol('handlePromise'),
        f = Symbol('stream')
      function p(T, E) {
        return { value: T, done: E }
      }
      function y(T) {
        var E = T[s]
        if (E !== null) {
          var k = T[f].read()
          k !== null && ((T[a] = null), (T[s] = null), (T[u] = null), E(p(k, !1)))
        }
      }
      function d(T) {
        lt.nextTick(y, T)
      }
      function h(T, E) {
        return function (k, w) {
          T.then(function () {
            if (E[l]) {
              k(p(void 0, !0))
              return
            }
            E[c](k, w)
          }, w)
        }
      }
      var m = Object.getPrototypeOf(function () {}),
        _ = Object.setPrototypeOf(
          ((t = {
            get stream() {
              return this[f]
            },
            next: function () {
              var E = this,
                k = this[o]
              if (k !== null) return Promise.reject(k)
              if (this[l]) return Promise.resolve(p(void 0, !0))
              if (this[f].destroyed)
                return new Promise(function (M, q) {
                  lt.nextTick(function () {
                    E[o] ? q(E[o]) : M(p(void 0, !0))
                  })
                })
              var w = this[a],
                v
              if (w) v = new Promise(h(w, this))
              else {
                var I = this[f].read()
                if (I !== null) return Promise.resolve(p(I, !1))
                v = new Promise(this[c])
              }
              return (this[a] = v), v
            }
          }),
          n(t, Symbol.asyncIterator, function () {
            return this
          }),
          n(t, 'return', function () {
            var E = this
            return new Promise(function (k, w) {
              E[f].destroy(null, function (v) {
                if (v) {
                  w(v)
                  return
                }
                k(p(void 0, !0))
              })
            })
          }),
          t),
          m
        ),
        A = function (E) {
          var k,
            w = Object.create(
              _,
              ((k = {}),
              n(k, f, { value: E, writable: !0 }),
              n(k, s, { value: null, writable: !0 }),
              n(k, u, { value: null, writable: !0 }),
              n(k, o, { value: null, writable: !0 }),
              n(k, l, { value: E._readableState.endEmitted, writable: !0 }),
              n(k, c, {
                value: function (I, M) {
                  var q = w[f].read()
                  q ? ((w[a] = null), (w[s] = null), (w[u] = null), I(p(q, !1))) : ((w[s] = I), (w[u] = M))
                },
                writable: !0
              }),
              k)
            )
          return (
            (w[a] = null),
            i(E, function (v) {
              if (v && v.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
                var I = w[u]
                I !== null && ((w[a] = null), (w[s] = null), (w[u] = null), I(v)), (w[o] = v)
                return
              }
              var M = w[s]
              M !== null && ((w[a] = null), (w[s] = null), (w[u] = null), M(p(void 0, !0))), (w[l] = !0)
            }),
            E.on('readable', d.bind(null, w)),
            w
          )
        }
      r.exports = A
    }
  }),
  sP = te({
    'node_modules/readable-stream/lib/internal/streams/from-browser.js'(e, r) {
      V(),
        F(),
        (r.exports = function () {
          throw new Error('Readable.from is not available in the browser')
        })
    }
  }),
  o_ = te({
    'node_modules/readable-stream/lib/_stream_readable.js'(e, r) {
      V(), F(), (r.exports = O)
      var t
      O.ReadableState = G
      var n = ln().EventEmitter,
        i = function (R, P) {
          return R.listeners(P).length
        },
        s = e_(),
        u = $r().Buffer,
        o = globalThis.Uint8Array || function () {}
      function l(S) {
        return u.from(S)
      }
      function a(S) {
        return u.isBuffer(S) || S instanceof o
      }
      var c = t_(),
        f
      c && c.debuglog ? (f = c.debuglog('stream')) : (f = function () {})
      var p = rP(),
        y = r_(),
        d = n_(),
        h = d.getHighWaterMark,
        m = Lo().codes,
        _ = m.ERR_INVALID_ARG_TYPE,
        A = m.ERR_STREAM_PUSH_AFTER_EOF,
        T = m.ERR_METHOD_NOT_IMPLEMENTED,
        E = m.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
        k,
        w,
        v
      ii()(O, s)
      var I = y.errorOrDestroy,
        M = ['error', 'close', 'destroy', 'pause', 'resume']
      function q(S, R, P) {
        if (typeof S.prependListener == 'function') return S.prependListener(R, P)
        !S._events || !S._events[R]
          ? S.on(R, P)
          : Array.isArray(S._events[R])
          ? S._events[R].unshift(P)
          : (S._events[R] = [P, S._events[R]])
      }
      function G(S, R, P) {
        ;(t = t || Uo()),
          (S = S || {}),
          typeof P != 'boolean' && (P = R instanceof t),
          (this.objectMode = !!S.objectMode),
          P && (this.objectMode = this.objectMode || !!S.readableObjectMode),
          (this.highWaterMark = h(this, S, 'readableHighWaterMark', P)),
          (this.buffer = new p()),
          (this.length = 0),
          (this.pipes = null),
          (this.pipesCount = 0),
          (this.flowing = null),
          (this.ended = !1),
          (this.endEmitted = !1),
          (this.reading = !1),
          (this.sync = !0),
          (this.needReadable = !1),
          (this.emittedReadable = !1),
          (this.readableListening = !1),
          (this.resumeScheduled = !1),
          (this.paused = !0),
          (this.emitClose = S.emitClose !== !1),
          (this.autoDestroy = !!S.autoDestroy),
          (this.destroyed = !1),
          (this.defaultEncoding = S.defaultEncoding || 'utf8'),
          (this.awaitDrain = 0),
          (this.readingMore = !1),
          (this.decoder = null),
          (this.encoding = null),
          S.encoding &&
            (k || (k = s_().StringDecoder), (this.decoder = new k(S.encoding)), (this.encoding = S.encoding))
      }
      function O(S) {
        if (((t = t || Uo()), !(this instanceof O))) return new O(S)
        var R = this instanceof t
        ;(this._readableState = new G(S, this, R)),
          (this.readable = !0),
          S &&
            (typeof S.read == 'function' && (this._read = S.read),
            typeof S.destroy == 'function' && (this._destroy = S.destroy)),
          s.call(this)
      }
      Object.defineProperty(O.prototype, 'destroyed', {
        enumerable: !1,
        get: function () {
          return this._readableState === void 0 ? !1 : this._readableState.destroyed
        },
        set: function (R) {
          !this._readableState || (this._readableState.destroyed = R)
        }
      }),
        (O.prototype.destroy = y.destroy),
        (O.prototype._undestroy = y.undestroy),
        (O.prototype._destroy = function (S, R) {
          R(S)
        }),
        (O.prototype.push = function (S, R) {
          var P = this._readableState,
            B
          return (
            P.objectMode
              ? (B = !0)
              : typeof S == 'string' &&
                ((R = R || P.defaultEncoding), R !== P.encoding && ((S = u.from(S, R)), (R = '')), (B = !0)),
            x(this, S, R, !1, B)
          )
        }),
        (O.prototype.unshift = function (S) {
          return x(this, S, null, !0, !1)
        })
      function x(S, R, P, B, D) {
        f('readableAddChunk', R)
        var $ = S._readableState
        if (R === null) ($.reading = !1), fe(S, $)
        else {
          var g
          if ((D || (g = K($, R)), g)) I(S, g)
          else if ($.objectMode || (R && R.length > 0))
            if ((typeof R != 'string' && !$.objectMode && Object.getPrototypeOf(R) !== u.prototype && (R = l(R)), B))
              $.endEmitted ? I(S, new E()) : L(S, $, R, !0)
            else if ($.ended) I(S, new A())
            else {
              if ($.destroyed) return !1
              ;($.reading = !1),
                $.decoder && !P
                  ? ((R = $.decoder.write(R)), $.objectMode || R.length !== 0 ? L(S, $, R, !1) : le(S, $))
                  : L(S, $, R, !1)
            }
          else B || (($.reading = !1), le(S, $))
        }
        return !$.ended && ($.length < $.highWaterMark || $.length === 0)
      }
      function L(S, R, P, B) {
        R.flowing && R.length === 0 && !R.sync
          ? ((R.awaitDrain = 0), S.emit('data', P))
          : ((R.length += R.objectMode ? 1 : P.length),
            B ? R.buffer.unshift(P) : R.buffer.push(P),
            R.needReadable && ie(S)),
          le(S, R)
      }
      function K(S, R) {
        var P
        return (
          !a(R) &&
            typeof R != 'string' &&
            R !== void 0 &&
            !S.objectMode &&
            (P = new _('chunk', ['string', 'Buffer', 'Uint8Array'], R)),
          P
        )
      }
      ;(O.prototype.isPaused = function () {
        return this._readableState.flowing === !1
      }),
        (O.prototype.setEncoding = function (S) {
          k || (k = s_().StringDecoder)
          var R = new k(S)
          ;(this._readableState.decoder = R), (this._readableState.encoding = this._readableState.decoder.encoding)
          for (var P = this._readableState.buffer.head, B = ''; P !== null; ) (B += R.write(P.data)), (P = P.next)
          return (
            this._readableState.buffer.clear(),
            B !== '' && this._readableState.buffer.push(B),
            (this._readableState.length = B.length),
            this
          )
        })
      var J = 1073741824
      function Z(S) {
        return (
          S >= J
            ? (S = J)
            : (S--, (S |= S >>> 1), (S |= S >>> 2), (S |= S >>> 4), (S |= S >>> 8), (S |= S >>> 16), S++),
          S
        )
      }
      function Q(S, R) {
        return S <= 0 || (R.length === 0 && R.ended)
          ? 0
          : R.objectMode
          ? 1
          : S !== S
          ? R.flowing && R.length
            ? R.buffer.head.data.length
            : R.length
          : (S > R.highWaterMark && (R.highWaterMark = Z(S)),
            S <= R.length ? S : R.ended ? R.length : ((R.needReadable = !0), 0))
      }
      O.prototype.read = function (S) {
        f('read', S), (S = parseInt(S, 10))
        var R = this._readableState,
          P = S
        if (
          (S !== 0 && (R.emittedReadable = !1),
          S === 0 &&
            R.needReadable &&
            ((R.highWaterMark !== 0 ? R.length >= R.highWaterMark : R.length > 0) || R.ended))
        )
          return f('read: emitReadable', R.length, R.ended), R.length === 0 && R.ended ? j(this) : ie(this), null
        if (((S = Q(S, R)), S === 0 && R.ended)) return R.length === 0 && j(this), null
        var B = R.needReadable
        f('need readable', B),
          (R.length === 0 || R.length - S < R.highWaterMark) && ((B = !0), f('length less than watermark', B)),
          R.ended || R.reading
            ? ((B = !1), f('reading or ended', B))
            : B &&
              (f('do read'),
              (R.reading = !0),
              (R.sync = !0),
              R.length === 0 && (R.needReadable = !0),
              this._read(R.highWaterMark),
              (R.sync = !1),
              R.reading || (S = Q(P, R)))
        var D
        return (
          S > 0 ? (D = re(S, R)) : (D = null),
          D === null
            ? ((R.needReadable = R.length <= R.highWaterMark), (S = 0))
            : ((R.length -= S), (R.awaitDrain = 0)),
          R.length === 0 && (R.ended || (R.needReadable = !0), P !== S && R.ended && j(this)),
          D !== null && this.emit('data', D),
          D
        )
      }
      function fe(S, R) {
        if ((f('onEofChunk'), !R.ended)) {
          if (R.decoder) {
            var P = R.decoder.end()
            P && P.length && (R.buffer.push(P), (R.length += R.objectMode ? 1 : P.length))
          }
          ;(R.ended = !0),
            R.sync ? ie(S) : ((R.needReadable = !1), R.emittedReadable || ((R.emittedReadable = !0), W(S)))
        }
      }
      function ie(S) {
        var R = S._readableState
        f('emitReadable', R.needReadable, R.emittedReadable),
          (R.needReadable = !1),
          R.emittedReadable || (f('emitReadable', R.flowing), (R.emittedReadable = !0), lt.nextTick(W, S))
      }
      function W(S) {
        var R = S._readableState
        f('emitReadable_', R.destroyed, R.length, R.ended),
          !R.destroyed && (R.length || R.ended) && (S.emit('readable'), (R.emittedReadable = !1)),
          (R.needReadable = !R.flowing && !R.ended && R.length <= R.highWaterMark),
          ge(S)
      }
      function le(S, R) {
        R.readingMore || ((R.readingMore = !0), lt.nextTick(xe, S, R))
      }
      function xe(S, R) {
        for (; !R.reading && !R.ended && (R.length < R.highWaterMark || (R.flowing && R.length === 0)); ) {
          var P = R.length
          if ((f('maybeReadMore read 0'), S.read(0), P === R.length)) break
        }
        R.readingMore = !1
      }
      ;(O.prototype._read = function (S) {
        I(this, new T('_read()'))
      }),
        (O.prototype.pipe = function (S, R) {
          var P = this,
            B = this._readableState
          switch (B.pipesCount) {
            case 0:
              B.pipes = S
              break
            case 1:
              B.pipes = [B.pipes, S]
              break
            default:
              B.pipes.push(S)
              break
          }
          ;(B.pipesCount += 1), f('pipe count=%d opts=%j', B.pipesCount, R)
          var D = (!R || R.end !== !1) && S !== lt.stdout && S !== lt.stderr,
            $ = D ? N : H
          B.endEmitted ? lt.nextTick($) : P.once('end', $), S.on('unpipe', g)
          function g(se, me) {
            f('onunpipe'), se === P && me && me.hasUnpiped === !1 && ((me.hasUnpiped = !0), ne())
          }
          function N() {
            f('onend'), S.end()
          }
          var U = _e(P)
          S.on('drain', U)
          var X = !1
          function ne() {
            f('cleanup'),
              S.removeListener('close', Y),
              S.removeListener('finish', z),
              S.removeListener('drain', U),
              S.removeListener('error', ae),
              S.removeListener('unpipe', g),
              P.removeListener('end', N),
              P.removeListener('end', H),
              P.removeListener('data', ee),
              (X = !0),
              B.awaitDrain && (!S._writableState || S._writableState.needDrain) && U()
          }
          P.on('data', ee)
          function ee(se) {
            f('ondata')
            var me = S.write(se)
            f('dest.write', me),
              me === !1 &&
                (((B.pipesCount === 1 && B.pipes === S) || (B.pipesCount > 1 && C(B.pipes, S) !== -1)) &&
                  !X &&
                  (f('false write response, pause', B.awaitDrain), B.awaitDrain++),
                P.pause())
          }
          function ae(se) {
            f('onerror', se), H(), S.removeListener('error', ae), i(S, 'error') === 0 && I(S, se)
          }
          q(S, 'error', ae)
          function Y() {
            S.removeListener('finish', z), H()
          }
          S.once('close', Y)
          function z() {
            f('onfinish'), S.removeListener('close', Y), H()
          }
          S.once('finish', z)
          function H() {
            f('unpipe'), P.unpipe(S)
          }
          return S.emit('pipe', P), B.flowing || (f('pipe resume'), P.resume()), S
        })
      function _e(S) {
        return function () {
          var P = S._readableState
          f('pipeOnDrain', P.awaitDrain),
            P.awaitDrain && P.awaitDrain--,
            P.awaitDrain === 0 && i(S, 'data') && ((P.flowing = !0), ge(S))
        }
      }
      ;(O.prototype.unpipe = function (S) {
        var R = this._readableState,
          P = { hasUnpiped: !1 }
        if (R.pipesCount === 0) return this
        if (R.pipesCount === 1)
          return S && S !== R.pipes
            ? this
            : (S || (S = R.pipes),
              (R.pipes = null),
              (R.pipesCount = 0),
              (R.flowing = !1),
              S && S.emit('unpipe', this, P),
              this)
        if (!S) {
          var B = R.pipes,
            D = R.pipesCount
          ;(R.pipes = null), (R.pipesCount = 0), (R.flowing = !1)
          for (var $ = 0; $ < D; $++) B[$].emit('unpipe', this, { hasUnpiped: !1 })
          return this
        }
        var g = C(R.pipes, S)
        return g === -1
          ? this
          : (R.pipes.splice(g, 1),
            (R.pipesCount -= 1),
            R.pipesCount === 1 && (R.pipes = R.pipes[0]),
            S.emit('unpipe', this, P),
            this)
      }),
        (O.prototype.on = function (S, R) {
          var P = s.prototype.on.call(this, S, R),
            B = this._readableState
          return (
            S === 'data'
              ? ((B.readableListening = this.listenerCount('readable') > 0), B.flowing !== !1 && this.resume())
              : S === 'readable' &&
                !B.endEmitted &&
                !B.readableListening &&
                ((B.readableListening = B.needReadable = !0),
                (B.flowing = !1),
                (B.emittedReadable = !1),
                f('on readable', B.length, B.reading),
                B.length ? ie(this) : B.reading || lt.nextTick(ke, this)),
            P
          )
        }),
        (O.prototype.addListener = O.prototype.on),
        (O.prototype.removeListener = function (S, R) {
          var P = s.prototype.removeListener.call(this, S, R)
          return S === 'readable' && lt.nextTick(Ne, this), P
        }),
        (O.prototype.removeAllListeners = function (S) {
          var R = s.prototype.removeAllListeners.apply(this, arguments)
          return (S === 'readable' || S === void 0) && lt.nextTick(Ne, this), R
        })
      function Ne(S) {
        var R = S._readableState
        ;(R.readableListening = S.listenerCount('readable') > 0),
          R.resumeScheduled && !R.paused ? (R.flowing = !0) : S.listenerCount('data') > 0 && S.resume()
      }
      function ke(S) {
        f('readable nexttick read 0'), S.read(0)
      }
      O.prototype.resume = function () {
        var S = this._readableState
        return S.flowing || (f('resume'), (S.flowing = !S.readableListening), oe(this, S)), (S.paused = !1), this
      }
      function oe(S, R) {
        R.resumeScheduled || ((R.resumeScheduled = !0), lt.nextTick(be, S, R))
      }
      function be(S, R) {
        f('resume', R.reading),
          R.reading || S.read(0),
          (R.resumeScheduled = !1),
          S.emit('resume'),
          ge(S),
          R.flowing && !R.reading && S.read(0)
      }
      O.prototype.pause = function () {
        return (
          f('call pause flowing=%j', this._readableState.flowing),
          this._readableState.flowing !== !1 && (f('pause'), (this._readableState.flowing = !1), this.emit('pause')),
          (this._readableState.paused = !0),
          this
        )
      }
      function ge(S) {
        var R = S._readableState
        for (f('flow', R.flowing); R.flowing && S.read() !== null; );
      }
      ;(O.prototype.wrap = function (S) {
        var R = this,
          P = this._readableState,
          B = !1
        S.on('end', function () {
          if ((f('wrapped end'), P.decoder && !P.ended)) {
            var g = P.decoder.end()
            g && g.length && R.push(g)
          }
          R.push(null)
        }),
          S.on('data', function (g) {
            if (
              (f('wrapped data'),
              P.decoder && (g = P.decoder.write(g)),
              !(P.objectMode && g == null) && !(!P.objectMode && (!g || !g.length)))
            ) {
              var N = R.push(g)
              N || ((B = !0), S.pause())
            }
          })
        for (var D in S)
          this[D] === void 0 &&
            typeof S[D] == 'function' &&
            (this[D] = (function (N) {
              return function () {
                return S[N].apply(S, arguments)
              }
            })(D))
        for (var $ = 0; $ < M.length; $++) S.on(M[$], this.emit.bind(this, M[$]))
        return (
          (this._read = function (g) {
            f('wrapped _read', g), B && ((B = !1), S.resume())
          }),
          this
        )
      }),
        typeof Symbol == 'function' &&
          (O.prototype[Symbol.asyncIterator] = function () {
            return w === void 0 && (w = iP()), w(this)
          }),
        Object.defineProperty(O.prototype, 'readableHighWaterMark', {
          enumerable: !1,
          get: function () {
            return this._readableState.highWaterMark
          }
        }),
        Object.defineProperty(O.prototype, 'readableBuffer', {
          enumerable: !1,
          get: function () {
            return this._readableState && this._readableState.buffer
          }
        }),
        Object.defineProperty(O.prototype, 'readableFlowing', {
          enumerable: !1,
          get: function () {
            return this._readableState.flowing
          },
          set: function (R) {
            this._readableState && (this._readableState.flowing = R)
          }
        }),
        (O._fromList = re),
        Object.defineProperty(O.prototype, 'readableLength', {
          enumerable: !1,
          get: function () {
            return this._readableState.length
          }
        })
      function re(S, R) {
        if (R.length === 0) return null
        var P
        return (
          R.objectMode
            ? (P = R.buffer.shift())
            : !S || S >= R.length
            ? (R.decoder
                ? (P = R.buffer.join(''))
                : R.buffer.length === 1
                ? (P = R.buffer.first())
                : (P = R.buffer.concat(R.length)),
              R.buffer.clear())
            : (P = R.buffer.consume(S, R.decoder)),
          P
        )
      }
      function j(S) {
        var R = S._readableState
        f('endReadable', R.endEmitted), R.endEmitted || ((R.ended = !0), lt.nextTick(b, R, S))
      }
      function b(S, R) {
        if (
          (f('endReadableNT', S.endEmitted, S.length),
          !S.endEmitted && S.length === 0 && ((S.endEmitted = !0), (R.readable = !1), R.emit('end'), S.autoDestroy))
        ) {
          var P = R._writableState
          ;(!P || (P.autoDestroy && P.finished)) && R.destroy()
        }
      }
      typeof Symbol == 'function' &&
        (O.from = function (S, R) {
          return v === void 0 && (v = sP()), v(O, S, R)
        })
      function C(S, R) {
        for (var P = 0, B = S.length; P < B; P++) if (S[P] === R) return P
        return -1
      }
    }
  }),
  a_ = te({
    'node_modules/readable-stream/lib/_stream_transform.js'(e, r) {
      V(), F(), (r.exports = a)
      var t = Lo().codes,
        n = t.ERR_METHOD_NOT_IMPLEMENTED,
        i = t.ERR_MULTIPLE_CALLBACK,
        s = t.ERR_TRANSFORM_ALREADY_TRANSFORMING,
        u = t.ERR_TRANSFORM_WITH_LENGTH_0,
        o = Uo()
      ii()(a, o)
      function l(p, y) {
        var d = this._transformState
        d.transforming = !1
        var h = d.writecb
        if (h === null) return this.emit('error', new i())
        ;(d.writechunk = null), (d.writecb = null), y != null && this.push(y), h(p)
        var m = this._readableState
        ;(m.reading = !1), (m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark)
      }
      function a(p) {
        if (!(this instanceof a)) return new a(p)
        o.call(this, p),
          (this._transformState = {
            afterTransform: l.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }),
          (this._readableState.needReadable = !0),
          (this._readableState.sync = !1),
          p &&
            (typeof p.transform == 'function' && (this._transform = p.transform),
            typeof p.flush == 'function' && (this._flush = p.flush)),
          this.on('prefinish', c)
      }
      function c() {
        var p = this
        typeof this._flush == 'function' && !this._readableState.destroyed
          ? this._flush(function (y, d) {
              f(p, y, d)
            })
          : f(this, null, null)
      }
      ;(a.prototype.push = function (p, y) {
        return (this._transformState.needTransform = !1), o.prototype.push.call(this, p, y)
      }),
        (a.prototype._transform = function (p, y, d) {
          d(new n('_transform()'))
        }),
        (a.prototype._write = function (p, y, d) {
          var h = this._transformState
          if (((h.writecb = d), (h.writechunk = p), (h.writeencoding = y), !h.transforming)) {
            var m = this._readableState
            ;(h.needTransform || m.needReadable || m.length < m.highWaterMark) && this._read(m.highWaterMark)
          }
        }),
        (a.prototype._read = function (p) {
          var y = this._transformState
          y.writechunk !== null && !y.transforming
            ? ((y.transforming = !0), this._transform(y.writechunk, y.writeencoding, y.afterTransform))
            : (y.needTransform = !0)
        }),
        (a.prototype._destroy = function (p, y) {
          o.prototype._destroy.call(this, p, function (d) {
            y(d)
          })
        })
      function f(p, y, d) {
        if (y) return p.emit('error', y)
        if ((d != null && p.push(d), p._writableState.length)) throw new u()
        if (p._transformState.transforming) throw new s()
        return p.push(null)
      }
    }
  }),
  oP = te({
    'node_modules/readable-stream/lib/_stream_passthrough.js'(e, r) {
      V(), F(), (r.exports = n)
      var t = a_()
      ii()(n, t)
      function n(i) {
        if (!(this instanceof n)) return new n(i)
        t.call(this, i)
      }
      n.prototype._transform = function (i, s, u) {
        u(null, i)
      }
    }
  }),
  aP = te({
    'node_modules/readable-stream/lib/internal/streams/pipeline.js'(e, r) {
      V(), F()
      var t
      function n(d) {
        var h = !1
        return function () {
          h || ((h = !0), d.apply(void 0, arguments))
        }
      }
      var i = Lo().codes,
        s = i.ERR_MISSING_ARGS,
        u = i.ERR_STREAM_DESTROYED
      function o(d) {
        if (d) throw d
      }
      function l(d) {
        return d.setHeader && typeof d.abort == 'function'
      }
      function a(d, h, m, _) {
        _ = n(_)
        var A = !1
        d.on('close', function () {
          A = !0
        }),
          t === void 0 && (t = Rp()),
          t(d, { readable: h, writable: m }, function (E) {
            if (E) return _(E)
            ;(A = !0), _()
          })
        var T = !1
        return function (E) {
          if (!A && !T) {
            if (((T = !0), l(d))) return d.abort()
            if (typeof d.destroy == 'function') return d.destroy()
            _(E || new u('pipe'))
          }
        }
      }
      function c(d) {
        d()
      }
      function f(d, h) {
        return d.pipe(h)
      }
      function p(d) {
        return !d.length || typeof d[d.length - 1] != 'function' ? o : d.pop()
      }
      function y() {
        for (var d = arguments.length, h = new Array(d), m = 0; m < d; m++) h[m] = arguments[m]
        var _ = p(h)
        if ((Array.isArray(h[0]) && (h = h[0]), h.length < 2)) throw new s('streams')
        var A,
          T = h.map(function (E, k) {
            var w = k < h.length - 1,
              v = k > 0
            return a(E, w, v, function (I) {
              A || (A = I), I && T.forEach(c), !w && (T.forEach(c), _(A))
            })
          })
        return h.reduce(f)
      }
      r.exports = y
    }
  }),
  cP = te({
    'node_modules/readable-stream/readable-browser.js'(e, r) {
      V(),
        F(),
        (e = r.exports = o_()),
        (e.Stream = e),
        (e.Readable = e),
        (e.Writable = i_()),
        (e.Duplex = Uo()),
        (e.Transform = a_()),
        (e.PassThrough = oP()),
        (e.finished = Rp()),
        (e.pipeline = aP())
    }
  }),
  uP = te({
    'node_modules/queue-microtask/index.js'(e, r) {
      V(), F()
      var t
      r.exports =
        typeof queueMicrotask == 'function'
          ? queueMicrotask.bind(typeof window != 'undefined' ? window : globalThis)
          : (n) =>
              (t || (t = Promise.resolve())).then(n).catch((i) =>
                setTimeout(() => {
                  throw i
                }, 0)
              )
    }
  }),
  lP = te({
    'node_modules/libp2p-webrtc-peer/node_modules/err-code/index.js'(e, r) {
      V(), F()
      function t(i, s) {
        for (let u in s) Object.defineProperty(i, u, { value: s[u], enumerable: !0, configurable: !0 })
        return i
      }
      function n(i, s, u) {
        if (!i || typeof i == 'string') throw new TypeError('Please pass an Error to err-code')
        u || (u = {}), typeof s == 'object' && ((u = s), (s = void 0)), s != null && (u.code = s)
        try {
          return t(i, u)
        } catch (o) {
          ;(u.message = i.message), (u.stack = i.stack)
          let l = function () {}
          return (l.prototype = Object.create(Object.getPrototypeOf(i))), t(new l(), u)
        }
      }
      r.exports = n
    }
  }),
  c_ = te({
    'node_modules/libp2p-webrtc-peer/index.js'(e, r) {
      V(), F()
      var t = mt()('simple-peer'),
        n = eP(),
        i = tP(),
        s = cP(),
        u = uP(),
        o = lP(),
        l = 64 * 1024,
        a = 5 * 1e3,
        c = 5 * 1e3
      function f(d) {
        return d.replace(/a=ice-options:trickle\s\n/g, '')
      }
      function p(d) {
        console.warn(d)
      }
      var y = class extends s.Duplex {
        constructor(d) {
          d = Object.assign({ allowHalfOpen: !1 }, d)
          super(d)
          if (
            ((this._id = i(4).toString('hex').slice(0, 7)),
            this._debug('new peer %o', d),
            (this.channelName = d.initiator ? d.channelName || i(20).toString('hex') : null),
            (this.initiator = d.initiator || !1),
            (this.channelConfig = d.channelConfig || y.channelConfig),
            (this.negotiated = this.channelConfig.negotiated),
            (this.config = Object.assign({}, y.config, d.config)),
            (this.offerOptions = d.offerOptions || {}),
            (this.answerOptions = d.answerOptions || {}),
            (this.sdpTransform = d.sdpTransform || ((h) => h)),
            (this.streams = d.streams || (d.stream ? [d.stream] : [])),
            (this.trickle = d.trickle !== void 0 ? d.trickle : !0),
            (this.allowHalfTrickle = d.allowHalfTrickle !== void 0 ? d.allowHalfTrickle : !1),
            (this.iceCompleteTimeout = d.iceCompleteTimeout || a),
            (this._connected = !1),
            (this.remoteAddress = void 0),
            (this.remoteFamily = void 0),
            (this.remotePort = void 0),
            (this.localAddress = void 0),
            (this.localFamily = void 0),
            (this.localPort = void 0),
            (this._wrtc = d.wrtc && typeof d.wrtc == 'object' ? d.wrtc : n()),
            !this._wrtc)
          )
            throw typeof window == 'undefined'
              ? o(new Error('No WebRTC support: Specify `opts.wrtc` option in this environment'), 'ERR_WEBRTC_SUPPORT')
              : o(new Error('No WebRTC support: Not a supported browser'), 'ERR_WEBRTC_SUPPORT')
          ;(this._pcReady = !1),
            (this._channelReady = !1),
            (this._iceComplete = !1),
            (this._iceCompleteTimer = null),
            (this._channel = null),
            (this._pendingCandidates = []),
            (this._isNegotiating = this.negotiated ? !1 : !this.initiator),
            (this._batchedNegotiation = !1),
            (this._queuedNegotiation = !1),
            (this._sendersAwaitingStable = []),
            (this._senderMap = new Map()),
            (this._firstStable = !0),
            (this._closingInterval = null),
            (this._remoteTracks = []),
            (this._remoteStreams = []),
            (this._chunk = null),
            (this._cb = null),
            (this._interval = null)
          try {
            this._pc = new this._wrtc.RTCPeerConnection(this.config)
          } catch (h) {
            u(() => this.destroy(o(h, 'ERR_PC_CONSTRUCTOR')))
            return
          }
          ;(this._isReactNativeWebrtc = typeof this._pc._peerConnectionId == 'number'),
            (this._pc.oniceconnectionstatechange = () => {
              this._onIceStateChange()
            }),
            (this._pc.onicegatheringstatechange = () => {
              this._onIceStateChange()
            }),
            (this._pc.onconnectionstatechange = () => {
              this._onConnectionStateChange()
            }),
            (this._pc.onsignalingstatechange = () => {
              this._onSignalingStateChange()
            }),
            (this._pc.onicecandidate = (h) => {
              this._onIceCandidate(h)
            }),
            this.initiator || this.negotiated
              ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) })
              : (this._pc.ondatachannel = (h) => {
                  this._setupData(h)
                }),
            this.streams &&
              this.streams.forEach((h) => {
                this.addStream(h)
              }),
            (this._pc.ontrack = (h) => {
              this._onTrack(h)
            }),
            this.initiator && this._needsNegotiation(),
            (this._onFinishBound = () => {
              this._onFinish()
            }),
            this.once('finish', this._onFinishBound)
        }
        get bufferSize() {
          return (this._channel && this._channel.bufferedAmount) || 0
        }
        get connected() {
          return this._connected && this._channel.readyState === 'open'
        }
        address() {
          return { port: this.localPort, family: this.localFamily, address: this.localAddress }
        }
        signal(d) {
          if (this.destroyed) throw o(new Error('cannot signal after peer is destroyed'), 'ERR_SIGNALING')
          if (typeof d == 'string')
            try {
              d = JSON.parse(d)
            } catch (h) {
              d = {}
            }
          this._debug('signal()'),
            d.renegotiate && this.initiator && (this._debug('got request to renegotiate'), this._needsNegotiation()),
            d.transceiverRequest &&
              this.initiator &&
              (this._debug('got request for transceiver'),
              this.addTransceiver(d.transceiverRequest.kind, d.transceiverRequest.init)),
            d.candidate &&
              (this._pc.remoteDescription && this._pc.remoteDescription.type
                ? this._addIceCandidate(d.candidate)
                : this._pendingCandidates.push(d.candidate)),
            d.sdp &&
              this._pc
                .setRemoteDescription(new this._wrtc.RTCSessionDescription(d))
                .then(() => {
                  this.destroyed ||
                    (this._pendingCandidates.forEach((h) => {
                      this._addIceCandidate(h)
                    }),
                    (this._pendingCandidates = []),
                    this._pc.remoteDescription.type === 'offer' && this._createAnswer())
                })
                .catch((h) => {
                  this.destroy(o(h, 'ERR_SET_REMOTE_DESCRIPTION'))
                }),
            !d.sdp &&
              !d.candidate &&
              !d.renegotiate &&
              !d.transceiverRequest &&
              this.destroy(o(new Error('signal() called with invalid signal data'), 'ERR_SIGNALING'))
        }
        _addIceCandidate(d) {
          var h = new this._wrtc.RTCIceCandidate(d)
          this._pc.addIceCandidate(h).catch((m) => {
            !h.address || h.address.endsWith('.local')
              ? p('Ignoring unsupported ICE candidate.')
              : this.destroy(o(m, 'ERR_ADD_ICE_CANDIDATE'))
          })
        }
        send(d) {
          this._channel.send(d)
        }
        addTransceiver(d, h) {
          if ((this._debug('addTransceiver()'), this.initiator))
            try {
              this._pc.addTransceiver(d, h), this._needsNegotiation()
            } catch (m) {
              this.destroy(o(m, 'ERR_ADD_TRANSCEIVER'))
            }
          else this.emit('signal', { transceiverRequest: { kind: d, init: h } })
        }
        addStream(d) {
          this._debug('addStream()'),
            d.getTracks().forEach((h) => {
              this.addTrack(h, d)
            })
        }
        addTrack(d, h) {
          this._debug('addTrack()')
          var m = this._senderMap.get(d) || new Map(),
            _ = m.get(h)
          if (!_) (_ = this._pc.addTrack(d, h)), m.set(h, _), this._senderMap.set(d, m), this._needsNegotiation()
          else
            throw _.removed
              ? o(
                  new Error('Track has been removed. You should enable/disable tracks that you want to re-add.'),
                  'ERR_SENDER_REMOVED'
                )
              : o(new Error('Track has already been added to that stream.'), 'ERR_SENDER_ALREADY_ADDED')
        }
        replaceTrack(d, h, m) {
          this._debug('replaceTrack()')
          var _ = this._senderMap.get(d),
            A = _ ? _.get(m) : null
          if (!A) throw o(new Error('Cannot replace track that was never added.'), 'ERR_TRACK_NOT_ADDED')
          h && this._senderMap.set(h, _),
            A.replaceTrack != null
              ? A.replaceTrack(h)
              : this.destroy(
                  o(new Error('replaceTrack is not supported in this browser'), 'ERR_UNSUPPORTED_REPLACETRACK')
                )
        }
        removeTrack(d, h) {
          this._debug('removeSender()')
          var m = this._senderMap.get(d),
            _ = m ? m.get(h) : null
          if (!_) throw o(new Error('Cannot remove track that was never added.'), 'ERR_TRACK_NOT_ADDED')
          try {
            ;(_.removed = !0), this._pc.removeTrack(_)
          } catch (A) {
            A.name === 'NS_ERROR_UNEXPECTED'
              ? this._sendersAwaitingStable.push(_)
              : this.destroy(o(A, 'ERR_REMOVE_TRACK'))
          }
          this._needsNegotiation()
        }
        removeStream(d) {
          this._debug('removeSenders()'),
            d.getTracks().forEach((h) => {
              this.removeTrack(h, d)
            })
        }
        _needsNegotiation() {
          this._debug('_needsNegotiation'),
            !this._batchedNegotiation &&
              ((this._batchedNegotiation = !0),
              u(() => {
                ;(this._batchedNegotiation = !1), this._debug('starting batched negotiation'), this.negotiate()
              }))
        }
        negotiate() {
          this.initiator
            ? this._isNegotiating
              ? ((this._queuedNegotiation = !0), this._debug('already negotiating, queueing'))
              : (this._debug('start negotiation'),
                setTimeout(() => {
                  this._createOffer()
                }, 0))
            : this._isNegotiating
            ? ((this._queuedNegotiation = !0), this._debug('already negotiating, queueing'))
            : (this._debug('requesting negotiation from initiator'), this.emit('signal', { renegotiate: !0 })),
            (this._isNegotiating = !0)
        }
        _destroy(d, h) {
          if (
            (this._debug('destroy (error: %s)', d && (d.message || d)),
            (this.readable = this.writable = !1),
            this._readableState.ended || this.push(null),
            this._writableState.finished || this.end(),
            (this._connected = !1),
            (this._pcReady = !1),
            (this._channelReady = !1),
            (this._remoteTracks = null),
            (this._remoteStreams = null),
            (this._senderMap = null),
            clearInterval(this._closingInterval),
            (this._closingInterval = null),
            clearInterval(this._interval),
            (this._interval = null),
            (this._chunk = null),
            (this._cb = null),
            this._onFinishBound && this.removeListener('finish', this._onFinishBound),
            (this._onFinishBound = null),
            this._channel)
          ) {
            try {
              this._channel.close()
            } catch (m) {}
            ;(this._channel.onmessage = null),
              (this._channel.onopen = null),
              (this._channel.onclose = null),
              (this._channel.onerror = null)
          }
          if (this._pc) {
            try {
              this._pc.close()
            } catch (m) {}
            ;(this._pc.oniceconnectionstatechange = null),
              (this._pc.onicegatheringstatechange = null),
              (this._pc.onsignalingstatechange = null),
              (this._pc.onicecandidate = null),
              (this._pc.ontrack = null),
              (this._pc.ondatachannel = null)
          }
          ;(this._pc = null), (this._channel = null), h(d)
        }
        _setupData(d) {
          if (!d.channel)
            return this.destroy(o(new Error('Data channel event is missing `channel` property'), 'ERR_DATA_CHANNEL'))
          ;(this._channel = d.channel),
            (this._channel.binaryType = 'arraybuffer'),
            typeof this._channel.bufferedAmountLowThreshold == 'number' &&
              (this._channel.bufferedAmountLowThreshold = l),
            (this.channelName = this._channel.label),
            (this._channel.onmessage = (m) => {
              this._onChannelMessage(m)
            }),
            (this._channel.onbufferedamountlow = () => {
              this._onChannelBufferedAmountLow()
            }),
            (this._channel.onopen = () => {
              this._onChannelOpen()
            }),
            (this._channel.onclose = () => {
              this._onChannelClose()
            }),
            (this._channel.onerror = (m) => {
              this.destroy(o(m, 'ERR_DATA_CHANNEL'))
            })
          var h = !1
          this._closingInterval = setInterval(() => {
            this._channel && this._channel.readyState === 'closing' ? (h && this._onChannelClose(), (h = !0)) : (h = !1)
          }, c)
        }
        _read() {}
        _write(d, h, m) {
          if (this.destroyed) return m(o(new Error('cannot write after peer is destroyed'), 'ERR_DATA_CHANNEL'))
          if (this._connected) {
            try {
              this.send(d)
            } catch (_) {
              return this.destroy(o(_, 'ERR_DATA_CHANNEL'))
            }
            this._channel.bufferedAmount > l
              ? (this._debug('start backpressure: bufferedAmount %d', this._channel.bufferedAmount), (this._cb = m))
              : m(null)
          } else this._debug('write before connect'), (this._chunk = d), (this._cb = m)
        }
        _onFinish() {
          if (this.destroyed) return
          let d = () => {
            setTimeout(() => this.destroy(), 1e3)
          }
          this._connected ? d() : this.once('connect', d)
        }
        _startIceCompleteTimeout() {
          this.destroyed ||
            this._iceCompleteTimer ||
            (this._debug('started iceComplete timeout'),
            (this._iceCompleteTimer = setTimeout(() => {
              this._iceComplete ||
                ((this._iceComplete = !0),
                this._debug('iceComplete timeout completed'),
                this.emit('iceTimeout'),
                this.emit('_iceComplete'))
            }, this.iceCompleteTimeout)))
        }
        _createOffer() {
          this.destroyed ||
            this._pc
              .createOffer(this.offerOptions)
              .then((d) => {
                if (this.destroyed) return
                !this.trickle && !this.allowHalfTrickle && (d.sdp = f(d.sdp)), (d.sdp = this.sdpTransform(d.sdp))
                let h = () => {
                    if (!this.destroyed) {
                      var A = this._pc.localDescription || d
                      this._debug('signal'), this.emit('signal', { type: A.type, sdp: A.sdp })
                    }
                  },
                  m = () => {
                    this._debug('createOffer success'),
                      !this.destroyed && (this.trickle || this._iceComplete ? h() : this.once('_iceComplete', h))
                  },
                  _ = (A) => {
                    this.destroy(o(A, 'ERR_SET_LOCAL_DESCRIPTION'))
                  }
                this._pc.setLocalDescription(d).then(m).catch(_)
              })
              .catch((d) => {
                this.destroy(o(d, 'ERR_CREATE_OFFER'))
              })
        }
        _requestMissingTransceivers() {
          this._pc.getTransceivers &&
            this._pc.getTransceivers().forEach((d) => {
              !d.mid && d.sender.track && !d.requested && ((d.requested = !0), this.addTransceiver(d.sender.track.kind))
            })
        }
        _createAnswer() {
          this.destroyed ||
            this._pc
              .createAnswer(this.answerOptions)
              .then((d) => {
                if (this.destroyed) return
                !this.trickle && !this.allowHalfTrickle && (d.sdp = f(d.sdp)), (d.sdp = this.sdpTransform(d.sdp))
                let h = () => {
                    if (!this.destroyed) {
                      var A = this._pc.localDescription || d
                      this._debug('signal'),
                        this.emit('signal', { type: A.type, sdp: A.sdp }),
                        this.initiator || this._requestMissingTransceivers()
                    }
                  },
                  m = () => {
                    this.destroyed || (this.trickle || this._iceComplete ? h() : this.once('_iceComplete', h))
                  },
                  _ = (A) => {
                    this.destroy(o(A, 'ERR_SET_LOCAL_DESCRIPTION'))
                  }
                this._pc.setLocalDescription(d).then(m).catch(_)
              })
              .catch((d) => {
                this.destroy(o(d, 'ERR_CREATE_ANSWER'))
              })
        }
        _onConnectionStateChange() {
          this.destroyed ||
            (this._pc.connectionState === 'failed' &&
              this.destroy(o(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE')))
        }
        _onIceStateChange() {
          if (!this.destroyed) {
            var d = this._pc.iceConnectionState,
              h = this._pc.iceGatheringState
            this._debug('iceStateChange (connection: %s) (gathering: %s)', d, h),
              this.emit('iceStateChange', d, h),
              (d === 'connected' || d === 'completed') && ((this._pcReady = !0), this._maybeReady()),
              d === 'failed' && this.destroy(o(new Error('Ice connection failed.'), 'ERR_ICE_CONNECTION_FAILURE')),
              d === 'closed' && this.destroy(o(new Error('Ice connection closed.'), 'ERR_ICE_CONNECTION_CLOSED'))
          }
        }
        getStats(d) {
          let h = (m) => (
            Object.prototype.toString.call(m.values) === '[object Array]' &&
              m.values.forEach((_) => {
                Object.assign(m, _)
              }),
            m
          )
          this._pc.getStats.length === 0 || this._isReactNativeWebrtc
            ? this._pc.getStats().then(
                (m) => {
                  var _ = []
                  m.forEach((A) => {
                    _.push(h(A))
                  }),
                    d(null, _)
                },
                (m) => d(m)
              )
            : this._pc.getStats.length > 0
            ? this._pc.getStats(
                (m) => {
                  if (!this.destroyed) {
                    var _ = []
                    m.result().forEach((A) => {
                      var T = {}
                      A.names().forEach((E) => {
                        T[E] = A.stat(E)
                      }),
                        (T.id = A.id),
                        (T.type = A.type),
                        (T.timestamp = A.timestamp),
                        _.push(h(T))
                    }),
                      d(null, _)
                  }
                },
                (m) => d(m)
              )
            : d(null, [])
        }
        _maybeReady() {
          if (
            (this._debug('maybeReady pc %s channel %s', this._pcReady, this._channelReady),
            this._connected || this._connecting || !this._pcReady || !this._channelReady)
          )
            return
          this._connecting = !0
          let d = () => {
            this.destroyed ||
              this.getStats((h, m) => {
                if (this.destroyed) return
                h && (m = [])
                var _ = {},
                  A = {},
                  T = {},
                  E = !1
                m.forEach((v) => {
                  ;(v.type === 'remotecandidate' || v.type === 'remote-candidate') && (_[v.id] = v),
                    (v.type === 'localcandidate' || v.type === 'local-candidate') && (A[v.id] = v),
                    (v.type === 'candidatepair' || v.type === 'candidate-pair') && (T[v.id] = v)
                })
                let k = (v) => {
                  E = !0
                  var I = A[v.localCandidateId]
                  I && (I.ip || I.address)
                    ? ((this.localAddress = I.ip || I.address), (this.localPort = Number(I.port)))
                    : I && I.ipAddress
                    ? ((this.localAddress = I.ipAddress), (this.localPort = Number(I.portNumber)))
                    : typeof v.googLocalAddress == 'string' &&
                      ((I = v.googLocalAddress.split(':')),
                      (this.localAddress = I[0]),
                      (this.localPort = Number(I[1]))),
                    this.localAddress && (this.localFamily = this.localAddress.includes(':') ? 'IPv6' : 'IPv4')
                  var M = _[v.remoteCandidateId]
                  M && (M.ip || M.address)
                    ? ((this.remoteAddress = M.ip || M.address), (this.remotePort = Number(M.port)))
                    : M && M.ipAddress
                    ? ((this.remoteAddress = M.ipAddress), (this.remotePort = Number(M.portNumber)))
                    : typeof v.googRemoteAddress == 'string' &&
                      ((M = v.googRemoteAddress.split(':')),
                      (this.remoteAddress = M[0]),
                      (this.remotePort = Number(M[1]))),
                    this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(':') ? 'IPv6' : 'IPv4'),
                    this._debug(
                      'connect local: %s:%s remote: %s:%s',
                      this.localAddress,
                      this.localPort,
                      this.remoteAddress,
                      this.remotePort
                    )
                }
                if (
                  (m.forEach((v) => {
                    v.type === 'transport' && v.selectedCandidatePairId && k(T[v.selectedCandidatePairId]),
                      ((v.type === 'googCandidatePair' && v.googActiveConnection === 'true') ||
                        ((v.type === 'candidatepair' || v.type === 'candidate-pair') && v.selected)) &&
                        k(v)
                  }),
                  !E && (!Object.keys(T).length || Object.keys(A).length))
                ) {
                  setTimeout(d, 100)
                  return
                } else (this._connecting = !1), (this._connected = !0)
                if (this._chunk) {
                  try {
                    this.send(this._chunk)
                  } catch (v) {
                    return this.destroy(o(v, 'ERR_DATA_CHANNEL'))
                  }
                  ;(this._chunk = null), this._debug('sent chunk from "write before connect"')
                  var w = this._cb
                  ;(this._cb = null), w(null)
                }
                typeof this._channel.bufferedAmountLowThreshold != 'number' &&
                  ((this._interval = setInterval(() => this._onInterval(), 150)),
                  this._interval.unref && this._interval.unref()),
                  this._debug('connect'),
                  this.emit('connect')
              })
          }
          d()
        }
        _onInterval() {
          !this._cb || !this._channel || this._channel.bufferedAmount > l || this._onChannelBufferedAmountLow()
        }
        _onSignalingStateChange() {
          this.destroyed ||
            (this._pc.signalingState === 'stable' &&
              !this._firstStable &&
              ((this._isNegotiating = !1),
              this._debug('flushing sender queue', this._sendersAwaitingStable),
              this._sendersAwaitingStable.forEach((d) => {
                this._pc.removeTrack(d), (this._queuedNegotiation = !0)
              }),
              (this._sendersAwaitingStable = []),
              this._queuedNegotiation &&
                (this._debug('flushing negotiation queue'), (this._queuedNegotiation = !1), this._needsNegotiation()),
              this._debug('negotiate'),
              this.emit('negotiate')),
            (this._firstStable = !1),
            this._debug('signalingStateChange %s', this._pc.signalingState),
            this.emit('signalingStateChange', this._pc.signalingState))
        }
        _onIceCandidate(d) {
          this.destroyed ||
            (d.candidate && this.trickle
              ? this.emit('signal', {
                  candidate: {
                    candidate: d.candidate.candidate,
                    sdpMLineIndex: d.candidate.sdpMLineIndex,
                    sdpMid: d.candidate.sdpMid
                  }
                })
              : !d.candidate && !this._iceComplete && ((this._iceComplete = !0), this.emit('_iceComplete')),
            d.candidate && this._startIceCompleteTimeout())
        }
        _onChannelMessage(d) {
          if (!this.destroyed) {
            var h = d.data
            h instanceof ArrayBuffer && (h = new Uint8Array(h)), this.push(h)
          }
        }
        _onChannelBufferedAmountLow() {
          if (!(this.destroyed || !this._cb)) {
            this._debug('ending backpressure: bufferedAmount %d', this._channel.bufferedAmount)
            var d = this._cb
            ;(this._cb = null), d(null)
          }
        }
        _onChannelOpen() {
          this._connected ||
            this.destroyed ||
            (this._debug('on channel open'), (this._channelReady = !0), this._maybeReady())
        }
        _onChannelClose() {
          this.destroyed || (this._debug('on channel close'), this.destroy())
        }
        _onTrack(d) {
          this.destroyed ||
            d.streams.forEach((h) => {
              this._debug('on track'),
                this.emit('track', d.track, h),
                this._remoteTracks.push({ track: d.track, stream: h }),
                !this._remoteStreams.some((m) => m.id === h.id) &&
                  (this._remoteStreams.push(h),
                  u(() => {
                    this.emit('stream', h)
                  }))
            })
        }
        _debug() {
          var d = [].slice.call(arguments)
          ;(d[0] = '[' + this._id + '] ' + d[0]), t.apply(null, d)
        }
      }
      ;(y.WEBRTC_SUPPORT = !!n()),
        (y.config = {
          iceServers: [{ urls: ['stun:stun.l.google.com:19302', 'stun:global.stun.twilio.com:3478'] }],
          sdpSemantics: 'unified-plan'
        }),
        (y.channelConfig = {}),
        (r.exports = y)
    }
  }),
  fP = te({
    'node_modules/ipfs-utils/src/supports.js'(e, r) {
      V(),
        F(),
        (r.exports = {
          supportsFileReader: typeof self != 'undefined' && 'FileReader' in self,
          supportsWebRTC:
            'RTCPeerConnection' in globalThis &&
            typeof navigator != 'undefined' &&
            typeof navigator.mediaDevices != 'undefined' &&
            'getUserMedia' in navigator.mediaDevices,
          supportsWebRTCDataChannels: 'RTCPeerConnection' in globalThis
        })
    }
  })
function dP(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var u_,
  l_,
  f_,
  hP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (u_ = dP), (l_ = u_), (f_ = l_)
    }
  }),
  d_ = {}
Re(d_, {
  coerce: () => gs,
  empty: () => Bp,
  equals: () => Np,
  fromHex: () => p_,
  fromString: () => Pp,
  isBinary: () => m_,
  toHex: () => h_,
  toString: () => Op
})
var Bp,
  h_,
  p_,
  Np,
  gs,
  m_,
  Pp,
  Op,
  ws = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (Bp = new Uint8Array(0)),
        (h_ = (e) => e.reduce((r, t) => r + t.toString(16).padStart(2, '0'), '')),
        (p_ = (e) => {
          let r = e.match(/../g)
          return r ? new Uint8Array(r.map((t) => parseInt(t, 16))) : Bp
        }),
        (Np = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (gs = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (m_ = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e)),
        (Pp = (e) => new TextEncoder().encode(e)),
        (Op = (e) => new TextDecoder().decode(e))
    }
  }),
  b_,
  y_,
  Dp,
  v_,
  Zl,
  qo,
  g_,
  w_,
  hr,
  si = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        hP(),
        ws(),
        (b_ = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (y_ = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new Dp(r)
          }
        }),
        (Dp = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new Dp({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (v_ = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new b_(e, r, t)),
              (this.decoder = new y_(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (Zl = ({ name: e, prefix: r, encode: t, decode: n }) => new v_(e, r, t, n)),
        (qo = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = f_(t, r)
          return Zl({ prefix: e, name: r, encode: n, decode: (s) => gs(i(s)) })
        }),
        (g_ = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (w_ = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (hr = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          Zl({
            prefix: r,
            name: e,
            encode(i) {
              return w_(i, n, t)
            },
            decode(i) {
              return g_(i, n, t, e)
            }
          }))
    }
  }),
  __ = {}
Re(__, { identity: () => E_ })
var E_,
  pP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), si(), ws(), (E_ = Zl({ prefix: '\0', name: 'identity', encode: (e) => Op(e), decode: (e) => Pp(e) }))
    }
  }),
  S_ = {}
Re(S_, { base2: () => A_ })
var A_,
  mP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), si(), (A_ = hr({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  I_ = {}
Re(I_, { base8: () => T_ })
var T_,
  bP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), si(), (T_ = hr({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  C_ = {}
Re(C_, { base10: () => k_ })
var k_,
  yP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), si(), (k_ = qo({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  M_ = {}
Re(M_, { base16: () => x_, base16upper: () => R_ })
var x_,
  R_,
  vP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        si(),
        (x_ = hr({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (R_ = hr({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  B_ = {}
Re(B_, {
  base32: () => jo,
  base32hex: () => D_,
  base32hexpad: () => U_,
  base32hexpadupper: () => q_,
  base32hexupper: () => L_,
  base32pad: () => P_,
  base32padupper: () => O_,
  base32upper: () => N_,
  base32z: () => j_
})
var jo,
  N_,
  P_,
  O_,
  D_,
  L_,
  U_,
  q_,
  j_,
  z_ = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        si(),
        (jo = hr({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (N_ = hr({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (P_ = hr({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (O_ = hr({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (D_ = hr({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        (L_ = hr({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (U_ = hr({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (q_ = hr({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (j_ = hr({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  K_ = {}
Re(K_, { base36: () => F_, base36upper: () => V_ })
var F_,
  V_,
  gP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        si(),
        (F_ = qo({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (V_ = qo({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  H_ = {}
Re(H_, { base58btc: () => Un, base58flickr: () => $_ })
var Un,
  $_,
  G_ = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        si(),
        (Un = qo({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        ($_ = qo({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  W_ = {}
Re(W_, { base64: () => J_, base64pad: () => X_, base64url: () => Y_, base64urlpad: () => Z_ })
var J_,
  X_,
  Y_,
  Z_,
  wP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        si(),
        (J_ = hr({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (X_ = hr({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (Y_ = hr({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (Z_ = hr({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function Q_(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= n7; ) (r[t++] = (e & 255) | Up), (e /= 128)
  for (; e & r7; ) (r[t++] = (e & 255) | Up), (e >>>= 7)
  return (r[t] = e | 0), (Q_.bytes = t - n + 1), r
}
function Lp(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((Lp.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & qp) << n : (s & qp) * Math.pow(2, n)), (n += 7)
  } while (s >= s7)
  return (Lp.bytes = i - r), t
}
var e7,
  Up,
  t7,
  r7,
  n7,
  i7,
  s7,
  qp,
  o7,
  a7,
  c7,
  u7,
  l7,
  f7,
  d7,
  h7,
  p7,
  m7,
  b7,
  y7,
  Bc,
  _P = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        (e7 = Q_),
        (Up = 128),
        (t7 = 127),
        (r7 = ~t7),
        (n7 = Math.pow(2, 31)),
        (i7 = Lp),
        (s7 = 128),
        (qp = 127),
        (o7 = Math.pow(2, 7)),
        (a7 = Math.pow(2, 14)),
        (c7 = Math.pow(2, 21)),
        (u7 = Math.pow(2, 28)),
        (l7 = Math.pow(2, 35)),
        (f7 = Math.pow(2, 42)),
        (d7 = Math.pow(2, 49)),
        (h7 = Math.pow(2, 56)),
        (p7 = Math.pow(2, 63)),
        (m7 = function (e) {
          return e < o7
            ? 1
            : e < a7
            ? 2
            : e < c7
            ? 3
            : e < u7
            ? 4
            : e < l7
            ? 5
            : e < f7
            ? 6
            : e < d7
            ? 7
            : e < h7
            ? 8
            : e < p7
            ? 9
            : 10
        }),
        (b7 = { encode: e7, decode: i7, encodingLength: m7 }),
        (y7 = b7),
        (Bc = y7)
    }
  }),
  v7 = {}
Re(v7, { decode: () => Nc, encodeTo: () => zo, encodingLength: () => Ko })
var Nc,
  zo,
  Ko,
  jp = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        _P(),
        (Nc = (e) => [Bc.decode(e), Bc.decode.bytes]),
        (zo = (e, r, t = 0) => (Bc.encode(e, r, t), r)),
        (Ko = (e) => Bc.encodingLength(e))
    }
  }),
  g7 = {}
Re(g7, { Digest: () => Pc, create: () => Ql, decode: () => zp, equals: () => Kp })
var Ql,
  zp,
  Kp,
  Pc,
  Fp = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        ws(),
        jp(),
        (Ql = (e, r) => {
          let t = r.byteLength,
            n = Ko(e),
            i = n + Ko(t),
            s = new Uint8Array(i + t)
          return zo(e, s, 0), zo(t, s, n), s.set(r, i), new Pc(e, t, r, s)
        }),
        (zp = (e) => {
          let r = gs(e),
            [t, n] = Nc(r),
            [i, s] = Nc(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new Pc(t, i, u, r)
        }),
        (Kp = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && Np(e.bytes, r.bytes))),
        (Pc = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  w7 = {}
Re(w7, { Hasher: () => Vp, from: () => Oc })
var Oc,
  Vp,
  Hp = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        Fp(),
        (Oc = ({ name: e, code: r, encode: t }) => new Vp(e, r, t)),
        (Vp = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return Ql(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  _7 = {}
Re(_7, { sha256: () => E7, sha512: () => S7 })
var $p,
  E7,
  S7,
  EP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        Hp(),
        ($p = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (E7 = Oc({ name: 'sha2-256', code: 18, encode: $p('SHA-256') })),
        (S7 = Oc({ name: 'sha2-512', code: 19, encode: $p('SHA-512') }))
    }
  }),
  A7 = {}
Re(A7, { identity: () => I7 })
var I7,
  SP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), Hp(), ws(), (I7 = Oc({ name: 'identity', code: 0, encode: (e) => gs(e) }))
    }
  }),
  T7 = {}
Re(T7, { code: () => k7, decode: () => x7, encode: () => M7, name: () => C7 })
var Gp,
  C7,
  k7,
  M7,
  x7,
  AP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(),
        F(),
        ws(),
        (Gp = (e) => gs(e)),
        ({ name: C7, code: k7, encode: M7, decode: x7 } = { name: 'raw', code: 85, decode: Gp, encode: Gp })
    }
  }),
  R7 = {}
Re(R7, { code: () => N7, decode: () => O7, encode: () => P7, name: () => B7 })
var B7,
  N7,
  P7,
  O7,
  IP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(),
        F(),
        ({
          name: B7,
          code: N7,
          encode: P7,
          decode: O7
        } = {
          name: 'json',
          code: 512,
          encode: (e) => new TextEncoder().encode(JSON.stringify(e)),
          decode: (e) => JSON.parse(new TextDecoder().decode(e))
        })
    }
  }),
  Rr,
  D7,
  L7,
  U7,
  Fo,
  q7,
  Wp,
  Jp,
  Dc,
  Lc,
  j7,
  z7,
  K7,
  TP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        jp(),
        Fp(),
        G_(),
        z_(),
        ws(),
        (Rr = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: Lc,
                byteLength: Lc,
                code: Dc,
                version: Dc,
                multihash: Dc,
                bytes: Dc,
                _baseCache: Lc,
                asCID: Lc
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== Fo) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== q7) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return Rr.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = Ql(e, r)
                return Rr.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && Kp(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return L7(r, n, e || Un.encoder)
              default:
                return U7(r, n, e || jo.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return z7(/^0\.0/, K7), !!(e && (e[Jp] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof Rr) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new Rr(r, t, n, i || Wp(r, t, n.bytes))
            } else if (e != null && e[Jp] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = zp(t)
              return Rr.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== Fo) throw new Error(`Version 0 CID must use dag-pb (code: ${Fo}) block encoding`)
                return new Rr(e, r, t, t.bytes)
              }
              case 1: {
                let n = Wp(e, r, t.bytes)
                return new Rr(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return Rr.create(0, Fo, e)
          }
          static createV1(e, r) {
            return Rr.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = Rr.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = Rr.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = gs(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new Pc(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? Rr.createV0(s) : Rr.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = Nc(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = Fo
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = D7(e, r),
              i = Rr.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (D7 = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || Un
              return [Un.prefix, t.decode(`${Un.prefix}${e}`)]
            }
            case Un.prefix: {
              let t = r || Un
              return [Un.prefix, t.decode(e)]
            }
            case jo.prefix: {
              let t = r || jo
              return [jo.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        (L7 = (e, r, t) => {
          let { prefix: n } = t
          if (n !== Un.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (U7 = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (Fo = 112),
        (q7 = 18),
        (Wp = (e, r, t) => {
          let n = Ko(e),
            i = n + Ko(r),
            s = new Uint8Array(i + t.byteLength)
          return zo(e, s, 0), zo(r, s, n), s.set(t, i), s
        }),
        (Jp = Symbol.for('@ipld/js-cid/CID')),
        (Dc = { writable: !1, configurable: !1, enumerable: !0 }),
        (Lc = { writable: !1, enumerable: !1, configurable: !1 }),
        (j7 = '0.0.0-dev'),
        (z7 = (e, r) => {
          if (e.test(j7)) console.warn(r)
          else throw new Error(r)
        }),
        (K7 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  CP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), TP(), jp(), ws(), Hp(), Fp()
    }
  }),
  F7 = {}
Re(F7, {
  CID: () => Rr,
  bases: () => V7,
  bytes: () => d_,
  codecs: () => $7,
  digest: () => g7,
  hasher: () => w7,
  hashes: () => H7,
  varint: () => v7
})
var V7,
  H7,
  $7,
  kP = Ie({
    'node_modules/libp2p-webrtc-star/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        pP(),
        mP(),
        bP(),
        yP(),
        vP(),
        z_(),
        gP(),
        G_(),
        wP(),
        EP(),
        SP(),
        AP(),
        IP(),
        CP(),
        (V7 = { ...__, ...S_, ...I_, ...C_, ...M_, ...B_, ...K_, ...H_, ...W_ }),
        (H7 = { ..._7, ...A7 }),
        ($7 = { raw: T7, json: R7 })
    }
  }),
  G7 = te({
    'node_modules/libp2p-webrtc-star/node_modules/uint8arrays/util/bases.js'(e, r) {
      V(), F()
      var { bases: t } = (kP(), F7)
      function n(o, l, a, c) {
        return { name: o, prefix: l, encoder: { name: o, prefix: l, encode: a }, decoder: { decode: c } }
      }
      var i = n(
          'utf8',
          'u',
          (o) => {
            let l = new TextDecoder('utf8')
            return 'u' + l.decode(o)
          },
          (o) => new TextEncoder().encode(o.substring(1))
        ),
        s = n(
          'ascii',
          'a',
          (o) => {
            let l = 'a'
            for (let a = 0; a < o.length; a++) l += String.fromCharCode(o[a])
            return l
          },
          (o) => {
            o = o.substring(1)
            let l = new Uint8Array(o.length)
            for (let a = 0; a < o.length; a++) l[a] = o.charCodeAt(a)
            return l
          }
        ),
        u = { utf8: i, 'utf-8': i, hex: t.base16, latin1: s, ascii: s, binary: s, ...t }
      r.exports = u
    }
  }),
  ef = te({
    'node_modules/libp2p-webrtc-star/node_modules/uint8arrays/to-string.js'(e, r) {
      V(), F()
      var t = G7()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.encoder.encode(i).substring(1)
      }
      r.exports = n
    }
  }),
  MP = te({
    'node_modules/libp2p-webrtc-star/node_modules/multiaddr/src/ip.js'(e, r) {
      V(), F()
      var t = yo(),
        n = ef(),
        i = t,
        s = t.v4,
        u = t.v6,
        o = function (a, c, f) {
          f = ~~f
          let p
          if (s(a))
            (p = c || new Uint8Array(f + 4)),
              a.split(/\./g).map(function (d) {
                p[f++] = parseInt(d, 10) & 255
              })
          else if (u(a)) {
            let d = a.split(':', 8),
              h
            for (h = 0; h < d.length; h++) {
              let m = s(d[h])
              var y
              m && ((y = o(d[h])), (d[h] = n(y.slice(0, 2), 'base16'))),
                y && ++h < 8 && d.splice(h, 0, n(y.slice(2, 4), 'base16'))
            }
            if (d[0] === '') for (; d.length < 8; ) d.unshift('0')
            else if (d[d.length - 1] === '') for (; d.length < 8; ) d.push('0')
            else if (d.length < 8) {
              for (h = 0; h < d.length && d[h] !== ''; h++);
              let m = [h, '1']
              for (h = 9 - d.length; h > 0; h--) m.push('0')
              d.splice.apply(d, m)
            }
            for (p = c || new Uint8Array(f + 16), h = 0; h < d.length; h++) {
              let m = parseInt(d[h], 16)
              ;(p[f++] = (m >> 8) & 255), (p[f++] = m & 255)
            }
          }
          if (!p) throw Error('Invalid ip address: ' + a)
          return p
        },
        l = function (a, c, f) {
          ;(c = ~~c), (f = f || a.length - c)
          let p = [],
            y,
            d = new DataView(a.buffer)
          if (f === 4) {
            for (let h = 0; h < f; h++) p.push(a[c + h])
            y = p.join('.')
          } else if (f === 16) {
            for (let h = 0; h < f; h += 2) p.push(d.getUint16(c + h).toString(16))
            ;(y = p.join(':')), (y = y.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')), (y = y.replace(/:{3,4}/, '::'))
          }
          return y
        }
      r.exports = { isIP: i, isV4: s, isV6: u, toBytes: o, toString: l }
    }
  }),
  Xp = te({
    'node_modules/libp2p-webrtc-star/node_modules/multiaddr/src/protocols-table.js'(e, r) {
      V(), F()
      function t(s) {
        if (typeof s == 'number') {
          if (t.codes[s]) return t.codes[s]
          throw new Error('no protocol with code: ' + s)
        } else if (typeof s == 'string') {
          if (t.names[s]) return t.names[s]
          throw new Error('no protocol with name: ' + s)
        }
        throw new Error('invalid protocol id type: ' + s)
      }
      var n = -1
      ;(t.lengthPrefixedVarSize = n),
        (t.V = n),
        (t.table = [
          [4, 32, 'ip4'],
          [6, 16, 'tcp'],
          [33, 16, 'dccp'],
          [41, 128, 'ip6'],
          [42, n, 'ip6zone'],
          [53, n, 'dns', 'resolvable'],
          [54, n, 'dns4', 'resolvable'],
          [55, n, 'dns6', 'resolvable'],
          [56, n, 'dnsaddr', 'resolvable'],
          [132, 16, 'sctp'],
          [273, 16, 'udp'],
          [275, 0, 'p2p-webrtc-star'],
          [276, 0, 'p2p-webrtc-direct'],
          [277, 0, 'p2p-stardust'],
          [290, 0, 'p2p-circuit'],
          [301, 0, 'udt'],
          [302, 0, 'utp'],
          [400, n, 'unix', !1, 'path'],
          [421, n, 'ipfs'],
          [421, n, 'p2p'],
          [443, 0, 'https'],
          [444, 96, 'onion'],
          [445, 296, 'onion3'],
          [446, n, 'garlic64'],
          [460, 0, 'quic'],
          [477, 0, 'ws'],
          [478, 0, 'wss'],
          [479, 0, 'p2p-websocket-star'],
          [480, 0, 'http'],
          [777, n, 'memory']
        ]),
        (t.names = {}),
        (t.codes = {}),
        t.table.map((s) => {
          let u = i.apply(null, s)
          return (t.codes[u.code] = u), (t.names[u.name] = u), null
        }),
        (t.object = i)
      function i(s, u, o, l, a) {
        return { code: s, size: u, name: o, resolvable: Boolean(l), path: Boolean(a) }
      }
      r.exports = t
    }
  }),
  xP = te({
    'node_modules/libp2p-webrtc-star/node_modules/uint8arrays/from-string.js'(e, r) {
      V(), F()
      var t = G7()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.decoder.decode(`${u.prefix}${i}`)
      }
      r.exports = n
    }
  }),
  W7 = te({
    'node_modules/libp2p-webrtc-star/node_modules/uint8arrays/concat.js'(e, r) {
      V(), F()
      function t(n, i) {
        i || (i = n.reduce((o, l) => o + l.length, 0))
        let s = new Uint8Array(i),
          u = 0
        for (let o of n) s.set(o, u), (u += o.length)
        return s
      }
      r.exports = t
    }
  }),
  RP = te({
    'node_modules/libp2p-webrtc-star/node_modules/multiaddr/src/convert.js'(e, r) {
      V(), F()
      var t = MP(),
        n = Xp(),
        i = Gr(),
        s = Di(),
        u = $t(),
        o = ef(),
        l = xP(),
        a = W7()
      r.exports = c
      function c(w, v) {
        return v instanceof Uint8Array ? c.toString(w, v) : c.toBytes(w, v)
      }
      ;(c.toString = function (v, I) {
        switch (n(v).code) {
          case 4:
          case 41:
            return p(I)
          case 6:
          case 273:
          case 33:
          case 132:
            return d(I).toString()
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return m(I)
          case 421:
            return A(I)
          case 444:
            return k(I)
          case 445:
            return k(I)
          default:
            return o(I, 'base16')
        }
      }),
        (c.toBytes = function (v, I) {
          switch (n(v).code) {
            case 4:
              return f(I)
            case 41:
              return f(I)
            case 6:
            case 273:
            case 33:
            case 132:
              return y(parseInt(I, 10))
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return h(I)
            case 421:
              return _(I)
            case 444:
              return T(I)
            case 445:
              return E(I)
            default:
              return l(I, 'base16')
          }
        })
      function f(w) {
        if (!t.isIP(w)) throw new Error('invalid ip address')
        return t.toBytes(w)
      }
      function p(w) {
        let v = t.toString(w)
        if (!v || !t.isIP(v)) throw new Error('invalid ip address')
        return v
      }
      function y(w) {
        let v = new ArrayBuffer(2)
        return new DataView(v).setUint16(0, w), new Uint8Array(v)
      }
      function d(w) {
        return new DataView(w.buffer).getUint16(w.byteOffset)
      }
      function h(w) {
        let v = l(w),
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function m(w) {
        let v = u.decode(w)
        if (((w = w.slice(u.decode.bytes)), w.length !== v)) throw new Error('inconsistent lengths')
        return o(w)
      }
      function _(w) {
        let v = new i(w).multihash,
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function A(w) {
        let v = u.decode(w),
          I = w.slice(u.decode.bytes)
        if (I.length !== v) throw new Error('inconsistent lengths')
        return o(I, 'base58btc')
      }
      function T(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 16) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function E(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 56) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion3 address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function k(w) {
        let v = w.slice(0, w.length - 2),
          I = w.slice(w.length - 2),
          M = o(v, 'base32'),
          q = d(I)
        return M + ':' + q
      }
    }
  }),
  BP = te({
    'node_modules/libp2p-webrtc-star/node_modules/multiaddr/src/codec.js'(e, r) {
      V(), F()
      var t = RP(),
        n = Xp(),
        i = $t(),
        s = W7(),
        u = ef()
      r.exports = {
        stringToStringTuples: o,
        stringTuplesToString: l,
        tuplesToStringTuples: c,
        stringTuplesToTuples: a,
        bytesToTuples: y,
        tuplesToBytes: f,
        bytesToString: d,
        stringToBytes: h,
        fromString: m,
        fromBytes: _,
        validateBytes: A,
        isValidBytes: T,
        cleanPath: E,
        ParseError: k,
        protoFromTuple: w,
        sizeForAddr: p
      }
      function o(v) {
        let I = [],
          M = v.split('/').slice(1)
        if (M.length === 1 && M[0] === '') return []
        for (let q = 0; q < M.length; q++) {
          let G = M[q],
            O = n(G)
          if (O.size === 0) {
            I.push([G])
            continue
          }
          if ((q++, q >= M.length)) throw k('invalid address: ' + v)
          if (O.path) {
            I.push([G, E(M.slice(q).join('/'))])
            break
          }
          I.push([G, M[q]])
        }
        return I
      }
      function l(v) {
        let I = []
        return (
          v.map((M) => {
            let q = w(M)
            return I.push(q.name), M.length > 1 && I.push(M[1]), null
          }),
          E(I.join('/'))
        )
      }
      function a(v) {
        return v.map((I) => {
          Array.isArray(I) || (I = [I])
          let M = w(I)
          return I.length > 1 ? [M.code, t.toBytes(M.code, I[1])] : [M.code]
        })
      }
      function c(v) {
        return v.map((I) => {
          let M = w(I)
          return I[1] ? [M.code, t.toString(M.code, I[1])] : [M.code]
        })
      }
      function f(v) {
        return _(
          s(
            v.map((I) => {
              let M = w(I),
                q = Uint8Array.from(i.encode(M.code))
              return I.length > 1 && (q = s([q, I[1]])), q
            })
          )
        )
      }
      function p(v, I) {
        return v.size > 0 ? v.size / 8 : v.size === 0 ? 0 : i.decode(I) + i.decode.bytes
      }
      function y(v) {
        let I = [],
          M = 0
        for (; M < v.length; ) {
          let q = i.decode(v, M),
            G = i.decode.bytes,
            O = n(q),
            x = p(O, v.slice(M + G))
          if (x === 0) {
            I.push([q]), (M += G)
            continue
          }
          let L = v.slice(M + G, M + G + x)
          if (((M += x + G), M > v.length)) throw k('Invalid address Uint8Array: ' + u(v, 'base16'))
          I.push([q, L])
        }
        return I
      }
      function d(v) {
        let I = y(v),
          M = c(I)
        return l(M)
      }
      function h(v) {
        v = E(v)
        let I = o(v),
          M = a(I)
        return f(M)
      }
      function m(v) {
        return h(v)
      }
      function _(v) {
        let I = A(v)
        if (I) throw I
        return Uint8Array.from(v)
      }
      function A(v) {
        try {
          y(v)
        } catch (I) {
          return I
        }
      }
      function T(v) {
        return A(v) === void 0
      }
      function E(v) {
        return (
          '/' +
          v
            .trim()
            .split('/')
            .filter((I) => I)
            .join('/')
        )
      }
      function k(v) {
        return new Error('Error parsing address: ' + v)
      }
      function w(v) {
        return n(v[0])
      }
    }
  }),
  NP = te({
    'node_modules/libp2p-webrtc-star/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  }),
  J7 = te({
    'node_modules/libp2p-webrtc-star/node_modules/multiaddr/src/index.js'(e, r) {
      V(), F()
      var t = BP(),
        n = Xp(),
        i = $t(),
        s = Gr(),
        u = pt(),
        o = Symbol.for('nodejs.util.inspect.custom'),
        l = ef(),
        a = NP(),
        c = new Map(),
        f = Symbol.for('@multiformats/js-multiaddr/multiaddr'),
        p = class {
          constructor(d) {
            if ((d == null && (d = ''), Object.defineProperty(this, f, { value: !0 }), d instanceof Uint8Array))
              this.bytes = t.fromBytes(d)
            else if (typeof d == 'string') {
              if (d.length > 0 && d.charAt(0) !== '/') throw new Error(`multiaddr "${d}" must start with a "/"`)
              this.bytes = t.fromString(d)
            } else if (p.isMultiaddr(d)) this.bytes = t.fromBytes(d.bytes)
            else throw new Error('addr must be a string, Buffer, or another Multiaddr')
          }
          toString() {
            return t.bytesToString(this.bytes)
          }
          toJSON() {
            return this.toString()
          }
          toOptions() {
            let d = {},
              h = this.toString().split('/')
            return (
              (d.family = h[1] === 'ip4' ? 4 : 6), (d.host = h[2]), (d.transport = h[3]), (d.port = parseInt(h[4])), d
            )
          }
          protos() {
            return this.protoCodes().map((d) => Object.assign({}, n(d)))
          }
          protoCodes() {
            let d = [],
              h = this.bytes,
              m = 0
            for (; m < h.length; ) {
              let _ = i.decode(h, m),
                A = i.decode.bytes,
                T = n(_)
              ;(m += t.sizeForAddr(T, h.slice(m + A)) + A), d.push(_)
            }
            return d
          }
          protoNames() {
            return this.protos().map((d) => d.name)
          }
          tuples() {
            return t.bytesToTuples(this.bytes)
          }
          stringTuples() {
            let d = t.bytesToTuples(this.bytes)
            return t.tuplesToStringTuples(d)
          }
          encapsulate(d) {
            return (d = new p(d)), new p(this.toString() + d.toString())
          }
          decapsulate(d) {
            let h = d.toString(),
              m = this.toString(),
              _ = m.lastIndexOf(h)
            if (_ < 0) throw new Error('Address ' + this + ' does not contain subaddress: ' + d)
            return new p(m.slice(0, _))
          }
          decapsulateCode(d) {
            let h = this.tuples()
            for (let m = h.length - 1; m >= 0; m--) if (h[m][0] === d) return new p(t.tuplesToBytes(h.slice(0, m)))
            return this
          }
          getPeerId() {
            try {
              let h = this.stringTuples()
                .filter((m) => m[0] === n.names.ipfs.code)
                .pop()
              return h && h[1] ? l(new s(h[1]).multihash, 'base58btc') : null
            } catch (d) {
              return null
            }
          }
          getPath() {
            let d = null
            try {
              ;(d = this.stringTuples().filter((h) => !!n(h[0]).path)[0][1]), d || (d = null)
            } catch (h) {
              d = null
            }
            return d
          }
          equals(d) {
            return a(this.bytes, d.bytes)
          }
          async resolve() {
            let d = this.protos().find((_) => _.resolvable)
            if (!d) return [this]
            let h = c.get(d.name)
            if (!h) throw u(new Error(`no available resolver for ${d.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
            return (await h(this)).map((_) => new p(_))
          }
          nodeAddress() {
            let d = this.protoCodes(),
              h = this.protoNames(),
              m = this.toString().split('/').slice(1)
            if (m.length < 4)
              throw new Error(
                'multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'
              )
            if (d[0] !== 4 && d[0] !== 41 && d[0] !== 54 && d[0] !== 55)
              throw new Error(
                `no protocol with name: "'${h[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`
              )
            if (m[2] !== 'tcp' && m[2] !== 'udp')
              throw new Error(`no protocol with name: "'${h[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
            return { family: d[0] === 41 || d[0] === 55 ? 6 : 4, address: m[1], port: parseInt(m[3]) }
          }
          isThinWaistAddress(d) {
            let h = (d || this).protos()
            return !(h.length !== 2 || (h[0].code !== 4 && h[0].code !== 41) || (h[1].code !== 6 && h[1].code !== 273))
          }
          static fromNodeAddress(d, h) {
            if (!d) throw new Error('requires node address object')
            if (!h) throw new Error('requires transport protocol')
            let m
            switch (d.family) {
              case 4:
                m = 'ip4'
                break
              case 6:
                m = 'ip6'
                break
              default:
                throw Error(`Invalid addr family. Got '${d.family}' instead of 4 or 6`)
            }
            return new p('/' + [m, d.address, h, d.port].join('/'))
          }
          static isName(d) {
            return p.isMultiaddr(d) ? d.protos().some((h) => h.resolvable) : !1
          }
          static isMultiaddr(d) {
            return d instanceof p || Boolean(d && d[f])
          }
          [o]() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
          inspect() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
        }
      ;(p.protocols = n), (p.resolvers = c)
      function y(d) {
        return new p(d)
      }
      r.exports = { Multiaddr: p, multiaddr: y, protocols: n, resolvers: c }
    }
  }),
  PP = te({
    'node_modules/@protobufjs/aspromise/index.js'(e, r) {
      V(), F(), (r.exports = t)
      function t(n, i) {
        for (var s = new Array(arguments.length - 1), u = 0, o = 2, l = !0; o < arguments.length; )
          s[u++] = arguments[o++]
        return new Promise(function (c, f) {
          s[u] = function (y) {
            if (l)
              if (((l = !1), y)) f(y)
              else {
                for (var d = new Array(arguments.length - 1), h = 0; h < d.length; ) d[h++] = arguments[h]
                c.apply(null, d)
              }
          }
          try {
            n.apply(i || null, s)
          } catch (p) {
            l && ((l = !1), f(p))
          }
        })
      }
    }
  }),
  OP = te({
    'node_modules/@protobufjs/base64/index.js'(e) {
      V(), F()
      var r = e
      r.length = function (o) {
        var l = o.length
        if (!l) return 0
        for (var a = 0; --l % 4 > 1 && o.charAt(l) === '='; ) ++a
        return Math.ceil(o.length * 3) / 4 - a
      }
      var t = new Array(64),
        n = new Array(123)
      for (i = 0; i < 64; ) n[(t[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : (i - 59) | 43)] = i++
      var i
      r.encode = function (o, l, a) {
        for (var c = null, f = [], p = 0, y = 0, d; l < a; ) {
          var h = o[l++]
          switch (y) {
            case 0:
              ;(f[p++] = t[h >> 2]), (d = (h & 3) << 4), (y = 1)
              break
            case 1:
              ;(f[p++] = t[d | (h >> 4)]), (d = (h & 15) << 2), (y = 2)
              break
            case 2:
              ;(f[p++] = t[d | (h >> 6)]), (f[p++] = t[h & 63]), (y = 0)
              break
          }
          p > 8191 && ((c || (c = [])).push(String.fromCharCode.apply(String, f)), (p = 0))
        }
        return (
          y && ((f[p++] = t[d]), (f[p++] = 61), y === 1 && (f[p++] = 61)),
          c
            ? (p && c.push(String.fromCharCode.apply(String, f.slice(0, p))), c.join(''))
            : String.fromCharCode.apply(String, f.slice(0, p))
        )
      }
      var s = 'invalid encoding'
      ;(r.decode = function (o, l, a) {
        for (var c = a, f = 0, p, y = 0; y < o.length; ) {
          var d = o.charCodeAt(y++)
          if (d === 61 && f > 1) break
          if ((d = n[d]) === void 0) throw Error(s)
          switch (f) {
            case 0:
              ;(p = d), (f = 1)
              break
            case 1:
              ;(l[a++] = (p << 2) | ((d & 48) >> 4)), (p = d), (f = 2)
              break
            case 2:
              ;(l[a++] = ((p & 15) << 4) | ((d & 60) >> 2)), (p = d), (f = 3)
              break
            case 3:
              ;(l[a++] = ((p & 3) << 6) | d), (f = 0)
              break
          }
        }
        if (f === 1) throw Error(s)
        return a - c
      }),
        (r.test = function (o) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(o)
        })
    }
  }),
  DP = te({
    'node_modules/@protobufjs/eventemitter/index.js'(e, r) {
      V(), F(), (r.exports = t)
      function t() {
        this._listeners = {}
      }
      ;(t.prototype.on = function (i, s, u) {
        return (this._listeners[i] || (this._listeners[i] = [])).push({ fn: s, ctx: u || this }), this
      }),
        (t.prototype.off = function (i, s) {
          if (i === void 0) this._listeners = {}
          else if (s === void 0) this._listeners[i] = []
          else for (var u = this._listeners[i], o = 0; o < u.length; ) u[o].fn === s ? u.splice(o, 1) : ++o
          return this
        }),
        (t.prototype.emit = function (i) {
          var s = this._listeners[i]
          if (s) {
            for (var u = [], o = 1; o < arguments.length; ) u.push(arguments[o++])
            for (o = 0; o < s.length; ) s[o].fn.apply(s[o++].ctx, u)
          }
          return this
        })
    }
  }),
  LP = te({
    'node_modules/@protobufjs/float/index.js'(e, r) {
      V(), F(), (r.exports = t(t))
      function t(o) {
        return (
          typeof Float32Array != 'undefined'
            ? (function () {
                var l = new Float32Array([-0]),
                  a = new Uint8Array(l.buffer),
                  c = a[3] === 128
                function f(h, m, _) {
                  ;(l[0] = h), (m[_] = a[0]), (m[_ + 1] = a[1]), (m[_ + 2] = a[2]), (m[_ + 3] = a[3])
                }
                function p(h, m, _) {
                  ;(l[0] = h), (m[_] = a[3]), (m[_ + 1] = a[2]), (m[_ + 2] = a[1]), (m[_ + 3] = a[0])
                }
                ;(o.writeFloatLE = c ? f : p), (o.writeFloatBE = c ? p : f)
                function y(h, m) {
                  return (a[0] = h[m]), (a[1] = h[m + 1]), (a[2] = h[m + 2]), (a[3] = h[m + 3]), l[0]
                }
                function d(h, m) {
                  return (a[3] = h[m]), (a[2] = h[m + 1]), (a[1] = h[m + 2]), (a[0] = h[m + 3]), l[0]
                }
                ;(o.readFloatLE = c ? y : d), (o.readFloatBE = c ? d : y)
              })()
            : (function () {
                function l(c, f, p, y) {
                  var d = f < 0 ? 1 : 0
                  if ((d && (f = -f), f === 0)) c(1 / f > 0 ? 0 : 2147483648, p, y)
                  else if (isNaN(f)) c(2143289344, p, y)
                  else if (f > 34028234663852886e22) c(((d << 31) | 2139095040) >>> 0, p, y)
                  else if (f < 11754943508222875e-54) c(((d << 31) | Math.round(f / 1401298464324817e-60)) >>> 0, p, y)
                  else {
                    var h = Math.floor(Math.log(f) / Math.LN2),
                      m = Math.round(f * Math.pow(2, -h) * 8388608) & 8388607
                    c(((d << 31) | ((h + 127) << 23) | m) >>> 0, p, y)
                  }
                }
                ;(o.writeFloatLE = l.bind(null, n)), (o.writeFloatBE = l.bind(null, i))
                function a(c, f, p) {
                  var y = c(f, p),
                    d = (y >> 31) * 2 + 1,
                    h = (y >>> 23) & 255,
                    m = y & 8388607
                  return h === 255
                    ? m
                      ? NaN
                      : d * (1 / 0)
                    : h === 0
                    ? d * 1401298464324817e-60 * m
                    : d * Math.pow(2, h - 150) * (m + 8388608)
                }
                ;(o.readFloatLE = a.bind(null, s)), (o.readFloatBE = a.bind(null, u))
              })(),
          typeof Float64Array != 'undefined'
            ? (function () {
                var l = new Float64Array([-0]),
                  a = new Uint8Array(l.buffer),
                  c = a[7] === 128
                function f(h, m, _) {
                  ;(l[0] = h),
                    (m[_] = a[0]),
                    (m[_ + 1] = a[1]),
                    (m[_ + 2] = a[2]),
                    (m[_ + 3] = a[3]),
                    (m[_ + 4] = a[4]),
                    (m[_ + 5] = a[5]),
                    (m[_ + 6] = a[6]),
                    (m[_ + 7] = a[7])
                }
                function p(h, m, _) {
                  ;(l[0] = h),
                    (m[_] = a[7]),
                    (m[_ + 1] = a[6]),
                    (m[_ + 2] = a[5]),
                    (m[_ + 3] = a[4]),
                    (m[_ + 4] = a[3]),
                    (m[_ + 5] = a[2]),
                    (m[_ + 6] = a[1]),
                    (m[_ + 7] = a[0])
                }
                ;(o.writeDoubleLE = c ? f : p), (o.writeDoubleBE = c ? p : f)
                function y(h, m) {
                  return (
                    (a[0] = h[m]),
                    (a[1] = h[m + 1]),
                    (a[2] = h[m + 2]),
                    (a[3] = h[m + 3]),
                    (a[4] = h[m + 4]),
                    (a[5] = h[m + 5]),
                    (a[6] = h[m + 6]),
                    (a[7] = h[m + 7]),
                    l[0]
                  )
                }
                function d(h, m) {
                  return (
                    (a[7] = h[m]),
                    (a[6] = h[m + 1]),
                    (a[5] = h[m + 2]),
                    (a[4] = h[m + 3]),
                    (a[3] = h[m + 4]),
                    (a[2] = h[m + 5]),
                    (a[1] = h[m + 6]),
                    (a[0] = h[m + 7]),
                    l[0]
                  )
                }
                ;(o.readDoubleLE = c ? y : d), (o.readDoubleBE = c ? d : y)
              })()
            : (function () {
                function l(c, f, p, y, d, h) {
                  var m = y < 0 ? 1 : 0
                  if ((m && (y = -y), y === 0)) c(0, d, h + f), c(1 / y > 0 ? 0 : 2147483648, d, h + p)
                  else if (isNaN(y)) c(0, d, h + f), c(2146959360, d, h + p)
                  else if (y > 17976931348623157e292) c(0, d, h + f), c(((m << 31) | 2146435072) >>> 0, d, h + p)
                  else {
                    var _
                    if (y < 22250738585072014e-324)
                      (_ = y / 5e-324), c(_ >>> 0, d, h + f), c(((m << 31) | (_ / 4294967296)) >>> 0, d, h + p)
                    else {
                      var A = Math.floor(Math.log(y) / Math.LN2)
                      A === 1024 && (A = 1023),
                        (_ = y * Math.pow(2, -A)),
                        c((_ * 4503599627370496) >>> 0, d, h + f),
                        c(((m << 31) | ((A + 1023) << 20) | ((_ * 1048576) & 1048575)) >>> 0, d, h + p)
                    }
                  }
                }
                ;(o.writeDoubleLE = l.bind(null, n, 0, 4)), (o.writeDoubleBE = l.bind(null, i, 4, 0))
                function a(c, f, p, y, d) {
                  var h = c(y, d + f),
                    m = c(y, d + p),
                    _ = (m >> 31) * 2 + 1,
                    A = (m >>> 20) & 2047,
                    T = 4294967296 * (m & 1048575) + h
                  return A === 2047
                    ? T
                      ? NaN
                      : _ * (1 / 0)
                    : A === 0
                    ? _ * 5e-324 * T
                    : _ * Math.pow(2, A - 1075) * (T + 4503599627370496)
                }
                ;(o.readDoubleLE = a.bind(null, s, 0, 4)), (o.readDoubleBE = a.bind(null, u, 4, 0))
              })(),
          o
        )
      }
      function n(o, l, a) {
        ;(l[a] = o & 255), (l[a + 1] = (o >>> 8) & 255), (l[a + 2] = (o >>> 16) & 255), (l[a + 3] = o >>> 24)
      }
      function i(o, l, a) {
        ;(l[a] = o >>> 24), (l[a + 1] = (o >>> 16) & 255), (l[a + 2] = (o >>> 8) & 255), (l[a + 3] = o & 255)
      }
      function s(o, l) {
        return (o[l] | (o[l + 1] << 8) | (o[l + 2] << 16) | (o[l + 3] << 24)) >>> 0
      }
      function u(o, l) {
        return ((o[l] << 24) | (o[l + 1] << 16) | (o[l + 2] << 8) | o[l + 3]) >>> 0
      }
    }
  }),
  UP = te({
    'node_modules/@protobufjs/inquire/index.js'(exports, module) {
      V(), F(), (module.exports = inquire)
      function inquire(moduleName) {
        try {
          var mod = eval('quire'.replace(/^/, 're'))(moduleName)
          if (mod && (mod.length || Object.keys(mod).length)) return mod
        } catch (e) {}
        return null
      }
    }
  }),
  qP = te({
    'node_modules/@protobufjs/utf8/index.js'(e) {
      V(), F()
      var r = e
      ;(r.length = function (n) {
        for (var i = 0, s = 0, u = 0; u < n.length; ++u)
          (s = n.charCodeAt(u)),
            s < 128
              ? (i += 1)
              : s < 2048
              ? (i += 2)
              : (s & 64512) == 55296 && (n.charCodeAt(u + 1) & 64512) == 56320
              ? (++u, (i += 4))
              : (i += 3)
        return i
      }),
        (r.read = function (n, i, s) {
          var u = s - i
          if (u < 1) return ''
          for (var o = null, l = [], a = 0, c; i < s; )
            (c = n[i++]),
              c < 128
                ? (l[a++] = c)
                : c > 191 && c < 224
                ? (l[a++] = ((c & 31) << 6) | (n[i++] & 63))
                : c > 239 && c < 365
                ? ((c = (((c & 7) << 18) | ((n[i++] & 63) << 12) | ((n[i++] & 63) << 6) | (n[i++] & 63)) - 65536),
                  (l[a++] = 55296 + (c >> 10)),
                  (l[a++] = 56320 + (c & 1023)))
                : (l[a++] = ((c & 15) << 12) | ((n[i++] & 63) << 6) | (n[i++] & 63)),
              a > 8191 && ((o || (o = [])).push(String.fromCharCode.apply(String, l)), (a = 0))
          return o
            ? (a && o.push(String.fromCharCode.apply(String, l.slice(0, a))), o.join(''))
            : String.fromCharCode.apply(String, l.slice(0, a))
        }),
        (r.write = function (n, i, s) {
          for (var u = s, o, l, a = 0; a < n.length; ++a)
            (o = n.charCodeAt(a)),
              o < 128
                ? (i[s++] = o)
                : o < 2048
                ? ((i[s++] = (o >> 6) | 192), (i[s++] = (o & 63) | 128))
                : (o & 64512) == 55296 && ((l = n.charCodeAt(a + 1)) & 64512) == 56320
                ? ((o = 65536 + ((o & 1023) << 10) + (l & 1023)),
                  ++a,
                  (i[s++] = (o >> 18) | 240),
                  (i[s++] = ((o >> 12) & 63) | 128),
                  (i[s++] = ((o >> 6) & 63) | 128),
                  (i[s++] = (o & 63) | 128))
                : ((i[s++] = (o >> 12) | 224), (i[s++] = ((o >> 6) & 63) | 128), (i[s++] = (o & 63) | 128))
          return s - u
        })
    }
  }),
  jP = te({
    'node_modules/@protobufjs/pool/index.js'(e, r) {
      V(), F(), (r.exports = t)
      function t(n, i, s) {
        var u = s || 8192,
          o = u >>> 1,
          l = null,
          a = u
        return function (f) {
          if (f < 1 || f > o) return n(f)
          a + f > u && ((l = n(u)), (a = 0))
          var p = i.call(l, a, (a += f))
          return a & 7 && (a = (a | 7) + 1), p
        }
      }
    }
  }),
  zP = te({
    'node_modules/protobufjs/src/util/longbits.js'(e, r) {
      V(), F(), (r.exports = n)
      var t = _s()
      function n(o, l) {
        ;(this.lo = o >>> 0), (this.hi = l >>> 0)
      }
      var i = (n.zero = new n(0, 0))
      ;(i.toNumber = function () {
        return 0
      }),
        (i.zzEncode = i.zzDecode =
          function () {
            return this
          }),
        (i.length = function () {
          return 1
        })
      var s = (n.zeroHash = '\0\0\0\0\0\0\0\0')
      ;(n.fromNumber = function (l) {
        if (l === 0) return i
        var a = l < 0
        a && (l = -l)
        var c = l >>> 0,
          f = ((l - c) / 4294967296) >>> 0
        return (
          a && ((f = ~f >>> 0), (c = ~c >>> 0), ++c > 4294967295 && ((c = 0), ++f > 4294967295 && (f = 0))), new n(c, f)
        )
      }),
        (n.from = function (l) {
          if (typeof l == 'number') return n.fromNumber(l)
          if (t.isString(l))
            if (t.Long) l = t.Long.fromString(l)
            else return n.fromNumber(parseInt(l, 10))
          return l.low || l.high ? new n(l.low >>> 0, l.high >>> 0) : i
        }),
        (n.prototype.toNumber = function (l) {
          if (!l && this.hi >>> 31) {
            var a = (~this.lo + 1) >>> 0,
              c = ~this.hi >>> 0
            return a || (c = (c + 1) >>> 0), -(a + c * 4294967296)
          }
          return this.lo + this.hi * 4294967296
        }),
        (n.prototype.toLong = function (l) {
          return t.Long
            ? new t.Long(this.lo | 0, this.hi | 0, Boolean(l))
            : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(l) }
        })
      var u = String.prototype.charCodeAt
      ;(n.fromHash = function (l) {
        return l === s
          ? i
          : new n(
              (u.call(l, 0) | (u.call(l, 1) << 8) | (u.call(l, 2) << 16) | (u.call(l, 3) << 24)) >>> 0,
              (u.call(l, 4) | (u.call(l, 5) << 8) | (u.call(l, 6) << 16) | (u.call(l, 7) << 24)) >>> 0
            )
      }),
        (n.prototype.toHash = function () {
          return String.fromCharCode(
            this.lo & 255,
            (this.lo >>> 8) & 255,
            (this.lo >>> 16) & 255,
            this.lo >>> 24,
            this.hi & 255,
            (this.hi >>> 8) & 255,
            (this.hi >>> 16) & 255,
            this.hi >>> 24
          )
        }),
        (n.prototype.zzEncode = function () {
          var l = this.hi >> 31
          return (
            (this.hi = (((this.hi << 1) | (this.lo >>> 31)) ^ l) >>> 0), (this.lo = ((this.lo << 1) ^ l) >>> 0), this
          )
        }),
        (n.prototype.zzDecode = function () {
          var l = -(this.lo & 1)
          return (
            (this.lo = (((this.lo >>> 1) | (this.hi << 31)) ^ l) >>> 0), (this.hi = ((this.hi >>> 1) ^ l) >>> 0), this
          )
        }),
        (n.prototype.length = function () {
          var l = this.lo,
            a = ((this.lo >>> 28) | (this.hi << 4)) >>> 0,
            c = this.hi >>> 24
          return c === 0
            ? a === 0
              ? l < 16384
                ? l < 128
                  ? 1
                  : 2
                : l < 2097152
                ? 3
                : 4
              : a < 16384
              ? a < 128
                ? 5
                : 6
              : a < 2097152
              ? 7
              : 8
            : c < 128
            ? 9
            : 10
        })
    }
  }),
  _s = te({
    'node_modules/protobufjs/src/util/minimal.js'(e) {
      V(), F()
      var r = e
      ;(r.asPromise = PP()),
        (r.base64 = OP()),
        (r.EventEmitter = DP()),
        (r.float = LP()),
        (r.inquire = UP()),
        (r.utf8 = qP()),
        (r.pool = jP()),
        (r.LongBits = zP()),
        (r.isNode = Boolean(
          typeof globalThis != 'undefined' &&
            globalThis &&
            globalThis.process &&
            globalThis.process.versions &&
            globalThis.process.versions.node
        )),
        (r.global =
          (r.isNode && globalThis) ||
          (typeof window != 'undefined' && window) ||
          (typeof self != 'undefined' && self) ||
          e),
        (r.emptyArray = Object.freeze ? Object.freeze([]) : []),
        (r.emptyObject = Object.freeze ? Object.freeze({}) : {}),
        (r.isInteger =
          Number.isInteger ||
          function (s) {
            return typeof s == 'number' && isFinite(s) && Math.floor(s) === s
          }),
        (r.isString = function (s) {
          return typeof s == 'string' || s instanceof String
        }),
        (r.isObject = function (s) {
          return s && typeof s == 'object'
        }),
        (r.isset = r.isSet =
          function (s, u) {
            var o = s[u]
            return o != null && s.hasOwnProperty(u)
              ? typeof o != 'object' || (Array.isArray(o) ? o.length : Object.keys(o).length) > 0
              : !1
          }),
        (r.Buffer = (function () {
          try {
            var i = r.inquire('buffer').Buffer
            return i.prototype.utf8Write ? i : null
          } catch (s) {
            return null
          }
        })()),
        (r._Buffer_from = null),
        (r._Buffer_allocUnsafe = null),
        (r.newBuffer = function (s) {
          return typeof s == 'number'
            ? r.Buffer
              ? r._Buffer_allocUnsafe(s)
              : new r.Array(s)
            : r.Buffer
            ? r._Buffer_from(s)
            : typeof Uint8Array == 'undefined'
            ? s
            : new Uint8Array(s)
        }),
        (r.Array = typeof Uint8Array != 'undefined' ? Uint8Array : Array),
        (r.Long = (r.global.dcodeIO && r.global.dcodeIO.Long) || r.global.Long || r.inquire('long')),
        (r.key2Re = /^true|false|0|1$/),
        (r.key32Re = /^-?(?:0|[1-9][0-9]*)$/),
        (r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/),
        (r.longToHash = function (s) {
          return s ? r.LongBits.from(s).toHash() : r.LongBits.zeroHash
        }),
        (r.longFromHash = function (s, u) {
          var o = r.LongBits.fromHash(s)
          return r.Long ? r.Long.fromBits(o.lo, o.hi, u) : o.toNumber(Boolean(u))
        })
      function t(i, s, u) {
        for (var o = Object.keys(s), l = 0; l < o.length; ++l) (i[o[l]] === void 0 || !u) && (i[o[l]] = s[o[l]])
        return i
      }
      ;(r.merge = t),
        (r.lcFirst = function (s) {
          return s.charAt(0).toLowerCase() + s.substring(1)
        })
      function n(i) {
        function s(u, o) {
          if (!(this instanceof s)) return new s(u, o)
          Object.defineProperty(this, 'message', {
            get: function () {
              return u
            }
          }),
            Error.captureStackTrace
              ? Error.captureStackTrace(this, s)
              : Object.defineProperty(this, 'stack', { value: new Error().stack || '' }),
            o && t(this, o)
        }
        return (
          ((s.prototype = Object.create(Error.prototype)).constructor = s),
          Object.defineProperty(s.prototype, 'name', {
            get: function () {
              return i
            }
          }),
          (s.prototype.toString = function () {
            return this.name + ': ' + this.message
          }),
          s
        )
      }
      ;(r.newError = n),
        (r.ProtocolError = n('ProtocolError')),
        (r.oneOfGetter = function (s) {
          for (var u = {}, o = 0; o < s.length; ++o) u[s[o]] = 1
          return function () {
            for (var l = Object.keys(this), a = l.length - 1; a > -1; --a)
              if (u[l[a]] === 1 && this[l[a]] !== void 0 && this[l[a]] !== null) return l[a]
          }
        }),
        (r.oneOfSetter = function (s) {
          return function (u) {
            for (var o = 0; o < s.length; ++o) s[o] !== u && delete this[s[o]]
          }
        }),
        (r.toJSONOptions = { longs: String, enums: String, bytes: String, json: !0 }),
        (r._configure = function () {
          var i = r.Buffer
          if (!i) {
            r._Buffer_from = r._Buffer_allocUnsafe = null
            return
          }
          ;(r._Buffer_from =
            (i.from !== Uint8Array.from && i.from) ||
            function (u, o) {
              return new i(u, o)
            }),
            (r._Buffer_allocUnsafe =
              i.allocUnsafe ||
              function (u) {
                return new i(u)
              })
        })
    }
  }),
  X7 = te({
    'node_modules/protobufjs/src/writer.js'(e, r) {
      V(), F(), (r.exports = c)
      var t = _s(),
        n,
        i = t.LongBits,
        s = t.base64,
        u = t.utf8
      function o(A, T, E) {
        ;(this.fn = A), (this.len = T), (this.next = void 0), (this.val = E)
      }
      function l() {}
      function a(A) {
        ;(this.head = A.head), (this.tail = A.tail), (this.len = A.len), (this.next = A.states)
      }
      function c() {
        ;(this.len = 0), (this.head = new o(l, 0, 0)), (this.tail = this.head), (this.states = null)
      }
      var f = function () {
        return t.Buffer
          ? function () {
              return (c.create = function () {
                return new n()
              })()
            }
          : function () {
              return new c()
            }
      }
      ;(c.create = f()),
        (c.alloc = function (T) {
          return new t.Array(T)
        }),
        t.Array !== Array && (c.alloc = t.pool(c.alloc, t.Array.prototype.subarray)),
        (c.prototype._push = function (T, E, k) {
          return (this.tail = this.tail.next = new o(T, E, k)), (this.len += E), this
        })
      function p(A, T, E) {
        T[E] = A & 255
      }
      function y(A, T, E) {
        for (; A > 127; ) (T[E++] = (A & 127) | 128), (A >>>= 7)
        T[E] = A
      }
      function d(A, T) {
        ;(this.len = A), (this.next = void 0), (this.val = T)
      }
      ;(d.prototype = Object.create(o.prototype)),
        (d.prototype.fn = y),
        (c.prototype.uint32 = function (T) {
          return (
            (this.len += (this.tail = this.tail.next =
              new d((T = T >>> 0) < 128 ? 1 : T < 16384 ? 2 : T < 2097152 ? 3 : T < 268435456 ? 4 : 5, T)).len),
            this
          )
        }),
        (c.prototype.int32 = function (T) {
          return T < 0 ? this._push(h, 10, i.fromNumber(T)) : this.uint32(T)
        }),
        (c.prototype.sint32 = function (T) {
          return this.uint32(((T << 1) ^ (T >> 31)) >>> 0)
        })
      function h(A, T, E) {
        for (; A.hi; ) (T[E++] = (A.lo & 127) | 128), (A.lo = ((A.lo >>> 7) | (A.hi << 25)) >>> 0), (A.hi >>>= 7)
        for (; A.lo > 127; ) (T[E++] = (A.lo & 127) | 128), (A.lo = A.lo >>> 7)
        T[E++] = A.lo
      }
      ;(c.prototype.uint64 = function (T) {
        var E = i.from(T)
        return this._push(h, E.length(), E)
      }),
        (c.prototype.int64 = c.prototype.uint64),
        (c.prototype.sint64 = function (T) {
          var E = i.from(T).zzEncode()
          return this._push(h, E.length(), E)
        }),
        (c.prototype.bool = function (T) {
          return this._push(p, 1, T ? 1 : 0)
        })
      function m(A, T, E) {
        ;(T[E] = A & 255), (T[E + 1] = (A >>> 8) & 255), (T[E + 2] = (A >>> 16) & 255), (T[E + 3] = A >>> 24)
      }
      ;(c.prototype.fixed32 = function (T) {
        return this._push(m, 4, T >>> 0)
      }),
        (c.prototype.sfixed32 = c.prototype.fixed32),
        (c.prototype.fixed64 = function (T) {
          var E = i.from(T)
          return this._push(m, 4, E.lo)._push(m, 4, E.hi)
        }),
        (c.prototype.sfixed64 = c.prototype.fixed64),
        (c.prototype.float = function (T) {
          return this._push(t.float.writeFloatLE, 4, T)
        }),
        (c.prototype.double = function (T) {
          return this._push(t.float.writeDoubleLE, 8, T)
        })
      var _ = t.Array.prototype.set
        ? function (T, E, k) {
            E.set(T, k)
          }
        : function (T, E, k) {
            for (var w = 0; w < T.length; ++w) E[k + w] = T[w]
          }
      ;(c.prototype.bytes = function (T) {
        var E = T.length >>> 0
        if (!E) return this._push(p, 1, 0)
        if (t.isString(T)) {
          var k = c.alloc((E = s.length(T)))
          s.decode(T, k, 0), (T = k)
        }
        return this.uint32(E)._push(_, E, T)
      }),
        (c.prototype.string = function (T) {
          var E = u.length(T)
          return E ? this.uint32(E)._push(u.write, E, T) : this._push(p, 1, 0)
        }),
        (c.prototype.fork = function () {
          return (this.states = new a(this)), (this.head = this.tail = new o(l, 0, 0)), (this.len = 0), this
        }),
        (c.prototype.reset = function () {
          return (
            this.states
              ? ((this.head = this.states.head),
                (this.tail = this.states.tail),
                (this.len = this.states.len),
                (this.states = this.states.next))
              : ((this.head = this.tail = new o(l, 0, 0)), (this.len = 0)),
            this
          )
        }),
        (c.prototype.ldelim = function () {
          var T = this.head,
            E = this.tail,
            k = this.len
          return this.reset().uint32(k), k && ((this.tail.next = T.next), (this.tail = E), (this.len += k)), this
        }),
        (c.prototype.finish = function () {
          for (var T = this.head.next, E = this.constructor.alloc(this.len), k = 0; T; )
            T.fn(T.val, E, k), (k += T.len), (T = T.next)
          return E
        }),
        (c._configure = function (A) {
          ;(n = A), (c.create = f()), n._configure()
        })
    }
  }),
  KP = te({
    'node_modules/protobufjs/src/writer_buffer.js'(e, r) {
      V(), F(), (r.exports = i)
      var t = X7()
      ;(i.prototype = Object.create(t.prototype)).constructor = i
      var n = _s()
      function i() {
        t.call(this)
      }
      ;(i._configure = function () {
        ;(i.alloc = n._Buffer_allocUnsafe),
          (i.writeBytesBuffer =
            n.Buffer && n.Buffer.prototype instanceof Uint8Array && n.Buffer.prototype.set.name === 'set'
              ? function (o, l, a) {
                  l.set(o, a)
                }
              : function (o, l, a) {
                  if (o.copy) o.copy(l, a, 0, o.length)
                  else for (var c = 0; c < o.length; ) l[a++] = o[c++]
                })
      }),
        (i.prototype.bytes = function (o) {
          n.isString(o) && (o = n._Buffer_from(o, 'base64'))
          var l = o.length >>> 0
          return this.uint32(l), l && this._push(i.writeBytesBuffer, l, o), this
        })
      function s(u, o, l) {
        u.length < 40 ? n.utf8.write(u, o, l) : o.utf8Write ? o.utf8Write(u, l) : o.write(u, l)
      }
      ;(i.prototype.string = function (o) {
        var l = n.Buffer.byteLength(o)
        return this.uint32(l), l && this._push(s, l, o), this
      }),
        i._configure()
    }
  }),
  Y7 = te({
    'node_modules/protobufjs/src/reader.js'(e, r) {
      V(), F(), (r.exports = o)
      var t = _s(),
        n,
        i = t.LongBits,
        s = t.utf8
      function u(y, d) {
        return RangeError('index out of range: ' + y.pos + ' + ' + (d || 1) + ' > ' + y.len)
      }
      function o(y) {
        ;(this.buf = y), (this.pos = 0), (this.len = y.length)
      }
      var l =
          typeof Uint8Array != 'undefined'
            ? function (d) {
                if (d instanceof Uint8Array || Array.isArray(d)) return new o(d)
                throw Error('illegal buffer')
              }
            : function (d) {
                if (Array.isArray(d)) return new o(d)
                throw Error('illegal buffer')
              },
        a = function () {
          return t.Buffer
            ? function (h) {
                return (o.create = function (_) {
                  return t.Buffer.isBuffer(_) ? new n(_) : l(_)
                })(h)
              }
            : l
        }
      ;(o.create = a()),
        (o.prototype._slice = t.Array.prototype.subarray || t.Array.prototype.slice),
        (o.prototype.uint32 = (function () {
          var d = 4294967295
          return function () {
            if (
              ((d = (this.buf[this.pos] & 127) >>> 0),
              this.buf[this.pos++] < 128 ||
                ((d = (d | ((this.buf[this.pos] & 127) << 7)) >>> 0), this.buf[this.pos++] < 128) ||
                ((d = (d | ((this.buf[this.pos] & 127) << 14)) >>> 0), this.buf[this.pos++] < 128) ||
                ((d = (d | ((this.buf[this.pos] & 127) << 21)) >>> 0), this.buf[this.pos++] < 128) ||
                ((d = (d | ((this.buf[this.pos] & 15) << 28)) >>> 0), this.buf[this.pos++] < 128))
            )
              return d
            if ((this.pos += 5) > this.len) throw ((this.pos = this.len), u(this, 10))
            return d
          }
        })()),
        (o.prototype.int32 = function () {
          return this.uint32() | 0
        }),
        (o.prototype.sint32 = function () {
          var d = this.uint32()
          return ((d >>> 1) ^ -(d & 1)) | 0
        })
      function c() {
        var y = new i(0, 0),
          d = 0
        if (this.len - this.pos > 4) {
          for (; d < 4; ++d)
            if (((y.lo = (y.lo | ((this.buf[this.pos] & 127) << (d * 7))) >>> 0), this.buf[this.pos++] < 128)) return y
          if (
            ((y.lo = (y.lo | ((this.buf[this.pos] & 127) << 28)) >>> 0),
            (y.hi = (y.hi | ((this.buf[this.pos] & 127) >> 4)) >>> 0),
            this.buf[this.pos++] < 128)
          )
            return y
          d = 0
        } else {
          for (; d < 3; ++d) {
            if (this.pos >= this.len) throw u(this)
            if (((y.lo = (y.lo | ((this.buf[this.pos] & 127) << (d * 7))) >>> 0), this.buf[this.pos++] < 128)) return y
          }
          return (y.lo = (y.lo | ((this.buf[this.pos++] & 127) << (d * 7))) >>> 0), y
        }
        if (this.len - this.pos > 4) {
          for (; d < 5; ++d)
            if (((y.hi = (y.hi | ((this.buf[this.pos] & 127) << (d * 7 + 3))) >>> 0), this.buf[this.pos++] < 128))
              return y
        } else
          for (; d < 5; ++d) {
            if (this.pos >= this.len) throw u(this)
            if (((y.hi = (y.hi | ((this.buf[this.pos] & 127) << (d * 7 + 3))) >>> 0), this.buf[this.pos++] < 128))
              return y
          }
        throw Error('invalid varint encoding')
      }
      o.prototype.bool = function () {
        return this.uint32() !== 0
      }
      function f(y, d) {
        return (y[d - 4] | (y[d - 3] << 8) | (y[d - 2] << 16) | (y[d - 1] << 24)) >>> 0
      }
      ;(o.prototype.fixed32 = function () {
        if (this.pos + 4 > this.len) throw u(this, 4)
        return f(this.buf, (this.pos += 4))
      }),
        (o.prototype.sfixed32 = function () {
          if (this.pos + 4 > this.len) throw u(this, 4)
          return f(this.buf, (this.pos += 4)) | 0
        })
      function p() {
        if (this.pos + 8 > this.len) throw u(this, 8)
        return new i(f(this.buf, (this.pos += 4)), f(this.buf, (this.pos += 4)))
      }
      ;(o.prototype.float = function () {
        if (this.pos + 4 > this.len) throw u(this, 4)
        var d = t.float.readFloatLE(this.buf, this.pos)
        return (this.pos += 4), d
      }),
        (o.prototype.double = function () {
          if (this.pos + 8 > this.len) throw u(this, 4)
          var d = t.float.readDoubleLE(this.buf, this.pos)
          return (this.pos += 8), d
        }),
        (o.prototype.bytes = function () {
          var d = this.uint32(),
            h = this.pos,
            m = this.pos + d
          if (m > this.len) throw u(this, d)
          return (
            (this.pos += d),
            Array.isArray(this.buf)
              ? this.buf.slice(h, m)
              : h === m
              ? new this.buf.constructor(0)
              : this._slice.call(this.buf, h, m)
          )
        }),
        (o.prototype.string = function () {
          var d = this.bytes()
          return s.read(d, 0, d.length)
        }),
        (o.prototype.skip = function (d) {
          if (typeof d == 'number') {
            if (this.pos + d > this.len) throw u(this, d)
            this.pos += d
          } else
            do if (this.pos >= this.len) throw u(this)
            while (this.buf[this.pos++] & 128)
          return this
        }),
        (o.prototype.skipType = function (y) {
          switch (y) {
            case 0:
              this.skip()
              break
            case 1:
              this.skip(8)
              break
            case 2:
              this.skip(this.uint32())
              break
            case 3:
              for (; (y = this.uint32() & 7) != 4; ) this.skipType(y)
              break
            case 5:
              this.skip(4)
              break
            default:
              throw Error('invalid wire type ' + y + ' at offset ' + this.pos)
          }
          return this
        }),
        (o._configure = function (y) {
          ;(n = y), (o.create = a()), n._configure()
          var d = t.Long ? 'toLong' : 'toNumber'
          t.merge(o.prototype, {
            int64: function () {
              return c.call(this)[d](!1)
            },
            uint64: function () {
              return c.call(this)[d](!0)
            },
            sint64: function () {
              return c.call(this).zzDecode()[d](!1)
            },
            fixed64: function () {
              return p.call(this)[d](!0)
            },
            sfixed64: function () {
              return p.call(this)[d](!1)
            }
          })
        })
    }
  }),
  FP = te({
    'node_modules/protobufjs/src/reader_buffer.js'(e, r) {
      V(), F(), (r.exports = i)
      var t = Y7()
      ;(i.prototype = Object.create(t.prototype)).constructor = i
      var n = _s()
      function i(s) {
        t.call(this, s)
      }
      ;(i._configure = function () {
        n.Buffer && (i.prototype._slice = n.Buffer.prototype.slice)
      }),
        (i.prototype.string = function () {
          var u = this.uint32()
          return this.buf.utf8Slice
            ? this.buf.utf8Slice(this.pos, (this.pos = Math.min(this.pos + u, this.len)))
            : this.buf.toString('utf-8', this.pos, (this.pos = Math.min(this.pos + u, this.len)))
        }),
        i._configure()
    }
  }),
  VP = te({
    'node_modules/protobufjs/src/rpc/service.js'(e, r) {
      V(), F(), (r.exports = n)
      var t = _s()
      ;(n.prototype = Object.create(t.EventEmitter.prototype)).constructor = n
      function n(i, s, u) {
        if (typeof i != 'function') throw TypeError('rpcImpl must be a function')
        t.EventEmitter.call(this),
          (this.rpcImpl = i),
          (this.requestDelimited = Boolean(s)),
          (this.responseDelimited = Boolean(u))
      }
      ;(n.prototype.rpcCall = function i(s, u, o, l, a) {
        if (!l) throw TypeError('request must be specified')
        var c = this
        if (!a) return t.asPromise(i, c, s, u, o, l)
        if (!c.rpcImpl) {
          setTimeout(function () {
            a(Error('already ended'))
          }, 0)
          return
        }
        try {
          return c.rpcImpl(s, u[c.requestDelimited ? 'encodeDelimited' : 'encode'](l).finish(), function (p, y) {
            if (p) return c.emit('error', p, s), a(p)
            if (y === null) {
              c.end(!0)
              return
            }
            if (!(y instanceof o))
              try {
                y = o[c.responseDelimited ? 'decodeDelimited' : 'decode'](y)
              } catch (d) {
                return c.emit('error', d, s), a(d)
              }
            return c.emit('data', y, s), a(null, y)
          })
        } catch (f) {
          c.emit('error', f, s),
            setTimeout(function () {
              a(f)
            }, 0)
          return
        }
      }),
        (n.prototype.end = function (s) {
          return (
            this.rpcImpl && (s || this.rpcImpl(null, null, null), (this.rpcImpl = null), this.emit('end').off()), this
          )
        })
    }
  }),
  HP = te({
    'node_modules/protobufjs/src/rpc.js'(e) {
      V(), F()
      var r = e
      r.Service = VP()
    }
  }),
  $P = te({
    'node_modules/protobufjs/src/roots.js'(e, r) {
      V(), F(), (r.exports = {})
    }
  }),
  GP = te({
    'node_modules/protobufjs/src/index-minimal.js'(e) {
      V(), F()
      var r = e
      ;(r.build = 'minimal'),
        (r.Writer = X7()),
        (r.BufferWriter = KP()),
        (r.Reader = Y7()),
        (r.BufferReader = FP()),
        (r.util = _s()),
        (r.rpc = HP()),
        (r.roots = $P()),
        (r.configure = t)
      function t() {
        r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader)
      }
      t()
    }
  }),
  oi = te({
    'node_modules/protobufjs/minimal.js'(e, r) {
      V(), F(), (r.exports = GP())
    }
  }),
  Yp = te({
    'node_modules/libp2p-crypto/src/keys/keys.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-crypto-keys'] || (t.roots['libp2p-crypto-keys'] = {})
      ;(u.KeyType = (function () {
        var o = {},
          l = Object.create(o)
        return (l[(o[0] = 'RSA')] = 0), (l[(o[1] = 'Ed25519')] = 1), (l[(o[2] = 'Secp256k1')] = 2), l
      })()),
        (u.PublicKey = (function () {
          function o(l) {
            if (l) for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
          }
          return (
            (o.prototype.Type = 0),
            (o.prototype.Data = s.newBuffer([])),
            (o.encode = function (a, c) {
              return c || (c = i.create()), c.uint32(8).int32(a.Type), c.uint32(18).bytes(a.Data), c
            }),
            (o.decode = function (a, c) {
              a instanceof n || (a = n.create(a))
              for (var f = c === void 0 ? a.len : a.pos + c, p = new u.PublicKey(); a.pos < f; ) {
                var y = a.uint32()
                switch (y >>> 3) {
                  case 1:
                    p.Type = a.int32()
                    break
                  case 2:
                    p.Data = a.bytes()
                    break
                  default:
                    a.skipType(y & 7)
                    break
                }
              }
              if (!p.hasOwnProperty('Type')) throw s.ProtocolError("missing required 'Type'", { instance: p })
              if (!p.hasOwnProperty('Data')) throw s.ProtocolError("missing required 'Data'", { instance: p })
              return p
            }),
            (o.fromObject = function (a) {
              if (a instanceof u.PublicKey) return a
              var c = new u.PublicKey()
              switch (a.Type) {
                case 'RSA':
                case 0:
                  c.Type = 0
                  break
                case 'Ed25519':
                case 1:
                  c.Type = 1
                  break
                case 'Secp256k1':
                case 2:
                  c.Type = 2
                  break
              }
              return (
                a.Data != null &&
                  (typeof a.Data == 'string'
                    ? s.base64.decode(a.Data, (c.Data = s.newBuffer(s.base64.length(a.Data))), 0)
                    : a.Data.length && (c.Data = a.Data)),
                c
              )
            }),
            (o.toObject = function (a, c) {
              c || (c = {})
              var f = {}
              return (
                c.defaults &&
                  ((f.Type = c.enums === String ? 'RSA' : 0),
                  c.bytes === String
                    ? (f.Data = '')
                    : ((f.Data = []), c.bytes !== Array && (f.Data = s.newBuffer(f.Data)))),
                a.Type != null &&
                  a.hasOwnProperty('Type') &&
                  (f.Type = c.enums === String ? u.KeyType[a.Type] : a.Type),
                a.Data != null &&
                  a.hasOwnProperty('Data') &&
                  (f.Data =
                    c.bytes === String
                      ? s.base64.encode(a.Data, 0, a.Data.length)
                      : c.bytes === Array
                      ? Array.prototype.slice.call(a.Data)
                      : a.Data),
                f
              )
            }),
            (o.prototype.toJSON = function () {
              return this.constructor.toObject(this, t.util.toJSONOptions)
            }),
            o
          )
        })()),
        (u.PrivateKey = (function () {
          function o(l) {
            if (l) for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
          }
          return (
            (o.prototype.Type = 0),
            (o.prototype.Data = s.newBuffer([])),
            (o.encode = function (a, c) {
              return c || (c = i.create()), c.uint32(8).int32(a.Type), c.uint32(18).bytes(a.Data), c
            }),
            (o.decode = function (a, c) {
              a instanceof n || (a = n.create(a))
              for (var f = c === void 0 ? a.len : a.pos + c, p = new u.PrivateKey(); a.pos < f; ) {
                var y = a.uint32()
                switch (y >>> 3) {
                  case 1:
                    p.Type = a.int32()
                    break
                  case 2:
                    p.Data = a.bytes()
                    break
                  default:
                    a.skipType(y & 7)
                    break
                }
              }
              if (!p.hasOwnProperty('Type')) throw s.ProtocolError("missing required 'Type'", { instance: p })
              if (!p.hasOwnProperty('Data')) throw s.ProtocolError("missing required 'Data'", { instance: p })
              return p
            }),
            (o.fromObject = function (a) {
              if (a instanceof u.PrivateKey) return a
              var c = new u.PrivateKey()
              switch (a.Type) {
                case 'RSA':
                case 0:
                  c.Type = 0
                  break
                case 'Ed25519':
                case 1:
                  c.Type = 1
                  break
                case 'Secp256k1':
                case 2:
                  c.Type = 2
                  break
              }
              return (
                a.Data != null &&
                  (typeof a.Data == 'string'
                    ? s.base64.decode(a.Data, (c.Data = s.newBuffer(s.base64.length(a.Data))), 0)
                    : a.Data.length && (c.Data = a.Data)),
                c
              )
            }),
            (o.toObject = function (a, c) {
              c || (c = {})
              var f = {}
              return (
                c.defaults &&
                  ((f.Type = c.enums === String ? 'RSA' : 0),
                  c.bytes === String
                    ? (f.Data = '')
                    : ((f.Data = []), c.bytes !== Array && (f.Data = s.newBuffer(f.Data)))),
                a.Type != null &&
                  a.hasOwnProperty('Type') &&
                  (f.Type = c.enums === String ? u.KeyType[a.Type] : a.Type),
                a.Data != null &&
                  a.hasOwnProperty('Data') &&
                  (f.Data =
                    c.bytes === String
                      ? s.base64.encode(a.Data, 0, a.Data.length)
                      : c.bytes === Array
                      ? Array.prototype.slice.call(a.Data)
                      : a.Data),
                f
              )
            }),
            (o.prototype.toJSON = function () {
              return this.constructor.toObject(this, t.util.toJSONOptions)
            }),
            o
          )
        })()),
        (r.exports = u)
    }
  }),
  yt = te({
    'node_modules/node-forge/lib/forge.js'(e, r) {
      V(), F(), (r.exports = { options: { usePureJavaScript: !1 } })
    }
  }),
  WP = te({
    'node_modules/node-forge/lib/baseN.js'(e, r) {
      V(), F()
      var t = {}
      r.exports = t
      var n = {}
      ;(t.encode = function (s, u, o) {
        if (typeof u != 'string') throw new TypeError('"alphabet" must be a string.')
        if (o !== void 0 && typeof o != 'number') throw new TypeError('"maxline" must be a number.')
        var l = ''
        if (!(s instanceof Uint8Array)) l = i(s, u)
        else {
          var a = 0,
            c = u.length,
            f = u.charAt(0),
            p = [0]
          for (a = 0; a < s.length; ++a) {
            for (var y = 0, d = s[a]; y < p.length; ++y) (d += p[y] << 8), (p[y] = d % c), (d = (d / c) | 0)
            for (; d > 0; ) p.push(d % c), (d = (d / c) | 0)
          }
          for (a = 0; s[a] === 0 && a < s.length - 1; ++a) l += f
          for (a = p.length - 1; a >= 0; --a) l += u[p[a]]
        }
        if (o) {
          var h = new RegExp('.{1,' + o + '}', 'g')
          l = l.match(h).join(`\r
`)
        }
        return l
      }),
        (t.decode = function (s, u) {
          if (typeof s != 'string') throw new TypeError('"input" must be a string.')
          if (typeof u != 'string') throw new TypeError('"alphabet" must be a string.')
          var o = n[u]
          if (!o) {
            o = n[u] = []
            for (var l = 0; l < u.length; ++l) o[u.charCodeAt(l)] = l
          }
          s = s.replace(/\s/g, '')
          for (var a = u.length, c = u.charAt(0), f = [0], l = 0; l < s.length; l++) {
            var p = o[s.charCodeAt(l)]
            if (p === void 0) return
            for (var y = 0, d = p; y < f.length; ++y) (d += f[y] * a), (f[y] = d & 255), (d >>= 8)
            for (; d > 0; ) f.push(d & 255), (d >>= 8)
          }
          for (var h = 0; s[h] === c && h < s.length - 1; ++h) f.push(0)
          return typeof Ve.Buffer != 'undefined' ? Ve.Buffer.from(f.reverse()) : new Uint8Array(f.reverse())
        })
      function i(s, u) {
        var o = 0,
          l = u.length,
          a = u.charAt(0),
          c = [0]
        for (o = 0; o < s.length(); ++o) {
          for (var f = 0, p = s.at(o); f < c.length; ++f) (p += c[f] << 8), (c[f] = p % l), (p = (p / l) | 0)
          for (; p > 0; ) c.push(p % l), (p = (p / l) | 0)
        }
        var y = ''
        for (o = 0; s.at(o) === 0 && o < s.length() - 1; ++o) y += a
        for (o = c.length - 1; o >= 0; --o) y += u[c[o]]
        return y
      }
    }
  }),
  zt = te({
    'node_modules/node-forge/lib/util.js'(e, r) {
      V(), F()
      var t = yt(),
        n = WP(),
        i = (r.exports = t.util = t.util || {})
      ;(function () {
        if (typeof lt != 'undefined' && lt.nextTick && !lt.browser) {
          ;(i.nextTick = lt.nextTick),
            typeof setImmediate == 'function' ? (i.setImmediate = setImmediate) : (i.setImmediate = i.nextTick)
          return
        }
        if (typeof setImmediate == 'function') {
          ;(i.setImmediate = function () {
            return setImmediate.apply(void 0, arguments)
          }),
            (i.nextTick = function (G) {
              return setImmediate(G)
            })
          return
        }
        if (
          ((i.setImmediate = function (G) {
            setTimeout(G, 0)
          }),
          typeof window != 'undefined' && typeof window.postMessage == 'function')
        ) {
          let G = function (O) {
            if (O.source === window && O.data === k) {
              O.stopPropagation()
              var x = w.slice()
              ;(w.length = 0),
                x.forEach(function (L) {
                  L()
                })
            }
          }
          var E = G,
            k = 'forge.setImmediate',
            w = []
          ;(i.setImmediate = function (O) {
            w.push(O), w.length === 1 && window.postMessage(k, '*')
          }),
            window.addEventListener('message', G, !0)
        }
        if (typeof MutationObserver != 'undefined') {
          var v = Date.now(),
            I = !0,
            M = document.createElement('div'),
            w = []
          new MutationObserver(function () {
            var O = w.slice()
            ;(w.length = 0),
              O.forEach(function (x) {
                x()
              })
          }).observe(M, { attributes: !0 })
          var q = i.setImmediate
          i.setImmediate = function (O) {
            Date.now() - v > 15
              ? ((v = Date.now()), q(O))
              : (w.push(O), w.length === 1 && M.setAttribute('a', (I = !I)))
          }
        }
        i.nextTick = i.setImmediate
      })(),
        (i.isNodejs = typeof lt != 'undefined' && lt.versions && lt.versions.node),
        (i.globalScope = (function () {
          return i.isNodejs ? globalThis : typeof self == 'undefined' ? window : self
        })()),
        (i.isArray =
          Array.isArray ||
          function (E) {
            return Object.prototype.toString.call(E) === '[object Array]'
          }),
        (i.isArrayBuffer = function (E) {
          return typeof ArrayBuffer != 'undefined' && E instanceof ArrayBuffer
        }),
        (i.isArrayBufferView = function (E) {
          return E && i.isArrayBuffer(E.buffer) && E.byteLength !== void 0
        })
      function s(E) {
        if (!(E === 8 || E === 16 || E === 24 || E === 32))
          throw new Error('Only 8, 16, 24, or 32 bits supported: ' + E)
      }
      i.ByteBuffer = u
      function u(E) {
        if (((this.data = ''), (this.read = 0), typeof E == 'string')) this.data = E
        else if (i.isArrayBuffer(E) || i.isArrayBufferView(E))
          if (typeof Ve.Buffer != 'undefined' && E instanceof Ve.Buffer) this.data = E.toString('binary')
          else {
            var k = new Uint8Array(E)
            try {
              this.data = String.fromCharCode.apply(null, k)
            } catch (v) {
              for (var w = 0; w < k.length; ++w) this.putByte(k[w])
            }
          }
        else
          (E instanceof u || (typeof E == 'object' && typeof E.data == 'string' && typeof E.read == 'number')) &&
            ((this.data = E.data), (this.read = E.read))
        this._constructedStringLength = 0
      }
      i.ByteStringBuffer = u
      var o = 4096
      ;(i.ByteStringBuffer.prototype._optimizeConstructedString = function (E) {
        ;(this._constructedStringLength += E),
          this._constructedStringLength > o && (this.data.substr(0, 1), (this._constructedStringLength = 0))
      }),
        (i.ByteStringBuffer.prototype.length = function () {
          return this.data.length - this.read
        }),
        (i.ByteStringBuffer.prototype.isEmpty = function () {
          return this.length() <= 0
        }),
        (i.ByteStringBuffer.prototype.putByte = function (E) {
          return this.putBytes(String.fromCharCode(E))
        }),
        (i.ByteStringBuffer.prototype.fillWithByte = function (E, k) {
          E = String.fromCharCode(E)
          for (var w = this.data; k > 0; ) k & 1 && (w += E), (k >>>= 1), k > 0 && (E += E)
          return (this.data = w), this._optimizeConstructedString(k), this
        }),
        (i.ByteStringBuffer.prototype.putBytes = function (E) {
          return (this.data += E), this._optimizeConstructedString(E.length), this
        }),
        (i.ByteStringBuffer.prototype.putString = function (E) {
          return this.putBytes(i.encodeUtf8(E))
        }),
        (i.ByteStringBuffer.prototype.putInt16 = function (E) {
          return this.putBytes(String.fromCharCode((E >> 8) & 255) + String.fromCharCode(E & 255))
        }),
        (i.ByteStringBuffer.prototype.putInt24 = function (E) {
          return this.putBytes(
            String.fromCharCode((E >> 16) & 255) + String.fromCharCode((E >> 8) & 255) + String.fromCharCode(E & 255)
          )
        }),
        (i.ByteStringBuffer.prototype.putInt32 = function (E) {
          return this.putBytes(
            String.fromCharCode((E >> 24) & 255) +
              String.fromCharCode((E >> 16) & 255) +
              String.fromCharCode((E >> 8) & 255) +
              String.fromCharCode(E & 255)
          )
        }),
        (i.ByteStringBuffer.prototype.putInt16Le = function (E) {
          return this.putBytes(String.fromCharCode(E & 255) + String.fromCharCode((E >> 8) & 255))
        }),
        (i.ByteStringBuffer.prototype.putInt24Le = function (E) {
          return this.putBytes(
            String.fromCharCode(E & 255) + String.fromCharCode((E >> 8) & 255) + String.fromCharCode((E >> 16) & 255)
          )
        }),
        (i.ByteStringBuffer.prototype.putInt32Le = function (E) {
          return this.putBytes(
            String.fromCharCode(E & 255) +
              String.fromCharCode((E >> 8) & 255) +
              String.fromCharCode((E >> 16) & 255) +
              String.fromCharCode((E >> 24) & 255)
          )
        }),
        (i.ByteStringBuffer.prototype.putInt = function (E, k) {
          s(k)
          var w = ''
          do (k -= 8), (w += String.fromCharCode((E >> k) & 255))
          while (k > 0)
          return this.putBytes(w)
        }),
        (i.ByteStringBuffer.prototype.putSignedInt = function (E, k) {
          return E < 0 && (E += 2 << (k - 1)), this.putInt(E, k)
        }),
        (i.ByteStringBuffer.prototype.putBuffer = function (E) {
          return this.putBytes(E.getBytes())
        }),
        (i.ByteStringBuffer.prototype.getByte = function () {
          return this.data.charCodeAt(this.read++)
        }),
        (i.ByteStringBuffer.prototype.getInt16 = function () {
          var E = (this.data.charCodeAt(this.read) << 8) ^ this.data.charCodeAt(this.read + 1)
          return (this.read += 2), E
        }),
        (i.ByteStringBuffer.prototype.getInt24 = function () {
          var E =
            (this.data.charCodeAt(this.read) << 16) ^
            (this.data.charCodeAt(this.read + 1) << 8) ^
            this.data.charCodeAt(this.read + 2)
          return (this.read += 3), E
        }),
        (i.ByteStringBuffer.prototype.getInt32 = function () {
          var E =
            (this.data.charCodeAt(this.read) << 24) ^
            (this.data.charCodeAt(this.read + 1) << 16) ^
            (this.data.charCodeAt(this.read + 2) << 8) ^
            this.data.charCodeAt(this.read + 3)
          return (this.read += 4), E
        }),
        (i.ByteStringBuffer.prototype.getInt16Le = function () {
          var E = this.data.charCodeAt(this.read) ^ (this.data.charCodeAt(this.read + 1) << 8)
          return (this.read += 2), E
        }),
        (i.ByteStringBuffer.prototype.getInt24Le = function () {
          var E =
            this.data.charCodeAt(this.read) ^
            (this.data.charCodeAt(this.read + 1) << 8) ^
            (this.data.charCodeAt(this.read + 2) << 16)
          return (this.read += 3), E
        }),
        (i.ByteStringBuffer.prototype.getInt32Le = function () {
          var E =
            this.data.charCodeAt(this.read) ^
            (this.data.charCodeAt(this.read + 1) << 8) ^
            (this.data.charCodeAt(this.read + 2) << 16) ^
            (this.data.charCodeAt(this.read + 3) << 24)
          return (this.read += 4), E
        }),
        (i.ByteStringBuffer.prototype.getInt = function (E) {
          s(E)
          var k = 0
          do (k = (k << 8) + this.data.charCodeAt(this.read++)), (E -= 8)
          while (E > 0)
          return k
        }),
        (i.ByteStringBuffer.prototype.getSignedInt = function (E) {
          var k = this.getInt(E),
            w = 2 << (E - 2)
          return k >= w && (k -= w << 1), k
        }),
        (i.ByteStringBuffer.prototype.getBytes = function (E) {
          var k
          return (
            E
              ? ((E = Math.min(this.length(), E)), (k = this.data.slice(this.read, this.read + E)), (this.read += E))
              : E === 0
              ? (k = '')
              : ((k = this.read === 0 ? this.data : this.data.slice(this.read)), this.clear()),
            k
          )
        }),
        (i.ByteStringBuffer.prototype.bytes = function (E) {
          return typeof E == 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + E)
        }),
        (i.ByteStringBuffer.prototype.at = function (E) {
          return this.data.charCodeAt(this.read + E)
        }),
        (i.ByteStringBuffer.prototype.setAt = function (E, k) {
          return (
            (this.data =
              this.data.substr(0, this.read + E) + String.fromCharCode(k) + this.data.substr(this.read + E + 1)),
            this
          )
        }),
        (i.ByteStringBuffer.prototype.last = function () {
          return this.data.charCodeAt(this.data.length - 1)
        }),
        (i.ByteStringBuffer.prototype.copy = function () {
          var E = i.createBuffer(this.data)
          return (E.read = this.read), E
        }),
        (i.ByteStringBuffer.prototype.compact = function () {
          return this.read > 0 && ((this.data = this.data.slice(this.read)), (this.read = 0)), this
        }),
        (i.ByteStringBuffer.prototype.clear = function () {
          return (this.data = ''), (this.read = 0), this
        }),
        (i.ByteStringBuffer.prototype.truncate = function (E) {
          var k = Math.max(0, this.length() - E)
          return (this.data = this.data.substr(this.read, k)), (this.read = 0), this
        }),
        (i.ByteStringBuffer.prototype.toHex = function () {
          for (var E = '', k = this.read; k < this.data.length; ++k) {
            var w = this.data.charCodeAt(k)
            w < 16 && (E += '0'), (E += w.toString(16))
          }
          return E
        }),
        (i.ByteStringBuffer.prototype.toString = function () {
          return i.decodeUtf8(this.bytes())
        })
      function l(E, k) {
        ;(k = k || {}), (this.read = k.readOffset || 0), (this.growSize = k.growSize || 1024)
        var w = i.isArrayBuffer(E),
          v = i.isArrayBufferView(E)
        if (w || v) {
          w ? (this.data = new DataView(E)) : (this.data = new DataView(E.buffer, E.byteOffset, E.byteLength)),
            (this.write = 'writeOffset' in k ? k.writeOffset : this.data.byteLength)
          return
        }
        ;(this.data = new DataView(new ArrayBuffer(0))),
          (this.write = 0),
          E != null && this.putBytes(E),
          'writeOffset' in k && (this.write = k.writeOffset)
      }
      ;(i.DataBuffer = l),
        (i.DataBuffer.prototype.length = function () {
          return this.write - this.read
        }),
        (i.DataBuffer.prototype.isEmpty = function () {
          return this.length() <= 0
        }),
        (i.DataBuffer.prototype.accommodate = function (E, k) {
          if (this.length() >= E) return this
          k = Math.max(k || this.growSize, E)
          var w = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength),
            v = new Uint8Array(this.length() + k)
          return v.set(w), (this.data = new DataView(v.buffer)), this
        }),
        (i.DataBuffer.prototype.putByte = function (E) {
          return this.accommodate(1), this.data.setUint8(this.write++, E), this
        }),
        (i.DataBuffer.prototype.fillWithByte = function (E, k) {
          this.accommodate(k)
          for (var w = 0; w < k; ++w) this.data.setUint8(E)
          return this
        }),
        (i.DataBuffer.prototype.putBytes = function (E, k) {
          if (i.isArrayBufferView(E)) {
            var w = new Uint8Array(E.buffer, E.byteOffset, E.byteLength),
              v = w.byteLength - w.byteOffset
            this.accommodate(v)
            var I = new Uint8Array(this.data.buffer, this.write)
            return I.set(w), (this.write += v), this
          }
          if (i.isArrayBuffer(E)) {
            var w = new Uint8Array(E)
            this.accommodate(w.byteLength)
            var I = new Uint8Array(this.data.buffer)
            return I.set(w, this.write), (this.write += w.byteLength), this
          }
          if (
            E instanceof i.DataBuffer ||
            (typeof E == 'object' &&
              typeof E.read == 'number' &&
              typeof E.write == 'number' &&
              i.isArrayBufferView(E.data))
          ) {
            var w = new Uint8Array(E.data.byteLength, E.read, E.length())
            this.accommodate(w.byteLength)
            var I = new Uint8Array(E.data.byteLength, this.write)
            return I.set(w), (this.write += w.byteLength), this
          }
          if (
            (E instanceof i.ByteStringBuffer && ((E = E.data), (k = 'binary')),
            (k = k || 'binary'),
            typeof E == 'string')
          ) {
            var M
            if (k === 'hex')
              return (
                this.accommodate(Math.ceil(E.length / 2)),
                (M = new Uint8Array(this.data.buffer, this.write)),
                (this.write += i.binary.hex.decode(E, M, this.write)),
                this
              )
            if (k === 'base64')
              return (
                this.accommodate(Math.ceil(E.length / 4) * 3),
                (M = new Uint8Array(this.data.buffer, this.write)),
                (this.write += i.binary.base64.decode(E, M, this.write)),
                this
              )
            if ((k === 'utf8' && ((E = i.encodeUtf8(E)), (k = 'binary')), k === 'binary' || k === 'raw'))
              return (
                this.accommodate(E.length),
                (M = new Uint8Array(this.data.buffer, this.write)),
                (this.write += i.binary.raw.decode(M)),
                this
              )
            if (k === 'utf16')
              return (
                this.accommodate(E.length * 2),
                (M = new Uint16Array(this.data.buffer, this.write)),
                (this.write += i.text.utf16.encode(M)),
                this
              )
            throw new Error('Invalid encoding: ' + k)
          }
          throw Error('Invalid parameter: ' + E)
        }),
        (i.DataBuffer.prototype.putBuffer = function (E) {
          return this.putBytes(E), E.clear(), this
        }),
        (i.DataBuffer.prototype.putString = function (E) {
          return this.putBytes(E, 'utf16')
        }),
        (i.DataBuffer.prototype.putInt16 = function (E) {
          return this.accommodate(2), this.data.setInt16(this.write, E), (this.write += 2), this
        }),
        (i.DataBuffer.prototype.putInt24 = function (E) {
          return (
            this.accommodate(3),
            this.data.setInt16(this.write, (E >> 8) & 65535),
            this.data.setInt8(this.write, (E >> 16) & 255),
            (this.write += 3),
            this
          )
        }),
        (i.DataBuffer.prototype.putInt32 = function (E) {
          return this.accommodate(4), this.data.setInt32(this.write, E), (this.write += 4), this
        }),
        (i.DataBuffer.prototype.putInt16Le = function (E) {
          return this.accommodate(2), this.data.setInt16(this.write, E, !0), (this.write += 2), this
        }),
        (i.DataBuffer.prototype.putInt24Le = function (E) {
          return (
            this.accommodate(3),
            this.data.setInt8(this.write, (E >> 16) & 255),
            this.data.setInt16(this.write, (E >> 8) & 65535, !0),
            (this.write += 3),
            this
          )
        }),
        (i.DataBuffer.prototype.putInt32Le = function (E) {
          return this.accommodate(4), this.data.setInt32(this.write, E, !0), (this.write += 4), this
        }),
        (i.DataBuffer.prototype.putInt = function (E, k) {
          s(k), this.accommodate(k / 8)
          do (k -= 8), this.data.setInt8(this.write++, (E >> k) & 255)
          while (k > 0)
          return this
        }),
        (i.DataBuffer.prototype.putSignedInt = function (E, k) {
          return s(k), this.accommodate(k / 8), E < 0 && (E += 2 << (k - 1)), this.putInt(E, k)
        }),
        (i.DataBuffer.prototype.getByte = function () {
          return this.data.getInt8(this.read++)
        }),
        (i.DataBuffer.prototype.getInt16 = function () {
          var E = this.data.getInt16(this.read)
          return (this.read += 2), E
        }),
        (i.DataBuffer.prototype.getInt24 = function () {
          var E = (this.data.getInt16(this.read) << 8) ^ this.data.getInt8(this.read + 2)
          return (this.read += 3), E
        }),
        (i.DataBuffer.prototype.getInt32 = function () {
          var E = this.data.getInt32(this.read)
          return (this.read += 4), E
        }),
        (i.DataBuffer.prototype.getInt16Le = function () {
          var E = this.data.getInt16(this.read, !0)
          return (this.read += 2), E
        }),
        (i.DataBuffer.prototype.getInt24Le = function () {
          var E = this.data.getInt8(this.read) ^ (this.data.getInt16(this.read + 1, !0) << 8)
          return (this.read += 3), E
        }),
        (i.DataBuffer.prototype.getInt32Le = function () {
          var E = this.data.getInt32(this.read, !0)
          return (this.read += 4), E
        }),
        (i.DataBuffer.prototype.getInt = function (E) {
          s(E)
          var k = 0
          do (k = (k << 8) + this.data.getInt8(this.read++)), (E -= 8)
          while (E > 0)
          return k
        }),
        (i.DataBuffer.prototype.getSignedInt = function (E) {
          var k = this.getInt(E),
            w = 2 << (E - 2)
          return k >= w && (k -= w << 1), k
        }),
        (i.DataBuffer.prototype.getBytes = function (E) {
          var k
          return (
            E
              ? ((E = Math.min(this.length(), E)), (k = this.data.slice(this.read, this.read + E)), (this.read += E))
              : E === 0
              ? (k = '')
              : ((k = this.read === 0 ? this.data : this.data.slice(this.read)), this.clear()),
            k
          )
        }),
        (i.DataBuffer.prototype.bytes = function (E) {
          return typeof E == 'undefined' ? this.data.slice(this.read) : this.data.slice(this.read, this.read + E)
        }),
        (i.DataBuffer.prototype.at = function (E) {
          return this.data.getUint8(this.read + E)
        }),
        (i.DataBuffer.prototype.setAt = function (E, k) {
          return this.data.setUint8(E, k), this
        }),
        (i.DataBuffer.prototype.last = function () {
          return this.data.getUint8(this.write - 1)
        }),
        (i.DataBuffer.prototype.copy = function () {
          return new i.DataBuffer(this)
        }),
        (i.DataBuffer.prototype.compact = function () {
          if (this.read > 0) {
            var E = new Uint8Array(this.data.buffer, this.read),
              k = new Uint8Array(E.byteLength)
            k.set(E), (this.data = new DataView(k)), (this.write -= this.read), (this.read = 0)
          }
          return this
        }),
        (i.DataBuffer.prototype.clear = function () {
          return (this.data = new DataView(new ArrayBuffer(0))), (this.read = this.write = 0), this
        }),
        (i.DataBuffer.prototype.truncate = function (E) {
          return (this.write = Math.max(0, this.length() - E)), (this.read = Math.min(this.read, this.write)), this
        }),
        (i.DataBuffer.prototype.toHex = function () {
          for (var E = '', k = this.read; k < this.data.byteLength; ++k) {
            var w = this.data.getUint8(k)
            w < 16 && (E += '0'), (E += w.toString(16))
          }
          return E
        }),
        (i.DataBuffer.prototype.toString = function (E) {
          var k = new Uint8Array(this.data, this.read, this.length())
          if (((E = E || 'utf8'), E === 'binary' || E === 'raw')) return i.binary.raw.encode(k)
          if (E === 'hex') return i.binary.hex.encode(k)
          if (E === 'base64') return i.binary.base64.encode(k)
          if (E === 'utf8') return i.text.utf8.decode(k)
          if (E === 'utf16') return i.text.utf16.decode(k)
          throw new Error('Invalid encoding: ' + E)
        }),
        (i.createBuffer = function (E, k) {
          return (k = k || 'raw'), E !== void 0 && k === 'utf8' && (E = i.encodeUtf8(E)), new i.ByteBuffer(E)
        }),
        (i.fillString = function (E, k) {
          for (var w = ''; k > 0; ) k & 1 && (w += E), (k >>>= 1), k > 0 && (E += E)
          return w
        }),
        (i.xorBytes = function (E, k, w) {
          for (var v = '', I = '', M = '', q = 0, G = 0; w > 0; --w, ++q)
            (I = E.charCodeAt(q) ^ k.charCodeAt(q)),
              G >= 10 && ((v += M), (M = ''), (G = 0)),
              (M += String.fromCharCode(I)),
              ++G
          return (v += M), v
        }),
        (i.hexToBytes = function (E) {
          var k = '',
            w = 0
          for (E.length & !0 && ((w = 1), (k += String.fromCharCode(parseInt(E[0], 16)))); w < E.length; w += 2)
            k += String.fromCharCode(parseInt(E.substr(w, 2), 16))
          return k
        }),
        (i.bytesToHex = function (E) {
          return i.createBuffer(E).toHex()
        }),
        (i.int32ToBytes = function (E) {
          return (
            String.fromCharCode((E >> 24) & 255) +
            String.fromCharCode((E >> 16) & 255) +
            String.fromCharCode((E >> 8) & 255) +
            String.fromCharCode(E & 255)
          )
        })
      var a = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
        c = [
          62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, 64, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6,
          7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28,
          29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
        ],
        f = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
      ;(i.encode64 = function (E, k) {
        for (var w = '', v = '', I, M, q, G = 0; G < E.length; )
          (I = E.charCodeAt(G++)),
            (M = E.charCodeAt(G++)),
            (q = E.charCodeAt(G++)),
            (w += a.charAt(I >> 2)),
            (w += a.charAt(((I & 3) << 4) | (M >> 4))),
            isNaN(M)
              ? (w += '==')
              : ((w += a.charAt(((M & 15) << 2) | (q >> 6))), (w += isNaN(q) ? '=' : a.charAt(q & 63))),
            k &&
              w.length > k &&
              ((v +=
                w.substr(0, k) +
                `\r
`),
              (w = w.substr(k)))
        return (v += w), v
      }),
        (i.decode64 = function (E) {
          E = E.replace(/[^A-Za-z0-9\+\/\=]/g, '')
          for (var k = '', w, v, I, M, q = 0; q < E.length; )
            (w = c[E.charCodeAt(q++) - 43]),
              (v = c[E.charCodeAt(q++) - 43]),
              (I = c[E.charCodeAt(q++) - 43]),
              (M = c[E.charCodeAt(q++) - 43]),
              (k += String.fromCharCode((w << 2) | (v >> 4))),
              I !== 64 &&
                ((k += String.fromCharCode(((v & 15) << 4) | (I >> 2))),
                M !== 64 && (k += String.fromCharCode(((I & 3) << 6) | M)))
          return k
        }),
        (i.encodeUtf8 = function (E) {
          return unescape(encodeURIComponent(E))
        }),
        (i.decodeUtf8 = function (E) {
          return decodeURIComponent(escape(E))
        }),
        (i.binary = { raw: {}, hex: {}, base64: {}, base58: {}, baseN: { encode: n.encode, decode: n.decode } }),
        (i.binary.raw.encode = function (E) {
          return String.fromCharCode.apply(null, E)
        }),
        (i.binary.raw.decode = function (E, k, w) {
          var v = k
          v || (v = new Uint8Array(E.length)), (w = w || 0)
          for (var I = w, M = 0; M < E.length; ++M) v[I++] = E.charCodeAt(M)
          return k ? I - w : v
        }),
        (i.binary.hex.encode = i.bytesToHex),
        (i.binary.hex.decode = function (E, k, w) {
          var v = k
          v || (v = new Uint8Array(Math.ceil(E.length / 2))), (w = w || 0)
          var I = 0,
            M = w
          for (E.length & 1 && ((I = 1), (v[M++] = parseInt(E[0], 16))); I < E.length; I += 2)
            v[M++] = parseInt(E.substr(I, 2), 16)
          return k ? M - w : v
        }),
        (i.binary.base64.encode = function (E, k) {
          for (var w = '', v = '', I, M, q, G = 0; G < E.byteLength; )
            (I = E[G++]),
              (M = E[G++]),
              (q = E[G++]),
              (w += a.charAt(I >> 2)),
              (w += a.charAt(((I & 3) << 4) | (M >> 4))),
              isNaN(M)
                ? (w += '==')
                : ((w += a.charAt(((M & 15) << 2) | (q >> 6))), (w += isNaN(q) ? '=' : a.charAt(q & 63))),
              k &&
                w.length > k &&
                ((v +=
                  w.substr(0, k) +
                  `\r
`),
                (w = w.substr(k)))
          return (v += w), v
        }),
        (i.binary.base64.decode = function (E, k, w) {
          var v = k
          v || (v = new Uint8Array(Math.ceil(E.length / 4) * 3)),
            (E = E.replace(/[^A-Za-z0-9\+\/\=]/g, '')),
            (w = w || 0)
          for (var I, M, q, G, O = 0, x = w; O < E.length; )
            (I = c[E.charCodeAt(O++) - 43]),
              (M = c[E.charCodeAt(O++) - 43]),
              (q = c[E.charCodeAt(O++) - 43]),
              (G = c[E.charCodeAt(O++) - 43]),
              (v[x++] = (I << 2) | (M >> 4)),
              q !== 64 && ((v[x++] = ((M & 15) << 4) | (q >> 2)), G !== 64 && (v[x++] = ((q & 3) << 6) | G))
          return k ? x - w : v.subarray(0, x)
        }),
        (i.binary.base58.encode = function (E, k) {
          return i.binary.baseN.encode(E, f, k)
        }),
        (i.binary.base58.decode = function (E, k) {
          return i.binary.baseN.decode(E, f, k)
        }),
        (i.text = { utf8: {}, utf16: {} }),
        (i.text.utf8.encode = function (E, k, w) {
          E = i.encodeUtf8(E)
          var v = k
          v || (v = new Uint8Array(E.length)), (w = w || 0)
          for (var I = w, M = 0; M < E.length; ++M) v[I++] = E.charCodeAt(M)
          return k ? I - w : v
        }),
        (i.text.utf8.decode = function (E) {
          return i.decodeUtf8(String.fromCharCode.apply(null, E))
        }),
        (i.text.utf16.encode = function (E, k, w) {
          var v = k
          v || (v = new Uint8Array(E.length * 2))
          var I = new Uint16Array(v.buffer)
          w = w || 0
          for (var M = w, q = w, G = 0; G < E.length; ++G) (I[q++] = E.charCodeAt(G)), (M += 2)
          return k ? M - w : v
        }),
        (i.text.utf16.decode = function (E) {
          return String.fromCharCode.apply(null, new Uint16Array(E.buffer))
        }),
        (i.deflate = function (E, k, w) {
          if (((k = i.decode64(E.deflate(i.encode64(k)).rval)), w)) {
            var v = 2,
              I = k.charCodeAt(1)
            I & 32 && (v = 6), (k = k.substring(v, k.length - 4))
          }
          return k
        }),
        (i.inflate = function (E, k, w) {
          var v = E.inflate(i.encode64(k)).rval
          return v === null ? null : i.decode64(v)
        })
      var p = function (E, k, w) {
          if (!E) throw new Error('WebStorage not available.')
          var v
          if (
            (w === null ? (v = E.removeItem(k)) : ((w = i.encode64(JSON.stringify(w))), (v = E.setItem(k, w))),
            typeof v != 'undefined' && v.rval !== !0)
          ) {
            var I = new Error(v.error.message)
            throw ((I.id = v.error.id), (I.name = v.error.name), I)
          }
        },
        y = function (E, k) {
          if (!E) throw new Error('WebStorage not available.')
          var w = E.getItem(k)
          if (E.init)
            if (w.rval === null) {
              if (w.error) {
                var v = new Error(w.error.message)
                throw ((v.id = w.error.id), (v.name = w.error.name), v)
              }
              w = null
            } else w = w.rval
          return w !== null && (w = JSON.parse(i.decode64(w))), w
        },
        d = function (E, k, w, v) {
          var I = y(E, k)
          I === null && (I = {}), (I[w] = v), p(E, k, I)
        },
        h = function (E, k, w) {
          var v = y(E, k)
          return v !== null && (v = w in v ? v[w] : null), v
        },
        m = function (E, k, w) {
          var v = y(E, k)
          if (v !== null && w in v) {
            delete v[w]
            var I = !0
            for (var M in v) {
              I = !1
              break
            }
            I && (v = null), p(E, k, v)
          }
        },
        _ = function (E, k) {
          p(E, k, null)
        },
        A = function (E, k, w) {
          var v = null
          typeof w == 'undefined' && (w = ['web', 'flash'])
          var I,
            M = !1,
            q = null
          for (var G in w) {
            I = w[G]
            try {
              if (I === 'flash' || I === 'both') {
                if (k[0] === null) throw new Error('Flash local storage not available.')
                ;(v = E.apply(this, k)), (M = I === 'flash')
              }
              ;(I === 'web' || I === 'both') && ((k[0] = localStorage), (v = E.apply(this, k)), (M = !0))
            } catch (O) {
              q = O
            }
            if (M) break
          }
          if (!M) throw q
          return v
        }
      ;(i.setItem = function (E, k, w, v, I) {
        A(d, arguments, I)
      }),
        (i.getItem = function (E, k, w, v) {
          return A(h, arguments, v)
        }),
        (i.removeItem = function (E, k, w, v) {
          A(m, arguments, v)
        }),
        (i.clearItems = function (E, k, w) {
          A(_, arguments, w)
        }),
        (i.parseUrl = function (E) {
          var k = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g
          k.lastIndex = 0
          var w = k.exec(E),
            v = w === null ? null : { full: E, scheme: w[1], host: w[2], port: w[3], path: w[4] }
          return (
            v &&
              ((v.fullHost = v.host),
              v.port
                ? ((v.port !== 80 && v.scheme === 'http') || (v.port !== 443 && v.scheme === 'https')) &&
                  (v.fullHost += ':' + v.port)
                : v.scheme === 'http'
                ? (v.port = 80)
                : v.scheme === 'https' && (v.port = 443),
              (v.full = v.scheme + '://' + v.fullHost)),
            v
          )
        })
      var T = null
      ;(i.getQueryVariables = function (E) {
        var k = function (v) {
            for (var I = {}, M = v.split('&'), q = 0; q < M.length; q++) {
              var G = M[q].indexOf('='),
                O,
                x
              G > 0 ? ((O = M[q].substring(0, G)), (x = M[q].substring(G + 1))) : ((O = M[q]), (x = null)),
                O in I || (I[O] = []),
                !(O in Object.prototype) && x !== null && I[O].push(unescape(x))
            }
            return I
          },
          w
        return (
          typeof E == 'undefined'
            ? (T === null &&
                (typeof window != 'undefined' && window.location && window.location.search
                  ? (T = k(window.location.search.substring(1)))
                  : (T = {})),
              (w = T))
            : (w = k(E)),
          w
        )
      }),
        (i.parseFragment = function (E) {
          var k = E,
            w = '',
            v = E.indexOf('?')
          v > 0 && ((k = E.substring(0, v)), (w = E.substring(v + 1)))
          var I = k.split('/')
          I.length > 0 && I[0] === '' && I.shift()
          var M = w === '' ? {} : i.getQueryVariables(w)
          return { pathString: k, queryString: w, path: I, query: M }
        }),
        (i.makeRequest = function (E) {
          var k = i.parseFragment(E),
            w = {
              path: k.pathString,
              query: k.queryString,
              getPath: function (v) {
                return typeof v == 'undefined' ? k.path : k.path[v]
              },
              getQuery: function (v, I) {
                var M
                return (
                  typeof v == 'undefined'
                    ? (M = k.query)
                    : ((M = k.query[v]), M && typeof I != 'undefined' && (M = M[I])),
                  M
                )
              },
              getQueryLast: function (v, I) {
                var M,
                  q = w.getQuery(v)
                return q ? (M = q[q.length - 1]) : (M = I), M
              }
            }
          return w
        }),
        (i.makeLink = function (E, k, w) {
          E = jQuery.isArray(E) ? E.join('/') : E
          var v = jQuery.param(k || {})
          return (w = w || ''), E + (v.length > 0 ? '?' + v : '') + (w.length > 0 ? '#' + w : '')
        }),
        (i.isEmpty = function (E) {
          for (var k in E) if (E.hasOwnProperty(k)) return !1
          return !0
        }),
        (i.format = function (E) {
          for (var k = /%./g, w, v, I = 0, M = [], q = 0; (w = k.exec(E)); ) {
            ;(v = E.substring(q, k.lastIndex - 2)), v.length > 0 && M.push(v), (q = k.lastIndex)
            var G = w[0][1]
            switch (G) {
              case 's':
              case 'o':
                I < arguments.length ? M.push(arguments[I++ + 1]) : M.push('<?>')
                break
              case '%':
                M.push('%')
                break
              default:
                M.push('<%' + G + '?>')
            }
          }
          return M.push(E.substring(q)), M.join('')
        }),
        (i.formatNumber = function (E, k, w, v) {
          var I = E,
            M = isNaN((k = Math.abs(k))) ? 2 : k,
            q = w === void 0 ? ',' : w,
            G = v === void 0 ? '.' : v,
            O = I < 0 ? '-' : '',
            x = parseInt((I = Math.abs(+I || 0).toFixed(M)), 10) + '',
            L = x.length > 3 ? x.length % 3 : 0
          return (
            O +
            (L ? x.substr(0, L) + G : '') +
            x.substr(L).replace(/(\d{3})(?=\d)/g, '$1' + G) +
            (M
              ? q +
                Math.abs(I - x)
                  .toFixed(M)
                  .slice(2)
              : '')
          )
        }),
        (i.formatSize = function (E) {
          return (
            E >= 1073741824
              ? (E = i.formatNumber(E / 1073741824, 2, '.', '') + ' GiB')
              : E >= 1048576
              ? (E = i.formatNumber(E / 1048576, 2, '.', '') + ' MiB')
              : E >= 1024
              ? (E = i.formatNumber(E / 1024, 0) + ' KiB')
              : (E = i.formatNumber(E, 0) + ' bytes'),
            E
          )
        }),
        (i.bytesFromIP = function (E) {
          return E.indexOf('.') !== -1 ? i.bytesFromIPv4(E) : E.indexOf(':') !== -1 ? i.bytesFromIPv6(E) : null
        }),
        (i.bytesFromIPv4 = function (E) {
          if (((E = E.split('.')), E.length !== 4)) return null
          for (var k = i.createBuffer(), w = 0; w < E.length; ++w) {
            var v = parseInt(E[w], 10)
            if (isNaN(v)) return null
            k.putByte(v)
          }
          return k.getBytes()
        }),
        (i.bytesFromIPv6 = function (E) {
          var k = 0
          E = E.split(':').filter(function (q) {
            return q.length === 0 && ++k, !0
          })
          for (var w = (8 - E.length + k) * 2, v = i.createBuffer(), I = 0; I < 8; ++I) {
            if (!E[I] || E[I].length === 0) {
              v.fillWithByte(0, w), (w = 0)
              continue
            }
            var M = i.hexToBytes(E[I])
            M.length < 2 && v.putByte(0), v.putBytes(M)
          }
          return v.getBytes()
        }),
        (i.bytesToIP = function (E) {
          return E.length === 4 ? i.bytesToIPv4(E) : E.length === 16 ? i.bytesToIPv6(E) : null
        }),
        (i.bytesToIPv4 = function (E) {
          if (E.length !== 4) return null
          for (var k = [], w = 0; w < E.length; ++w) k.push(E.charCodeAt(w))
          return k.join('.')
        }),
        (i.bytesToIPv6 = function (E) {
          if (E.length !== 16) return null
          for (var k = [], w = [], v = 0, I = 0; I < E.length; I += 2) {
            for (var M = i.bytesToHex(E[I] + E[I + 1]); M[0] === '0' && M !== '0'; ) M = M.substr(1)
            if (M === '0') {
              var q = w[w.length - 1],
                G = k.length
              !q || G !== q.end + 1
                ? w.push({ start: G, end: G })
                : ((q.end = G), q.end - q.start > w[v].end - w[v].start && (v = w.length - 1))
            }
            k.push(M)
          }
          if (w.length > 0) {
            var O = w[v]
            O.end - O.start > 0 &&
              (k.splice(O.start, O.end - O.start + 1, ''), O.start === 0 && k.unshift(''), O.end === 7 && k.push(''))
          }
          return k.join(':')
        }),
        (i.estimateCores = function (E, k) {
          if ((typeof E == 'function' && ((k = E), (E = {})), (E = E || {}), 'cores' in i && !E.update))
            return k(null, i.cores)
          if (
            typeof navigator != 'undefined' &&
            'hardwareConcurrency' in navigator &&
            navigator.hardwareConcurrency > 0
          )
            return (i.cores = navigator.hardwareConcurrency), k(null, i.cores)
          if (typeof Worker == 'undefined') return (i.cores = 1), k(null, i.cores)
          if (typeof Blob == 'undefined') return (i.cores = 2), k(null, i.cores)
          var w = URL.createObjectURL(
            new Blob(
              [
                '(',
                function () {
                  self.addEventListener('message', function (q) {
                    for (var G = Date.now(), O = G + 4; Date.now() < O; );
                    self.postMessage({ st: G, et: O })
                  })
                }.toString(),
                ')()'
              ],
              { type: 'application/javascript' }
            )
          )
          v([], 5, 16)
          function v(q, G, O) {
            if (G === 0) {
              var x = Math.floor(
                q.reduce(function (L, K) {
                  return L + K
                }, 0) / q.length
              )
              return (i.cores = Math.max(1, x)), URL.revokeObjectURL(w), k(null, i.cores)
            }
            I(O, function (L, K) {
              q.push(M(O, K)), v(q, G - 1, O)
            })
          }
          function I(q, G) {
            for (var O = [], x = [], L = 0; L < q; ++L) {
              var K = new Worker(w)
              K.addEventListener('message', function (J) {
                if ((x.push(J.data), x.length === q)) {
                  for (var Z = 0; Z < q; ++Z) O[Z].terminate()
                  G(null, x)
                }
              }),
                O.push(K)
            }
            for (var L = 0; L < q; ++L) O[L].postMessage(L)
          }
          function M(q, G) {
            for (var O = [], x = 0; x < q; ++x)
              for (var L = G[x], K = (O[x] = []), J = 0; J < q; ++J)
                if (x !== J) {
                  var Z = G[J]
                  ;((L.st > Z.st && L.st < Z.et) || (Z.st > L.st && Z.st < L.et)) && K.push(J)
                }
            return O.reduce(function (Q, fe) {
              return Math.max(Q, fe.length)
            }, 0)
          }
        })
    }
  }),
  Uc = te({
    'node_modules/node-forge/lib/oids.js'(e, r) {
      V(), F()
      var t = yt()
      t.pki = t.pki || {}
      var n = (r.exports = t.pki.oids = t.oids = t.oids || {})
      function i(u, o) {
        ;(n[u] = o), (n[o] = u)
      }
      function s(u, o) {
        n[u] = o
      }
      i('1.2.840.113549.1.1.1', 'rsaEncryption'),
        i('1.2.840.113549.1.1.4', 'md5WithRSAEncryption'),
        i('1.2.840.113549.1.1.5', 'sha1WithRSAEncryption'),
        i('1.2.840.113549.1.1.7', 'RSAES-OAEP'),
        i('1.2.840.113549.1.1.8', 'mgf1'),
        i('1.2.840.113549.1.1.9', 'pSpecified'),
        i('1.2.840.113549.1.1.10', 'RSASSA-PSS'),
        i('1.2.840.113549.1.1.11', 'sha256WithRSAEncryption'),
        i('1.2.840.113549.1.1.12', 'sha384WithRSAEncryption'),
        i('1.2.840.113549.1.1.13', 'sha512WithRSAEncryption'),
        i('1.3.101.112', 'EdDSA25519'),
        i('1.2.840.10040.4.3', 'dsa-with-sha1'),
        i('1.3.14.3.2.7', 'desCBC'),
        i('1.3.14.3.2.26', 'sha1'),
        i('2.16.840.1.101.3.4.2.1', 'sha256'),
        i('2.16.840.1.101.3.4.2.2', 'sha384'),
        i('2.16.840.1.101.3.4.2.3', 'sha512'),
        i('1.2.840.113549.2.5', 'md5'),
        i('1.2.840.113549.1.7.1', 'data'),
        i('1.2.840.113549.1.7.2', 'signedData'),
        i('1.2.840.113549.1.7.3', 'envelopedData'),
        i('1.2.840.113549.1.7.4', 'signedAndEnvelopedData'),
        i('1.2.840.113549.1.7.5', 'digestedData'),
        i('1.2.840.113549.1.7.6', 'encryptedData'),
        i('1.2.840.113549.1.9.1', 'emailAddress'),
        i('1.2.840.113549.1.9.2', 'unstructuredName'),
        i('1.2.840.113549.1.9.3', 'contentType'),
        i('1.2.840.113549.1.9.4', 'messageDigest'),
        i('1.2.840.113549.1.9.5', 'signingTime'),
        i('1.2.840.113549.1.9.6', 'counterSignature'),
        i('1.2.840.113549.1.9.7', 'challengePassword'),
        i('1.2.840.113549.1.9.8', 'unstructuredAddress'),
        i('1.2.840.113549.1.9.14', 'extensionRequest'),
        i('1.2.840.113549.1.9.20', 'friendlyName'),
        i('1.2.840.113549.1.9.21', 'localKeyId'),
        i('1.2.840.113549.1.9.22.1', 'x509Certificate'),
        i('1.2.840.113549.1.12.10.1.1', 'keyBag'),
        i('1.2.840.113549.1.12.10.1.2', 'pkcs8ShroudedKeyBag'),
        i('1.2.840.113549.1.12.10.1.3', 'certBag'),
        i('1.2.840.113549.1.12.10.1.4', 'crlBag'),
        i('1.2.840.113549.1.12.10.1.5', 'secretBag'),
        i('1.2.840.113549.1.12.10.1.6', 'safeContentsBag'),
        i('1.2.840.113549.1.5.13', 'pkcs5PBES2'),
        i('1.2.840.113549.1.5.12', 'pkcs5PBKDF2'),
        i('1.2.840.113549.1.12.1.1', 'pbeWithSHAAnd128BitRC4'),
        i('1.2.840.113549.1.12.1.2', 'pbeWithSHAAnd40BitRC4'),
        i('1.2.840.113549.1.12.1.3', 'pbeWithSHAAnd3-KeyTripleDES-CBC'),
        i('1.2.840.113549.1.12.1.4', 'pbeWithSHAAnd2-KeyTripleDES-CBC'),
        i('1.2.840.113549.1.12.1.5', 'pbeWithSHAAnd128BitRC2-CBC'),
        i('1.2.840.113549.1.12.1.6', 'pbewithSHAAnd40BitRC2-CBC'),
        i('1.2.840.113549.2.7', 'hmacWithSHA1'),
        i('1.2.840.113549.2.8', 'hmacWithSHA224'),
        i('1.2.840.113549.2.9', 'hmacWithSHA256'),
        i('1.2.840.113549.2.10', 'hmacWithSHA384'),
        i('1.2.840.113549.2.11', 'hmacWithSHA512'),
        i('1.2.840.113549.3.7', 'des-EDE3-CBC'),
        i('2.16.840.1.101.3.4.1.2', 'aes128-CBC'),
        i('2.16.840.1.101.3.4.1.22', 'aes192-CBC'),
        i('2.16.840.1.101.3.4.1.42', 'aes256-CBC'),
        i('2.5.4.3', 'commonName'),
        i('2.5.4.5', 'serialName'),
        i('2.5.4.6', 'countryName'),
        i('2.5.4.7', 'localityName'),
        i('2.5.4.8', 'stateOrProvinceName'),
        i('2.5.4.9', 'streetAddress'),
        i('2.5.4.10', 'organizationName'),
        i('2.5.4.11', 'organizationalUnitName'),
        i('2.5.4.13', 'description'),
        i('2.5.4.15', 'businessCategory'),
        i('2.5.4.17', 'postalCode'),
        i('1.3.6.1.4.1.311.60.2.1.2', 'jurisdictionOfIncorporationStateOrProvinceName'),
        i('1.3.6.1.4.1.311.60.2.1.3', 'jurisdictionOfIncorporationCountryName'),
        i('2.16.840.1.113730.1.1', 'nsCertType'),
        i('2.16.840.1.113730.1.13', 'nsComment'),
        s('2.5.29.1', 'authorityKeyIdentifier'),
        s('2.5.29.2', 'keyAttributes'),
        s('2.5.29.3', 'certificatePolicies'),
        s('2.5.29.4', 'keyUsageRestriction'),
        s('2.5.29.5', 'policyMapping'),
        s('2.5.29.6', 'subtreesConstraint'),
        s('2.5.29.7', 'subjectAltName'),
        s('2.5.29.8', 'issuerAltName'),
        s('2.5.29.9', 'subjectDirectoryAttributes'),
        s('2.5.29.10', 'basicConstraints'),
        s('2.5.29.11', 'nameConstraints'),
        s('2.5.29.12', 'policyConstraints'),
        s('2.5.29.13', 'basicConstraints'),
        i('2.5.29.14', 'subjectKeyIdentifier'),
        i('2.5.29.15', 'keyUsage'),
        s('2.5.29.16', 'privateKeyUsagePeriod'),
        i('2.5.29.17', 'subjectAltName'),
        i('2.5.29.18', 'issuerAltName'),
        i('2.5.29.19', 'basicConstraints'),
        s('2.5.29.20', 'cRLNumber'),
        s('2.5.29.21', 'cRLReason'),
        s('2.5.29.22', 'expirationDate'),
        s('2.5.29.23', 'instructionCode'),
        s('2.5.29.24', 'invalidityDate'),
        s('2.5.29.25', 'cRLDistributionPoints'),
        s('2.5.29.26', 'issuingDistributionPoint'),
        s('2.5.29.27', 'deltaCRLIndicator'),
        s('2.5.29.28', 'issuingDistributionPoint'),
        s('2.5.29.29', 'certificateIssuer'),
        s('2.5.29.30', 'nameConstraints'),
        i('2.5.29.31', 'cRLDistributionPoints'),
        i('2.5.29.32', 'certificatePolicies'),
        s('2.5.29.33', 'policyMappings'),
        s('2.5.29.34', 'policyConstraints'),
        i('2.5.29.35', 'authorityKeyIdentifier'),
        s('2.5.29.36', 'policyConstraints'),
        i('2.5.29.37', 'extKeyUsage'),
        s('2.5.29.46', 'freshestCRL'),
        s('2.5.29.54', 'inhibitAnyPolicy'),
        i('1.3.6.1.4.1.11129.2.4.2', 'timestampList'),
        i('1.3.6.1.5.5.7.1.1', 'authorityInfoAccess'),
        i('1.3.6.1.5.5.7.3.1', 'serverAuth'),
        i('1.3.6.1.5.5.7.3.2', 'clientAuth'),
        i('1.3.6.1.5.5.7.3.3', 'codeSigning'),
        i('1.3.6.1.5.5.7.3.4', 'emailProtection'),
        i('1.3.6.1.5.5.7.3.8', 'timeStamping')
    }
  }),
  qi = te({
    'node_modules/node-forge/lib/asn1.js'(e, r) {
      V(), F()
      var t = yt()
      zt(), Uc()
      var n = (r.exports = t.asn1 = t.asn1 || {})
      ;(n.Class = { UNIVERSAL: 0, APPLICATION: 64, CONTEXT_SPECIFIC: 128, PRIVATE: 192 }),
        (n.Type = {
          NONE: 0,
          BOOLEAN: 1,
          INTEGER: 2,
          BITSTRING: 3,
          OCTETSTRING: 4,
          NULL: 5,
          OID: 6,
          ODESC: 7,
          EXTERNAL: 8,
          REAL: 9,
          ENUMERATED: 10,
          EMBEDDED: 11,
          UTF8: 12,
          ROID: 13,
          SEQUENCE: 16,
          SET: 17,
          PRINTABLESTRING: 19,
          IA5STRING: 22,
          UTCTIME: 23,
          GENERALIZEDTIME: 24,
          BMPSTRING: 30
        }),
        (n.create = function (l, a, c, f, p) {
          if (t.util.isArray(f)) {
            for (var y = [], d = 0; d < f.length; ++d) f[d] !== void 0 && y.push(f[d])
            f = y
          }
          var h = { tagClass: l, type: a, constructed: c, composed: c || t.util.isArray(f), value: f }
          return (
            p && 'bitStringContents' in p && ((h.bitStringContents = p.bitStringContents), (h.original = n.copy(h))), h
          )
        }),
        (n.copy = function (l, a) {
          var c
          if (t.util.isArray(l)) {
            c = []
            for (var f = 0; f < l.length; ++f) c.push(n.copy(l[f], a))
            return c
          }
          return typeof l == 'string'
            ? l
            : ((c = {
                tagClass: l.tagClass,
                type: l.type,
                constructed: l.constructed,
                composed: l.composed,
                value: n.copy(l.value, a)
              }),
              a && !a.excludeBitStringContents && (c.bitStringContents = l.bitStringContents),
              c)
        }),
        (n.equals = function (l, a, c) {
          if (t.util.isArray(l)) {
            if (!t.util.isArray(a) || l.length !== a.length) return !1
            for (var f = 0; f < l.length; ++f) if (!n.equals(l[f], a[f])) return !1
            return !0
          }
          if (typeof l != typeof a) return !1
          if (typeof l == 'string') return l === a
          var p =
            l.tagClass === a.tagClass &&
            l.type === a.type &&
            l.constructed === a.constructed &&
            l.composed === a.composed &&
            n.equals(l.value, a.value)
          return c && c.includeBitStringContents && (p = p && l.bitStringContents === a.bitStringContents), p
        }),
        (n.getBerValueLength = function (l) {
          var a = l.getByte()
          if (a !== 128) {
            var c,
              f = a & 128
            return f ? (c = l.getInt((a & 127) << 3)) : (c = a), c
          }
        })
      function i(l, a, c) {
        if (c > a) {
          var f = new Error('Too few bytes to parse DER.')
          throw ((f.available = l.length()), (f.remaining = a), (f.requested = c), f)
        }
      }
      var s = function (l, a) {
        var c = l.getByte()
        if ((a--, c !== 128)) {
          var f,
            p = c & 128
          if (!p) f = c
          else {
            var y = c & 127
            i(l, a, y), (f = l.getInt(y << 3))
          }
          if (f < 0) throw new Error('Negative length: ' + f)
          return f
        }
      }
      n.fromDer = function (l, a) {
        return (
          a === void 0 && (a = { strict: !0, decodeBitStrings: !0 }),
          typeof a == 'boolean' && (a = { strict: a, decodeBitStrings: !0 }),
          'strict' in a || (a.strict = !0),
          'decodeBitStrings' in a || (a.decodeBitStrings = !0),
          typeof l == 'string' && (l = t.util.createBuffer(l)),
          u(l, l.length(), 0, a)
        )
      }
      function u(l, a, c, f) {
        var p
        i(l, a, 2)
        var y = l.getByte()
        a--
        var d = y & 192,
          h = y & 31
        p = l.length()
        var m = s(l, a)
        if (((a -= p - l.length()), m !== void 0 && m > a)) {
          if (f.strict) {
            var _ = new Error('Too few bytes to read ASN.1 value.')
            throw ((_.available = l.length()), (_.remaining = a), (_.requested = m), _)
          }
          m = a
        }
        var A,
          T,
          E = (y & 32) == 32
        if (E)
          if (((A = []), m === void 0))
            for (;;) {
              if ((i(l, a, 2), l.bytes(2) === String.fromCharCode(0, 0))) {
                l.getBytes(2), (a -= 2)
                break
              }
              ;(p = l.length()), A.push(u(l, a, c + 1, f)), (a -= p - l.length())
            }
          else for (; m > 0; ) (p = l.length()), A.push(u(l, m, c + 1, f)), (a -= p - l.length()), (m -= p - l.length())
        if (
          (A === void 0 && d === n.Class.UNIVERSAL && h === n.Type.BITSTRING && (T = l.bytes(m)),
          A === void 0 && f.decodeBitStrings && d === n.Class.UNIVERSAL && h === n.Type.BITSTRING && m > 1)
        ) {
          var k = l.read,
            w = a,
            v = 0
          if ((h === n.Type.BITSTRING && (i(l, a, 1), (v = l.getByte()), a--), v === 0))
            try {
              p = l.length()
              var I = { verbose: f.verbose, strict: !0, decodeBitStrings: !0 },
                M = u(l, a, c + 1, I),
                q = p - l.length()
              ;(a -= q), h == n.Type.BITSTRING && q++
              var G = M.tagClass
              q === m && (G === n.Class.UNIVERSAL || G === n.Class.CONTEXT_SPECIFIC) && (A = [M])
            } catch (x) {}
          A === void 0 && ((l.read = k), (a = w))
        }
        if (A === void 0) {
          if (m === void 0) {
            if (f.strict) throw new Error('Non-constructed ASN.1 object of indefinite length.')
            m = a
          }
          if (h === n.Type.BMPSTRING)
            for (A = ''; m > 0; m -= 2) i(l, a, 2), (A += String.fromCharCode(l.getInt16())), (a -= 2)
          else A = l.getBytes(m)
        }
        var O = T === void 0 ? null : { bitStringContents: T }
        return n.create(d, h, E, A, O)
      }
      ;(n.toDer = function (l) {
        var a = t.util.createBuffer(),
          c = l.tagClass | l.type,
          f = t.util.createBuffer(),
          p = !1
        if (('bitStringContents' in l && ((p = !0), l.original && (p = n.equals(l, l.original))), p))
          f.putBytes(l.bitStringContents)
        else if (l.composed) {
          l.constructed ? (c |= 32) : f.putByte(0)
          for (var y = 0; y < l.value.length; ++y) l.value[y] !== void 0 && f.putBuffer(n.toDer(l.value[y]))
        } else if (l.type === n.Type.BMPSTRING)
          for (var y = 0; y < l.value.length; ++y) f.putInt16(l.value.charCodeAt(y))
        else
          l.type === n.Type.INTEGER &&
          l.value.length > 1 &&
          ((l.value.charCodeAt(0) === 0 && (l.value.charCodeAt(1) & 128) == 0) ||
            (l.value.charCodeAt(0) === 255 && (l.value.charCodeAt(1) & 128) == 128))
            ? f.putBytes(l.value.substr(1))
            : f.putBytes(l.value)
        if ((a.putByte(c), f.length() <= 127)) a.putByte(f.length() & 127)
        else {
          var d = f.length(),
            h = ''
          do (h += String.fromCharCode(d & 255)), (d = d >>> 8)
          while (d > 0)
          a.putByte(h.length | 128)
          for (var y = h.length - 1; y >= 0; --y) a.putByte(h.charCodeAt(y))
        }
        return a.putBuffer(f), a
      }),
        (n.oidToDer = function (l) {
          var a = l.split('.'),
            c = t.util.createBuffer()
          c.putByte(40 * parseInt(a[0], 10) + parseInt(a[1], 10))
          for (var f, p, y, d, h = 2; h < a.length; ++h) {
            ;(f = !0), (p = []), (y = parseInt(a[h], 10))
            do (d = y & 127), (y = y >>> 7), f || (d |= 128), p.push(d), (f = !1)
            while (y > 0)
            for (var m = p.length - 1; m >= 0; --m) c.putByte(p[m])
          }
          return c
        }),
        (n.derToOid = function (l) {
          var a
          typeof l == 'string' && (l = t.util.createBuffer(l))
          var c = l.getByte()
          a = Math.floor(c / 40) + '.' + (c % 40)
          for (var f = 0; l.length() > 0; )
            (c = l.getByte()), (f = f << 7), c & 128 ? (f += c & 127) : ((a += '.' + (f + c)), (f = 0))
          return a
        }),
        (n.utcTimeToDate = function (l) {
          var a = new Date(),
            c = parseInt(l.substr(0, 2), 10)
          c = c >= 50 ? 1900 + c : 2e3 + c
          var f = parseInt(l.substr(2, 2), 10) - 1,
            p = parseInt(l.substr(4, 2), 10),
            y = parseInt(l.substr(6, 2), 10),
            d = parseInt(l.substr(8, 2), 10),
            h = 0
          if (l.length > 11) {
            var m = l.charAt(10),
              _ = 10
            m !== '+' && m !== '-' && ((h = parseInt(l.substr(10, 2), 10)), (_ += 2))
          }
          if (
            (a.setUTCFullYear(c, f, p), a.setUTCHours(y, d, h, 0), _ && ((m = l.charAt(_)), m === '+' || m === '-'))
          ) {
            var A = parseInt(l.substr(_ + 1, 2), 10),
              T = parseInt(l.substr(_ + 4, 2), 10),
              E = A * 60 + T
            ;(E *= 6e4), m === '+' ? a.setTime(+a - E) : a.setTime(+a + E)
          }
          return a
        }),
        (n.generalizedTimeToDate = function (l) {
          var a = new Date(),
            c = parseInt(l.substr(0, 4), 10),
            f = parseInt(l.substr(4, 2), 10) - 1,
            p = parseInt(l.substr(6, 2), 10),
            y = parseInt(l.substr(8, 2), 10),
            d = parseInt(l.substr(10, 2), 10),
            h = parseInt(l.substr(12, 2), 10),
            m = 0,
            _ = 0,
            A = !1
          l.charAt(l.length - 1) === 'Z' && (A = !0)
          var T = l.length - 5,
            E = l.charAt(T)
          if (E === '+' || E === '-') {
            var k = parseInt(l.substr(T + 1, 2), 10),
              w = parseInt(l.substr(T + 4, 2), 10)
            ;(_ = k * 60 + w), (_ *= 6e4), E === '+' && (_ *= -1), (A = !0)
          }
          return (
            l.charAt(14) === '.' && (m = parseFloat(l.substr(14), 10) * 1e3),
            A
              ? (a.setUTCFullYear(c, f, p), a.setUTCHours(y, d, h, m), a.setTime(+a + _))
              : (a.setFullYear(c, f, p), a.setHours(y, d, h, m)),
            a
          )
        }),
        (n.dateToUtcTime = function (l) {
          if (typeof l == 'string') return l
          var a = '',
            c = []
          c.push(('' + l.getUTCFullYear()).substr(2)),
            c.push('' + (l.getUTCMonth() + 1)),
            c.push('' + l.getUTCDate()),
            c.push('' + l.getUTCHours()),
            c.push('' + l.getUTCMinutes()),
            c.push('' + l.getUTCSeconds())
          for (var f = 0; f < c.length; ++f) c[f].length < 2 && (a += '0'), (a += c[f])
          return (a += 'Z'), a
        }),
        (n.dateToGeneralizedTime = function (l) {
          if (typeof l == 'string') return l
          var a = '',
            c = []
          c.push('' + l.getUTCFullYear()),
            c.push('' + (l.getUTCMonth() + 1)),
            c.push('' + l.getUTCDate()),
            c.push('' + l.getUTCHours()),
            c.push('' + l.getUTCMinutes()),
            c.push('' + l.getUTCSeconds())
          for (var f = 0; f < c.length; ++f) c[f].length < 2 && (a += '0'), (a += c[f])
          return (a += 'Z'), a
        }),
        (n.integerToDer = function (l) {
          var a = t.util.createBuffer()
          if (l >= -128 && l < 128) return a.putSignedInt(l, 8)
          if (l >= -32768 && l < 32768) return a.putSignedInt(l, 16)
          if (l >= -8388608 && l < 8388608) return a.putSignedInt(l, 24)
          if (l >= -2147483648 && l < 2147483648) return a.putSignedInt(l, 32)
          var c = new Error('Integer too large; max is 32-bits.')
          throw ((c.integer = l), c)
        }),
        (n.derToInteger = function (l) {
          typeof l == 'string' && (l = t.util.createBuffer(l))
          var a = l.length() * 8
          if (a > 32) throw new Error('Integer too large; max is 32-bits.')
          return l.getSignedInt(a)
        }),
        (n.validate = function (l, a, c, f) {
          var p = !1
          if (
            (l.tagClass === a.tagClass || typeof a.tagClass == 'undefined') &&
            (l.type === a.type || typeof a.type == 'undefined')
          )
            if (l.constructed === a.constructed || typeof a.constructed == 'undefined') {
              if (((p = !0), a.value && t.util.isArray(a.value)))
                for (var y = 0, d = 0; p && d < a.value.length; ++d)
                  (p = a.value[d].optional || !1),
                    l.value[y] &&
                      ((p = n.validate(l.value[y], a.value[d], c, f)), p ? ++y : a.value[d].optional && (p = !0)),
                    !p &&
                      f &&
                      f.push(
                        '[' +
                          a.name +
                          '] Tag class "' +
                          a.tagClass +
                          '", type "' +
                          a.type +
                          '" expected value length "' +
                          a.value.length +
                          '", got "' +
                          l.value.length +
                          '"'
                      )
              if (
                p &&
                c &&
                (a.capture && (c[a.capture] = l.value),
                a.captureAsn1 && (c[a.captureAsn1] = l),
                a.captureBitStringContents &&
                  'bitStringContents' in l &&
                  (c[a.captureBitStringContents] = l.bitStringContents),
                a.captureBitStringValue && 'bitStringContents' in l)
              ) {
                var h
                if (l.bitStringContents.length < 2) c[a.captureBitStringValue] = ''
                else {
                  var m = l.bitStringContents.charCodeAt(0)
                  if (m !== 0) throw new Error('captureBitStringValue only supported for zero unused bits')
                  c[a.captureBitStringValue] = l.bitStringContents.slice(1)
                }
              }
            } else
              f && f.push('[' + a.name + '] Expected constructed "' + a.constructed + '", got "' + l.constructed + '"')
          else
            f &&
              (l.tagClass !== a.tagClass &&
                f.push('[' + a.name + '] Expected tag class "' + a.tagClass + '", got "' + l.tagClass + '"'),
              l.type !== a.type && f.push('[' + a.name + '] Expected type "' + a.type + '", got "' + l.type + '"'))
          return p
        })
      var o = /[^\\u0000-\\u00ff]/
      n.prettyPrint = function (l, a, c) {
        var f = ''
        ;(a = a || 0),
          (c = c || 2),
          a > 0 &&
            (f += `
`)
        for (var p = '', y = 0; y < a * c; ++y) p += ' '
        switch (((f += p + 'Tag: '), l.tagClass)) {
          case n.Class.UNIVERSAL:
            f += 'Universal:'
            break
          case n.Class.APPLICATION:
            f += 'Application:'
            break
          case n.Class.CONTEXT_SPECIFIC:
            f += 'Context-Specific:'
            break
          case n.Class.PRIVATE:
            f += 'Private:'
            break
        }
        if (l.tagClass === n.Class.UNIVERSAL)
          switch (((f += l.type), l.type)) {
            case n.Type.NONE:
              f += ' (None)'
              break
            case n.Type.BOOLEAN:
              f += ' (Boolean)'
              break
            case n.Type.INTEGER:
              f += ' (Integer)'
              break
            case n.Type.BITSTRING:
              f += ' (Bit string)'
              break
            case n.Type.OCTETSTRING:
              f += ' (Octet string)'
              break
            case n.Type.NULL:
              f += ' (Null)'
              break
            case n.Type.OID:
              f += ' (Object Identifier)'
              break
            case n.Type.ODESC:
              f += ' (Object Descriptor)'
              break
            case n.Type.EXTERNAL:
              f += ' (External or Instance of)'
              break
            case n.Type.REAL:
              f += ' (Real)'
              break
            case n.Type.ENUMERATED:
              f += ' (Enumerated)'
              break
            case n.Type.EMBEDDED:
              f += ' (Embedded PDV)'
              break
            case n.Type.UTF8:
              f += ' (UTF8)'
              break
            case n.Type.ROID:
              f += ' (Relative Object Identifier)'
              break
            case n.Type.SEQUENCE:
              f += ' (Sequence)'
              break
            case n.Type.SET:
              f += ' (Set)'
              break
            case n.Type.PRINTABLESTRING:
              f += ' (Printable String)'
              break
            case n.Type.IA5String:
              f += ' (IA5String (ASCII))'
              break
            case n.Type.UTCTIME:
              f += ' (UTC time)'
              break
            case n.Type.GENERALIZEDTIME:
              f += ' (Generalized time)'
              break
            case n.Type.BMPSTRING:
              f += ' (BMP String)'
              break
          }
        else f += l.type
        if (
          ((f += `
`),
          (f +=
            p +
            'Constructed: ' +
            l.constructed +
            `
`),
          l.composed)
        ) {
          for (var d = 0, h = '', y = 0; y < l.value.length; ++y)
            l.value[y] !== void 0 &&
              ((d += 1), (h += n.prettyPrint(l.value[y], a + 1, c)), y + 1 < l.value.length && (h += ','))
          f += p + 'Sub values: ' + d + h
        } else {
          if (((f += p + 'Value: '), l.type === n.Type.OID)) {
            var m = n.derToOid(l.value)
            ;(f += m), t.pki && t.pki.oids && m in t.pki.oids && (f += ' (' + t.pki.oids[m] + ') ')
          }
          if (l.type === n.Type.INTEGER)
            try {
              f += n.derToInteger(l.value)
            } catch (A) {
              f += '0x' + t.util.bytesToHex(l.value)
            }
          else if (l.type === n.Type.BITSTRING) {
            if (
              (l.value.length > 1 ? (f += '0x' + t.util.bytesToHex(l.value.slice(1))) : (f += '(none)'),
              l.value.length > 0)
            ) {
              var _ = l.value.charCodeAt(0)
              _ == 1 ? (f += ' (1 unused bit shown)') : _ > 1 && (f += ' (' + _ + ' unused bits shown)')
            }
          } else
            l.type === n.Type.OCTETSTRING
              ? (o.test(l.value) || (f += '(' + l.value + ') '), (f += '0x' + t.util.bytesToHex(l.value)))
              : l.type === n.Type.UTF8
              ? (f += t.util.decodeUtf8(l.value))
              : l.type === n.Type.PRINTABLESTRING || l.type === n.Type.IA5String
              ? (f += l.value)
              : o.test(l.value)
              ? (f += '0x' + t.util.bytesToHex(l.value))
              : l.value.length === 0
              ? (f += '[null]')
              : (f += l.value)
        }
        return f
      }
    }
  }),
  Z7 = te({
    'node_modules/node-forge/lib/cipher.js'(e, r) {
      V(), F()
      var t = yt()
      zt(),
        (r.exports = t.cipher = t.cipher || {}),
        (t.cipher.algorithms = t.cipher.algorithms || {}),
        (t.cipher.createCipher = function (i, s) {
          var u = i
          if ((typeof u == 'string' && ((u = t.cipher.getAlgorithm(u)), u && (u = u())), !u))
            throw new Error('Unsupported algorithm: ' + i)
          return new t.cipher.BlockCipher({ algorithm: u, key: s, decrypt: !1 })
        }),
        (t.cipher.createDecipher = function (i, s) {
          var u = i
          if ((typeof u == 'string' && ((u = t.cipher.getAlgorithm(u)), u && (u = u())), !u))
            throw new Error('Unsupported algorithm: ' + i)
          return new t.cipher.BlockCipher({ algorithm: u, key: s, decrypt: !0 })
        }),
        (t.cipher.registerAlgorithm = function (i, s) {
          ;(i = i.toUpperCase()), (t.cipher.algorithms[i] = s)
        }),
        (t.cipher.getAlgorithm = function (i) {
          return (i = i.toUpperCase()), i in t.cipher.algorithms ? t.cipher.algorithms[i] : null
        })
      var n = (t.cipher.BlockCipher = function (i) {
        ;(this.algorithm = i.algorithm),
          (this.mode = this.algorithm.mode),
          (this.blockSize = this.mode.blockSize),
          (this._finish = !1),
          (this._input = null),
          (this.output = null),
          (this._op = i.decrypt ? this.mode.decrypt : this.mode.encrypt),
          (this._decrypt = i.decrypt),
          this.algorithm.initialize(i)
      })
      ;(n.prototype.start = function (i) {
        i = i || {}
        var s = {}
        for (var u in i) s[u] = i[u]
        ;(s.decrypt = this._decrypt),
          (this._finish = !1),
          (this._input = t.util.createBuffer()),
          (this.output = i.output || t.util.createBuffer()),
          this.mode.start(s)
      }),
        (n.prototype.update = function (i) {
          for (
            i && this._input.putBuffer(i);
            !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish;

          );
          this._input.compact()
        }),
        (n.prototype.finish = function (i) {
          i &&
            (this.mode.name === 'ECB' || this.mode.name === 'CBC') &&
            ((this.mode.pad = function (u) {
              return i(this.blockSize, u, !1)
            }),
            (this.mode.unpad = function (u) {
              return i(this.blockSize, u, !0)
            }))
          var s = {}
          return (
            (s.decrypt = this._decrypt),
            (s.overflow = this._input.length() % this.blockSize),
            !(
              (!this._decrypt && this.mode.pad && !this.mode.pad(this._input, s)) ||
              ((this._finish = !0),
              this.update(),
              this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, s)) ||
              (this.mode.afterFinish && !this.mode.afterFinish(this.output, s))
            )
          )
        })
    }
  }),
  Q7 = te({
    'node_modules/node-forge/lib/cipherModes.js'(e, r) {
      V(), F()
      var t = yt()
      zt(), (t.cipher = t.cipher || {})
      var n = (r.exports = t.cipher.modes = t.cipher.modes || {})
      ;(n.ecb = function (o) {
        ;(o = o || {}),
          (this.name = 'ECB'),
          (this.cipher = o.cipher),
          (this.blockSize = o.blockSize || 16),
          (this._ints = this.blockSize / 4),
          (this._inBlock = new Array(this._ints)),
          (this._outBlock = new Array(this._ints))
      }),
        (n.ecb.prototype.start = function (o) {}),
        (n.ecb.prototype.encrypt = function (o, l, a) {
          if (o.length() < this.blockSize && !(a && o.length() > 0)) return !0
          for (var c = 0; c < this._ints; ++c) this._inBlock[c] = o.getInt32()
          this.cipher.encrypt(this._inBlock, this._outBlock)
          for (var c = 0; c < this._ints; ++c) l.putInt32(this._outBlock[c])
        }),
        (n.ecb.prototype.decrypt = function (o, l, a) {
          if (o.length() < this.blockSize && !(a && o.length() > 0)) return !0
          for (var c = 0; c < this._ints; ++c) this._inBlock[c] = o.getInt32()
          this.cipher.decrypt(this._inBlock, this._outBlock)
          for (var c = 0; c < this._ints; ++c) l.putInt32(this._outBlock[c])
        }),
        (n.ecb.prototype.pad = function (o, l) {
          var a = o.length() === this.blockSize ? this.blockSize : this.blockSize - o.length()
          return o.fillWithByte(a, a), !0
        }),
        (n.ecb.prototype.unpad = function (o, l) {
          if (l.overflow > 0) return !1
          var a = o.length(),
            c = o.at(a - 1)
          return c > this.blockSize << 2 ? !1 : (o.truncate(c), !0)
        }),
        (n.cbc = function (o) {
          ;(o = o || {}),
            (this.name = 'CBC'),
            (this.cipher = o.cipher),
            (this.blockSize = o.blockSize || 16),
            (this._ints = this.blockSize / 4),
            (this._inBlock = new Array(this._ints)),
            (this._outBlock = new Array(this._ints))
        }),
        (n.cbc.prototype.start = function (o) {
          if (o.iv === null) {
            if (!this._prev) throw new Error('Invalid IV parameter.')
            this._iv = this._prev.slice(0)
          } else if ('iv' in o) (this._iv = i(o.iv, this.blockSize)), (this._prev = this._iv.slice(0))
          else throw new Error('Invalid IV parameter.')
        }),
        (n.cbc.prototype.encrypt = function (o, l, a) {
          if (o.length() < this.blockSize && !(a && o.length() > 0)) return !0
          for (var c = 0; c < this._ints; ++c) this._inBlock[c] = this._prev[c] ^ o.getInt32()
          this.cipher.encrypt(this._inBlock, this._outBlock)
          for (var c = 0; c < this._ints; ++c) l.putInt32(this._outBlock[c])
          this._prev = this._outBlock
        }),
        (n.cbc.prototype.decrypt = function (o, l, a) {
          if (o.length() < this.blockSize && !(a && o.length() > 0)) return !0
          for (var c = 0; c < this._ints; ++c) this._inBlock[c] = o.getInt32()
          this.cipher.decrypt(this._inBlock, this._outBlock)
          for (var c = 0; c < this._ints; ++c) l.putInt32(this._prev[c] ^ this._outBlock[c])
          this._prev = this._inBlock.slice(0)
        }),
        (n.cbc.prototype.pad = function (o, l) {
          var a = o.length() === this.blockSize ? this.blockSize : this.blockSize - o.length()
          return o.fillWithByte(a, a), !0
        }),
        (n.cbc.prototype.unpad = function (o, l) {
          if (l.overflow > 0) return !1
          var a = o.length(),
            c = o.at(a - 1)
          return c > this.blockSize << 2 ? !1 : (o.truncate(c), !0)
        }),
        (n.cfb = function (o) {
          ;(o = o || {}),
            (this.name = 'CFB'),
            (this.cipher = o.cipher),
            (this.blockSize = o.blockSize || 16),
            (this._ints = this.blockSize / 4),
            (this._inBlock = null),
            (this._outBlock = new Array(this._ints)),
            (this._partialBlock = new Array(this._ints)),
            (this._partialOutput = t.util.createBuffer()),
            (this._partialBytes = 0)
        }),
        (n.cfb.prototype.start = function (o) {
          if (!('iv' in o)) throw new Error('Invalid IV parameter.')
          ;(this._iv = i(o.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
        }),
        (n.cfb.prototype.encrypt = function (o, l, a) {
          var c = o.length()
          if (c === 0) return !0
          if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && c >= this.blockSize)) {
            for (var f = 0; f < this._ints; ++f)
              (this._inBlock[f] = o.getInt32() ^ this._outBlock[f]), l.putInt32(this._inBlock[f])
            return
          }
          var p = (this.blockSize - c) % this.blockSize
          p > 0 && (p = this.blockSize - p), this._partialOutput.clear()
          for (var f = 0; f < this._ints; ++f)
            (this._partialBlock[f] = o.getInt32() ^ this._outBlock[f]),
              this._partialOutput.putInt32(this._partialBlock[f])
          if (p > 0) o.read -= this.blockSize
          else for (var f = 0; f < this._ints; ++f) this._inBlock[f] = this._partialBlock[f]
          if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), p > 0 && !a))
            return l.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), (this._partialBytes = p), !0
          l.putBytes(this._partialOutput.getBytes(c - this._partialBytes)), (this._partialBytes = 0)
        }),
        (n.cfb.prototype.decrypt = function (o, l, a) {
          var c = o.length()
          if (c === 0) return !0
          if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && c >= this.blockSize)) {
            for (var f = 0; f < this._ints; ++f)
              (this._inBlock[f] = o.getInt32()), l.putInt32(this._inBlock[f] ^ this._outBlock[f])
            return
          }
          var p = (this.blockSize - c) % this.blockSize
          p > 0 && (p = this.blockSize - p), this._partialOutput.clear()
          for (var f = 0; f < this._ints; ++f)
            (this._partialBlock[f] = o.getInt32()),
              this._partialOutput.putInt32(this._partialBlock[f] ^ this._outBlock[f])
          if (p > 0) o.read -= this.blockSize
          else for (var f = 0; f < this._ints; ++f) this._inBlock[f] = this._partialBlock[f]
          if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), p > 0 && !a))
            return l.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), (this._partialBytes = p), !0
          l.putBytes(this._partialOutput.getBytes(c - this._partialBytes)), (this._partialBytes = 0)
        }),
        (n.ofb = function (o) {
          ;(o = o || {}),
            (this.name = 'OFB'),
            (this.cipher = o.cipher),
            (this.blockSize = o.blockSize || 16),
            (this._ints = this.blockSize / 4),
            (this._inBlock = null),
            (this._outBlock = new Array(this._ints)),
            (this._partialOutput = t.util.createBuffer()),
            (this._partialBytes = 0)
        }),
        (n.ofb.prototype.start = function (o) {
          if (!('iv' in o)) throw new Error('Invalid IV parameter.')
          ;(this._iv = i(o.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
        }),
        (n.ofb.prototype.encrypt = function (o, l, a) {
          var c = o.length()
          if (o.length() === 0) return !0
          if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && c >= this.blockSize)) {
            for (var f = 0; f < this._ints; ++f)
              l.putInt32(o.getInt32() ^ this._outBlock[f]), (this._inBlock[f] = this._outBlock[f])
            return
          }
          var p = (this.blockSize - c) % this.blockSize
          p > 0 && (p = this.blockSize - p), this._partialOutput.clear()
          for (var f = 0; f < this._ints; ++f) this._partialOutput.putInt32(o.getInt32() ^ this._outBlock[f])
          if (p > 0) o.read -= this.blockSize
          else for (var f = 0; f < this._ints; ++f) this._inBlock[f] = this._outBlock[f]
          if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), p > 0 && !a))
            return l.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), (this._partialBytes = p), !0
          l.putBytes(this._partialOutput.getBytes(c - this._partialBytes)), (this._partialBytes = 0)
        }),
        (n.ofb.prototype.decrypt = n.ofb.prototype.encrypt),
        (n.ctr = function (o) {
          ;(o = o || {}),
            (this.name = 'CTR'),
            (this.cipher = o.cipher),
            (this.blockSize = o.blockSize || 16),
            (this._ints = this.blockSize / 4),
            (this._inBlock = null),
            (this._outBlock = new Array(this._ints)),
            (this._partialOutput = t.util.createBuffer()),
            (this._partialBytes = 0)
        }),
        (n.ctr.prototype.start = function (o) {
          if (!('iv' in o)) throw new Error('Invalid IV parameter.')
          ;(this._iv = i(o.iv, this.blockSize)), (this._inBlock = this._iv.slice(0)), (this._partialBytes = 0)
        }),
        (n.ctr.prototype.encrypt = function (o, l, a) {
          var c = o.length()
          if (c === 0) return !0
          if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && c >= this.blockSize))
            for (var f = 0; f < this._ints; ++f) l.putInt32(o.getInt32() ^ this._outBlock[f])
          else {
            var p = (this.blockSize - c) % this.blockSize
            p > 0 && (p = this.blockSize - p), this._partialOutput.clear()
            for (var f = 0; f < this._ints; ++f) this._partialOutput.putInt32(o.getInt32() ^ this._outBlock[f])
            if (
              (p > 0 && (o.read -= this.blockSize),
              this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes),
              p > 0 && !a)
            )
              return l.putBytes(this._partialOutput.getBytes(p - this._partialBytes)), (this._partialBytes = p), !0
            l.putBytes(this._partialOutput.getBytes(c - this._partialBytes)), (this._partialBytes = 0)
          }
          s(this._inBlock)
        }),
        (n.ctr.prototype.decrypt = n.ctr.prototype.encrypt),
        (n.gcm = function (o) {
          ;(o = o || {}),
            (this.name = 'GCM'),
            (this.cipher = o.cipher),
            (this.blockSize = o.blockSize || 16),
            (this._ints = this.blockSize / 4),
            (this._inBlock = new Array(this._ints)),
            (this._outBlock = new Array(this._ints)),
            (this._partialOutput = t.util.createBuffer()),
            (this._partialBytes = 0),
            (this._R = 3774873600)
        }),
        (n.gcm.prototype.start = function (o) {
          if (!('iv' in o)) throw new Error('Invalid IV parameter.')
          var l = t.util.createBuffer(o.iv)
          this._cipherLength = 0
          var a
          if (
            ('additionalData' in o ? (a = t.util.createBuffer(o.additionalData)) : (a = t.util.createBuffer()),
            'tagLength' in o ? (this._tagLength = o.tagLength) : (this._tagLength = 128),
            (this._tag = null),
            o.decrypt &&
              ((this._tag = t.util.createBuffer(o.tag).getBytes()), this._tag.length !== this._tagLength / 8))
          )
            throw new Error('Authentication tag does not match tag length.')
          ;(this._hashBlock = new Array(this._ints)),
            (this.tag = null),
            (this._hashSubkey = new Array(this._ints)),
            this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey),
            (this.componentBits = 4),
            (this._m = this.generateHashTable(this._hashSubkey, this.componentBits))
          var c = l.length()
          if (c === 12) this._j0 = [l.getInt32(), l.getInt32(), l.getInt32(), 1]
          else {
            for (this._j0 = [0, 0, 0, 0]; l.length() > 0; )
              this._j0 = this.ghash(this._hashSubkey, this._j0, [
                l.getInt32(),
                l.getInt32(),
                l.getInt32(),
                l.getInt32()
              ])
            this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(u(c * 8)))
          }
          ;(this._inBlock = this._j0.slice(0)),
            s(this._inBlock),
            (this._partialBytes = 0),
            (a = t.util.createBuffer(a)),
            (this._aDataLength = u(a.length() * 8))
          var f = a.length() % this.blockSize
          for (f && a.fillWithByte(0, this.blockSize - f), this._s = [0, 0, 0, 0]; a.length() > 0; )
            this._s = this.ghash(this._hashSubkey, this._s, [a.getInt32(), a.getInt32(), a.getInt32(), a.getInt32()])
        }),
        (n.gcm.prototype.encrypt = function (o, l, a) {
          var c = o.length()
          if (c === 0) return !0
          if ((this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && c >= this.blockSize)) {
            for (var f = 0; f < this._ints; ++f) l.putInt32((this._outBlock[f] ^= o.getInt32()))
            this._cipherLength += this.blockSize
          } else {
            var p = (this.blockSize - c) % this.blockSize
            p > 0 && (p = this.blockSize - p), this._partialOutput.clear()
            for (var f = 0; f < this._ints; ++f) this._partialOutput.putInt32(o.getInt32() ^ this._outBlock[f])
            if (p <= 0 || a) {
              if (a) {
                var y = c % this.blockSize
                ;(this._cipherLength += y), this._partialOutput.truncate(this.blockSize - y)
              } else this._cipherLength += this.blockSize
              for (var f = 0; f < this._ints; ++f) this._outBlock[f] = this._partialOutput.getInt32()
              this._partialOutput.read -= this.blockSize
            }
            if ((this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), p > 0 && !a))
              return (
                (o.read -= this.blockSize),
                l.putBytes(this._partialOutput.getBytes(p - this._partialBytes)),
                (this._partialBytes = p),
                !0
              )
            l.putBytes(this._partialOutput.getBytes(c - this._partialBytes)), (this._partialBytes = 0)
          }
          ;(this._s = this.ghash(this._hashSubkey, this._s, this._outBlock)), s(this._inBlock)
        }),
        (n.gcm.prototype.decrypt = function (o, l, a) {
          var c = o.length()
          if (c < this.blockSize && !(a && c > 0)) return !0
          this.cipher.encrypt(this._inBlock, this._outBlock),
            s(this._inBlock),
            (this._hashBlock[0] = o.getInt32()),
            (this._hashBlock[1] = o.getInt32()),
            (this._hashBlock[2] = o.getInt32()),
            (this._hashBlock[3] = o.getInt32()),
            (this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock))
          for (var f = 0; f < this._ints; ++f) l.putInt32(this._outBlock[f] ^ this._hashBlock[f])
          c < this.blockSize ? (this._cipherLength += c % this.blockSize) : (this._cipherLength += this.blockSize)
        }),
        (n.gcm.prototype.afterFinish = function (o, l) {
          var a = !0
          l.decrypt && l.overflow && o.truncate(this.blockSize - l.overflow), (this.tag = t.util.createBuffer())
          var c = this._aDataLength.concat(u(this._cipherLength * 8))
          this._s = this.ghash(this._hashSubkey, this._s, c)
          var f = []
          this.cipher.encrypt(this._j0, f)
          for (var p = 0; p < this._ints; ++p) this.tag.putInt32(this._s[p] ^ f[p])
          return (
            this.tag.truncate(this.tag.length() % (this._tagLength / 8)),
            l.decrypt && this.tag.bytes() !== this._tag && (a = !1),
            a
          )
        }),
        (n.gcm.prototype.multiply = function (o, l) {
          for (var a = [0, 0, 0, 0], c = l.slice(0), f = 0; f < 128; ++f) {
            var p = o[(f / 32) | 0] & (1 << (31 - (f % 32)))
            p && ((a[0] ^= c[0]), (a[1] ^= c[1]), (a[2] ^= c[2]), (a[3] ^= c[3])), this.pow(c, c)
          }
          return a
        }),
        (n.gcm.prototype.pow = function (o, l) {
          for (var a = o[3] & 1, c = 3; c > 0; --c) l[c] = (o[c] >>> 1) | ((o[c - 1] & 1) << 31)
          ;(l[0] = o[0] >>> 1), a && (l[0] ^= this._R)
        }),
        (n.gcm.prototype.tableMultiply = function (o) {
          for (var l = [0, 0, 0, 0], a = 0; a < 32; ++a) {
            var c = (a / 8) | 0,
              f = (o[c] >>> ((7 - (a % 8)) * 4)) & 15,
              p = this._m[a][f]
            ;(l[0] ^= p[0]), (l[1] ^= p[1]), (l[2] ^= p[2]), (l[3] ^= p[3])
          }
          return l
        }),
        (n.gcm.prototype.ghash = function (o, l, a) {
          return (l[0] ^= a[0]), (l[1] ^= a[1]), (l[2] ^= a[2]), (l[3] ^= a[3]), this.tableMultiply(l)
        }),
        (n.gcm.prototype.generateHashTable = function (o, l) {
          for (var a = 8 / l, c = 4 * a, f = 16 * a, p = new Array(f), y = 0; y < f; ++y) {
            var d = [0, 0, 0, 0],
              h = (y / c) | 0,
              m = (c - 1 - (y % c)) * l
            ;(d[h] = (1 << (l - 1)) << m), (p[y] = this.generateSubHashTable(this.multiply(d, o), l))
          }
          return p
        }),
        (n.gcm.prototype.generateSubHashTable = function (o, l) {
          var a = 1 << l,
            c = a >>> 1,
            f = new Array(a)
          f[c] = o.slice(0)
          for (var p = c >>> 1; p > 0; ) this.pow(f[2 * p], (f[p] = [])), (p >>= 1)
          for (p = 2; p < c; ) {
            for (var y = 1; y < p; ++y) {
              var d = f[p],
                h = f[y]
              f[p + y] = [d[0] ^ h[0], d[1] ^ h[1], d[2] ^ h[2], d[3] ^ h[3]]
            }
            p *= 2
          }
          for (f[0] = [0, 0, 0, 0], p = c + 1; p < a; ++p) {
            var m = f[p ^ c]
            f[p] = [o[0] ^ m[0], o[1] ^ m[1], o[2] ^ m[2], o[3] ^ m[3]]
          }
          return f
        })
      function i(o, l) {
        if ((typeof o == 'string' && (o = t.util.createBuffer(o)), t.util.isArray(o) && o.length > 4)) {
          var a = o
          o = t.util.createBuffer()
          for (var c = 0; c < a.length; ++c) o.putByte(a[c])
        }
        if (o.length() < l)
          throw new Error('Invalid IV length; got ' + o.length() + ' bytes and expected ' + l + ' bytes.')
        if (!t.util.isArray(o)) {
          for (var f = [], p = l / 4, c = 0; c < p; ++c) f.push(o.getInt32())
          o = f
        }
        return o
      }
      function s(o) {
        o[o.length - 1] = (o[o.length - 1] + 1) & 4294967295
      }
      function u(o) {
        return [(o / 4294967296) | 0, o & 4294967295]
      }
    }
  }),
  qc = te({
    'node_modules/node-forge/lib/aes.js'(e, r) {
      V(), F()
      var t = yt()
      Z7(),
        Q7(),
        zt(),
        (r.exports = t.aes = t.aes || {}),
        (t.aes.startEncrypting = function (h, m, _, A) {
          var T = d({ key: h, output: _, decrypt: !1, mode: A })
          return T.start(m), T
        }),
        (t.aes.createEncryptionCipher = function (h, m) {
          return d({ key: h, output: null, decrypt: !1, mode: m })
        }),
        (t.aes.startDecrypting = function (h, m, _, A) {
          var T = d({ key: h, output: _, decrypt: !0, mode: A })
          return T.start(m), T
        }),
        (t.aes.createDecryptionCipher = function (h, m) {
          return d({ key: h, output: null, decrypt: !0, mode: m })
        }),
        (t.aes.Algorithm = function (h, m) {
          i || f()
          var _ = this
          ;(_.name = h),
            (_.mode = new m({
              blockSize: 16,
              cipher: {
                encrypt: function (A, T) {
                  return y(_._w, A, T, !1)
                },
                decrypt: function (A, T) {
                  return y(_._w, A, T, !0)
                }
              }
            })),
            (_._init = !1)
        }),
        (t.aes.Algorithm.prototype.initialize = function (h) {
          if (!this._init) {
            var m = h.key,
              _
            if (typeof m == 'string' && (m.length === 16 || m.length === 24 || m.length === 32))
              m = t.util.createBuffer(m)
            else if (t.util.isArray(m) && (m.length === 16 || m.length === 24 || m.length === 32)) {
              ;(_ = m), (m = t.util.createBuffer())
              for (var A = 0; A < _.length; ++A) m.putByte(_[A])
            }
            if (!t.util.isArray(m)) {
              ;(_ = m), (m = [])
              var T = _.length()
              if (T === 16 || T === 24 || T === 32) {
                T = T >>> 2
                for (var A = 0; A < T; ++A) m.push(_.getInt32())
              }
            }
            if (!t.util.isArray(m) || !(m.length === 4 || m.length === 6 || m.length === 8))
              throw new Error('Invalid key parameter.')
            var E = this.mode.name,
              k = ['CFB', 'OFB', 'CTR', 'GCM'].indexOf(E) !== -1
            ;(this._w = p(m, h.decrypt && !k)), (this._init = !0)
          }
        }),
        (t.aes._expandKey = function (h, m) {
          return i || f(), p(h, m)
        }),
        (t.aes._updateBlock = y),
        n('AES-ECB', t.cipher.modes.ecb),
        n('AES-CBC', t.cipher.modes.cbc),
        n('AES-CFB', t.cipher.modes.cfb),
        n('AES-OFB', t.cipher.modes.ofb),
        n('AES-CTR', t.cipher.modes.ctr),
        n('AES-GCM', t.cipher.modes.gcm)
      function n(h, m) {
        var _ = function () {
          return new t.aes.Algorithm(h, m)
        }
        t.cipher.registerAlgorithm(h, _)
      }
      var i = !1,
        s = 4,
        u,
        o,
        l,
        a,
        c
      function f() {
        ;(i = !0), (l = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54])
        for (var h = new Array(256), m = 0; m < 128; ++m) (h[m] = m << 1), (h[m + 128] = ((m + 128) << 1) ^ 283)
        ;(u = new Array(256)), (o = new Array(256)), (a = new Array(4)), (c = new Array(4))
        for (var m = 0; m < 4; ++m) (a[m] = new Array(256)), (c[m] = new Array(256))
        for (var _ = 0, A = 0, T, E, k, w, v, I, M, m = 0; m < 256; ++m) {
          ;(w = A ^ (A << 1) ^ (A << 2) ^ (A << 3) ^ (A << 4)),
            (w = (w >> 8) ^ (w & 255) ^ 99),
            (u[_] = w),
            (o[w] = _),
            (v = h[w]),
            (T = h[_]),
            (E = h[T]),
            (k = h[E]),
            (I = (v << 24) ^ (w << 16) ^ (w << 8) ^ (w ^ v)),
            (M = ((T ^ E ^ k) << 24) ^ ((_ ^ k) << 16) ^ ((_ ^ E ^ k) << 8) ^ (_ ^ T ^ k))
          for (var q = 0; q < 4; ++q)
            (a[q][_] = I), (c[q][w] = M), (I = (I << 24) | (I >>> 8)), (M = (M << 24) | (M >>> 8))
          _ === 0 ? (_ = A = 1) : ((_ = T ^ h[h[h[T ^ k]]]), (A ^= h[h[A]]))
        }
      }
      function p(h, m) {
        for (var _ = h.slice(0), A, T = 1, E = _.length, k = E + 6 + 1, w = s * k, v = E; v < w; ++v)
          (A = _[v - 1]),
            v % E == 0
              ? ((A =
                  (u[(A >>> 16) & 255] << 24) ^
                  (u[(A >>> 8) & 255] << 16) ^
                  (u[A & 255] << 8) ^
                  u[A >>> 24] ^
                  (l[T] << 24)),
                T++)
              : E > 6 &&
                v % E == 4 &&
                (A = (u[A >>> 24] << 24) ^ (u[(A >>> 16) & 255] << 16) ^ (u[(A >>> 8) & 255] << 8) ^ u[A & 255]),
            (_[v] = _[v - E] ^ A)
        if (m) {
          var I,
            M = c[0],
            q = c[1],
            G = c[2],
            O = c[3],
            x = _.slice(0)
          w = _.length
          for (var v = 0, L = w - s; v < w; v += s, L -= s)
            if (v === 0 || v === w - s)
              (x[v] = _[L]), (x[v + 1] = _[L + 3]), (x[v + 2] = _[L + 2]), (x[v + 3] = _[L + 1])
            else
              for (var K = 0; K < s; ++K)
                (I = _[L + K]),
                  (x[v + (3 & -K)] = M[u[I >>> 24]] ^ q[u[(I >>> 16) & 255]] ^ G[u[(I >>> 8) & 255]] ^ O[u[I & 255]])
          _ = x
        }
        return _
      }
      function y(h, m, _, A) {
        var T = h.length / 4 - 1,
          E,
          k,
          w,
          v,
          I
        A
          ? ((E = c[0]), (k = c[1]), (w = c[2]), (v = c[3]), (I = o))
          : ((E = a[0]), (k = a[1]), (w = a[2]), (v = a[3]), (I = u))
        var M, q, G, O, x, L, K
        ;(M = m[0] ^ h[0]), (q = m[A ? 3 : 1] ^ h[1]), (G = m[2] ^ h[2]), (O = m[A ? 1 : 3] ^ h[3])
        for (var J = 3, Z = 1; Z < T; ++Z)
          (x = E[M >>> 24] ^ k[(q >>> 16) & 255] ^ w[(G >>> 8) & 255] ^ v[O & 255] ^ h[++J]),
            (L = E[q >>> 24] ^ k[(G >>> 16) & 255] ^ w[(O >>> 8) & 255] ^ v[M & 255] ^ h[++J]),
            (K = E[G >>> 24] ^ k[(O >>> 16) & 255] ^ w[(M >>> 8) & 255] ^ v[q & 255] ^ h[++J]),
            (O = E[O >>> 24] ^ k[(M >>> 16) & 255] ^ w[(q >>> 8) & 255] ^ v[G & 255] ^ h[++J]),
            (M = x),
            (q = L),
            (G = K)
        ;(_[0] = (I[M >>> 24] << 24) ^ (I[(q >>> 16) & 255] << 16) ^ (I[(G >>> 8) & 255] << 8) ^ I[O & 255] ^ h[++J]),
          (_[A ? 3 : 1] =
            (I[q >>> 24] << 24) ^ (I[(G >>> 16) & 255] << 16) ^ (I[(O >>> 8) & 255] << 8) ^ I[M & 255] ^ h[++J]),
          (_[2] = (I[G >>> 24] << 24) ^ (I[(O >>> 16) & 255] << 16) ^ (I[(M >>> 8) & 255] << 8) ^ I[q & 255] ^ h[++J]),
          (_[A ? 1 : 3] =
            (I[O >>> 24] << 24) ^ (I[(M >>> 16) & 255] << 16) ^ (I[(q >>> 8) & 255] << 8) ^ I[G & 255] ^ h[++J])
      }
      function d(h) {
        h = h || {}
        var m = (h.mode || 'CBC').toUpperCase(),
          _ = 'AES-' + m,
          A
        h.decrypt ? (A = t.cipher.createDecipher(_, h.key)) : (A = t.cipher.createCipher(_, h.key))
        var T = A.start
        return (
          (A.start = function (E, k) {
            var w = null
            k instanceof t.util.ByteBuffer && ((w = k), (k = {})),
              (k = k || {}),
              (k.output = w),
              (k.iv = E),
              T.call(A, k)
          }),
          A
        )
      }
    }
  }),
  Zp = te({
    'node_modules/node-forge/lib/des.js'(e, r) {
      V(), F()
      var t = yt()
      Z7(),
        Q7(),
        zt(),
        (r.exports = t.des = t.des || {}),
        (t.des.startEncrypting = function (h, m, _, A) {
          var T = d({ key: h, output: _, decrypt: !1, mode: A || (m === null ? 'ECB' : 'CBC') })
          return T.start(m), T
        }),
        (t.des.createEncryptionCipher = function (h, m) {
          return d({ key: h, output: null, decrypt: !1, mode: m })
        }),
        (t.des.startDecrypting = function (h, m, _, A) {
          var T = d({ key: h, output: _, decrypt: !0, mode: A || (m === null ? 'ECB' : 'CBC') })
          return T.start(m), T
        }),
        (t.des.createDecryptionCipher = function (h, m) {
          return d({ key: h, output: null, decrypt: !0, mode: m })
        }),
        (t.des.Algorithm = function (h, m) {
          var _ = this
          ;(_.name = h),
            (_.mode = new m({
              blockSize: 8,
              cipher: {
                encrypt: function (A, T) {
                  return y(_._keys, A, T, !1)
                },
                decrypt: function (A, T) {
                  return y(_._keys, A, T, !0)
                }
              }
            })),
            (_._init = !1)
        }),
        (t.des.Algorithm.prototype.initialize = function (h) {
          if (!this._init) {
            var m = t.util.createBuffer(h.key)
            if (this.name.indexOf('3DES') === 0 && m.length() !== 24)
              throw new Error('Invalid Triple-DES key size: ' + m.length() * 8)
            ;(this._keys = p(m)), (this._init = !0)
          }
        }),
        n('DES-ECB', t.cipher.modes.ecb),
        n('DES-CBC', t.cipher.modes.cbc),
        n('DES-CFB', t.cipher.modes.cfb),
        n('DES-OFB', t.cipher.modes.ofb),
        n('DES-CTR', t.cipher.modes.ctr),
        n('3DES-ECB', t.cipher.modes.ecb),
        n('3DES-CBC', t.cipher.modes.cbc),
        n('3DES-CFB', t.cipher.modes.cfb),
        n('3DES-OFB', t.cipher.modes.ofb),
        n('3DES-CTR', t.cipher.modes.ctr)
      function n(h, m) {
        var _ = function () {
          return new t.des.Algorithm(h, m)
        }
        t.cipher.registerAlgorithm(h, _)
      }
      var i = [
          16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756,
          16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220,
          65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756,
          65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564,
          16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756
        ],
        s = [
          -2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272,
          -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0,
          -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072,
          32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072,
          -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616,
          1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040,
          -2146402272, 1081344
        ],
        u = [
          520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072,
          134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592,
          134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072,
          134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072,
          134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8,
          134348808, 131584
        ],
        o = [
          8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736,
          8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928,
          8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801,
          8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128,
          8388608, 8192, 8396928
        ],
        l = [
          256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688,
          1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080,
          1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256,
          524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824,
          1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800,
          34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080
        ],
        a = [
          536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304,
          536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16,
          541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232,
          4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616,
          4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320,
          536887312, 0, 541081600, 536870912, 4194320, 536887312
        ],
        c = [
          2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2,
          67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154,
          69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914,
          69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050,
          67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048,
          2097154
        ],
        f = [
          268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240,
          268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696,
          4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664,
          4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760,
          262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208,
          268435456, 268701696
        ]
      function p(h) {
        for (
          var m = [
              0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048,
              66052, 536936960, 536936964
            ],
            _ = [
              0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120,
              67109121, 68157696, 68157697
            ],
            A = [
              0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264,
              16779272
            ],
            T = [
              0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800,
              136445952, 139264, 2236416, 134356992, 136454144
            ],
            E = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256],
            k = [
              0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456,
              33554464, 33555488
            ],
            w = [
              0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2,
              268435458, 524290, 268959746
            ],
            v = [
              0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656,
              537001984, 537067520, 537004032, 537069568
            ],
            I = [
              0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578,
              33554434, 33816578
            ],
            M = [
              0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480,
              1032, 268436488
            ],
            q = [
              0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768,
              1056800
            ],
            G = [
              0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592,
              69206016, 85983232, 69206528, 85983744
            ],
            O = [
              0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840,
              524304, 528400, 134742032, 134746128
            ],
            x = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261],
            L = h.length() > 8 ? 3 : 1,
            K = [],
            J = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
            Z = 0,
            Q,
            fe = 0;
          fe < L;
          fe++
        ) {
          var ie = h.getInt32(),
            W = h.getInt32()
          ;(Q = ((ie >>> 4) ^ W) & 252645135),
            (W ^= Q),
            (ie ^= Q << 4),
            (Q = ((W >>> -16) ^ ie) & 65535),
            (ie ^= Q),
            (W ^= Q << -16),
            (Q = ((ie >>> 2) ^ W) & 858993459),
            (W ^= Q),
            (ie ^= Q << 2),
            (Q = ((W >>> -16) ^ ie) & 65535),
            (ie ^= Q),
            (W ^= Q << -16),
            (Q = ((ie >>> 1) ^ W) & 1431655765),
            (W ^= Q),
            (ie ^= Q << 1),
            (Q = ((W >>> 8) ^ ie) & 16711935),
            (ie ^= Q),
            (W ^= Q << 8),
            (Q = ((ie >>> 1) ^ W) & 1431655765),
            (W ^= Q),
            (ie ^= Q << 1),
            (Q = (ie << 8) | ((W >>> 20) & 240)),
            (ie = (W << 24) | ((W << 8) & 16711680) | ((W >>> 8) & 65280) | ((W >>> 24) & 240)),
            (W = Q)
          for (var le = 0; le < J.length; ++le) {
            J[le]
              ? ((ie = (ie << 2) | (ie >>> 26)), (W = (W << 2) | (W >>> 26)))
              : ((ie = (ie << 1) | (ie >>> 27)), (W = (W << 1) | (W >>> 27))),
              (ie &= -15),
              (W &= -15)
            var xe =
                m[ie >>> 28] |
                _[(ie >>> 24) & 15] |
                A[(ie >>> 20) & 15] |
                T[(ie >>> 16) & 15] |
                E[(ie >>> 12) & 15] |
                k[(ie >>> 8) & 15] |
                w[(ie >>> 4) & 15],
              _e =
                v[W >>> 28] |
                I[(W >>> 24) & 15] |
                M[(W >>> 20) & 15] |
                q[(W >>> 16) & 15] |
                G[(W >>> 12) & 15] |
                O[(W >>> 8) & 15] |
                x[(W >>> 4) & 15]
            ;(Q = ((_e >>> 16) ^ xe) & 65535), (K[Z++] = xe ^ Q), (K[Z++] = _e ^ (Q << 16))
          }
        }
        return K
      }
      function y(h, m, _, A) {
        var T = h.length === 32 ? 3 : 9,
          E
        T === 3
          ? (E = A ? [30, -2, -2] : [0, 32, 2])
          : (E = A ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2])
        var k,
          w = m[0],
          v = m[1]
        ;(k = ((w >>> 4) ^ v) & 252645135),
          (v ^= k),
          (w ^= k << 4),
          (k = ((w >>> 16) ^ v) & 65535),
          (v ^= k),
          (w ^= k << 16),
          (k = ((v >>> 2) ^ w) & 858993459),
          (w ^= k),
          (v ^= k << 2),
          (k = ((v >>> 8) ^ w) & 16711935),
          (w ^= k),
          (v ^= k << 8),
          (k = ((w >>> 1) ^ v) & 1431655765),
          (v ^= k),
          (w ^= k << 1),
          (w = (w << 1) | (w >>> 31)),
          (v = (v << 1) | (v >>> 31))
        for (var I = 0; I < T; I += 3) {
          for (var M = E[I + 1], q = E[I + 2], G = E[I]; G != M; G += q) {
            var O = v ^ h[G],
              x = ((v >>> 4) | (v << 28)) ^ h[G + 1]
            ;(k = w),
              (w = v),
              (v =
                k ^
                (s[(O >>> 24) & 63] |
                  o[(O >>> 16) & 63] |
                  a[(O >>> 8) & 63] |
                  f[O & 63] |
                  i[(x >>> 24) & 63] |
                  u[(x >>> 16) & 63] |
                  l[(x >>> 8) & 63] |
                  c[x & 63]))
          }
          ;(k = w), (w = v), (v = k)
        }
        ;(w = (w >>> 1) | (w << 31)),
          (v = (v >>> 1) | (v << 31)),
          (k = ((w >>> 1) ^ v) & 1431655765),
          (v ^= k),
          (w ^= k << 1),
          (k = ((v >>> 8) ^ w) & 16711935),
          (w ^= k),
          (v ^= k << 8),
          (k = ((v >>> 2) ^ w) & 858993459),
          (w ^= k),
          (v ^= k << 2),
          (k = ((w >>> 16) ^ v) & 65535),
          (v ^= k),
          (w ^= k << 16),
          (k = ((w >>> 4) ^ v) & 252645135),
          (v ^= k),
          (w ^= k << 4),
          (_[0] = w),
          (_[1] = v)
      }
      function d(h) {
        h = h || {}
        var m = (h.mode || 'CBC').toUpperCase(),
          _ = 'DES-' + m,
          A
        h.decrypt ? (A = t.cipher.createDecipher(_, h.key)) : (A = t.cipher.createCipher(_, h.key))
        var T = A.start
        return (
          (A.start = function (E, k) {
            var w = null
            k instanceof t.util.ByteBuffer && ((w = k), (k = {})),
              (k = k || {}),
              (k.output = w),
              (k.iv = E),
              T.call(A, k)
          }),
          A
        )
      }
    }
  }),
  Es = te({
    'node_modules/node-forge/lib/md.js'(e, r) {
      V(), F()
      var t = yt()
      ;(r.exports = t.md = t.md || {}), (t.md.algorithms = t.md.algorithms || {})
    }
  }),
  JP = te({
    'node_modules/node-forge/lib/hmac.js'(e, r) {
      V(), F()
      var t = yt()
      Es(), zt()
      var n = (r.exports = t.hmac = t.hmac || {})
      n.create = function () {
        var i = null,
          s = null,
          u = null,
          o = null,
          l = {}
        return (
          (l.start = function (a, c) {
            if (a !== null)
              if (typeof a == 'string')
                if (((a = a.toLowerCase()), a in t.md.algorithms)) s = t.md.algorithms[a].create()
                else throw new Error('Unknown hash algorithm "' + a + '"')
              else s = a
            if (c === null) c = i
            else {
              if (typeof c == 'string') c = t.util.createBuffer(c)
              else if (t.util.isArray(c)) {
                var f = c
                c = t.util.createBuffer()
                for (var p = 0; p < f.length; ++p) c.putByte(f[p])
              }
              var y = c.length()
              y > s.blockLength && (s.start(), s.update(c.bytes()), (c = s.digest())),
                (u = t.util.createBuffer()),
                (o = t.util.createBuffer()),
                (y = c.length())
              for (var p = 0; p < y; ++p) {
                var f = c.at(p)
                u.putByte(54 ^ f), o.putByte(92 ^ f)
              }
              if (y < s.blockLength) for (var f = s.blockLength - y, p = 0; p < f; ++p) u.putByte(54), o.putByte(92)
              ;(i = c), (u = u.bytes()), (o = o.bytes())
            }
            s.start(), s.update(u)
          }),
          (l.update = function (a) {
            s.update(a)
          }),
          (l.getMac = function () {
            var a = s.digest().bytes()
            return s.start(), s.update(o), s.update(a), s.digest()
          }),
          (l.digest = l.getMac),
          l
        )
      }
    }
  }),
  tf = te({
    '(disabled):crypto'() {
      V(), F()
    }
  }),
  e9 = te({
    'node_modules/node-forge/lib/pbkdf2.js'(e, r) {
      V(), F()
      var t = yt()
      JP(), Es(), zt()
      var n = (t.pkcs5 = t.pkcs5 || {}),
        i
      t.util.isNodejs && !t.options.usePureJavaScript && (i = tf()),
        (r.exports =
          t.pbkdf2 =
          n.pbkdf2 =
            function (s, u, o, l, a, c) {
              if (
                (typeof a == 'function' && ((c = a), (a = null)),
                t.util.isNodejs &&
                  !t.options.usePureJavaScript &&
                  i.pbkdf2 &&
                  (a === null || typeof a != 'object') &&
                  (i.pbkdf2Sync.length > 4 || !a || a === 'sha1'))
              )
                return (
                  typeof a != 'string' && (a = 'sha1'),
                  (s = Ve.Buffer.from(s, 'binary')),
                  (u = Ve.Buffer.from(u, 'binary')),
                  c
                    ? i.pbkdf2Sync.length === 4
                      ? i.pbkdf2(s, u, o, l, function (I, M) {
                          if (I) return c(I)
                          c(null, M.toString('binary'))
                        })
                      : i.pbkdf2(s, u, o, l, a, function (I, M) {
                          if (I) return c(I)
                          c(null, M.toString('binary'))
                        })
                    : i.pbkdf2Sync.length === 4
                    ? i.pbkdf2Sync(s, u, o, l).toString('binary')
                    : i.pbkdf2Sync(s, u, o, l, a).toString('binary')
                )
              if (((typeof a == 'undefined' || a === null) && (a = 'sha1'), typeof a == 'string')) {
                if (!(a in t.md.algorithms)) throw new Error('Unknown hash algorithm: ' + a)
                a = t.md[a].create()
              }
              var f = a.digestLength
              if (l > 4294967295 * f) {
                var p = new Error('Derived key is too long.')
                if (c) return c(p)
                throw p
              }
              var y = Math.ceil(l / f),
                d = l - (y - 1) * f,
                h = t.hmac.create()
              h.start(a, s)
              var m = '',
                _,
                A,
                T
              if (!c) {
                for (var E = 1; E <= y; ++E) {
                  h.start(null, null), h.update(u), h.update(t.util.int32ToBytes(E)), (_ = T = h.digest().getBytes())
                  for (var k = 2; k <= o; ++k)
                    h.start(null, null),
                      h.update(T),
                      (A = h.digest().getBytes()),
                      (_ = t.util.xorBytes(_, A, f)),
                      (T = A)
                  m += E < y ? _ : _.substr(0, d)
                }
                return m
              }
              var E = 1,
                k
              function w() {
                if (E > y) return c(null, m)
                h.start(null, null),
                  h.update(u),
                  h.update(t.util.int32ToBytes(E)),
                  (_ = T = h.digest().getBytes()),
                  (k = 2),
                  v()
              }
              function v() {
                if (k <= o)
                  return (
                    h.start(null, null),
                    h.update(T),
                    (A = h.digest().getBytes()),
                    (_ = t.util.xorBytes(_, A, f)),
                    (T = A),
                    ++k,
                    t.util.setImmediate(v)
                  )
                ;(m += E < y ? _ : _.substr(0, d)), ++E, w()
              }
              w()
            })
    }
  }),
  Qp = te({
    'node_modules/node-forge/lib/pem.js'(e, r) {
      V(), F()
      var t = yt()
      zt()
      var n = (r.exports = t.pem = t.pem || {})
      ;(n.encode = function (u, o) {
        o = o || {}
        var l =
            '-----BEGIN ' +
            u.type +
            `-----\r
`,
          a
        if (
          (u.procType &&
            ((a = { name: 'Proc-Type', values: [String(u.procType.version), u.procType.type] }), (l += i(a))),
          u.contentDomain && ((a = { name: 'Content-Domain', values: [u.contentDomain] }), (l += i(a))),
          u.dekInfo &&
            ((a = { name: 'DEK-Info', values: [u.dekInfo.algorithm] }),
            u.dekInfo.parameters && a.values.push(u.dekInfo.parameters),
            (l += i(a))),
          u.headers)
        )
          for (var c = 0; c < u.headers.length; ++c) l += i(u.headers[c])
        return (
          u.procType &&
            (l += `\r
`),
          (l +=
            t.util.encode64(u.body, o.maxline || 64) +
            `\r
`),
          (l +=
            '-----END ' +
            u.type +
            `-----\r
`),
          l
        )
      }),
        (n.decode = function (u) {
          for (
            var o = [],
              l =
                /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,
              a = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,
              c = /\r?\n/,
              f;
            (f = l.exec(u)), !!f;

          ) {
            var p = {
              type: f[1],
              procType: null,
              contentDomain: null,
              dekInfo: null,
              headers: [],
              body: t.util.decode64(f[3])
            }
            if ((o.push(p), !!f[2])) {
              for (var y = f[2].split(c), d = 0; f && d < y.length; ) {
                for (var h = y[d].replace(/\s+$/, ''), m = d + 1; m < y.length; ++m) {
                  var _ = y[m]
                  if (!/\s/.test(_[0])) break
                  ;(h += _), (d = m)
                }
                if (((f = h.match(a)), f)) {
                  for (var A = { name: f[1], values: [] }, T = f[2].split(','), E = 0; E < T.length; ++E)
                    A.values.push(s(T[E]))
                  if (p.procType)
                    if (!p.contentDomain && A.name === 'Content-Domain') p.contentDomain = T[0] || ''
                    else if (!p.dekInfo && A.name === 'DEK-Info') {
                      if (A.values.length === 0)
                        throw new Error(
                          'Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.'
                        )
                      p.dekInfo = { algorithm: T[0], parameters: T[1] || null }
                    } else p.headers.push(A)
                  else {
                    if (A.name !== 'Proc-Type')
                      throw new Error(
                        'Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".'
                      )
                    if (A.values.length !== 2)
                      throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.')
                    p.procType = { version: T[0], type: T[1] }
                  }
                }
                ++d
              }
              if (p.procType === 'ENCRYPTED' && !p.dekInfo)
                throw new Error(
                  'Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".'
                )
            }
          }
          if (o.length === 0) throw new Error('Invalid PEM formatted message.')
          return o
        })
      function i(u) {
        for (
          var o = u.name + ': ',
            l = [],
            a = function (d, h) {
              return ' ' + h
            },
            c = 0;
          c < u.values.length;
          ++c
        )
          l.push(u.values[c].replace(/^(\S+\r\n)/, a))
        o +=
          l.join(',') +
          `\r
`
        for (var f = 0, p = -1, c = 0; c < o.length; ++c, ++f)
          if (f > 65 && p !== -1) {
            var y = o[p]
            y === ','
              ? (++p,
                (o =
                  o.substr(0, p) +
                  `\r
 ` +
                  o.substr(p)))
              : (o =
                  o.substr(0, p) +
                  `\r
` +
                  y +
                  o.substr(p + 1)),
              (f = c - p - 1),
              (p = -1),
              ++c
          } else (o[c] === ' ' || o[c] === '	' || o[c] === ',') && (p = c)
        return o
      }
      function s(u) {
        return u.replace(/^\s+/, '')
      }
    }
  }),
  XP = te({
    'node_modules/node-forge/lib/sha256.js'(e, r) {
      V(), F()
      var t = yt()
      Es(), zt()
      var n = (r.exports = t.sha256 = t.sha256 || {})
      ;(t.md.sha256 = t.md.algorithms.sha256 = n),
        (n.create = function () {
          s || o()
          var a = null,
            c = t.util.createBuffer(),
            f = new Array(64),
            p = {
              algorithm: 'sha256',
              blockLength: 64,
              digestLength: 32,
              messageLength: 0,
              fullMessageLength: null,
              messageLengthSize: 8
            }
          return (
            (p.start = function () {
              ;(p.messageLength = 0), (p.fullMessageLength = p.messageLength64 = [])
              for (var y = p.messageLengthSize / 4, d = 0; d < y; ++d) p.fullMessageLength.push(0)
              return (
                (c = t.util.createBuffer()),
                (a = {
                  h0: 1779033703,
                  h1: 3144134277,
                  h2: 1013904242,
                  h3: 2773480762,
                  h4: 1359893119,
                  h5: 2600822924,
                  h6: 528734635,
                  h7: 1541459225
                }),
                p
              )
            }),
            p.start(),
            (p.update = function (y, d) {
              d === 'utf8' && (y = t.util.encodeUtf8(y))
              var h = y.length
              ;(p.messageLength += h), (h = [(h / 4294967296) >>> 0, h >>> 0])
              for (var m = p.fullMessageLength.length - 1; m >= 0; --m)
                (p.fullMessageLength[m] += h[1]),
                  (h[1] = h[0] + ((p.fullMessageLength[m] / 4294967296) >>> 0)),
                  (p.fullMessageLength[m] = p.fullMessageLength[m] >>> 0),
                  (h[0] = (h[1] / 4294967296) >>> 0)
              return c.putBytes(y), l(a, f, c), (c.read > 2048 || c.length() === 0) && c.compact(), p
            }),
            (p.digest = function () {
              var y = t.util.createBuffer()
              y.putBytes(c.bytes())
              var d = p.fullMessageLength[p.fullMessageLength.length - 1] + p.messageLengthSize,
                h = d & (p.blockLength - 1)
              y.putBytes(i.substr(0, p.blockLength - h))
              for (var m, _, A = p.fullMessageLength[0] * 8, T = 0; T < p.fullMessageLength.length - 1; ++T)
                (m = p.fullMessageLength[T + 1] * 8),
                  (_ = (m / 4294967296) >>> 0),
                  (A += _),
                  y.putInt32(A >>> 0),
                  (A = m >>> 0)
              y.putInt32(A)
              var E = { h0: a.h0, h1: a.h1, h2: a.h2, h3: a.h3, h4: a.h4, h5: a.h5, h6: a.h6, h7: a.h7 }
              l(E, f, y)
              var k = t.util.createBuffer()
              return (
                k.putInt32(E.h0),
                k.putInt32(E.h1),
                k.putInt32(E.h2),
                k.putInt32(E.h3),
                k.putInt32(E.h4),
                k.putInt32(E.h5),
                k.putInt32(E.h6),
                k.putInt32(E.h7),
                k
              )
            }),
            p
          )
        })
      var i = null,
        s = !1,
        u = null
      function o() {
        ;(i = String.fromCharCode(128)),
          (i += t.util.fillString(String.fromCharCode(0), 64)),
          (u = [
            1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080,
            310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
            264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808,
            3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
            1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817,
            3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
            1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
            3329325298
          ]),
          (s = !0)
      }
      function l(a, c, f) {
        for (var p, y, d, h, m, _, A, T, E, k, w, v, I, M, q, G = f.length(); G >= 64; ) {
          for (A = 0; A < 16; ++A) c[A] = f.getInt32()
          for (; A < 64; ++A)
            (p = c[A - 2]),
              (p = ((p >>> 17) | (p << 15)) ^ ((p >>> 19) | (p << 13)) ^ (p >>> 10)),
              (y = c[A - 15]),
              (y = ((y >>> 7) | (y << 25)) ^ ((y >>> 18) | (y << 14)) ^ (y >>> 3)),
              (c[A] = (p + c[A - 7] + y + c[A - 16]) | 0)
          for (T = a.h0, E = a.h1, k = a.h2, w = a.h3, v = a.h4, I = a.h5, M = a.h6, q = a.h7, A = 0; A < 64; ++A)
            (h = ((v >>> 6) | (v << 26)) ^ ((v >>> 11) | (v << 21)) ^ ((v >>> 25) | (v << 7))),
              (m = M ^ (v & (I ^ M))),
              (d = ((T >>> 2) | (T << 30)) ^ ((T >>> 13) | (T << 19)) ^ ((T >>> 22) | (T << 10))),
              (_ = (T & E) | (k & (T ^ E))),
              (p = q + h + m + u[A] + c[A]),
              (y = d + _),
              (q = M),
              (M = I),
              (I = v),
              (v = (w + p) >>> 0),
              (w = k),
              (k = E),
              (E = T),
              (T = (p + y) >>> 0)
          ;(a.h0 = (a.h0 + T) | 0),
            (a.h1 = (a.h1 + E) | 0),
            (a.h2 = (a.h2 + k) | 0),
            (a.h3 = (a.h3 + w) | 0),
            (a.h4 = (a.h4 + v) | 0),
            (a.h5 = (a.h5 + I) | 0),
            (a.h6 = (a.h6 + M) | 0),
            (a.h7 = (a.h7 + q) | 0),
            (G -= 64)
        }
      }
    }
  }),
  YP = te({
    'node_modules/node-forge/lib/prng.js'(e, r) {
      V(), F()
      var t = yt()
      zt()
      var n = null
      t.util.isNodejs && !t.options.usePureJavaScript && !lt.versions['node-webkit'] && (n = tf())
      var i = (r.exports = t.prng = t.prng || {})
      i.create = function (s) {
        for (
          var u = { plugin: s, key: null, seed: null, time: null, reseeds: 0, generated: 0, keyBytes: '' },
            o = s.md,
            l = new Array(32),
            a = 0;
          a < 32;
          ++a
        )
          l[a] = o.create()
        ;(u.pools = l),
          (u.pool = 0),
          (u.generate = function (d, h) {
            if (!h) return u.generateSync(d)
            var m = u.plugin.cipher,
              _ = u.plugin.increment,
              A = u.plugin.formatKey,
              T = u.plugin.formatSeed,
              E = t.util.createBuffer()
            ;(u.key = null), k()
            function k(w) {
              if (w) return h(w)
              if (E.length() >= d) return h(null, E.getBytes(d))
              if ((u.generated > 1048575 && (u.key = null), u.key === null))
                return t.util.nextTick(function () {
                  c(k)
                })
              var v = m(u.key, u.seed)
              ;(u.generated += v.length),
                E.putBytes(v),
                (u.key = A(m(u.key, _(u.seed)))),
                (u.seed = T(m(u.key, u.seed))),
                t.util.setImmediate(k)
            }
          }),
          (u.generateSync = function (d) {
            var h = u.plugin.cipher,
              m = u.plugin.increment,
              _ = u.plugin.formatKey,
              A = u.plugin.formatSeed
            u.key = null
            for (var T = t.util.createBuffer(); T.length() < d; ) {
              u.generated > 1048575 && (u.key = null), u.key === null && f()
              var E = h(u.key, u.seed)
              ;(u.generated += E.length),
                T.putBytes(E),
                (u.key = _(h(u.key, m(u.seed)))),
                (u.seed = A(h(u.key, u.seed)))
            }
            return T.getBytes(d)
          })
        function c(d) {
          if (u.pools[0].messageLength >= 32) return p(), d()
          var h = (32 - u.pools[0].messageLength) << 5
          u.seedFile(h, function (m, _) {
            if (m) return d(m)
            u.collect(_), p(), d()
          })
        }
        function f() {
          if (u.pools[0].messageLength >= 32) return p()
          var d = (32 - u.pools[0].messageLength) << 5
          u.collect(u.seedFileSync(d)), p()
        }
        function p() {
          u.reseeds = u.reseeds === 4294967295 ? 0 : u.reseeds + 1
          var d = u.plugin.md.create()
          d.update(u.keyBytes)
          for (var h = 1, m = 0; m < 32; ++m)
            u.reseeds % h == 0 && (d.update(u.pools[m].digest().getBytes()), u.pools[m].start()), (h = h << 1)
          ;(u.keyBytes = d.digest().getBytes()), d.start(), d.update(u.keyBytes)
          var _ = d.digest().getBytes()
          ;(u.key = u.plugin.formatKey(u.keyBytes)), (u.seed = u.plugin.formatSeed(_)), (u.generated = 0)
        }
        function y(d) {
          var h = null,
            m = t.util.globalScope,
            _ = m.crypto || m.msCrypto
          _ &&
            _.getRandomValues &&
            (h = function (q) {
              return _.getRandomValues(q)
            })
          var A = t.util.createBuffer()
          if (h)
            for (; A.length() < d; ) {
              var T = Math.max(1, Math.min(d - A.length(), 65536) / 4),
                E = new Uint32Array(Math.floor(T))
              try {
                h(E)
                for (var k = 0; k < E.length; ++k) A.putInt32(E[k])
              } catch (q) {
                if (!(typeof QuotaExceededError != 'undefined' && q instanceof QuotaExceededError)) throw q
              }
            }
          if (A.length() < d)
            for (var w, v, I, M = Math.floor(Math.random() * 65536); A.length() < d; ) {
              ;(v = 16807 * (M & 65535)),
                (w = 16807 * (M >> 16)),
                (v += (w & 32767) << 16),
                (v += w >> 15),
                (v = (v & 2147483647) + (v >> 31)),
                (M = v & 4294967295)
              for (var k = 0; k < 3; ++k)
                (I = M >>> (k << 3)), (I ^= Math.floor(Math.random() * 256)), A.putByte(String.fromCharCode(I & 255))
            }
          return A.getBytes(d)
        }
        return (
          n
            ? ((u.seedFile = function (d, h) {
                n.randomBytes(d, function (m, _) {
                  if (m) return h(m)
                  h(null, _.toString())
                })
              }),
              (u.seedFileSync = function (d) {
                return n.randomBytes(d).toString()
              }))
            : ((u.seedFile = function (d, h) {
                try {
                  h(null, y(d))
                } catch (m) {
                  h(m)
                }
              }),
              (u.seedFileSync = y)),
          (u.collect = function (d) {
            for (var h = d.length, m = 0; m < h; ++m)
              u.pools[u.pool].update(d.substr(m, 1)), (u.pool = u.pool === 31 ? 0 : u.pool + 1)
          }),
          (u.collectInt = function (d, h) {
            for (var m = '', _ = 0; _ < h; _ += 8) m += String.fromCharCode((d >> _) & 255)
            u.collect(m)
          }),
          (u.registerWorker = function (d) {
            if (d === self)
              u.seedFile = function (m, _) {
                function A(T) {
                  var E = T.data
                  E.forge &&
                    E.forge.prng &&
                    (self.removeEventListener('message', A), _(E.forge.prng.err, E.forge.prng.bytes))
                }
                self.addEventListener('message', A), self.postMessage({ forge: { prng: { needed: m } } })
              }
            else {
              var h = function (m) {
                var _ = m.data
                _.forge &&
                  _.forge.prng &&
                  u.seedFile(_.forge.prng.needed, function (A, T) {
                    d.postMessage({ forge: { prng: { err: A, bytes: T } } })
                  })
              }
              d.addEventListener('message', h)
            }
          }),
          u
        )
      }
    }
  }),
  Ss = te({
    'node_modules/node-forge/lib/random.js'(e, r) {
      V(), F()
      var t = yt()
      qc(),
        XP(),
        YP(),
        zt(),
        (function () {
          if (t.random && t.random.getBytes) {
            r.exports = t.random
            return
          }
          ;(function (n) {
            var i = {},
              s = new Array(4),
              u = t.util.createBuffer()
            ;(i.formatKey = function (d) {
              var h = t.util.createBuffer(d)
              return (
                (d = new Array(4)),
                (d[0] = h.getInt32()),
                (d[1] = h.getInt32()),
                (d[2] = h.getInt32()),
                (d[3] = h.getInt32()),
                t.aes._expandKey(d, !1)
              )
            }),
              (i.formatSeed = function (d) {
                var h = t.util.createBuffer(d)
                return (
                  (d = new Array(4)),
                  (d[0] = h.getInt32()),
                  (d[1] = h.getInt32()),
                  (d[2] = h.getInt32()),
                  (d[3] = h.getInt32()),
                  d
                )
              }),
              (i.cipher = function (d, h) {
                return (
                  t.aes._updateBlock(d, h, s, !1),
                  u.putInt32(s[0]),
                  u.putInt32(s[1]),
                  u.putInt32(s[2]),
                  u.putInt32(s[3]),
                  u.getBytes()
                )
              }),
              (i.increment = function (d) {
                return ++d[3], d
              }),
              (i.md = t.md.sha256)
            function o() {
              var d = t.prng.create(i)
              return (
                (d.getBytes = function (h, m) {
                  return d.generate(h, m)
                }),
                (d.getBytesSync = function (h) {
                  return d.generate(h)
                }),
                d
              )
            }
            var l = o(),
              a = null,
              c = t.util.globalScope,
              f = c.crypto || c.msCrypto
            if (
              (f &&
                f.getRandomValues &&
                (a = function (d) {
                  return f.getRandomValues(d)
                }),
              t.options.usePureJavaScript || (!t.util.isNodejs && !a))
            ) {
              if (
                (typeof window == 'undefined' || window.document === void 0,
                l.collectInt(+new Date(), 32),
                typeof navigator != 'undefined')
              ) {
                var p = ''
                for (var y in navigator)
                  try {
                    typeof navigator[y] == 'string' && (p += navigator[y])
                  } catch (d) {}
                l.collect(p), (p = null)
              }
              n &&
                (n().mousemove(function (d) {
                  l.collectInt(d.clientX, 16), l.collectInt(d.clientY, 16)
                }),
                n().keypress(function (d) {
                  l.collectInt(d.charCode, 8)
                }))
            }
            if (!t.random) t.random = l
            else for (var y in l) t.random[y] = l[y]
            ;(t.random.createInstance = o), (r.exports = t.random)
          })(typeof jQuery != 'undefined' ? jQuery : null)
        })()
    }
  }),
  ZP = te({
    'node_modules/node-forge/lib/rc2.js'(e, r) {
      V(), F()
      var t = yt()
      zt()
      var n = [
          217, 120, 249, 196, 25, 221, 181, 237, 40, 233, 253, 121, 74, 160, 216, 157, 198, 126, 55, 131, 43, 118, 83,
          142, 98, 76, 100, 136, 68, 139, 251, 162, 23, 154, 89, 245, 135, 179, 79, 19, 97, 69, 109, 141, 9, 129, 125,
          50, 189, 143, 64, 235, 134, 183, 123, 11, 240, 149, 33, 34, 92, 107, 78, 130, 84, 214, 101, 147, 206, 96, 178,
          28, 115, 86, 192, 20, 167, 140, 241, 220, 18, 117, 202, 31, 59, 190, 228, 209, 66, 61, 212, 48, 163, 60, 182,
          38, 111, 191, 14, 218, 70, 105, 7, 87, 39, 242, 29, 155, 188, 148, 67, 3, 248, 17, 199, 246, 144, 239, 62,
          231, 6, 195, 213, 47, 200, 102, 30, 215, 8, 232, 234, 222, 128, 82, 238, 247, 132, 170, 114, 172, 53, 77, 106,
          42, 150, 26, 210, 113, 90, 21, 73, 116, 75, 159, 208, 94, 4, 24, 164, 236, 194, 224, 65, 110, 15, 81, 203,
          204, 36, 145, 175, 80, 161, 244, 112, 57, 153, 124, 58, 133, 35, 184, 180, 122, 252, 2, 54, 91, 37, 85, 151,
          49, 45, 93, 250, 152, 227, 138, 146, 174, 5, 223, 41, 16, 103, 108, 186, 201, 211, 0, 230, 207, 225, 158, 168,
          44, 99, 22, 1, 63, 88, 226, 137, 169, 13, 56, 52, 27, 171, 51, 255, 176, 187, 72, 12, 95, 185, 177, 205, 46,
          197, 243, 219, 71, 229, 165, 156, 119, 10, 166, 32, 104, 254, 127, 193, 173
        ],
        i = [1, 2, 3, 5],
        s = function (l, a) {
          return ((l << a) & 65535) | ((l & 65535) >> (16 - a))
        },
        u = function (l, a) {
          return ((l & 65535) >> a) | ((l << (16 - a)) & 65535)
        }
      ;(r.exports = t.rc2 = t.rc2 || {}),
        (t.rc2.expandKey = function (l, a) {
          typeof l == 'string' && (l = t.util.createBuffer(l)), (a = a || 128)
          var c = l,
            f = l.length(),
            p = a,
            y = Math.ceil(p / 8),
            d = 255 >> (p & 7),
            h
          for (h = f; h < 128; h++) c.putByte(n[(c.at(h - 1) + c.at(h - f)) & 255])
          for (c.setAt(128 - y, n[c.at(128 - y) & d]), h = 127 - y; h >= 0; h--)
            c.setAt(h, n[c.at(h + 1) ^ c.at(h + y)])
          return c
        })
      var o = function (l, a, c) {
        var f = !1,
          p = null,
          y = null,
          d = null,
          h,
          m,
          _,
          A,
          T = []
        for (l = t.rc2.expandKey(l, a), _ = 0; _ < 64; _++) T.push(l.getInt16Le())
        c
          ? ((h = function (w) {
              for (_ = 0; _ < 4; _++)
                (w[_] += T[A] + (w[(_ + 3) % 4] & w[(_ + 2) % 4]) + (~w[(_ + 3) % 4] & w[(_ + 1) % 4])),
                  (w[_] = s(w[_], i[_])),
                  A++
            }),
            (m = function (w) {
              for (_ = 0; _ < 4; _++) w[_] += T[w[(_ + 3) % 4] & 63]
            }))
          : ((h = function (w) {
              for (_ = 3; _ >= 0; _--)
                (w[_] = u(w[_], i[_])),
                  (w[_] -= T[A] + (w[(_ + 3) % 4] & w[(_ + 2) % 4]) + (~w[(_ + 3) % 4] & w[(_ + 1) % 4])),
                  A--
            }),
            (m = function (w) {
              for (_ = 3; _ >= 0; _--) w[_] -= T[w[(_ + 3) % 4] & 63]
            }))
        var E = function (w) {
            var v = []
            for (_ = 0; _ < 4; _++) {
              var I = p.getInt16Le()
              d !== null && (c ? (I ^= d.getInt16Le()) : d.putInt16Le(I)), v.push(I & 65535)
            }
            A = c ? 0 : 63
            for (var M = 0; M < w.length; M++) for (var q = 0; q < w[M][0]; q++) w[M][1](v)
            for (_ = 0; _ < 4; _++)
              d !== null && (c ? d.putInt16Le(v[_]) : (v[_] ^= d.getInt16Le())), y.putInt16Le(v[_])
          },
          k = null
        return (
          (k = {
            start: function (w, v) {
              w && typeof w == 'string' && (w = t.util.createBuffer(w)),
                (f = !1),
                (p = t.util.createBuffer()),
                (y = v || new t.util.createBuffer()),
                (d = w),
                (k.output = y)
            },
            update: function (w) {
              for (f || p.putBuffer(w); p.length() >= 8; )
                E([
                  [5, h],
                  [1, m],
                  [6, h],
                  [1, m],
                  [5, h]
                ])
            },
            finish: function (w) {
              var v = !0
              if (c)
                if (w) v = w(8, p, !c)
                else {
                  var I = p.length() === 8 ? 8 : 8 - p.length()
                  p.fillWithByte(I, I)
                }
              if ((v && ((f = !0), k.update()), !c && ((v = p.length() === 0), v)))
                if (w) v = w(8, y, !c)
                else {
                  var M = y.length(),
                    q = y.at(M - 1)
                  q > M ? (v = !1) : y.truncate(q)
                }
              return v
            }
          }),
          k
        )
      }
      ;(t.rc2.startEncrypting = function (l, a, c) {
        var f = t.rc2.createEncryptionCipher(l, 128)
        return f.start(a, c), f
      }),
        (t.rc2.createEncryptionCipher = function (l, a) {
          return o(l, a, !0)
        }),
        (t.rc2.startDecrypting = function (l, a, c) {
          var f = t.rc2.createDecryptionCipher(l, 128)
          return f.start(a, c), f
        }),
        (t.rc2.createDecryptionCipher = function (l, a) {
          return o(l, a, !1)
        })
    }
  }),
  rf = te({
    'node_modules/node-forge/lib/jsbn.js'(e, r) {
      V(), F()
      var t = yt()
      r.exports = t.jsbn = t.jsbn || {}
      var n,
        i = 244837814094590,
        s = (i & 16777215) == 15715070
      function u(de, pe, ye) {
        ;(this.data = []),
          de != null &&
            (typeof de == 'number'
              ? this.fromNumber(de, pe, ye)
              : pe == null && typeof de != 'string'
              ? this.fromString(de, 256)
              : this.fromString(de, pe))
      }
      t.jsbn.BigInteger = u
      function o() {
        return new u(null)
      }
      function l(de, pe, ye, Te, De, Le) {
        for (; --Le >= 0; ) {
          var $e = pe * this.data[de++] + ye.data[Te] + De
          ;(De = Math.floor($e / 67108864)), (ye.data[Te++] = $e & 67108863)
        }
        return De
      }
      function a(de, pe, ye, Te, De, Le) {
        for (var $e = pe & 32767, Fe = pe >> 15; --Le >= 0; ) {
          var Tt = this.data[de] & 32767,
            Gt = this.data[de++] >> 15,
            tr = Fe * Tt + Gt * $e
          ;(Tt = $e * Tt + ((tr & 32767) << 15) + ye.data[Te] + (De & 1073741823)),
            (De = (Tt >>> 30) + (tr >>> 15) + Fe * Gt + (De >>> 30)),
            (ye.data[Te++] = Tt & 1073741823)
        }
        return De
      }
      function c(de, pe, ye, Te, De, Le) {
        for (var $e = pe & 16383, Fe = pe >> 14; --Le >= 0; ) {
          var Tt = this.data[de] & 16383,
            Gt = this.data[de++] >> 14,
            tr = Fe * Tt + Gt * $e
          ;(Tt = $e * Tt + ((tr & 16383) << 14) + ye.data[Te] + De),
            (De = (Tt >> 28) + (tr >> 14) + Fe * Gt),
            (ye.data[Te++] = Tt & 268435455)
        }
        return De
      }
      typeof navigator == 'undefined'
        ? ((u.prototype.am = c), (n = 28))
        : s && navigator.appName == 'Microsoft Internet Explorer'
        ? ((u.prototype.am = a), (n = 30))
        : s && navigator.appName != 'Netscape'
        ? ((u.prototype.am = l), (n = 26))
        : ((u.prototype.am = c), (n = 28)),
        (u.prototype.DB = n),
        (u.prototype.DM = (1 << n) - 1),
        (u.prototype.DV = 1 << n)
      var f = 52
      ;(u.prototype.FV = Math.pow(2, f)), (u.prototype.F1 = f - n), (u.prototype.F2 = 2 * n - f)
      var p = '0123456789abcdefghijklmnopqrstuvwxyz',
        y = new Array(),
        d,
        h
      for (d = '0'.charCodeAt(0), h = 0; h <= 9; ++h) y[d++] = h
      for (d = 'a'.charCodeAt(0), h = 10; h < 36; ++h) y[d++] = h
      for (d = 'A'.charCodeAt(0), h = 10; h < 36; ++h) y[d++] = h
      function m(de) {
        return p.charAt(de)
      }
      function _(de, pe) {
        var ye = y[de.charCodeAt(pe)]
        return ye ?? -1
      }
      function A(de) {
        for (var pe = this.t - 1; pe >= 0; --pe) de.data[pe] = this.data[pe]
        ;(de.t = this.t), (de.s = this.s)
      }
      function T(de) {
        ;(this.t = 1),
          (this.s = de < 0 ? -1 : 0),
          de > 0 ? (this.data[0] = de) : de < -1 ? (this.data[0] = de + this.DV) : (this.t = 0)
      }
      function E(de) {
        var pe = o()
        return pe.fromInt(de), pe
      }
      function k(de, pe) {
        var ye
        if (pe == 16) ye = 4
        else if (pe == 8) ye = 3
        else if (pe == 256) ye = 8
        else if (pe == 2) ye = 1
        else if (pe == 32) ye = 5
        else if (pe == 4) ye = 2
        else {
          this.fromRadix(de, pe)
          return
        }
        ;(this.t = 0), (this.s = 0)
        for (var Te = de.length, De = !1, Le = 0; --Te >= 0; ) {
          var $e = ye == 8 ? de[Te] & 255 : _(de, Te)
          if ($e < 0) {
            de.charAt(Te) == '-' && (De = !0)
            continue
          }
          ;(De = !1),
            Le == 0
              ? (this.data[this.t++] = $e)
              : Le + ye > this.DB
              ? ((this.data[this.t - 1] |= ($e & ((1 << (this.DB - Le)) - 1)) << Le),
                (this.data[this.t++] = $e >> (this.DB - Le)))
              : (this.data[this.t - 1] |= $e << Le),
            (Le += ye),
            Le >= this.DB && (Le -= this.DB)
        }
        ye == 8 &&
          (de[0] & 128) != 0 &&
          ((this.s = -1), Le > 0 && (this.data[this.t - 1] |= ((1 << (this.DB - Le)) - 1) << Le)),
          this.clamp(),
          De && u.ZERO.subTo(this, this)
      }
      function w() {
        for (var de = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == de; ) --this.t
      }
      function v(de) {
        if (this.s < 0) return '-' + this.negate().toString(de)
        var pe
        if (de == 16) pe = 4
        else if (de == 8) pe = 3
        else if (de == 2) pe = 1
        else if (de == 32) pe = 5
        else if (de == 4) pe = 2
        else return this.toRadix(de)
        var ye = (1 << pe) - 1,
          Te,
          De = !1,
          Le = '',
          $e = this.t,
          Fe = this.DB - (($e * this.DB) % pe)
        if ($e-- > 0)
          for (Fe < this.DB && (Te = this.data[$e] >> Fe) > 0 && ((De = !0), (Le = m(Te))); $e >= 0; )
            Fe < pe
              ? ((Te = (this.data[$e] & ((1 << Fe) - 1)) << (pe - Fe)), (Te |= this.data[--$e] >> (Fe += this.DB - pe)))
              : ((Te = (this.data[$e] >> (Fe -= pe)) & ye), Fe <= 0 && ((Fe += this.DB), --$e)),
              Te > 0 && (De = !0),
              De && (Le += m(Te))
        return De ? Le : '0'
      }
      function I() {
        var de = o()
        return u.ZERO.subTo(this, de), de
      }
      function M() {
        return this.s < 0 ? this.negate() : this
      }
      function q(de) {
        var pe = this.s - de.s
        if (pe != 0) return pe
        var ye = this.t
        if (((pe = ye - de.t), pe != 0)) return this.s < 0 ? -pe : pe
        for (; --ye >= 0; ) if ((pe = this.data[ye] - de.data[ye]) != 0) return pe
        return 0
      }
      function G(de) {
        var pe = 1,
          ye
        return (
          (ye = de >>> 16) != 0 && ((de = ye), (pe += 16)),
          (ye = de >> 8) != 0 && ((de = ye), (pe += 8)),
          (ye = de >> 4) != 0 && ((de = ye), (pe += 4)),
          (ye = de >> 2) != 0 && ((de = ye), (pe += 2)),
          (ye = de >> 1) != 0 && ((de = ye), (pe += 1)),
          pe
        )
      }
      function O() {
        return this.t <= 0 ? 0 : this.DB * (this.t - 1) + G(this.data[this.t - 1] ^ (this.s & this.DM))
      }
      function x(de, pe) {
        var ye
        for (ye = this.t - 1; ye >= 0; --ye) pe.data[ye + de] = this.data[ye]
        for (ye = de - 1; ye >= 0; --ye) pe.data[ye] = 0
        ;(pe.t = this.t + de), (pe.s = this.s)
      }
      function L(de, pe) {
        for (var ye = de; ye < this.t; ++ye) pe.data[ye - de] = this.data[ye]
        ;(pe.t = Math.max(this.t - de, 0)), (pe.s = this.s)
      }
      function K(de, pe) {
        var ye = de % this.DB,
          Te = this.DB - ye,
          De = (1 << Te) - 1,
          Le = Math.floor(de / this.DB),
          $e = (this.s << ye) & this.DM,
          Fe
        for (Fe = this.t - 1; Fe >= 0; --Fe)
          (pe.data[Fe + Le + 1] = (this.data[Fe] >> Te) | $e), ($e = (this.data[Fe] & De) << ye)
        for (Fe = Le - 1; Fe >= 0; --Fe) pe.data[Fe] = 0
        ;(pe.data[Le] = $e), (pe.t = this.t + Le + 1), (pe.s = this.s), pe.clamp()
      }
      function J(de, pe) {
        pe.s = this.s
        var ye = Math.floor(de / this.DB)
        if (ye >= this.t) {
          pe.t = 0
          return
        }
        var Te = de % this.DB,
          De = this.DB - Te,
          Le = (1 << Te) - 1
        pe.data[0] = this.data[ye] >> Te
        for (var $e = ye + 1; $e < this.t; ++$e)
          (pe.data[$e - ye - 1] |= (this.data[$e] & Le) << De), (pe.data[$e - ye] = this.data[$e] >> Te)
        Te > 0 && (pe.data[this.t - ye - 1] |= (this.s & Le) << De), (pe.t = this.t - ye), pe.clamp()
      }
      function Z(de, pe) {
        for (var ye = 0, Te = 0, De = Math.min(de.t, this.t); ye < De; )
          (Te += this.data[ye] - de.data[ye]), (pe.data[ye++] = Te & this.DM), (Te >>= this.DB)
        if (de.t < this.t) {
          for (Te -= de.s; ye < this.t; ) (Te += this.data[ye]), (pe.data[ye++] = Te & this.DM), (Te >>= this.DB)
          Te += this.s
        } else {
          for (Te += this.s; ye < de.t; ) (Te -= de.data[ye]), (pe.data[ye++] = Te & this.DM), (Te >>= this.DB)
          Te -= de.s
        }
        ;(pe.s = Te < 0 ? -1 : 0),
          Te < -1 ? (pe.data[ye++] = this.DV + Te) : Te > 0 && (pe.data[ye++] = Te),
          (pe.t = ye),
          pe.clamp()
      }
      function Q(de, pe) {
        var ye = this.abs(),
          Te = de.abs(),
          De = ye.t
        for (pe.t = De + Te.t; --De >= 0; ) pe.data[De] = 0
        for (De = 0; De < Te.t; ++De) pe.data[De + ye.t] = ye.am(0, Te.data[De], pe, De, 0, ye.t)
        ;(pe.s = 0), pe.clamp(), this.s != de.s && u.ZERO.subTo(pe, pe)
      }
      function fe(de) {
        for (var pe = this.abs(), ye = (de.t = 2 * pe.t); --ye >= 0; ) de.data[ye] = 0
        for (ye = 0; ye < pe.t - 1; ++ye) {
          var Te = pe.am(ye, pe.data[ye], de, 2 * ye, 0, 1)
          ;(de.data[ye + pe.t] += pe.am(ye + 1, 2 * pe.data[ye], de, 2 * ye + 1, Te, pe.t - ye - 1)) >= pe.DV &&
            ((de.data[ye + pe.t] -= pe.DV), (de.data[ye + pe.t + 1] = 1))
        }
        de.t > 0 && (de.data[de.t - 1] += pe.am(ye, pe.data[ye], de, 2 * ye, 0, 1)), (de.s = 0), de.clamp()
      }
      function ie(de, pe, ye) {
        var Te = de.abs()
        if (!(Te.t <= 0)) {
          var De = this.abs()
          if (De.t < Te.t) {
            pe != null && pe.fromInt(0), ye != null && this.copyTo(ye)
            return
          }
          ye == null && (ye = o())
          var Le = o(),
            $e = this.s,
            Fe = de.s,
            Tt = this.DB - G(Te.data[Te.t - 1])
          Tt > 0 ? (Te.lShiftTo(Tt, Le), De.lShiftTo(Tt, ye)) : (Te.copyTo(Le), De.copyTo(ye))
          var Gt = Le.t,
            tr = Le.data[Gt - 1]
          if (tr != 0) {
            var Zt = tr * (1 << this.F1) + (Gt > 1 ? Le.data[Gt - 2] >> this.F2 : 0),
              Lr = this.FV / Zt,
              An = (1 << this.F1) / Zt,
              yr = 1 << this.F2,
              nr = ye.t,
              ce = nr - Gt,
              he = pe ?? o()
            for (
              Le.dlShiftTo(ce, he),
                ye.compareTo(he) >= 0 && ((ye.data[ye.t++] = 1), ye.subTo(he, ye)),
                u.ONE.dlShiftTo(Gt, he),
                he.subTo(Le, Le);
              Le.t < Gt;

            )
              Le.data[Le.t++] = 0
            for (; --ce >= 0; ) {
              var ve = ye.data[--nr] == tr ? this.DM : Math.floor(ye.data[nr] * Lr + (ye.data[nr - 1] + yr) * An)
              if ((ye.data[nr] += Le.am(0, ve, ye, ce, 0, Gt)) < ve)
                for (Le.dlShiftTo(ce, he), ye.subTo(he, ye); ye.data[nr] < --ve; ) ye.subTo(he, ye)
            }
            pe != null && (ye.drShiftTo(Gt, pe), $e != Fe && u.ZERO.subTo(pe, pe)),
              (ye.t = Gt),
              ye.clamp(),
              Tt > 0 && ye.rShiftTo(Tt, ye),
              $e < 0 && u.ZERO.subTo(ye, ye)
          }
        }
      }
      function W(de) {
        var pe = o()
        return this.abs().divRemTo(de, null, pe), this.s < 0 && pe.compareTo(u.ZERO) > 0 && de.subTo(pe, pe), pe
      }
      function le(de) {
        this.m = de
      }
      function xe(de) {
        return de.s < 0 || de.compareTo(this.m) >= 0 ? de.mod(this.m) : de
      }
      function _e(de) {
        return de
      }
      function Ne(de) {
        de.divRemTo(this.m, null, de)
      }
      function ke(de, pe, ye) {
        de.multiplyTo(pe, ye), this.reduce(ye)
      }
      function oe(de, pe) {
        de.squareTo(pe), this.reduce(pe)
      }
      ;(le.prototype.convert = xe),
        (le.prototype.revert = _e),
        (le.prototype.reduce = Ne),
        (le.prototype.mulTo = ke),
        (le.prototype.sqrTo = oe)
      function be() {
        if (this.t < 1) return 0
        var de = this.data[0]
        if ((de & 1) == 0) return 0
        var pe = de & 3
        return (
          (pe = (pe * (2 - (de & 15) * pe)) & 15),
          (pe = (pe * (2 - (de & 255) * pe)) & 255),
          (pe = (pe * (2 - (((de & 65535) * pe) & 65535))) & 65535),
          (pe = (pe * (2 - ((de * pe) % this.DV))) % this.DV),
          pe > 0 ? this.DV - pe : -pe
        )
      }
      function ge(de) {
        ;(this.m = de),
          (this.mp = de.invDigit()),
          (this.mpl = this.mp & 32767),
          (this.mph = this.mp >> 15),
          (this.um = (1 << (de.DB - 15)) - 1),
          (this.mt2 = 2 * de.t)
      }
      function re(de) {
        var pe = o()
        return (
          de.abs().dlShiftTo(this.m.t, pe),
          pe.divRemTo(this.m, null, pe),
          de.s < 0 && pe.compareTo(u.ZERO) > 0 && this.m.subTo(pe, pe),
          pe
        )
      }
      function j(de) {
        var pe = o()
        return de.copyTo(pe), this.reduce(pe), pe
      }
      function b(de) {
        for (; de.t <= this.mt2; ) de.data[de.t++] = 0
        for (var pe = 0; pe < this.m.t; ++pe) {
          var ye = de.data[pe] & 32767,
            Te = (ye * this.mpl + (((ye * this.mph + (de.data[pe] >> 15) * this.mpl) & this.um) << 15)) & de.DM
          for (ye = pe + this.m.t, de.data[ye] += this.m.am(0, Te, de, pe, 0, this.m.t); de.data[ye] >= de.DV; )
            (de.data[ye] -= de.DV), de.data[++ye]++
        }
        de.clamp(), de.drShiftTo(this.m.t, de), de.compareTo(this.m) >= 0 && de.subTo(this.m, de)
      }
      function C(de, pe) {
        de.squareTo(pe), this.reduce(pe)
      }
      function S(de, pe, ye) {
        de.multiplyTo(pe, ye), this.reduce(ye)
      }
      ;(ge.prototype.convert = re),
        (ge.prototype.revert = j),
        (ge.prototype.reduce = b),
        (ge.prototype.mulTo = S),
        (ge.prototype.sqrTo = C)
      function R() {
        return (this.t > 0 ? this.data[0] & 1 : this.s) == 0
      }
      function P(de, pe) {
        if (de > 4294967295 || de < 1) return u.ONE
        var ye = o(),
          Te = o(),
          De = pe.convert(this),
          Le = G(de) - 1
        for (De.copyTo(ye); --Le >= 0; )
          if ((pe.sqrTo(ye, Te), (de & (1 << Le)) > 0)) pe.mulTo(Te, De, ye)
          else {
            var $e = ye
            ;(ye = Te), (Te = $e)
          }
        return pe.revert(ye)
      }
      function B(de, pe) {
        var ye
        return de < 256 || pe.isEven() ? (ye = new le(pe)) : (ye = new ge(pe)), this.exp(de, ye)
      }
      ;(u.prototype.copyTo = A),
        (u.prototype.fromInt = T),
        (u.prototype.fromString = k),
        (u.prototype.clamp = w),
        (u.prototype.dlShiftTo = x),
        (u.prototype.drShiftTo = L),
        (u.prototype.lShiftTo = K),
        (u.prototype.rShiftTo = J),
        (u.prototype.subTo = Z),
        (u.prototype.multiplyTo = Q),
        (u.prototype.squareTo = fe),
        (u.prototype.divRemTo = ie),
        (u.prototype.invDigit = be),
        (u.prototype.isEven = R),
        (u.prototype.exp = P),
        (u.prototype.toString = v),
        (u.prototype.negate = I),
        (u.prototype.abs = M),
        (u.prototype.compareTo = q),
        (u.prototype.bitLength = O),
        (u.prototype.mod = W),
        (u.prototype.modPowInt = B),
        (u.ZERO = E(0)),
        (u.ONE = E(1))
      function D() {
        var de = o()
        return this.copyTo(de), de
      }
      function $() {
        if (this.s < 0) {
          if (this.t == 1) return this.data[0] - this.DV
          if (this.t == 0) return -1
        } else {
          if (this.t == 1) return this.data[0]
          if (this.t == 0) return 0
        }
        return ((this.data[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this.data[0]
      }
      function g() {
        return this.t == 0 ? this.s : (this.data[0] << 24) >> 24
      }
      function N() {
        return this.t == 0 ? this.s : (this.data[0] << 16) >> 16
      }
      function U(de) {
        return Math.floor((Math.LN2 * this.DB) / Math.log(de))
      }
      function X() {
        return this.s < 0 ? -1 : this.t <= 0 || (this.t == 1 && this.data[0] <= 0) ? 0 : 1
      }
      function ne(de) {
        if ((de == null && (de = 10), this.signum() == 0 || de < 2 || de > 36)) return '0'
        var pe = this.chunkSize(de),
          ye = Math.pow(de, pe),
          Te = E(ye),
          De = o(),
          Le = o(),
          $e = ''
        for (this.divRemTo(Te, De, Le); De.signum() > 0; )
          ($e = (ye + Le.intValue()).toString(de).substr(1) + $e), De.divRemTo(Te, De, Le)
        return Le.intValue().toString(de) + $e
      }
      function ee(de, pe) {
        this.fromInt(0), pe == null && (pe = 10)
        for (
          var ye = this.chunkSize(pe), Te = Math.pow(pe, ye), De = !1, Le = 0, $e = 0, Fe = 0;
          Fe < de.length;
          ++Fe
        ) {
          var Tt = _(de, Fe)
          if (Tt < 0) {
            de.charAt(Fe) == '-' && this.signum() == 0 && (De = !0)
            continue
          }
          ;($e = pe * $e + Tt), ++Le >= ye && (this.dMultiply(Te), this.dAddOffset($e, 0), (Le = 0), ($e = 0))
        }
        Le > 0 && (this.dMultiply(Math.pow(pe, Le)), this.dAddOffset($e, 0)), De && u.ZERO.subTo(this, this)
      }
      function ae(de, pe, ye) {
        if (typeof pe == 'number')
          if (de < 2) this.fromInt(1)
          else
            for (
              this.fromNumber(de, ye),
                this.testBit(de - 1) || this.bitwiseTo(u.ONE.shiftLeft(de - 1), Me, this),
                this.isEven() && this.dAddOffset(1, 0);
              !this.isProbablePrime(pe);

            )
              this.dAddOffset(2, 0), this.bitLength() > de && this.subTo(u.ONE.shiftLeft(de - 1), this)
        else {
          var Te = new Array(),
            De = de & 7
          ;(Te.length = (de >> 3) + 1),
            pe.nextBytes(Te),
            De > 0 ? (Te[0] &= (1 << De) - 1) : (Te[0] = 0),
            this.fromString(Te, 256)
        }
      }
      function Y() {
        var de = this.t,
          pe = new Array()
        pe[0] = this.s
        var ye = this.DB - ((de * this.DB) % 8),
          Te,
          De = 0
        if (de-- > 0)
          for (
            ye < this.DB &&
            (Te = this.data[de] >> ye) != (this.s & this.DM) >> ye &&
            (pe[De++] = Te | (this.s << (this.DB - ye)));
            de >= 0;

          )
            ye < 8
              ? ((Te = (this.data[de] & ((1 << ye) - 1)) << (8 - ye)), (Te |= this.data[--de] >> (ye += this.DB - 8)))
              : ((Te = (this.data[de] >> (ye -= 8)) & 255), ye <= 0 && ((ye += this.DB), --de)),
              (Te & 128) != 0 && (Te |= -256),
              De == 0 && (this.s & 128) != (Te & 128) && ++De,
              (De > 0 || Te != this.s) && (pe[De++] = Te)
        return pe
      }
      function z(de) {
        return this.compareTo(de) == 0
      }
      function H(de) {
        return this.compareTo(de) < 0 ? this : de
      }
      function se(de) {
        return this.compareTo(de) > 0 ? this : de
      }
      function me(de, pe, ye) {
        var Te,
          De,
          Le = Math.min(de.t, this.t)
        for (Te = 0; Te < Le; ++Te) ye.data[Te] = pe(this.data[Te], de.data[Te])
        if (de.t < this.t) {
          for (De = de.s & this.DM, Te = Le; Te < this.t; ++Te) ye.data[Te] = pe(this.data[Te], De)
          ye.t = this.t
        } else {
          for (De = this.s & this.DM, Te = Le; Te < de.t; ++Te) ye.data[Te] = pe(De, de.data[Te])
          ye.t = de.t
        }
        ;(ye.s = pe(this.s, de.s)), ye.clamp()
      }
      function we(de, pe) {
        return de & pe
      }
      function Ee(de) {
        var pe = o()
        return this.bitwiseTo(de, we, pe), pe
      }
      function Me(de, pe) {
        return de | pe
      }
      function Be(de) {
        var pe = o()
        return this.bitwiseTo(de, Me, pe), pe
      }
      function je(de, pe) {
        return de ^ pe
      }
      function Pe(de) {
        var pe = o()
        return this.bitwiseTo(de, je, pe), pe
      }
      function Oe(de, pe) {
        return de & ~pe
      }
      function ht(de) {
        var pe = o()
        return this.bitwiseTo(de, Oe, pe), pe
      }
      function Qe() {
        for (var de = o(), pe = 0; pe < this.t; ++pe) de.data[pe] = this.DM & ~this.data[pe]
        return (de.t = this.t), (de.s = ~this.s), de
      }
      function et(de) {
        var pe = o()
        return de < 0 ? this.rShiftTo(-de, pe) : this.lShiftTo(de, pe), pe
      }
      function Mt(de) {
        var pe = o()
        return de < 0 ? this.lShiftTo(-de, pe) : this.rShiftTo(de, pe), pe
      }
      function ut(de) {
        if (de == 0) return -1
        var pe = 0
        return (
          (de & 65535) == 0 && ((de >>= 16), (pe += 16)),
          (de & 255) == 0 && ((de >>= 8), (pe += 8)),
          (de & 15) == 0 && ((de >>= 4), (pe += 4)),
          (de & 3) == 0 && ((de >>= 2), (pe += 2)),
          (de & 1) == 0 && ++pe,
          pe
        )
      }
      function at() {
        for (var de = 0; de < this.t; ++de) if (this.data[de] != 0) return de * this.DB + ut(this.data[de])
        return this.s < 0 ? this.t * this.DB : -1
      }
      function Pt(de) {
        for (var pe = 0; de != 0; ) (de &= de - 1), ++pe
        return pe
      }
      function ft() {
        for (var de = 0, pe = this.s & this.DM, ye = 0; ye < this.t; ++ye) de += Pt(this.data[ye] ^ pe)
        return de
      }
      function We(de) {
        var pe = Math.floor(de / this.DB)
        return pe >= this.t ? this.s != 0 : (this.data[pe] & (1 << de % this.DB)) != 0
      }
      function gt(de, pe) {
        var ye = u.ONE.shiftLeft(de)
        return this.bitwiseTo(ye, pe, ye), ye
      }
      function Ge(de) {
        return this.changeBit(de, Me)
      }
      function He(de) {
        return this.changeBit(de, Oe)
      }
      function wt(de) {
        return this.changeBit(de, je)
      }
      function tt(de, pe) {
        for (var ye = 0, Te = 0, De = Math.min(de.t, this.t); ye < De; )
          (Te += this.data[ye] + de.data[ye]), (pe.data[ye++] = Te & this.DM), (Te >>= this.DB)
        if (de.t < this.t) {
          for (Te += de.s; ye < this.t; ) (Te += this.data[ye]), (pe.data[ye++] = Te & this.DM), (Te >>= this.DB)
          Te += this.s
        } else {
          for (Te += this.s; ye < de.t; ) (Te += de.data[ye]), (pe.data[ye++] = Te & this.DM), (Te >>= this.DB)
          Te += de.s
        }
        ;(pe.s = Te < 0 ? -1 : 0),
          Te > 0 ? (pe.data[ye++] = Te) : Te < -1 && (pe.data[ye++] = this.DV + Te),
          (pe.t = ye),
          pe.clamp()
      }
      function Xe(de) {
        var pe = o()
        return this.addTo(de, pe), pe
      }
      function _t(de) {
        var pe = o()
        return this.subTo(de, pe), pe
      }
      function nt(de) {
        var pe = o()
        return this.multiplyTo(de, pe), pe
      }
      function it(de) {
        var pe = o()
        return this.divRemTo(de, pe, null), pe
      }
      function xt(de) {
        var pe = o()
        return this.divRemTo(de, null, pe), pe
      }
      function st(de) {
        var pe = o(),
          ye = o()
        return this.divRemTo(de, pe, ye), new Array(pe, ye)
      }
      function ot(de) {
        ;(this.data[this.t] = this.am(0, de - 1, this, 0, 0, this.t)), ++this.t, this.clamp()
      }
      function Rt(de, pe) {
        if (de != 0) {
          for (; this.t <= pe; ) this.data[this.t++] = 0
          for (this.data[pe] += de; this.data[pe] >= this.DV; )
            (this.data[pe] -= this.DV), ++pe >= this.t && (this.data[this.t++] = 0), ++this.data[pe]
        }
      }
      function Ze() {}
      function Ye(de) {
        return de
      }
      function Er(de, pe, ye) {
        de.multiplyTo(pe, ye)
      }
      function Et(de, pe) {
        de.squareTo(pe)
      }
      ;(Ze.prototype.convert = Ye), (Ze.prototype.revert = Ye), (Ze.prototype.mulTo = Er), (Ze.prototype.sqrTo = Et)
      function St(de) {
        return this.exp(de, new Ze())
      }
      function Dr(de, pe, ye) {
        var Te = Math.min(this.t + de.t, pe)
        for (ye.s = 0, ye.t = Te; Te > 0; ) ye.data[--Te] = 0
        var De
        for (De = ye.t - this.t; Te < De; ++Te) ye.data[Te + this.t] = this.am(0, de.data[Te], ye, Te, 0, this.t)
        for (De = Math.min(de.t, pe); Te < De; ++Te) this.am(0, de.data[Te], ye, Te, 0, pe - Te)
        ye.clamp()
      }
      function At(de, pe, ye) {
        --pe
        var Te = (ye.t = this.t + de.t - pe)
        for (ye.s = 0; --Te >= 0; ) ye.data[Te] = 0
        for (Te = Math.max(pe - this.t, 0); Te < de.t; ++Te)
          ye.data[this.t + Te - pe] = this.am(pe - Te, de.data[Te], ye, 0, 0, this.t + Te - pe)
        ye.clamp(), ye.drShiftTo(1, ye)
      }
      function vt(de) {
        ;(this.r2 = o()),
          (this.q3 = o()),
          u.ONE.dlShiftTo(2 * de.t, this.r2),
          (this.mu = this.r2.divide(de)),
          (this.m = de)
      }
      function Yt(de) {
        if (de.s < 0 || de.t > 2 * this.m.t) return de.mod(this.m)
        if (de.compareTo(this.m) < 0) return de
        var pe = o()
        return de.copyTo(pe), this.reduce(pe), pe
      }
      function It(de) {
        return de
      }
      function Ot(de) {
        for (
          de.drShiftTo(this.m.t - 1, this.r2),
            de.t > this.m.t + 1 && ((de.t = this.m.t + 1), de.clamp()),
            this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3),
            this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          de.compareTo(this.r2) < 0;

        )
          de.dAddOffset(1, this.m.t + 1)
        for (de.subTo(this.r2, de); de.compareTo(this.m) >= 0; ) de.subTo(this.m, de)
      }
      function En(de, pe) {
        de.squareTo(pe), this.reduce(pe)
      }
      function Dt(de, pe, ye) {
        de.multiplyTo(pe, ye), this.reduce(ye)
      }
      ;(vt.prototype.convert = Yt),
        (vt.prototype.revert = It),
        (vt.prototype.reduce = Ot),
        (vt.prototype.mulTo = Dt),
        (vt.prototype.sqrTo = En)
      function Lt(de, pe) {
        var ye = de.bitLength(),
          Te,
          De = E(1),
          Le
        if (ye <= 0) return De
        ye < 18 ? (Te = 1) : ye < 48 ? (Te = 3) : ye < 144 ? (Te = 4) : ye < 768 ? (Te = 5) : (Te = 6),
          ye < 8 ? (Le = new le(pe)) : pe.isEven() ? (Le = new vt(pe)) : (Le = new ge(pe))
        var $e = new Array(),
          Fe = 3,
          Tt = Te - 1,
          Gt = (1 << Te) - 1
        if ((($e[1] = Le.convert(this)), Te > 1)) {
          var tr = o()
          for (Le.sqrTo($e[1], tr); Fe <= Gt; ) ($e[Fe] = o()), Le.mulTo(tr, $e[Fe - 2], $e[Fe]), (Fe += 2)
        }
        var Zt = de.t - 1,
          Lr,
          An = !0,
          yr = o(),
          nr
        for (ye = G(de.data[Zt]) - 1; Zt >= 0; ) {
          for (
            ye >= Tt
              ? (Lr = (de.data[Zt] >> (ye - Tt)) & Gt)
              : ((Lr = (de.data[Zt] & ((1 << (ye + 1)) - 1)) << (Tt - ye)),
                Zt > 0 && (Lr |= de.data[Zt - 1] >> (this.DB + ye - Tt))),
              Fe = Te;
            (Lr & 1) == 0;

          )
            (Lr >>= 1), --Fe
          if (((ye -= Fe) < 0 && ((ye += this.DB), --Zt), An)) $e[Lr].copyTo(De), (An = !1)
          else {
            for (; Fe > 1; ) Le.sqrTo(De, yr), Le.sqrTo(yr, De), (Fe -= 2)
            Fe > 0 ? Le.sqrTo(De, yr) : ((nr = De), (De = yr), (yr = nr)), Le.mulTo(yr, $e[Lr], De)
          }
          for (; Zt >= 0 && (de.data[Zt] & (1 << ye)) == 0; )
            Le.sqrTo(De, yr), (nr = De), (De = yr), (yr = nr), --ye < 0 && ((ye = this.DB - 1), --Zt)
        }
        return Le.revert(De)
      }
      function Sn(de) {
        var pe = this.s < 0 ? this.negate() : this.clone(),
          ye = de.s < 0 ? de.negate() : de.clone()
        if (pe.compareTo(ye) < 0) {
          var Te = pe
          ;(pe = ye), (ye = Te)
        }
        var De = pe.getLowestSetBit(),
          Le = ye.getLowestSetBit()
        if (Le < 0) return pe
        for (De < Le && (Le = De), Le > 0 && (pe.rShiftTo(Le, pe), ye.rShiftTo(Le, ye)); pe.signum() > 0; )
          (De = pe.getLowestSetBit()) > 0 && pe.rShiftTo(De, pe),
            (De = ye.getLowestSetBit()) > 0 && ye.rShiftTo(De, ye),
            pe.compareTo(ye) >= 0 ? (pe.subTo(ye, pe), pe.rShiftTo(1, pe)) : (ye.subTo(pe, ye), ye.rShiftTo(1, ye))
        return Le > 0 && ye.lShiftTo(Le, ye), ye
      }
      function Ut(de) {
        if (de <= 0) return 0
        var pe = this.DV % de,
          ye = this.s < 0 ? de - 1 : 0
        if (this.t > 0)
          if (pe == 0) ye = this.data[0] % de
          else for (var Te = this.t - 1; Te >= 0; --Te) ye = (pe * ye + this.data[Te]) % de
        return ye
      }
      function qt(de) {
        var pe = de.isEven()
        if ((this.isEven() && pe) || de.signum() == 0) return u.ZERO
        for (var ye = de.clone(), Te = this.clone(), De = E(1), Le = E(0), $e = E(0), Fe = E(1); ye.signum() != 0; ) {
          for (; ye.isEven(); )
            ye.rShiftTo(1, ye),
              pe
                ? ((!De.isEven() || !Le.isEven()) && (De.addTo(this, De), Le.subTo(de, Le)), De.rShiftTo(1, De))
                : Le.isEven() || Le.subTo(de, Le),
              Le.rShiftTo(1, Le)
          for (; Te.isEven(); )
            Te.rShiftTo(1, Te),
              pe
                ? ((!$e.isEven() || !Fe.isEven()) && ($e.addTo(this, $e), Fe.subTo(de, Fe)), $e.rShiftTo(1, $e))
                : Fe.isEven() || Fe.subTo(de, Fe),
              Fe.rShiftTo(1, Fe)
          ye.compareTo(Te) >= 0
            ? (ye.subTo(Te, ye), pe && De.subTo($e, De), Le.subTo(Fe, Le))
            : (Te.subTo(ye, Te), pe && $e.subTo(De, $e), Fe.subTo(Le, Fe))
        }
        if (Te.compareTo(u.ONE) != 0) return u.ZERO
        if (Fe.compareTo(de) >= 0) return Fe.subtract(de)
        if (Fe.signum() < 0) Fe.addTo(de, Fe)
        else return Fe
        return Fe.signum() < 0 ? Fe.add(de) : Fe
      }
      var dt = [
          2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107,
          109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229,
          233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359,
          367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491,
          499, 503, 509
        ],
        Se = (1 << 26) / dt[dt.length - 1]
      function ue(de) {
        var pe,
          ye = this.abs()
        if (ye.t == 1 && ye.data[0] <= dt[dt.length - 1]) {
          for (pe = 0; pe < dt.length; ++pe) if (ye.data[0] == dt[pe]) return !0
          return !1
        }
        if (ye.isEven()) return !1
        for (pe = 1; pe < dt.length; ) {
          for (var Te = dt[pe], De = pe + 1; De < dt.length && Te < Se; ) Te *= dt[De++]
          for (Te = ye.modInt(Te); pe < De; ) if (Te % dt[pe++] == 0) return !1
        }
        return ye.millerRabin(de)
      }
      function Ae(de) {
        var pe = this.subtract(u.ONE),
          ye = pe.getLowestSetBit()
        if (ye <= 0) return !1
        for (var Te = pe.shiftRight(ye), De = Fi(), Le, $e = 0; $e < de; ++$e) {
          do Le = new u(this.bitLength(), De)
          while (Le.compareTo(u.ONE) <= 0 || Le.compareTo(pe) >= 0)
          var Fe = Le.modPow(Te, this)
          if (Fe.compareTo(u.ONE) != 0 && Fe.compareTo(pe) != 0) {
            for (var Tt = 1; Tt++ < ye && Fe.compareTo(pe) != 0; )
              if (((Fe = Fe.modPowInt(2, this)), Fe.compareTo(u.ONE) == 0)) return !1
            if (Fe.compareTo(pe) != 0) return !1
          }
        }
        return !0
      }
      function Fi() {
        return {
          nextBytes: function (de) {
            for (var pe = 0; pe < de.length; ++pe) de[pe] = Math.floor(Math.random() * 256)
          }
        }
      }
      ;(u.prototype.chunkSize = U),
        (u.prototype.toRadix = ne),
        (u.prototype.fromRadix = ee),
        (u.prototype.fromNumber = ae),
        (u.prototype.bitwiseTo = me),
        (u.prototype.changeBit = gt),
        (u.prototype.addTo = tt),
        (u.prototype.dMultiply = ot),
        (u.prototype.dAddOffset = Rt),
        (u.prototype.multiplyLowerTo = Dr),
        (u.prototype.multiplyUpperTo = At),
        (u.prototype.modInt = Ut),
        (u.prototype.millerRabin = Ae),
        (u.prototype.clone = D),
        (u.prototype.intValue = $),
        (u.prototype.byteValue = g),
        (u.prototype.shortValue = N),
        (u.prototype.signum = X),
        (u.prototype.toByteArray = Y),
        (u.prototype.equals = z),
        (u.prototype.min = H),
        (u.prototype.max = se),
        (u.prototype.and = Ee),
        (u.prototype.or = Be),
        (u.prototype.xor = Pe),
        (u.prototype.andNot = ht),
        (u.prototype.not = Qe),
        (u.prototype.shiftLeft = et),
        (u.prototype.shiftRight = Mt),
        (u.prototype.getLowestSetBit = at),
        (u.prototype.bitCount = ft),
        (u.prototype.testBit = We),
        (u.prototype.setBit = Ge),
        (u.prototype.clearBit = He),
        (u.prototype.flipBit = wt),
        (u.prototype.add = Xe),
        (u.prototype.subtract = _t),
        (u.prototype.multiply = nt),
        (u.prototype.divide = it),
        (u.prototype.remainder = xt),
        (u.prototype.divideAndRemainder = st),
        (u.prototype.modPow = Lt),
        (u.prototype.modInverse = qt),
        (u.prototype.pow = St),
        (u.prototype.gcd = Sn),
        (u.prototype.isProbablePrime = ue)
    }
  }),
  QP = te({
    'node_modules/node-forge/lib/sha1.js'(e, r) {
      V(), F()
      var t = yt()
      Es(), zt()
      var n = (r.exports = t.sha1 = t.sha1 || {})
      ;(t.md.sha1 = t.md.algorithms.sha1 = n),
        (n.create = function () {
          s || u()
          var l = null,
            a = t.util.createBuffer(),
            c = new Array(80),
            f = {
              algorithm: 'sha1',
              blockLength: 64,
              digestLength: 20,
              messageLength: 0,
              fullMessageLength: null,
              messageLengthSize: 8
            }
          return (
            (f.start = function () {
              ;(f.messageLength = 0), (f.fullMessageLength = f.messageLength64 = [])
              for (var p = f.messageLengthSize / 4, y = 0; y < p; ++y) f.fullMessageLength.push(0)
              return (
                (a = t.util.createBuffer()),
                (l = { h0: 1732584193, h1: 4023233417, h2: 2562383102, h3: 271733878, h4: 3285377520 }),
                f
              )
            }),
            f.start(),
            (f.update = function (p, y) {
              y === 'utf8' && (p = t.util.encodeUtf8(p))
              var d = p.length
              ;(f.messageLength += d), (d = [(d / 4294967296) >>> 0, d >>> 0])
              for (var h = f.fullMessageLength.length - 1; h >= 0; --h)
                (f.fullMessageLength[h] += d[1]),
                  (d[1] = d[0] + ((f.fullMessageLength[h] / 4294967296) >>> 0)),
                  (f.fullMessageLength[h] = f.fullMessageLength[h] >>> 0),
                  (d[0] = (d[1] / 4294967296) >>> 0)
              return a.putBytes(p), o(l, c, a), (a.read > 2048 || a.length() === 0) && a.compact(), f
            }),
            (f.digest = function () {
              var p = t.util.createBuffer()
              p.putBytes(a.bytes())
              var y = f.fullMessageLength[f.fullMessageLength.length - 1] + f.messageLengthSize,
                d = y & (f.blockLength - 1)
              p.putBytes(i.substr(0, f.blockLength - d))
              for (var h, m, _ = f.fullMessageLength[0] * 8, A = 0; A < f.fullMessageLength.length - 1; ++A)
                (h = f.fullMessageLength[A + 1] * 8),
                  (m = (h / 4294967296) >>> 0),
                  (_ += m),
                  p.putInt32(_ >>> 0),
                  (_ = h >>> 0)
              p.putInt32(_)
              var T = { h0: l.h0, h1: l.h1, h2: l.h2, h3: l.h3, h4: l.h4 }
              o(T, c, p)
              var E = t.util.createBuffer()
              return E.putInt32(T.h0), E.putInt32(T.h1), E.putInt32(T.h2), E.putInt32(T.h3), E.putInt32(T.h4), E
            }),
            f
          )
        })
      var i = null,
        s = !1
      function u() {
        ;(i = String.fromCharCode(128)), (i += t.util.fillString(String.fromCharCode(0), 64)), (s = !0)
      }
      function o(l, a, c) {
        for (var f, p, y, d, h, m, _, A, T = c.length(); T >= 64; ) {
          for (p = l.h0, y = l.h1, d = l.h2, h = l.h3, m = l.h4, A = 0; A < 16; ++A)
            (f = c.getInt32()),
              (a[A] = f),
              (_ = h ^ (y & (d ^ h))),
              (f = ((p << 5) | (p >>> 27)) + _ + m + 1518500249 + f),
              (m = h),
              (h = d),
              (d = ((y << 30) | (y >>> 2)) >>> 0),
              (y = p),
              (p = f)
          for (; A < 20; ++A)
            (f = a[A - 3] ^ a[A - 8] ^ a[A - 14] ^ a[A - 16]),
              (f = (f << 1) | (f >>> 31)),
              (a[A] = f),
              (_ = h ^ (y & (d ^ h))),
              (f = ((p << 5) | (p >>> 27)) + _ + m + 1518500249 + f),
              (m = h),
              (h = d),
              (d = ((y << 30) | (y >>> 2)) >>> 0),
              (y = p),
              (p = f)
          for (; A < 32; ++A)
            (f = a[A - 3] ^ a[A - 8] ^ a[A - 14] ^ a[A - 16]),
              (f = (f << 1) | (f >>> 31)),
              (a[A] = f),
              (_ = y ^ d ^ h),
              (f = ((p << 5) | (p >>> 27)) + _ + m + 1859775393 + f),
              (m = h),
              (h = d),
              (d = ((y << 30) | (y >>> 2)) >>> 0),
              (y = p),
              (p = f)
          for (; A < 40; ++A)
            (f = a[A - 6] ^ a[A - 16] ^ a[A - 28] ^ a[A - 32]),
              (f = (f << 2) | (f >>> 30)),
              (a[A] = f),
              (_ = y ^ d ^ h),
              (f = ((p << 5) | (p >>> 27)) + _ + m + 1859775393 + f),
              (m = h),
              (h = d),
              (d = ((y << 30) | (y >>> 2)) >>> 0),
              (y = p),
              (p = f)
          for (; A < 60; ++A)
            (f = a[A - 6] ^ a[A - 16] ^ a[A - 28] ^ a[A - 32]),
              (f = (f << 2) | (f >>> 30)),
              (a[A] = f),
              (_ = (y & d) | (h & (y ^ d))),
              (f = ((p << 5) | (p >>> 27)) + _ + m + 2400959708 + f),
              (m = h),
              (h = d),
              (d = ((y << 30) | (y >>> 2)) >>> 0),
              (y = p),
              (p = f)
          for (; A < 80; ++A)
            (f = a[A - 6] ^ a[A - 16] ^ a[A - 28] ^ a[A - 32]),
              (f = (f << 2) | (f >>> 30)),
              (a[A] = f),
              (_ = y ^ d ^ h),
              (f = ((p << 5) | (p >>> 27)) + _ + m + 3395469782 + f),
              (m = h),
              (h = d),
              (d = ((y << 30) | (y >>> 2)) >>> 0),
              (y = p),
              (p = f)
          ;(l.h0 = (l.h0 + p) | 0),
            (l.h1 = (l.h1 + y) | 0),
            (l.h2 = (l.h2 + d) | 0),
            (l.h3 = (l.h3 + h) | 0),
            (l.h4 = (l.h4 + m) | 0),
            (T -= 64)
        }
      }
    }
  }),
  eO = te({
    'node_modules/node-forge/lib/pkcs1.js'(e, r) {
      V(), F()
      var t = yt()
      zt(), Ss(), QP()
      var n = (r.exports = t.pkcs1 = t.pkcs1 || {})
      ;(n.encode_rsa_oaep = function (s, u, o) {
        var l, a, c, f
        typeof o == 'string'
          ? ((l = o), (a = arguments[3] || void 0), (c = arguments[4] || void 0))
          : o &&
            ((l = o.label || void 0),
            (a = o.seed || void 0),
            (c = o.md || void 0),
            o.mgf1 && o.mgf1.md && (f = o.mgf1.md)),
          c ? c.start() : (c = t.md.sha1.create()),
          f || (f = c)
        var p = Math.ceil(s.n.bitLength() / 8),
          y = p - 2 * c.digestLength - 2
        if (u.length > y) {
          var d = new Error('RSAES-OAEP input message length is too long.')
          throw ((d.length = u.length), (d.maxLength = y), d)
        }
        l || (l = ''), c.update(l, 'raw')
        for (var h = c.digest(), m = '', _ = y - u.length, A = 0; A < _; A++) m += '\0'
        var T = h.getBytes() + m + '' + u
        if (!a) a = t.random.getBytes(c.digestLength)
        else if (a.length !== c.digestLength) {
          var d = new Error('Invalid RSAES-OAEP seed. The seed length must match the digest length.')
          throw ((d.seedLength = a.length), (d.digestLength = c.digestLength), d)
        }
        var E = i(a, p - c.digestLength - 1, f),
          k = t.util.xorBytes(T, E, T.length),
          w = i(k, c.digestLength, f),
          v = t.util.xorBytes(a, w, a.length)
        return '\0' + v + k
      }),
        (n.decode_rsa_oaep = function (s, u, o) {
          var l, a, c
          typeof o == 'string'
            ? ((l = o), (a = arguments[3] || void 0))
            : o && ((l = o.label || void 0), (a = o.md || void 0), o.mgf1 && o.mgf1.md && (c = o.mgf1.md))
          var f = Math.ceil(s.n.bitLength() / 8)
          if (u.length !== f) {
            var k = new Error('RSAES-OAEP encoded message length is invalid.')
            throw ((k.length = u.length), (k.expectedLength = f), k)
          }
          if ((a === void 0 ? (a = t.md.sha1.create()) : a.start(), c || (c = a), f < 2 * a.digestLength + 2))
            throw new Error('RSAES-OAEP key is too short for the hash function.')
          l || (l = ''), a.update(l, 'raw')
          for (
            var p = a.digest().getBytes(),
              y = u.charAt(0),
              d = u.substring(1, a.digestLength + 1),
              h = u.substring(1 + a.digestLength),
              m = i(h, a.digestLength, c),
              _ = t.util.xorBytes(d, m, d.length),
              A = i(_, f - a.digestLength - 1, c),
              T = t.util.xorBytes(h, A, h.length),
              E = T.substring(0, a.digestLength),
              k = y !== '\0',
              w = 0;
            w < a.digestLength;
            ++w
          )
            k |= p.charAt(w) !== E.charAt(w)
          for (var v = 1, I = a.digestLength, M = a.digestLength; M < T.length; M++) {
            var q = T.charCodeAt(M),
              G = (q & 1) ^ 1,
              O = v ? 65534 : 0
            ;(k |= q & O), (v = v & G), (I += v)
          }
          if (k || T.charCodeAt(I) !== 1) throw new Error('Invalid RSAES-OAEP padding.')
          return T.substring(I + 1)
        })
      function i(s, u, o) {
        o || (o = t.md.sha1.create())
        for (var l = '', a = Math.ceil(u / o.digestLength), c = 0; c < a; ++c) {
          var f = String.fromCharCode((c >> 24) & 255, (c >> 16) & 255, (c >> 8) & 255, c & 255)
          o.start(), o.update(s + f), (l += o.digest().getBytes())
        }
        return l.substring(0, u)
      }
    }
  }),
  tO = te({
    'node_modules/node-forge/lib/prime.js'(e, r) {
      V(), F()
      var t = yt()
      zt(),
        rf(),
        Ss(),
        (function () {
          if (t.prime) {
            r.exports = t.prime
            return
          }
          var n = (r.exports = t.prime = t.prime || {}),
            i = t.jsbn.BigInteger,
            s = [6, 4, 2, 4, 2, 4, 6, 2],
            u = new i(null)
          u.fromInt(30)
          var o = function (d, h) {
            return d | h
          }
          n.generateProbablePrime = function (d, h, m) {
            typeof h == 'function' && ((m = h), (h = {})), (h = h || {})
            var _ = h.algorithm || 'PRIMEINC'
            typeof _ == 'string' && (_ = { name: _ }), (_.options = _.options || {})
            var A = h.prng || t.random,
              T = {
                nextBytes: function (E) {
                  for (var k = A.getBytesSync(E.length), w = 0; w < E.length; ++w) E[w] = k.charCodeAt(w)
                }
              }
            if (_.name === 'PRIMEINC') return l(d, T, _.options, m)
            throw new Error('Invalid prime generation algorithm: ' + _.name)
          }
          function l(d, h, m, _) {
            return 'workers' in m ? f(d, h, m, _) : a(d, h, m, _)
          }
          function a(d, h, m, _) {
            var A = p(d, h),
              T = 0,
              E = y(A.bitLength())
            'millerRabinTests' in m && (E = m.millerRabinTests)
            var k = 10
            'maxBlockTime' in m && (k = m.maxBlockTime), c(A, d, h, T, E, k, _)
          }
          function c(d, h, m, _, A, T, E) {
            var k = +new Date()
            do {
              if ((d.bitLength() > h && (d = p(h, m)), d.isProbablePrime(A))) return E(null, d)
              d.dAddOffset(s[_++ % 8], 0)
            } while (T < 0 || +new Date() - k < T)
            t.util.setImmediate(function () {
              c(d, h, m, _, A, T, E)
            })
          }
          function f(d, h, m, _) {
            if (typeof Worker == 'undefined') return a(d, h, m, _)
            var A = p(d, h),
              T = m.workers,
              E = m.workLoad || 100,
              k = (E * 30) / 8,
              w = m.workerScript || 'forge/prime.worker.js'
            if (T === -1)
              return t.util.estimateCores(function (I, M) {
                I && (M = 2), (T = M - 1), v()
              })
            v()
            function v() {
              T = Math.max(1, T)
              for (var I = [], M = 0; M < T; ++M) I[M] = new Worker(w)
              for (var q = T, M = 0; M < T; ++M) I[M].addEventListener('message', O)
              var G = !1
              function O(x) {
                if (!G) {
                  --q
                  var L = x.data
                  if (L.found) {
                    for (var K = 0; K < I.length; ++K) I[K].terminate()
                    return (G = !0), _(null, new i(L.prime, 16))
                  }
                  A.bitLength() > d && (A = p(d, h))
                  var J = A.toString(16)
                  x.target.postMessage({ hex: J, workLoad: E }), A.dAddOffset(k, 0)
                }
              }
            }
          }
          function p(d, h) {
            var m = new i(d, h),
              _ = d - 1
            return m.testBit(_) || m.bitwiseTo(i.ONE.shiftLeft(_), o, m), m.dAddOffset(31 - m.mod(u).byteValue(), 0), m
          }
          function y(d) {
            return d <= 100
              ? 27
              : d <= 150
              ? 18
              : d <= 200
              ? 15
              : d <= 250
              ? 12
              : d <= 300
              ? 9
              : d <= 350
              ? 8
              : d <= 400
              ? 7
              : d <= 500
              ? 6
              : d <= 600
              ? 5
              : d <= 800
              ? 4
              : d <= 1250
              ? 3
              : 2
          }
        })()
    }
  }),
  nf = te({
    'node_modules/node-forge/lib/rsa.js'(e, r) {
      V(), F()
      var t = yt()
      qi(), rf(), Uc(), eO(), tO(), Ss(), zt(), typeof n == 'undefined' && (n = t.jsbn.BigInteger)
      var n,
        i = t.util.isNodejs ? tf() : null,
        s = t.asn1,
        u = t.util
      ;(t.pki = t.pki || {}), (r.exports = t.pki.rsa = t.rsa = t.rsa || {})
      var o = t.pki,
        l = [6, 4, 2, 4, 2, 4, 6, 2],
        a = {
          name: 'PrivateKeyInfo',
          tagClass: s.Class.UNIVERSAL,
          type: s.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'PrivateKeyInfo.version',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyVersion'
            },
            {
              name: 'PrivateKeyInfo.privateKeyAlgorithm',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'AlgorithmIdentifier.algorithm',
                  tagClass: s.Class.UNIVERSAL,
                  type: s.Type.OID,
                  constructed: !1,
                  capture: 'privateKeyOid'
                }
              ]
            },
            {
              name: 'PrivateKeyInfo',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.OCTETSTRING,
              constructed: !1,
              capture: 'privateKey'
            }
          ]
        },
        c = {
          name: 'RSAPrivateKey',
          tagClass: s.Class.UNIVERSAL,
          type: s.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'RSAPrivateKey.version',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyVersion'
            },
            {
              name: 'RSAPrivateKey.modulus',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyModulus'
            },
            {
              name: 'RSAPrivateKey.publicExponent',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyPublicExponent'
            },
            {
              name: 'RSAPrivateKey.privateExponent',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyPrivateExponent'
            },
            {
              name: 'RSAPrivateKey.prime1',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyPrime1'
            },
            {
              name: 'RSAPrivateKey.prime2',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyPrime2'
            },
            {
              name: 'RSAPrivateKey.exponent1',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyExponent1'
            },
            {
              name: 'RSAPrivateKey.exponent2',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyExponent2'
            },
            {
              name: 'RSAPrivateKey.coefficient',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'privateKeyCoefficient'
            }
          ]
        },
        f = {
          name: 'RSAPublicKey',
          tagClass: s.Class.UNIVERSAL,
          type: s.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'RSAPublicKey.modulus',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'publicKeyModulus'
            },
            {
              name: 'RSAPublicKey.exponent',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.INTEGER,
              constructed: !1,
              capture: 'publicKeyExponent'
            }
          ]
        },
        p = (t.pki.rsa.publicKeyValidator = {
          name: 'SubjectPublicKeyInfo',
          tagClass: s.Class.UNIVERSAL,
          type: s.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: 'subjectPublicKeyInfo',
          value: [
            {
              name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'AlgorithmIdentifier.algorithm',
                  tagClass: s.Class.UNIVERSAL,
                  type: s.Type.OID,
                  constructed: !1,
                  capture: 'publicKeyOid'
                }
              ]
            },
            {
              name: 'SubjectPublicKeyInfo.subjectPublicKey',
              tagClass: s.Class.UNIVERSAL,
              type: s.Type.BITSTRING,
              constructed: !1,
              value: [
                {
                  name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
                  tagClass: s.Class.UNIVERSAL,
                  type: s.Type.SEQUENCE,
                  constructed: !0,
                  optional: !0,
                  captureAsn1: 'rsaPublicKey'
                }
              ]
            }
          ]
        }),
        y = function (I) {
          var M
          if (I.algorithm in o.oids) M = o.oids[I.algorithm]
          else {
            var q = new Error('Unknown message digest algorithm.')
            throw ((q.algorithm = I.algorithm), q)
          }
          var G = s.oidToDer(M).getBytes(),
            O = s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, []),
            x = s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [])
          x.value.push(s.create(s.Class.UNIVERSAL, s.Type.OID, !1, G)),
            x.value.push(s.create(s.Class.UNIVERSAL, s.Type.NULL, !1, ''))
          var L = s.create(s.Class.UNIVERSAL, s.Type.OCTETSTRING, !1, I.digest().getBytes())
          return O.value.push(x), O.value.push(L), s.toDer(O).getBytes()
        },
        d = function (I, M, q) {
          if (q) return I.modPow(M.e, M.n)
          if (!M.p || !M.q) return I.modPow(M.d, M.n)
          M.dP || (M.dP = M.d.mod(M.p.subtract(n.ONE))),
            M.dQ || (M.dQ = M.d.mod(M.q.subtract(n.ONE))),
            M.qInv || (M.qInv = M.q.modInverse(M.p))
          var G
          do G = new n(t.util.bytesToHex(t.random.getBytes(M.n.bitLength() / 8)), 16)
          while (G.compareTo(M.n) >= 0 || !G.gcd(M.n).equals(n.ONE))
          I = I.multiply(G.modPow(M.e, M.n)).mod(M.n)
          for (var O = I.mod(M.p).modPow(M.dP, M.p), x = I.mod(M.q).modPow(M.dQ, M.q); O.compareTo(x) < 0; )
            O = O.add(M.p)
          var L = O.subtract(x).multiply(M.qInv).mod(M.p).multiply(M.q).add(x)
          return (L = L.multiply(G.modInverse(M.n)).mod(M.n)), L
        }
      ;(o.rsa.encrypt = function (I, M, q) {
        var G = q,
          O,
          x = Math.ceil(M.n.bitLength() / 8)
        q !== !1 && q !== !0 ? ((G = q === 2), (O = h(I, M, q))) : ((O = t.util.createBuffer()), O.putBytes(I))
        for (
          var L = new n(O.toHex(), 16),
            K = d(L, M, G),
            J = K.toString(16),
            Z = t.util.createBuffer(),
            Q = x - Math.ceil(J.length / 2);
          Q > 0;

        )
          Z.putByte(0), --Q
        return Z.putBytes(t.util.hexToBytes(J)), Z.getBytes()
      }),
        (o.rsa.decrypt = function (I, M, q, G) {
          var O = Math.ceil(M.n.bitLength() / 8)
          if (I.length !== O) {
            var x = new Error('Encrypted message length is invalid.')
            throw ((x.length = I.length), (x.expected = O), x)
          }
          var L = new n(t.util.createBuffer(I).toHex(), 16)
          if (L.compareTo(M.n) >= 0) throw new Error('Encrypted message is invalid.')
          for (
            var K = d(L, M, q), J = K.toString(16), Z = t.util.createBuffer(), Q = O - Math.ceil(J.length / 2);
            Q > 0;

          )
            Z.putByte(0), --Q
          return Z.putBytes(t.util.hexToBytes(J)), G !== !1 ? m(Z.getBytes(), M, q) : Z.getBytes()
        }),
        (o.rsa.createKeyPairGenerationState = function (I, M, q) {
          typeof I == 'string' && (I = parseInt(I, 10)), (I = I || 2048), (q = q || {})
          var G = q.prng || t.random,
            O = {
              nextBytes: function (K) {
                for (var J = G.getBytesSync(K.length), Z = 0; Z < K.length; ++Z) K[Z] = J.charCodeAt(Z)
              }
            },
            x = q.algorithm || 'PRIMEINC',
            L
          if (x === 'PRIMEINC')
            (L = {
              algorithm: x,
              state: 0,
              bits: I,
              rng: O,
              eInt: M || 65537,
              e: new n(null),
              p: null,
              q: null,
              qBits: I >> 1,
              pBits: I - (I >> 1),
              pqState: 0,
              num: null,
              keys: null
            }),
              L.e.fromInt(L.eInt)
          else throw new Error('Invalid key generation algorithm: ' + x)
          return L
        }),
        (o.rsa.stepKeyPairGenerationState = function (I, M) {
          'algorithm' in I || (I.algorithm = 'PRIMEINC')
          var q = new n(null)
          q.fromInt(30)
          for (
            var G = 0,
              O = function (fe, ie) {
                return fe | ie
              },
              x = +new Date(),
              L,
              K = 0;
            I.keys === null && (M <= 0 || K < M);

          ) {
            if (I.state === 0) {
              var J = I.p === null ? I.pBits : I.qBits,
                Z = J - 1
              I.pqState === 0
                ? ((I.num = new n(J, I.rng)),
                  I.num.testBit(Z) || I.num.bitwiseTo(n.ONE.shiftLeft(Z), O, I.num),
                  I.num.dAddOffset(31 - I.num.mod(q).byteValue(), 0),
                  (G = 0),
                  ++I.pqState)
                : I.pqState === 1
                ? I.num.bitLength() > J
                  ? (I.pqState = 0)
                  : I.num.isProbablePrime(T(I.num.bitLength()))
                  ? ++I.pqState
                  : I.num.dAddOffset(l[G++ % 8], 0)
                : I.pqState === 2
                ? (I.pqState = I.num.subtract(n.ONE).gcd(I.e).compareTo(n.ONE) === 0 ? 3 : 0)
                : I.pqState === 3 &&
                  ((I.pqState = 0),
                  I.p === null ? (I.p = I.num) : (I.q = I.num),
                  I.p !== null && I.q !== null && ++I.state,
                  (I.num = null))
            } else if (I.state === 1) I.p.compareTo(I.q) < 0 && ((I.num = I.p), (I.p = I.q), (I.q = I.num)), ++I.state
            else if (I.state === 2)
              (I.p1 = I.p.subtract(n.ONE)), (I.q1 = I.q.subtract(n.ONE)), (I.phi = I.p1.multiply(I.q1)), ++I.state
            else if (I.state === 3)
              I.phi.gcd(I.e).compareTo(n.ONE) === 0 ? ++I.state : ((I.p = null), (I.q = null), (I.state = 0))
            else if (I.state === 4)
              (I.n = I.p.multiply(I.q)), I.n.bitLength() === I.bits ? ++I.state : ((I.q = null), (I.state = 0))
            else if (I.state === 5) {
              var Q = I.e.modInverse(I.phi)
              I.keys = {
                privateKey: o.rsa.setPrivateKey(I.n, I.e, Q, I.p, I.q, Q.mod(I.p1), Q.mod(I.q1), I.q.modInverse(I.p)),
                publicKey: o.rsa.setPublicKey(I.n, I.e)
              }
            }
            ;(L = +new Date()), (K += L - x), (x = L)
          }
          return I.keys !== null
        }),
        (o.rsa.generateKeyPair = function (I, M, q, G) {
          if (
            (arguments.length === 1
              ? typeof I == 'object'
                ? ((q = I), (I = void 0))
                : typeof I == 'function' && ((G = I), (I = void 0))
              : arguments.length === 2
              ? typeof I == 'number'
                ? typeof M == 'function'
                  ? ((G = M), (M = void 0))
                  : typeof M != 'number' && ((q = M), (M = void 0))
                : ((q = I), (G = M), (I = void 0), (M = void 0))
              : arguments.length === 3 &&
                (typeof M == 'number'
                  ? typeof q == 'function' && ((G = q), (q = void 0))
                  : ((G = q), (q = M), (M = void 0))),
            (q = q || {}),
            I === void 0 && (I = q.bits || 2048),
            M === void 0 && (M = q.e || 65537),
            !t.options.usePureJavaScript && !q.prng && I >= 256 && I <= 16384 && (M === 65537 || M === 3))
          ) {
            if (G) {
              if (E('generateKeyPair'))
                return i.generateKeyPair(
                  'rsa',
                  {
                    modulusLength: I,
                    publicExponent: M,
                    publicKeyEncoding: { type: 'spki', format: 'pem' },
                    privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
                  },
                  function (K, J, Z) {
                    if (K) return G(K)
                    G(null, { privateKey: o.privateKeyFromPem(Z), publicKey: o.publicKeyFromPem(J) })
                  }
                )
              if (k('generateKey') && k('exportKey'))
                return u.globalScope.crypto.subtle
                  .generateKey(
                    { name: 'RSASSA-PKCS1-v1_5', modulusLength: I, publicExponent: v(M), hash: { name: 'SHA-256' } },
                    !0,
                    ['sign', 'verify']
                  )
                  .then(function (K) {
                    return u.globalScope.crypto.subtle.exportKey('pkcs8', K.privateKey)
                  })
                  .then(void 0, function (K) {
                    G(K)
                  })
                  .then(function (K) {
                    if (K) {
                      var J = o.privateKeyFromAsn1(s.fromDer(t.util.createBuffer(K)))
                      G(null, { privateKey: J, publicKey: o.setRsaPublicKey(J.n, J.e) })
                    }
                  })
              if (w('generateKey') && w('exportKey')) {
                var O = u.globalScope.msCrypto.subtle.generateKey(
                  { name: 'RSASSA-PKCS1-v1_5', modulusLength: I, publicExponent: v(M), hash: { name: 'SHA-256' } },
                  !0,
                  ['sign', 'verify']
                )
                ;(O.oncomplete = function (K) {
                  var J = K.target.result,
                    Z = u.globalScope.msCrypto.subtle.exportKey('pkcs8', J.privateKey)
                  ;(Z.oncomplete = function (Q) {
                    var fe = Q.target.result,
                      ie = o.privateKeyFromAsn1(s.fromDer(t.util.createBuffer(fe)))
                    G(null, { privateKey: ie, publicKey: o.setRsaPublicKey(ie.n, ie.e) })
                  }),
                    (Z.onerror = function (Q) {
                      G(Q)
                    })
                }),
                  (O.onerror = function (K) {
                    G(K)
                  })
                return
              }
            } else if (E('generateKeyPairSync')) {
              var x = i.generateKeyPairSync('rsa', {
                modulusLength: I,
                publicExponent: M,
                publicKeyEncoding: { type: 'spki', format: 'pem' },
                privateKeyEncoding: { type: 'pkcs8', format: 'pem' }
              })
              return { privateKey: o.privateKeyFromPem(x.privateKey), publicKey: o.publicKeyFromPem(x.publicKey) }
            }
          }
          var L = o.rsa.createKeyPairGenerationState(I, M, q)
          if (!G) return o.rsa.stepKeyPairGenerationState(L, 0), L.keys
          _(L, q, G)
        }),
        (o.setRsaPublicKey = o.rsa.setPublicKey =
          function (I, M) {
            var q = { n: I, e: M }
            return (
              (q.encrypt = function (G, O, x) {
                if (
                  (typeof O == 'string' ? (O = O.toUpperCase()) : O === void 0 && (O = 'RSAES-PKCS1-V1_5'),
                  O === 'RSAES-PKCS1-V1_5')
                )
                  O = {
                    encode: function (K, J, Z) {
                      return h(K, J, 2).getBytes()
                    }
                  }
                else if (O === 'RSA-OAEP' || O === 'RSAES-OAEP')
                  O = {
                    encode: function (K, J) {
                      return t.pkcs1.encode_rsa_oaep(J, K, x)
                    }
                  }
                else if (['RAW', 'NONE', 'NULL', null].indexOf(O) !== -1)
                  O = {
                    encode: function (K) {
                      return K
                    }
                  }
                else if (typeof O == 'string') throw new Error('Unsupported encryption scheme: "' + O + '".')
                var L = O.encode(G, q, !0)
                return o.rsa.encrypt(L, q, !0)
              }),
              (q.verify = function (G, O, x) {
                typeof x == 'string' ? (x = x.toUpperCase()) : x === void 0 && (x = 'RSASSA-PKCS1-V1_5'),
                  x === 'RSASSA-PKCS1-V1_5'
                    ? (x = {
                        verify: function (K, J) {
                          J = m(J, q, !0)
                          var Z = s.fromDer(J)
                          return K === Z.value[1].value
                        }
                      })
                    : (x === 'NONE' || x === 'NULL' || x === null) &&
                      (x = {
                        verify: function (K, J) {
                          return (J = m(J, q, !0)), K === J
                        }
                      })
                var L = o.rsa.decrypt(O, q, !0, !1)
                return x.verify(G, L, q.n.bitLength())
              }),
              q
            )
          }),
        (o.setRsaPrivateKey = o.rsa.setPrivateKey =
          function (I, M, q, G, O, x, L, K) {
            var J = { n: I, e: M, d: q, p: G, q: O, dP: x, dQ: L, qInv: K }
            return (
              (J.decrypt = function (Z, Q, fe) {
                typeof Q == 'string' ? (Q = Q.toUpperCase()) : Q === void 0 && (Q = 'RSAES-PKCS1-V1_5')
                var ie = o.rsa.decrypt(Z, J, !1, !1)
                if (Q === 'RSAES-PKCS1-V1_5') Q = { decode: m }
                else if (Q === 'RSA-OAEP' || Q === 'RSAES-OAEP')
                  Q = {
                    decode: function (W, le) {
                      return t.pkcs1.decode_rsa_oaep(le, W, fe)
                    }
                  }
                else if (['RAW', 'NONE', 'NULL', null].indexOf(Q) !== -1)
                  Q = {
                    decode: function (W) {
                      return W
                    }
                  }
                else throw new Error('Unsupported encryption scheme: "' + Q + '".')
                return Q.decode(ie, J, !1)
              }),
              (J.sign = function (Z, Q) {
                var fe = !1
                typeof Q == 'string' && (Q = Q.toUpperCase()),
                  Q === void 0 || Q === 'RSASSA-PKCS1-V1_5'
                    ? ((Q = { encode: y }), (fe = 1))
                    : (Q === 'NONE' || Q === 'NULL' || Q === null) &&
                      ((Q = {
                        encode: function () {
                          return Z
                        }
                      }),
                      (fe = 1))
                var ie = Q.encode(Z, J.n.bitLength())
                return o.rsa.encrypt(ie, J, fe)
              }),
              J
            )
          }),
        (o.wrapRsaPrivateKey = function (I) {
          return s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [
            s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, s.integerToDer(0).getBytes()),
            s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [
              s.create(s.Class.UNIVERSAL, s.Type.OID, !1, s.oidToDer(o.oids.rsaEncryption).getBytes()),
              s.create(s.Class.UNIVERSAL, s.Type.NULL, !1, '')
            ]),
            s.create(s.Class.UNIVERSAL, s.Type.OCTETSTRING, !1, s.toDer(I).getBytes())
          ])
        }),
        (o.privateKeyFromAsn1 = function (I) {
          var M = {},
            q = []
          if (
            (s.validate(I, a, M, q) && (I = s.fromDer(t.util.createBuffer(M.privateKey))),
            (M = {}),
            (q = []),
            !s.validate(I, c, M, q))
          ) {
            var G = new Error('Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.')
            throw ((G.errors = q), G)
          }
          var O, x, L, K, J, Z, Q, fe
          return (
            (O = t.util.createBuffer(M.privateKeyModulus).toHex()),
            (x = t.util.createBuffer(M.privateKeyPublicExponent).toHex()),
            (L = t.util.createBuffer(M.privateKeyPrivateExponent).toHex()),
            (K = t.util.createBuffer(M.privateKeyPrime1).toHex()),
            (J = t.util.createBuffer(M.privateKeyPrime2).toHex()),
            (Z = t.util.createBuffer(M.privateKeyExponent1).toHex()),
            (Q = t.util.createBuffer(M.privateKeyExponent2).toHex()),
            (fe = t.util.createBuffer(M.privateKeyCoefficient).toHex()),
            o.setRsaPrivateKey(
              new n(O, 16),
              new n(x, 16),
              new n(L, 16),
              new n(K, 16),
              new n(J, 16),
              new n(Z, 16),
              new n(Q, 16),
              new n(fe, 16)
            )
          )
        }),
        (o.privateKeyToAsn1 = o.privateKeyToRSAPrivateKey =
          function (I) {
            return s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, s.integerToDer(0).getBytes()),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.n)),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.e)),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.d)),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.p)),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.q)),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.dP)),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.dQ)),
              s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.qInv))
            ])
          }),
        (o.publicKeyFromAsn1 = function (I) {
          var M = {},
            q = []
          if (s.validate(I, p, M, q)) {
            var G = s.derToOid(M.publicKeyOid)
            if (G !== o.oids.rsaEncryption) {
              var O = new Error('Cannot read public key. Unknown OID.')
              throw ((O.oid = G), O)
            }
            I = M.rsaPublicKey
          }
          if (((q = []), !s.validate(I, f, M, q))) {
            var O = new Error('Cannot read public key. ASN.1 object does not contain an RSAPublicKey.')
            throw ((O.errors = q), O)
          }
          var x = t.util.createBuffer(M.publicKeyModulus).toHex(),
            L = t.util.createBuffer(M.publicKeyExponent).toHex()
          return o.setRsaPublicKey(new n(x, 16), new n(L, 16))
        }),
        (o.publicKeyToAsn1 = o.publicKeyToSubjectPublicKeyInfo =
          function (I) {
            return s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [
              s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [
                s.create(s.Class.UNIVERSAL, s.Type.OID, !1, s.oidToDer(o.oids.rsaEncryption).getBytes()),
                s.create(s.Class.UNIVERSAL, s.Type.NULL, !1, '')
              ]),
              s.create(s.Class.UNIVERSAL, s.Type.BITSTRING, !1, [o.publicKeyToRSAPublicKey(I)])
            ])
          }),
        (o.publicKeyToRSAPublicKey = function (I) {
          return s.create(s.Class.UNIVERSAL, s.Type.SEQUENCE, !0, [
            s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.n)),
            s.create(s.Class.UNIVERSAL, s.Type.INTEGER, !1, A(I.e))
          ])
        })
      function h(I, M, q) {
        var G = t.util.createBuffer(),
          O = Math.ceil(M.n.bitLength() / 8)
        if (I.length > O - 11) {
          var x = new Error('Message is too long for PKCS#1 v1.5 padding.')
          throw ((x.length = I.length), (x.max = O - 11), x)
        }
        G.putByte(0), G.putByte(q)
        var L = O - 3 - I.length,
          K
        if (q === 0 || q === 1) {
          K = q === 0 ? 0 : 255
          for (var J = 0; J < L; ++J) G.putByte(K)
        } else
          for (; L > 0; ) {
            for (var Z = 0, Q = t.random.getBytes(L), J = 0; J < L; ++J)
              (K = Q.charCodeAt(J)), K === 0 ? ++Z : G.putByte(K)
            L = Z
          }
        return G.putByte(0), G.putBytes(I), G
      }
      function m(I, M, q, G) {
        var O = Math.ceil(M.n.bitLength() / 8),
          x = t.util.createBuffer(I),
          L = x.getByte(),
          K = x.getByte()
        if (L !== 0 || (q && K !== 0 && K !== 1) || (!q && K != 2) || (q && K === 0 && typeof G == 'undefined'))
          throw new Error('Encryption block is invalid.')
        var J = 0
        if (K === 0) {
          J = O - 3 - G
          for (var Z = 0; Z < J; ++Z) if (x.getByte() !== 0) throw new Error('Encryption block is invalid.')
        } else if (K === 1)
          for (J = 0; x.length() > 1; ) {
            if (x.getByte() !== 255) {
              --x.read
              break
            }
            ++J
          }
        else if (K === 2)
          for (J = 0; x.length() > 1; ) {
            if (x.getByte() === 0) {
              --x.read
              break
            }
            ++J
          }
        var Q = x.getByte()
        if (Q !== 0 || J !== O - 3 - x.length()) throw new Error('Encryption block is invalid.')
        return x.getBytes()
      }
      function _(I, M, q) {
        typeof M == 'function' && ((q = M), (M = {})), (M = M || {})
        var G = {
          algorithm: {
            name: M.algorithm || 'PRIMEINC',
            options: { workers: M.workers || 2, workLoad: M.workLoad || 100, workerScript: M.workerScript }
          }
        }
        'prng' in M && (G.prng = M.prng), O()
        function O() {
          x(I.pBits, function (K, J) {
            if (K) return q(K)
            if (((I.p = J), I.q !== null)) return L(K, I.q)
            x(I.qBits, L)
          })
        }
        function x(K, J) {
          t.prime.generateProbablePrime(K, G, J)
        }
        function L(K, J) {
          if (K) return q(K)
          if (((I.q = J), I.p.compareTo(I.q) < 0)) {
            var Z = I.p
            ;(I.p = I.q), (I.q = Z)
          }
          if (I.p.subtract(n.ONE).gcd(I.e).compareTo(n.ONE) !== 0) {
            ;(I.p = null), O()
            return
          }
          if (I.q.subtract(n.ONE).gcd(I.e).compareTo(n.ONE) !== 0) {
            ;(I.q = null), x(I.qBits, L)
            return
          }
          if (
            ((I.p1 = I.p.subtract(n.ONE)),
            (I.q1 = I.q.subtract(n.ONE)),
            (I.phi = I.p1.multiply(I.q1)),
            I.phi.gcd(I.e).compareTo(n.ONE) !== 0)
          ) {
            ;(I.p = I.q = null), O()
            return
          }
          if (((I.n = I.p.multiply(I.q)), I.n.bitLength() !== I.bits)) {
            ;(I.q = null), x(I.qBits, L)
            return
          }
          var Q = I.e.modInverse(I.phi)
          ;(I.keys = {
            privateKey: o.rsa.setPrivateKey(I.n, I.e, Q, I.p, I.q, Q.mod(I.p1), Q.mod(I.q1), I.q.modInverse(I.p)),
            publicKey: o.rsa.setPublicKey(I.n, I.e)
          }),
            q(null, I.keys)
        }
      }
      function A(I) {
        var M = I.toString(16)
        M[0] >= '8' && (M = '00' + M)
        var q = t.util.hexToBytes(M)
        return q.length > 1 &&
          ((q.charCodeAt(0) === 0 && (q.charCodeAt(1) & 128) == 0) ||
            (q.charCodeAt(0) === 255 && (q.charCodeAt(1) & 128) == 128))
          ? q.substr(1)
          : q
      }
      function T(I) {
        return I <= 100
          ? 27
          : I <= 150
          ? 18
          : I <= 200
          ? 15
          : I <= 250
          ? 12
          : I <= 300
          ? 9
          : I <= 350
          ? 8
          : I <= 400
          ? 7
          : I <= 500
          ? 6
          : I <= 600
          ? 5
          : I <= 800
          ? 4
          : I <= 1250
          ? 3
          : 2
      }
      function E(I) {
        return t.util.isNodejs && typeof i[I] == 'function'
      }
      function k(I) {
        return (
          typeof u.globalScope != 'undefined' &&
          typeof u.globalScope.crypto == 'object' &&
          typeof u.globalScope.crypto.subtle == 'object' &&
          typeof u.globalScope.crypto.subtle[I] == 'function'
        )
      }
      function w(I) {
        return (
          typeof u.globalScope != 'undefined' &&
          typeof u.globalScope.msCrypto == 'object' &&
          typeof u.globalScope.msCrypto.subtle == 'object' &&
          typeof u.globalScope.msCrypto.subtle[I] == 'function'
        )
      }
      function v(I) {
        for (var M = t.util.hexToBytes(I.toString(16)), q = new Uint8Array(M.length), G = 0; G < M.length; ++G)
          q[G] = M.charCodeAt(G)
        return q
      }
    }
  }),
  t9 = te({
    'node_modules/node-forge/lib/pbe.js'(e, r) {
      V(), F()
      var t = yt()
      qc(),
        qi(),
        Zp(),
        Es(),
        Uc(),
        e9(),
        Qp(),
        Ss(),
        ZP(),
        nf(),
        zt(),
        typeof n == 'undefined' && (n = t.jsbn.BigInteger)
      var n,
        i = t.asn1,
        s = (t.pki = t.pki || {})
      r.exports = s.pbe = t.pbe = t.pbe || {}
      var u = s.oids,
        o = {
          name: 'EncryptedPrivateKeyInfo',
          tagClass: i.Class.UNIVERSAL,
          type: i.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'EncryptedPrivateKeyInfo.encryptionAlgorithm',
              tagClass: i.Class.UNIVERSAL,
              type: i.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'AlgorithmIdentifier.algorithm',
                  tagClass: i.Class.UNIVERSAL,
                  type: i.Type.OID,
                  constructed: !1,
                  capture: 'encryptionOid'
                },
                {
                  name: 'AlgorithmIdentifier.parameters',
                  tagClass: i.Class.UNIVERSAL,
                  type: i.Type.SEQUENCE,
                  constructed: !0,
                  captureAsn1: 'encryptionParams'
                }
              ]
            },
            {
              name: 'EncryptedPrivateKeyInfo.encryptedData',
              tagClass: i.Class.UNIVERSAL,
              type: i.Type.OCTETSTRING,
              constructed: !1,
              capture: 'encryptedData'
            }
          ]
        },
        l = {
          name: 'PBES2Algorithms',
          tagClass: i.Class.UNIVERSAL,
          type: i.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'PBES2Algorithms.keyDerivationFunc',
              tagClass: i.Class.UNIVERSAL,
              type: i.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'PBES2Algorithms.keyDerivationFunc.oid',
                  tagClass: i.Class.UNIVERSAL,
                  type: i.Type.OID,
                  constructed: !1,
                  capture: 'kdfOid'
                },
                {
                  name: 'PBES2Algorithms.params',
                  tagClass: i.Class.UNIVERSAL,
                  type: i.Type.SEQUENCE,
                  constructed: !0,
                  value: [
                    {
                      name: 'PBES2Algorithms.params.salt',
                      tagClass: i.Class.UNIVERSAL,
                      type: i.Type.OCTETSTRING,
                      constructed: !1,
                      capture: 'kdfSalt'
                    },
                    {
                      name: 'PBES2Algorithms.params.iterationCount',
                      tagClass: i.Class.UNIVERSAL,
                      type: i.Type.INTEGER,
                      constructed: !1,
                      capture: 'kdfIterationCount'
                    },
                    {
                      name: 'PBES2Algorithms.params.keyLength',
                      tagClass: i.Class.UNIVERSAL,
                      type: i.Type.INTEGER,
                      constructed: !1,
                      optional: !0,
                      capture: 'keyLength'
                    },
                    {
                      name: 'PBES2Algorithms.params.prf',
                      tagClass: i.Class.UNIVERSAL,
                      type: i.Type.SEQUENCE,
                      constructed: !0,
                      optional: !0,
                      value: [
                        {
                          name: 'PBES2Algorithms.params.prf.algorithm',
                          tagClass: i.Class.UNIVERSAL,
                          type: i.Type.OID,
                          constructed: !1,
                          capture: 'prfOid'
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              name: 'PBES2Algorithms.encryptionScheme',
              tagClass: i.Class.UNIVERSAL,
              type: i.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'PBES2Algorithms.encryptionScheme.oid',
                  tagClass: i.Class.UNIVERSAL,
                  type: i.Type.OID,
                  constructed: !1,
                  capture: 'encOid'
                },
                {
                  name: 'PBES2Algorithms.encryptionScheme.iv',
                  tagClass: i.Class.UNIVERSAL,
                  type: i.Type.OCTETSTRING,
                  constructed: !1,
                  capture: 'encIv'
                }
              ]
            }
          ]
        },
        a = {
          name: 'pkcs-12PbeParams',
          tagClass: i.Class.UNIVERSAL,
          type: i.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'pkcs-12PbeParams.salt',
              tagClass: i.Class.UNIVERSAL,
              type: i.Type.OCTETSTRING,
              constructed: !1,
              capture: 'salt'
            },
            {
              name: 'pkcs-12PbeParams.iterations',
              tagClass: i.Class.UNIVERSAL,
              type: i.Type.INTEGER,
              constructed: !1,
              capture: 'iterations'
            }
          ]
        }
      ;(s.encryptPrivateKeyInfo = function (d, h, m) {
        ;(m = m || {}),
          (m.saltSize = m.saltSize || 8),
          (m.count = m.count || 2048),
          (m.algorithm = m.algorithm || 'aes128'),
          (m.prfAlgorithm = m.prfAlgorithm || 'sha1')
        var _ = t.random.getBytesSync(m.saltSize),
          A = m.count,
          T = i.integerToDer(A),
          E,
          k,
          w
        if (m.algorithm.indexOf('aes') === 0 || m.algorithm === 'des') {
          var v, I, M
          switch (m.algorithm) {
            case 'aes128':
              ;(E = 16), (v = 16), (I = u['aes128-CBC']), (M = t.aes.createEncryptionCipher)
              break
            case 'aes192':
              ;(E = 24), (v = 16), (I = u['aes192-CBC']), (M = t.aes.createEncryptionCipher)
              break
            case 'aes256':
              ;(E = 32), (v = 16), (I = u['aes256-CBC']), (M = t.aes.createEncryptionCipher)
              break
            case 'des':
              ;(E = 8), (v = 8), (I = u.desCBC), (M = t.des.createEncryptionCipher)
              break
            default:
              var q = new Error('Cannot encrypt private key. Unknown encryption algorithm.')
              throw ((q.algorithm = m.algorithm), q)
          }
          var G = 'hmacWith' + m.prfAlgorithm.toUpperCase(),
            O = p(G),
            x = t.pkcs5.pbkdf2(h, _, A, E, O),
            L = t.random.getBytesSync(v),
            K = M(x)
          K.start(L), K.update(i.toDer(d)), K.finish(), (w = K.output.getBytes())
          var J = y(_, T, E, G)
          k = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
            i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(u.pkcs5PBES2).getBytes()),
            i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
              i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
                i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(u.pkcs5PBKDF2).getBytes()),
                J
              ]),
              i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
                i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(I).getBytes()),
                i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, L)
              ])
            ])
          ])
        } else if (m.algorithm === '3des') {
          E = 24
          var Z = new t.util.ByteBuffer(_),
            x = s.pbe.generatePkcs12Key(h, Z, 1, A, E),
            L = s.pbe.generatePkcs12Key(h, Z, 2, A, E),
            K = t.des.createEncryptionCipher(x)
          K.start(L),
            K.update(i.toDer(d)),
            K.finish(),
            (w = K.output.getBytes()),
            (k = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
              i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(u['pbeWithSHAAnd3-KeyTripleDES-CBC']).getBytes()),
              i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
                i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, _),
                i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, T.getBytes())
              ])
            ]))
        } else {
          var q = new Error('Cannot encrypt private key. Unknown encryption algorithm.')
          throw ((q.algorithm = m.algorithm), q)
        }
        var Q = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
          k,
          i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, w)
        ])
        return Q
      }),
        (s.decryptPrivateKeyInfo = function (d, h) {
          var m = null,
            _ = {},
            A = []
          if (!i.validate(d, o, _, A)) {
            var T = new Error(
              'Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.'
            )
            throw ((T.errors = A), T)
          }
          var E = i.derToOid(_.encryptionOid),
            k = s.pbe.getCipher(E, _.encryptionParams, h),
            w = t.util.createBuffer(_.encryptedData)
          return k.update(w), k.finish() && (m = i.fromDer(k.output)), m
        }),
        (s.encryptedPrivateKeyToPem = function (d, h) {
          var m = { type: 'ENCRYPTED PRIVATE KEY', body: i.toDer(d).getBytes() }
          return t.pem.encode(m, { maxline: h })
        }),
        (s.encryptedPrivateKeyFromPem = function (d) {
          var h = t.pem.decode(d)[0]
          if (h.type !== 'ENCRYPTED PRIVATE KEY') {
            var m = new Error(
              'Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".'
            )
            throw ((m.headerType = h.type), m)
          }
          if (h.procType && h.procType.type === 'ENCRYPTED')
            throw new Error('Could not convert encrypted private key from PEM; PEM is encrypted.')
          return i.fromDer(h.body)
        }),
        (s.encryptRsaPrivateKey = function (d, h, m) {
          if (((m = m || {}), !m.legacy)) {
            var _ = s.wrapRsaPrivateKey(s.privateKeyToAsn1(d))
            return (_ = s.encryptPrivateKeyInfo(_, h, m)), s.encryptedPrivateKeyToPem(_)
          }
          var A, T, E, k
          switch (m.algorithm) {
            case 'aes128':
              ;(A = 'AES-128-CBC'), (E = 16), (T = t.random.getBytesSync(16)), (k = t.aes.createEncryptionCipher)
              break
            case 'aes192':
              ;(A = 'AES-192-CBC'), (E = 24), (T = t.random.getBytesSync(16)), (k = t.aes.createEncryptionCipher)
              break
            case 'aes256':
              ;(A = 'AES-256-CBC'), (E = 32), (T = t.random.getBytesSync(16)), (k = t.aes.createEncryptionCipher)
              break
            case '3des':
              ;(A = 'DES-EDE3-CBC'), (E = 24), (T = t.random.getBytesSync(8)), (k = t.des.createEncryptionCipher)
              break
            case 'des':
              ;(A = 'DES-CBC'), (E = 8), (T = t.random.getBytesSync(8)), (k = t.des.createEncryptionCipher)
              break
            default:
              var w = new Error(
                'Could not encrypt RSA private key; unsupported encryption algorithm "' + m.algorithm + '".'
              )
              throw ((w.algorithm = m.algorithm), w)
          }
          var v = t.pbe.opensslDeriveBytes(h, T.substr(0, 8), E),
            I = k(v)
          I.start(T), I.update(i.toDer(s.privateKeyToAsn1(d))), I.finish()
          var M = {
            type: 'RSA PRIVATE KEY',
            procType: { version: '4', type: 'ENCRYPTED' },
            dekInfo: { algorithm: A, parameters: t.util.bytesToHex(T).toUpperCase() },
            body: I.output.getBytes()
          }
          return t.pem.encode(M)
        }),
        (s.decryptRsaPrivateKey = function (d, h) {
          var m = null,
            _ = t.pem.decode(d)[0]
          if (_.type !== 'ENCRYPTED PRIVATE KEY' && _.type !== 'PRIVATE KEY' && _.type !== 'RSA PRIVATE KEY') {
            var A = new Error(
              'Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".'
            )
            throw ((A.headerType = A), A)
          }
          if (_.procType && _.procType.type === 'ENCRYPTED') {
            var T, E
            switch (_.dekInfo.algorithm) {
              case 'DES-CBC':
                ;(T = 8), (E = t.des.createDecryptionCipher)
                break
              case 'DES-EDE3-CBC':
                ;(T = 24), (E = t.des.createDecryptionCipher)
                break
              case 'AES-128-CBC':
                ;(T = 16), (E = t.aes.createDecryptionCipher)
                break
              case 'AES-192-CBC':
                ;(T = 24), (E = t.aes.createDecryptionCipher)
                break
              case 'AES-256-CBC':
                ;(T = 32), (E = t.aes.createDecryptionCipher)
                break
              case 'RC2-40-CBC':
                ;(T = 5),
                  (E = function (M) {
                    return t.rc2.createDecryptionCipher(M, 40)
                  })
                break
              case 'RC2-64-CBC':
                ;(T = 8),
                  (E = function (M) {
                    return t.rc2.createDecryptionCipher(M, 64)
                  })
                break
              case 'RC2-128-CBC':
                ;(T = 16),
                  (E = function (M) {
                    return t.rc2.createDecryptionCipher(M, 128)
                  })
                break
              default:
                var A = new Error(
                  'Could not decrypt private key; unsupported encryption algorithm "' + _.dekInfo.algorithm + '".'
                )
                throw ((A.algorithm = _.dekInfo.algorithm), A)
            }
            var k = t.util.hexToBytes(_.dekInfo.parameters),
              w = t.pbe.opensslDeriveBytes(h, k.substr(0, 8), T),
              v = E(w)
            if ((v.start(k), v.update(t.util.createBuffer(_.body)), v.finish())) m = v.output.getBytes()
            else return m
          } else m = _.body
          return (
            _.type === 'ENCRYPTED PRIVATE KEY' ? (m = s.decryptPrivateKeyInfo(i.fromDer(m), h)) : (m = i.fromDer(m)),
            m !== null && (m = s.privateKeyFromAsn1(m)),
            m
          )
        }),
        (s.pbe.generatePkcs12Key = function (d, h, m, _, A, T) {
          var E, k
          if (typeof T == 'undefined' || T === null) {
            if (!('sha1' in t.md)) throw new Error('"sha1" hash algorithm unavailable.')
            T = t.md.sha1.create()
          }
          var w = T.digestLength,
            v = T.blockLength,
            I = new t.util.ByteBuffer(),
            M = new t.util.ByteBuffer()
          if (d != null) {
            for (k = 0; k < d.length; k++) M.putInt16(d.charCodeAt(k))
            M.putInt16(0)
          }
          var q = M.length(),
            G = h.length(),
            O = new t.util.ByteBuffer()
          O.fillWithByte(m, v)
          var x = v * Math.ceil(G / v),
            L = new t.util.ByteBuffer()
          for (k = 0; k < x; k++) L.putByte(h.at(k % G))
          var K = v * Math.ceil(q / v),
            J = new t.util.ByteBuffer()
          for (k = 0; k < K; k++) J.putByte(M.at(k % q))
          var Z = L
          Z.putBuffer(J)
          for (var Q = Math.ceil(A / w), fe = 1; fe <= Q; fe++) {
            var ie = new t.util.ByteBuffer()
            ie.putBytes(O.bytes()), ie.putBytes(Z.bytes())
            for (var W = 0; W < _; W++) T.start(), T.update(ie.getBytes()), (ie = T.digest())
            var le = new t.util.ByteBuffer()
            for (k = 0; k < v; k++) le.putByte(ie.at(k % w))
            var xe = Math.ceil(G / v) + Math.ceil(q / v),
              _e = new t.util.ByteBuffer()
            for (E = 0; E < xe; E++) {
              var Ne = new t.util.ByteBuffer(Z.getBytes(v)),
                ke = 511
              for (k = le.length() - 1; k >= 0; k--) (ke = ke >> 8), (ke += le.at(k) + Ne.at(k)), Ne.setAt(k, ke & 255)
              _e.putBuffer(Ne)
            }
            ;(Z = _e), I.putBuffer(ie)
          }
          return I.truncate(I.length() - A), I
        }),
        (s.pbe.getCipher = function (d, h, m) {
          switch (d) {
            case s.oids.pkcs5PBES2:
              return s.pbe.getCipherForPBES2(d, h, m)
            case s.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
            case s.oids['pbewithSHAAnd40BitRC2-CBC']:
              return s.pbe.getCipherForPKCS12PBE(d, h, m)
            default:
              var _ = new Error('Cannot read encrypted PBE data block. Unsupported OID.')
              throw (
                ((_.oid = d),
                (_.supportedOids = ['pkcs5PBES2', 'pbeWithSHAAnd3-KeyTripleDES-CBC', 'pbewithSHAAnd40BitRC2-CBC']),
                _)
              )
          }
        }),
        (s.pbe.getCipherForPBES2 = function (d, h, m) {
          var _ = {},
            A = []
          if (!i.validate(h, l, _, A)) {
            var T = new Error(
              'Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.'
            )
            throw ((T.errors = A), T)
          }
          if (((d = i.derToOid(_.kdfOid)), d !== s.oids.pkcs5PBKDF2)) {
            var T = new Error('Cannot read encrypted private key. Unsupported key derivation function OID.')
            throw ((T.oid = d), (T.supportedOids = ['pkcs5PBKDF2']), T)
          }
          if (
            ((d = i.derToOid(_.encOid)),
            d !== s.oids['aes128-CBC'] &&
              d !== s.oids['aes192-CBC'] &&
              d !== s.oids['aes256-CBC'] &&
              d !== s.oids['des-EDE3-CBC'] &&
              d !== s.oids.desCBC)
          ) {
            var T = new Error('Cannot read encrypted private key. Unsupported encryption scheme OID.')
            throw (
              ((T.oid = d), (T.supportedOids = ['aes128-CBC', 'aes192-CBC', 'aes256-CBC', 'des-EDE3-CBC', 'desCBC']), T)
            )
          }
          var E = _.kdfSalt,
            k = t.util.createBuffer(_.kdfIterationCount)
          k = k.getInt(k.length() << 3)
          var w, v
          switch (s.oids[d]) {
            case 'aes128-CBC':
              ;(w = 16), (v = t.aes.createDecryptionCipher)
              break
            case 'aes192-CBC':
              ;(w = 24), (v = t.aes.createDecryptionCipher)
              break
            case 'aes256-CBC':
              ;(w = 32), (v = t.aes.createDecryptionCipher)
              break
            case 'des-EDE3-CBC':
              ;(w = 24), (v = t.des.createDecryptionCipher)
              break
            case 'desCBC':
              ;(w = 8), (v = t.des.createDecryptionCipher)
              break
          }
          var I = f(_.prfOid),
            M = t.pkcs5.pbkdf2(m, E, k, w, I),
            q = _.encIv,
            G = v(M)
          return G.start(q), G
        }),
        (s.pbe.getCipherForPKCS12PBE = function (d, h, m) {
          var _ = {},
            A = []
          if (!i.validate(h, a, _, A)) {
            var T = new Error(
              'Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.'
            )
            throw ((T.errors = A), T)
          }
          var E = t.util.createBuffer(_.salt),
            k = t.util.createBuffer(_.iterations)
          k = k.getInt(k.length() << 3)
          var w, v, I
          switch (d) {
            case s.oids['pbeWithSHAAnd3-KeyTripleDES-CBC']:
              ;(w = 24), (v = 8), (I = t.des.startDecrypting)
              break
            case s.oids['pbewithSHAAnd40BitRC2-CBC']:
              ;(w = 5),
                (v = 8),
                (I = function (x, L) {
                  var K = t.rc2.createDecryptionCipher(x, 40)
                  return K.start(L, null), K
                })
              break
            default:
              var T = new Error('Cannot read PKCS #12 PBE data block. Unsupported OID.')
              throw ((T.oid = d), T)
          }
          var M = f(_.prfOid),
            q = s.pbe.generatePkcs12Key(m, E, 1, k, w, M)
          M.start()
          var G = s.pbe.generatePkcs12Key(m, E, 2, k, v, M)
          return I(q, G)
        }),
        (s.pbe.opensslDeriveBytes = function (d, h, m, _) {
          if (typeof _ == 'undefined' || _ === null) {
            if (!('md5' in t.md)) throw new Error('"md5" hash algorithm unavailable.')
            _ = t.md.md5.create()
          }
          h === null && (h = '')
          for (var A = [c(_, d + h)], T = 16, E = 1; T < m; ++E, T += 16) A.push(c(_, A[E - 1] + d + h))
          return A.join('').substr(0, m)
        })
      function c(d, h) {
        return d.start().update(h).digest().getBytes()
      }
      function f(d) {
        var h
        if (!d) h = 'hmacWithSHA1'
        else if (((h = s.oids[i.derToOid(d)]), !h)) {
          var m = new Error('Unsupported PRF OID.')
          throw (
            ((m.oid = d),
            (m.supported = ['hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384', 'hmacWithSHA512']),
            m)
          )
        }
        return p(h)
      }
      function p(d) {
        var h = t.md
        switch (d) {
          case 'hmacWithSHA224':
            h = t.md.sha512
          case 'hmacWithSHA1':
          case 'hmacWithSHA256':
          case 'hmacWithSHA384':
          case 'hmacWithSHA512':
            d = d.substr(8).toLowerCase()
            break
          default:
            var m = new Error('Unsupported PRF algorithm.')
            throw (
              ((m.algorithm = d),
              (m.supported = ['hmacWithSHA1', 'hmacWithSHA224', 'hmacWithSHA256', 'hmacWithSHA384', 'hmacWithSHA512']),
              m)
            )
        }
        if (!h || !(d in h)) throw new Error('Unknown hash algorithm: ' + d)
        return h[d].create()
      }
      function y(d, h, m, _) {
        var A = i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
          i.create(i.Class.UNIVERSAL, i.Type.OCTETSTRING, !1, d),
          i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, h.getBytes())
        ])
        return (
          _ !== 'hmacWithSHA1' &&
            A.value.push(
              i.create(i.Class.UNIVERSAL, i.Type.INTEGER, !1, t.util.hexToBytes(m.toString(16))),
              i.create(i.Class.UNIVERSAL, i.Type.SEQUENCE, !0, [
                i.create(i.Class.UNIVERSAL, i.Type.OID, !1, i.oidToDer(s.oids[_]).getBytes()),
                i.create(i.Class.UNIVERSAL, i.Type.NULL, !1, '')
              ])
            ),
          A
        )
      }
    }
  })
function rO(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var r9,
  n9,
  i9,
  nO = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (r9 = rO), (n9 = r9), (i9 = n9)
    }
  }),
  iO,
  e1,
  t1 = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (iO = new Uint8Array(0)),
        (e1 = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        })
    }
  }),
  s9,
  o9,
  r1,
  a9,
  n1,
  i1,
  c9,
  u9,
  jc,
  l9 = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        nO(),
        t1(),
        (s9 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (o9 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new r1(r)
          }
        }),
        (r1 = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new r1({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (a9 = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new s9(e, r, t)),
              (this.decoder = new o9(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (n1 = ({ name: e, prefix: r, encode: t, decode: n }) => new a9(e, r, t, n)),
        (i1 = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = i9(t, r)
          return n1({ prefix: e, name: r, encode: n, decode: (s) => e1(i(s)) })
        }),
        (c9 = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (u9 = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (jc = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          n1({
            prefix: r,
            name: e,
            encode(i) {
              return u9(i, n, t)
            },
            decode(i) {
              return c9(i, n, t, e)
            }
          }))
    }
  }),
  s1 = {}
Re(s1, { base64: () => f9, base64pad: () => d9, base64url: () => h9, base64urlpad: () => p9 })
var f9,
  d9,
  h9,
  p9,
  m9 = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        l9(),
        (f9 = jc({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (d9 = jc({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (h9 = jc({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (p9 = jc({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  }),
  sf = te({
    'node_modules/libp2p-crypto/src/webcrypto.js'(e) {
      V(),
        F(),
        (e.get = (r = self) => {
          let t = r.crypto || r.msCrypto
          if (!t || !t.subtle)
            throw Object.assign(
              new Error(
                'Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api'
              ),
              { code: 'ERR_MISSING_WEB_CRYPTO' }
            )
          return t
        })
    }
  }),
  b9 = te({
    'node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js'(e, r) {
      V(), F()
      var { concat: t } = (hs(), Li),
        { fromString: n } = (gn(), un),
        i = sf()
      function s({
        algorithm: u = 'AES-GCM',
        nonceLength: o = 12,
        keyLength: l = 16,
        digest: a = 'SHA-256',
        saltLength: c = 16,
        iterations: f = 32767
      } = {}) {
        let p = i.get()
        l *= 8
        async function y(h, m) {
          let _ = p.getRandomValues(new Uint8Array(c)),
            A = p.getRandomValues(new Uint8Array(o)),
            T = { name: u, iv: A },
            E = { name: 'PBKDF2', salt: _, iterations: f, hash: { name: a } },
            k = await p.subtle.importKey('raw', n(m), { name: 'PBKDF2' }, !1, ['deriveKey', 'deriveBits']),
            w = await p.subtle.deriveKey(E, k, { name: u, length: l }, !0, ['encrypt']),
            v = await p.subtle.encrypt(T, w, h)
          return t([_, T.iv, new Uint8Array(v)])
        }
        async function d(h, m) {
          let _ = h.slice(0, c),
            A = h.slice(c, c + o),
            T = h.slice(c + o),
            E = { name: u, iv: A },
            k = { name: 'PBKDF2', salt: _, iterations: f, hash: { name: a } },
            w = await p.subtle.importKey('raw', n(m), { name: 'PBKDF2' }, !1, ['deriveKey', 'deriveBits']),
            v = await p.subtle.deriveKey(k, w, { name: u, length: l }, !0, ['decrypt']),
            I = await p.subtle.decrypt(E, v, T)
          return new Uint8Array(I)
        }
        return { encrypt: y, decrypt: d }
      }
      r.exports = { create: s }
    }
  }),
  sO = te({
    'node_modules/libp2p-crypto/src/keys/importer.js'(e, r) {
      V(), F()
      var { base64: t } = (m9(), s1),
        n = b9()
      r.exports = {
        import: async function (i, s) {
          let u = t.decode(i)
          return await n.create().decrypt(u, s)
        }
      }
    }
  })
function y9(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= _9; ) (r[t++] = (e & 255) | a1), (e /= 128)
  for (; e & w9; ) (r[t++] = (e & 255) | a1), (e >>>= 7)
  return (r[t] = e | 0), (y9.bytes = t - n + 1), r
}
function o1(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((o1.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & c1) << n : (s & c1) * Math.pow(2, n)), (n += 7)
  } while (s >= S9)
  return (o1.bytes = i - r), t
}
var v9,
  a1,
  g9,
  w9,
  _9,
  E9,
  S9,
  c1,
  A9,
  I9,
  T9,
  C9,
  k9,
  M9,
  x9,
  R9,
  B9,
  N9,
  P9,
  O9,
  u1,
  oO = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        (v9 = y9),
        (a1 = 128),
        (g9 = 127),
        (w9 = ~g9),
        (_9 = Math.pow(2, 31)),
        (E9 = o1),
        (S9 = 128),
        (c1 = 127),
        (A9 = Math.pow(2, 7)),
        (I9 = Math.pow(2, 14)),
        (T9 = Math.pow(2, 21)),
        (C9 = Math.pow(2, 28)),
        (k9 = Math.pow(2, 35)),
        (M9 = Math.pow(2, 42)),
        (x9 = Math.pow(2, 49)),
        (R9 = Math.pow(2, 56)),
        (B9 = Math.pow(2, 63)),
        (N9 = function (e) {
          return e < A9
            ? 1
            : e < I9
            ? 2
            : e < T9
            ? 3
            : e < C9
            ? 4
            : e < k9
            ? 5
            : e < M9
            ? 6
            : e < x9
            ? 7
            : e < R9
            ? 8
            : e < B9
            ? 9
            : 10
        }),
        (P9 = { encode: v9, decode: E9, encodingLength: N9 }),
        (O9 = P9),
        (u1 = O9)
    }
  }),
  l1,
  f1,
  aO = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/varint.js'() {
      V(), F(), oO(), (l1 = (e, r, t = 0) => (u1.encode(e, r, t), r)), (f1 = (e) => u1.encodingLength(e))
    }
  }),
  D9,
  L9,
  cO = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        t1(),
        aO(),
        (D9 = (e, r) => {
          let t = r.byteLength,
            n = f1(e),
            i = n + f1(t),
            s = new Uint8Array(i + t)
          return l1(e, s, 0), l1(t, s, n), s.set(r, i), new L9(e, t, r, s)
        }),
        (L9 = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  of,
  U9,
  q9 = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        cO(),
        (of = ({ name: e, code: r, encode: t }) => new U9(e, r, t)),
        (U9 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return D9(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  zc = {}
Re(zc, { sha256: () => j9, sha512: () => z9 })
var d1,
  j9,
  z9,
  af = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        q9(),
        (d1 = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (j9 = of({ name: 'sha2-256', code: 18, encode: d1('SHA-256') })),
        (z9 = of({ name: 'sha2-512', code: 19, encode: d1('SHA-512') }))
    }
  }),
  h1 = te({
    'node_modules/node-forge/lib/sha512.js'(e, r) {
      V(), F()
      var t = yt()
      Es(), zt()
      var n = (r.exports = t.sha512 = t.sha512 || {})
      t.md.sha512 = t.md.algorithms.sha512 = n
      var i = (t.sha384 = t.sha512.sha384 = t.sha512.sha384 || {})
      ;(i.create = function () {
        return n.create('SHA-384')
      }),
        (t.md.sha384 = t.md.algorithms.sha384 = i),
        (t.sha512.sha256 = t.sha512.sha256 || {
          create: function () {
            return n.create('SHA-512/256')
          }
        }),
        (t.md['sha512/256'] = t.md.algorithms['sha512/256'] = t.sha512.sha256),
        (t.sha512.sha224 = t.sha512.sha224 || {
          create: function () {
            return n.create('SHA-512/224')
          }
        }),
        (t.md['sha512/224'] = t.md.algorithms['sha512/224'] = t.sha512.sha224),
        (n.create = function (f) {
          if ((u || a(), typeof f == 'undefined' && (f = 'SHA-512'), !(f in l)))
            throw new Error('Invalid SHA-512 algorithm: ' + f)
          for (var p = l[f], y = null, d = t.util.createBuffer(), h = new Array(80), m = 0; m < 80; ++m)
            h[m] = new Array(2)
          var _ = 64
          switch (f) {
            case 'SHA-384':
              _ = 48
              break
            case 'SHA-512/256':
              _ = 32
              break
            case 'SHA-512/224':
              _ = 28
              break
          }
          var A = {
            algorithm: f.replace('-', '').toLowerCase(),
            blockLength: 128,
            digestLength: _,
            messageLength: 0,
            fullMessageLength: null,
            messageLengthSize: 16
          }
          return (
            (A.start = function () {
              ;(A.messageLength = 0), (A.fullMessageLength = A.messageLength128 = [])
              for (var T = A.messageLengthSize / 4, E = 0; E < T; ++E) A.fullMessageLength.push(0)
              ;(d = t.util.createBuffer()), (y = new Array(p.length))
              for (var E = 0; E < p.length; ++E) y[E] = p[E].slice(0)
              return A
            }),
            A.start(),
            (A.update = function (T, E) {
              E === 'utf8' && (T = t.util.encodeUtf8(T))
              var k = T.length
              ;(A.messageLength += k), (k = [(k / 4294967296) >>> 0, k >>> 0])
              for (var w = A.fullMessageLength.length - 1; w >= 0; --w)
                (A.fullMessageLength[w] += k[1]),
                  (k[1] = k[0] + ((A.fullMessageLength[w] / 4294967296) >>> 0)),
                  (A.fullMessageLength[w] = A.fullMessageLength[w] >>> 0),
                  (k[0] = (k[1] / 4294967296) >>> 0)
              return d.putBytes(T), c(y, h, d), (d.read > 2048 || d.length() === 0) && d.compact(), A
            }),
            (A.digest = function () {
              var T = t.util.createBuffer()
              T.putBytes(d.bytes())
              var E = A.fullMessageLength[A.fullMessageLength.length - 1] + A.messageLengthSize,
                k = E & (A.blockLength - 1)
              T.putBytes(s.substr(0, A.blockLength - k))
              for (var w, v, I = A.fullMessageLength[0] * 8, M = 0; M < A.fullMessageLength.length - 1; ++M)
                (w = A.fullMessageLength[M + 1] * 8),
                  (v = (w / 4294967296) >>> 0),
                  (I += v),
                  T.putInt32(I >>> 0),
                  (I = w >>> 0)
              T.putInt32(I)
              for (var q = new Array(y.length), M = 0; M < y.length; ++M) q[M] = y[M].slice(0)
              c(q, h, T)
              var G = t.util.createBuffer(),
                O
              f === 'SHA-512' ? (O = q.length) : f === 'SHA-384' ? (O = q.length - 2) : (O = q.length - 4)
              for (var M = 0; M < O; ++M)
                G.putInt32(q[M][0]), (M !== O - 1 || f !== 'SHA-512/224') && G.putInt32(q[M][1])
              return G
            }),
            A
          )
        })
      var s = null,
        u = !1,
        o = null,
        l = null
      function a() {
        ;(s = String.fromCharCode(128)),
          (s += t.util.fillString(String.fromCharCode(0), 128)),
          (o = [
            [1116352408, 3609767458],
            [1899447441, 602891725],
            [3049323471, 3964484399],
            [3921009573, 2173295548],
            [961987163, 4081628472],
            [1508970993, 3053834265],
            [2453635748, 2937671579],
            [2870763221, 3664609560],
            [3624381080, 2734883394],
            [310598401, 1164996542],
            [607225278, 1323610764],
            [1426881987, 3590304994],
            [1925078388, 4068182383],
            [2162078206, 991336113],
            [2614888103, 633803317],
            [3248222580, 3479774868],
            [3835390401, 2666613458],
            [4022224774, 944711139],
            [264347078, 2341262773],
            [604807628, 2007800933],
            [770255983, 1495990901],
            [1249150122, 1856431235],
            [1555081692, 3175218132],
            [1996064986, 2198950837],
            [2554220882, 3999719339],
            [2821834349, 766784016],
            [2952996808, 2566594879],
            [3210313671, 3203337956],
            [3336571891, 1034457026],
            [3584528711, 2466948901],
            [113926993, 3758326383],
            [338241895, 168717936],
            [666307205, 1188179964],
            [773529912, 1546045734],
            [1294757372, 1522805485],
            [1396182291, 2643833823],
            [1695183700, 2343527390],
            [1986661051, 1014477480],
            [2177026350, 1206759142],
            [2456956037, 344077627],
            [2730485921, 1290863460],
            [2820302411, 3158454273],
            [3259730800, 3505952657],
            [3345764771, 106217008],
            [3516065817, 3606008344],
            [3600352804, 1432725776],
            [4094571909, 1467031594],
            [275423344, 851169720],
            [430227734, 3100823752],
            [506948616, 1363258195],
            [659060556, 3750685593],
            [883997877, 3785050280],
            [958139571, 3318307427],
            [1322822218, 3812723403],
            [1537002063, 2003034995],
            [1747873779, 3602036899],
            [1955562222, 1575990012],
            [2024104815, 1125592928],
            [2227730452, 2716904306],
            [2361852424, 442776044],
            [2428436474, 593698344],
            [2756734187, 3733110249],
            [3204031479, 2999351573],
            [3329325298, 3815920427],
            [3391569614, 3928383900],
            [3515267271, 566280711],
            [3940187606, 3454069534],
            [4118630271, 4000239992],
            [116418474, 1914138554],
            [174292421, 2731055270],
            [289380356, 3203993006],
            [460393269, 320620315],
            [685471733, 587496836],
            [852142971, 1086792851],
            [1017036298, 365543100],
            [1126000580, 2618297676],
            [1288033470, 3409855158],
            [1501505948, 4234509866],
            [1607167915, 987167468],
            [1816402316, 1246189591]
          ]),
          (l = {}),
          (l['SHA-512'] = [
            [1779033703, 4089235720],
            [3144134277, 2227873595],
            [1013904242, 4271175723],
            [2773480762, 1595750129],
            [1359893119, 2917565137],
            [2600822924, 725511199],
            [528734635, 4215389547],
            [1541459225, 327033209]
          ]),
          (l['SHA-384'] = [
            [3418070365, 3238371032],
            [1654270250, 914150663],
            [2438529370, 812702999],
            [355462360, 4144912697],
            [1731405415, 4290775857],
            [2394180231, 1750603025],
            [3675008525, 1694076839],
            [1203062813, 3204075428]
          ]),
          (l['SHA-512/256'] = [
            [573645204, 4230739756],
            [2673172387, 3360449730],
            [596883563, 1867755857],
            [2520282905, 1497426621],
            [2519219938, 2827943907],
            [3193839141, 1401305490],
            [721525244, 746961066],
            [246885852, 2177182882]
          ]),
          (l['SHA-512/224'] = [
            [2352822216, 424955298],
            [1944164710, 2312950998],
            [502970286, 855612546],
            [1738396948, 1479516111],
            [258812777, 2077511080],
            [2011393907, 79989058],
            [1067287976, 1780299464],
            [286451373, 2446758561]
          ]),
          (u = !0)
      }
      function c(f, p, y) {
        for (
          var d,
            h,
            m,
            _,
            A,
            T,
            E,
            k,
            w,
            v,
            I,
            M,
            q,
            G,
            O,
            x,
            L,
            K,
            J,
            Z,
            Q,
            fe,
            ie,
            W,
            le,
            xe,
            _e,
            Ne,
            ke,
            oe,
            be,
            ge,
            re,
            j,
            b,
            C = y.length();
          C >= 128;

        ) {
          for (ke = 0; ke < 16; ++ke) (p[ke][0] = y.getInt32() >>> 0), (p[ke][1] = y.getInt32() >>> 0)
          for (; ke < 80; ++ke)
            (ge = p[ke - 2]),
              (oe = ge[0]),
              (be = ge[1]),
              (d = (((oe >>> 19) | (be << 13)) ^ ((be >>> 29) | (oe << 3)) ^ (oe >>> 6)) >>> 0),
              (h = (((oe << 13) | (be >>> 19)) ^ ((be << 3) | (oe >>> 29)) ^ ((oe << 26) | (be >>> 6))) >>> 0),
              (j = p[ke - 15]),
              (oe = j[0]),
              (be = j[1]),
              (m = (((oe >>> 1) | (be << 31)) ^ ((oe >>> 8) | (be << 24)) ^ (oe >>> 7)) >>> 0),
              (_ = (((oe << 31) | (be >>> 1)) ^ ((oe << 24) | (be >>> 8)) ^ ((oe << 25) | (be >>> 7))) >>> 0),
              (re = p[ke - 7]),
              (b = p[ke - 16]),
              (be = h + re[1] + _ + b[1]),
              (p[ke][0] = (d + re[0] + m + b[0] + ((be / 4294967296) >>> 0)) >>> 0),
              (p[ke][1] = be >>> 0)
          for (
            q = f[0][0],
              G = f[0][1],
              O = f[1][0],
              x = f[1][1],
              L = f[2][0],
              K = f[2][1],
              J = f[3][0],
              Z = f[3][1],
              Q = f[4][0],
              fe = f[4][1],
              ie = f[5][0],
              W = f[5][1],
              le = f[6][0],
              xe = f[6][1],
              _e = f[7][0],
              Ne = f[7][1],
              ke = 0;
            ke < 80;
            ++ke
          )
            (E = (((Q >>> 14) | (fe << 18)) ^ ((Q >>> 18) | (fe << 14)) ^ ((fe >>> 9) | (Q << 23))) >>> 0),
              (k = (((Q << 18) | (fe >>> 14)) ^ ((Q << 14) | (fe >>> 18)) ^ ((fe << 23) | (Q >>> 9))) >>> 0),
              (w = (le ^ (Q & (ie ^ le))) >>> 0),
              (v = (xe ^ (fe & (W ^ xe))) >>> 0),
              (A = (((q >>> 28) | (G << 4)) ^ ((G >>> 2) | (q << 30)) ^ ((G >>> 7) | (q << 25))) >>> 0),
              (T = (((q << 4) | (G >>> 28)) ^ ((G << 30) | (q >>> 2)) ^ ((G << 25) | (q >>> 7))) >>> 0),
              (I = ((q & O) | (L & (q ^ O))) >>> 0),
              (M = ((G & x) | (K & (G ^ x))) >>> 0),
              (be = Ne + k + v + o[ke][1] + p[ke][1]),
              (d = (_e + E + w + o[ke][0] + p[ke][0] + ((be / 4294967296) >>> 0)) >>> 0),
              (h = be >>> 0),
              (be = T + M),
              (m = (A + I + ((be / 4294967296) >>> 0)) >>> 0),
              (_ = be >>> 0),
              (_e = le),
              (Ne = xe),
              (le = ie),
              (xe = W),
              (ie = Q),
              (W = fe),
              (be = Z + h),
              (Q = (J + d + ((be / 4294967296) >>> 0)) >>> 0),
              (fe = be >>> 0),
              (J = L),
              (Z = K),
              (L = O),
              (K = x),
              (O = q),
              (x = G),
              (be = h + _),
              (q = (d + m + ((be / 4294967296) >>> 0)) >>> 0),
              (G = be >>> 0)
          ;(be = f[0][1] + G),
            (f[0][0] = (f[0][0] + q + ((be / 4294967296) >>> 0)) >>> 0),
            (f[0][1] = be >>> 0),
            (be = f[1][1] + x),
            (f[1][0] = (f[1][0] + O + ((be / 4294967296) >>> 0)) >>> 0),
            (f[1][1] = be >>> 0),
            (be = f[2][1] + K),
            (f[2][0] = (f[2][0] + L + ((be / 4294967296) >>> 0)) >>> 0),
            (f[2][1] = be >>> 0),
            (be = f[3][1] + Z),
            (f[3][0] = (f[3][0] + J + ((be / 4294967296) >>> 0)) >>> 0),
            (f[3][1] = be >>> 0),
            (be = f[4][1] + fe),
            (f[4][0] = (f[4][0] + Q + ((be / 4294967296) >>> 0)) >>> 0),
            (f[4][1] = be >>> 0),
            (be = f[5][1] + W),
            (f[5][0] = (f[5][0] + ie + ((be / 4294967296) >>> 0)) >>> 0),
            (f[5][1] = be >>> 0),
            (be = f[6][1] + xe),
            (f[6][0] = (f[6][0] + le + ((be / 4294967296) >>> 0)) >>> 0),
            (f[6][1] = be >>> 0),
            (be = f[7][1] + Ne),
            (f[7][0] = (f[7][0] + _e + ((be / 4294967296) >>> 0)) >>> 0),
            (f[7][1] = be >>> 0),
            (C -= 128)
        }
      }
    }
  }),
  uO = te({
    'node_modules/node-forge/lib/asn1-validator.js'(e) {
      V(), F()
      var r = yt()
      qi()
      var t = r.asn1
      ;(e.privateKeyValidator = {
        name: 'PrivateKeyInfo',
        tagClass: t.Class.UNIVERSAL,
        type: t.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'PrivateKeyInfo.version',
            tagClass: t.Class.UNIVERSAL,
            type: t.Type.INTEGER,
            constructed: !1,
            capture: 'privateKeyVersion'
          },
          {
            name: 'PrivateKeyInfo.privateKeyAlgorithm',
            tagClass: t.Class.UNIVERSAL,
            type: t.Type.SEQUENCE,
            constructed: !0,
            value: [
              {
                name: 'AlgorithmIdentifier.algorithm',
                tagClass: t.Class.UNIVERSAL,
                type: t.Type.OID,
                constructed: !1,
                capture: 'privateKeyOid'
              }
            ]
          },
          {
            name: 'PrivateKeyInfo',
            tagClass: t.Class.UNIVERSAL,
            type: t.Type.OCTETSTRING,
            constructed: !1,
            capture: 'privateKey'
          }
        ]
      }),
        (e.publicKeyValidator = {
          name: 'SubjectPublicKeyInfo',
          tagClass: t.Class.UNIVERSAL,
          type: t.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: 'subjectPublicKeyInfo',
          value: [
            {
              name: 'SubjectPublicKeyInfo.AlgorithmIdentifier',
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'AlgorithmIdentifier.algorithm',
                  tagClass: t.Class.UNIVERSAL,
                  type: t.Type.OID,
                  constructed: !1,
                  capture: 'publicKeyOid'
                }
              ]
            },
            {
              tagClass: t.Class.UNIVERSAL,
              type: t.Type.BITSTRING,
              constructed: !1,
              composed: !0,
              captureBitStringValue: 'ed25519PublicKey'
            }
          ]
        })
    }
  }),
  K9 = te({
    'node_modules/node-forge/lib/ed25519.js'(e, r) {
      V(), F()
      var t = yt()
      rf(), Ss(), h1(), zt()
      var n = uO(),
        i = n.publicKeyValidator,
        s = n.privateKeyValidator
      typeof u == 'undefined' && (u = t.jsbn.BigInteger)
      var u,
        o = t.util.ByteBuffer,
        l = typeof Ve.Buffer == 'undefined' ? Uint8Array : Ve.Buffer
      ;(t.pki = t.pki || {}), (r.exports = t.pki.ed25519 = t.ed25519 = t.ed25519 || {})
      var a = t.ed25519
      ;(a.constants = {}),
        (a.constants.PUBLIC_KEY_BYTE_LENGTH = 32),
        (a.constants.PRIVATE_KEY_BYTE_LENGTH = 64),
        (a.constants.SEED_BYTE_LENGTH = 32),
        (a.constants.SIGN_BYTE_LENGTH = 64),
        (a.constants.HASH_BYTE_LENGTH = 64),
        (a.generateKeyPair = function (j) {
          j = j || {}
          var b = j.seed
          if (b === void 0) b = t.random.getBytesSync(a.constants.SEED_BYTE_LENGTH)
          else if (typeof b == 'string') {
            if (b.length !== a.constants.SEED_BYTE_LENGTH)
              throw new TypeError('"seed" must be ' + a.constants.SEED_BYTE_LENGTH + ' bytes in length.')
          } else if (!(b instanceof Uint8Array))
            throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.')
          b = c({ message: b, encoding: 'binary' })
          for (
            var C = new l(a.constants.PUBLIC_KEY_BYTE_LENGTH), S = new l(a.constants.PRIVATE_KEY_BYTE_LENGTH), R = 0;
            R < 32;
            ++R
          )
            S[R] = b[R]
          return E(C, S), { publicKey: C, privateKey: S }
        }),
        (a.privateKeyFromAsn1 = function (j) {
          var b = {},
            C = [],
            S = t.asn1.validate(j, s, b, C)
          if (!S) {
            var R = new Error('Invalid Key.')
            throw ((R.errors = C), R)
          }
          var P = t.asn1.derToOid(b.privateKeyOid),
            B = t.oids.EdDSA25519
          if (P !== B) throw new Error('Invalid OID "' + P + '"; OID must be "' + B + '".')
          var D = b.privateKey,
            $ = c({ message: t.asn1.fromDer(D).value, encoding: 'binary' })
          return { privateKeyBytes: $ }
        }),
        (a.publicKeyFromAsn1 = function (j) {
          var b = {},
            C = [],
            S = t.asn1.validate(j, i, b, C)
          if (!S) {
            var R = new Error('Invalid Key.')
            throw ((R.errors = C), R)
          }
          var P = t.asn1.derToOid(b.publicKeyOid),
            B = t.oids.EdDSA25519
          if (P !== B) throw new Error('Invalid OID "' + P + '"; OID must be "' + B + '".')
          var D = b.ed25519PublicKey
          if (D.length !== a.constants.PUBLIC_KEY_BYTE_LENGTH) throw new Error('Key length is invalid.')
          return c({ message: D, encoding: 'binary' })
        }),
        (a.publicKeyFromPrivateKey = function (j) {
          j = j || {}
          var b = c({ message: j.privateKey, encoding: 'binary' })
          if (b.length !== a.constants.PRIVATE_KEY_BYTE_LENGTH)
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' + a.constants.PRIVATE_KEY_BYTE_LENGTH
            )
          for (var C = new l(a.constants.PUBLIC_KEY_BYTE_LENGTH), S = 0; S < C.length; ++S) C[S] = b[32 + S]
          return C
        }),
        (a.sign = function (j) {
          j = j || {}
          var b = c(j),
            C = c({ message: j.privateKey, encoding: 'binary' })
          if (C.length === a.constants.SEED_BYTE_LENGTH) {
            var S = a.generateKeyPair({ seed: C })
            C = S.privateKey
          } else if (C.length !== a.constants.PRIVATE_KEY_BYTE_LENGTH)
            throw new TypeError(
              '"options.privateKey" must have a byte length of ' +
                a.constants.SEED_BYTE_LENGTH +
                ' or ' +
                a.constants.PRIVATE_KEY_BYTE_LENGTH
            )
          var R = new l(a.constants.SIGN_BYTE_LENGTH + b.length)
          k(R, b, b.length, C)
          for (var P = new l(a.constants.SIGN_BYTE_LENGTH), B = 0; B < P.length; ++B) P[B] = R[B]
          return P
        }),
        (a.verify = function (j) {
          j = j || {}
          var b = c(j)
          if (j.signature === void 0)
            throw new TypeError(
              '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
            )
          var C = c({ message: j.signature, encoding: 'binary' })
          if (C.length !== a.constants.SIGN_BYTE_LENGTH)
            throw new TypeError('"options.signature" must have a byte length of ' + a.constants.SIGN_BYTE_LENGTH)
          var S = c({ message: j.publicKey, encoding: 'binary' })
          if (S.length !== a.constants.PUBLIC_KEY_BYTE_LENGTH)
            throw new TypeError('"options.publicKey" must have a byte length of ' + a.constants.PUBLIC_KEY_BYTE_LENGTH)
          var R = new l(a.constants.SIGN_BYTE_LENGTH + b.length),
            P = new l(a.constants.SIGN_BYTE_LENGTH + b.length),
            B
          for (B = 0; B < a.constants.SIGN_BYTE_LENGTH; ++B) R[B] = C[B]
          for (B = 0; B < b.length; ++B) R[B + a.constants.SIGN_BYTE_LENGTH] = b[B]
          return w(P, R, R.length, S) >= 0
        })
      function c(j) {
        var b = j.message
        if (b instanceof Uint8Array || b instanceof l) return b
        var C = j.encoding
        if (b === void 0)
          if (j.md) (b = j.md.digest().getBytes()), (C = 'binary')
          else throw new TypeError('"options.message" or "options.md" not specified.')
        if (typeof b == 'string' && !C) throw new TypeError('"options.encoding" must be "binary" or "utf8".')
        if (typeof b == 'string') {
          if (typeof Ve.Buffer != 'undefined') return Ve.Buffer.from(b, C)
          b = new o(b, C)
        } else if (!(b instanceof o))
          throw new TypeError(
            '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
          )
        for (var S = new l(b.length()), R = 0; R < S.length; ++R) S[R] = b.at(R)
        return S
      }
      var f = ke(),
        p = ke([1]),
        y = ke([
          30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995
        ]),
        d = ke([
          61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222
        ]),
        h = ke([
          54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553
        ]),
        m = ke([
          26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214
        ]),
        _ = new Float64Array([
          237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
          0, 0, 0, 16
        ]),
        A = ke([
          41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139
        ])
      function T(j, b) {
        var C = t.md.sha512.create(),
          S = new o(j)
        C.update(S.getBytes(b), 'binary')
        var R = C.digest().getBytes()
        if (typeof Ve.Buffer != 'undefined') return Ve.Buffer.from(R, 'binary')
        for (var P = new l(a.constants.HASH_BYTE_LENGTH), B = 0; B < 64; ++B) P[B] = R.charCodeAt(B)
        return P
      }
      function E(j, b) {
        var C = [ke(), ke(), ke(), ke()],
          S,
          R = T(b, 32)
        for (R[0] &= 248, R[31] &= 127, R[31] |= 64, W(C, R), G(j, C), S = 0; S < 32; ++S) b[S + 32] = j[S]
        return 0
      }
      function k(j, b, C, S) {
        var R,
          P,
          B = new Float64Array(64),
          D = [ke(), ke(), ke(), ke()],
          $ = T(S, 32)
        ;($[0] &= 248), ($[31] &= 127), ($[31] |= 64)
        var g = C + 64
        for (R = 0; R < C; ++R) j[64 + R] = b[R]
        for (R = 0; R < 32; ++R) j[32 + R] = $[32 + R]
        var N = T(j.subarray(32), C + 32)
        for (I(N), W(D, N), G(j, D), R = 32; R < 64; ++R) j[R] = S[R]
        var U = T(j, C + 64)
        for (I(U), R = 32; R < 64; ++R) B[R] = 0
        for (R = 0; R < 32; ++R) B[R] = N[R]
        for (R = 0; R < 32; ++R) for (P = 0; P < 32; P++) B[R + P] += U[R] * $[P]
        return v(j.subarray(32), B), g
      }
      function w(j, b, C, S) {
        var R,
          P,
          B = new l(32),
          D = [ke(), ke(), ke(), ke()],
          $ = [ke(), ke(), ke(), ke()]
        if (((P = -1), C < 64 || x($, S))) return -1
        for (R = 0; R < C; ++R) j[R] = b[R]
        for (R = 0; R < 32; ++R) j[R + 32] = S[R]
        var g = T(j, C)
        if ((I(g), ie(D, $, g), W($, b.subarray(32)), M(D, $), G(B, D), (C -= 64), Z(b, 0, B, 0))) {
          for (R = 0; R < C; ++R) j[R] = 0
          return -1
        }
        for (R = 0; R < C; ++R) j[R] = b[R + 64]
        return (P = C), P
      }
      function v(j, b) {
        var C, S, R, P
        for (S = 63; S >= 32; --S) {
          for (C = 0, R = S - 32, P = S - 12; R < P; ++R)
            (b[R] += C - 16 * b[S] * _[R - (S - 32)]), (C = (b[R] + 128) >> 8), (b[R] -= C * 256)
          ;(b[R] += C), (b[S] = 0)
        }
        for (C = 0, R = 0; R < 32; ++R) (b[R] += C - (b[31] >> 4) * _[R]), (C = b[R] >> 8), (b[R] &= 255)
        for (R = 0; R < 32; ++R) b[R] -= C * _[R]
        for (S = 0; S < 32; ++S) (b[S + 1] += b[S] >> 8), (j[S] = b[S] & 255)
      }
      function I(j) {
        for (var b = new Float64Array(64), C = 0; C < 64; ++C) (b[C] = j[C]), (j[C] = 0)
        v(j, b)
      }
      function M(j, b) {
        var C = ke(),
          S = ke(),
          R = ke(),
          P = ke(),
          B = ke(),
          D = ke(),
          $ = ke(),
          g = ke(),
          N = ke()
        be(C, j[1], j[0]),
          be(N, b[1], b[0]),
          re(C, C, N),
          oe(S, j[0], j[1]),
          oe(N, b[0], b[1]),
          re(S, S, N),
          re(R, j[3], b[3]),
          re(R, R, d),
          re(P, j[2], b[2]),
          oe(P, P, P),
          be(B, S, C),
          be(D, P, R),
          oe($, P, R),
          oe(g, S, C),
          re(j[0], B, D),
          re(j[1], g, $),
          re(j[2], $, D),
          re(j[3], B, g)
      }
      function q(j, b, C) {
        for (var S = 0; S < 4; ++S) Ne(j[S], b[S], C)
      }
      function G(j, b) {
        var C = ke(),
          S = ke(),
          R = ke()
        xe(R, b[2]), re(C, b[0], R), re(S, b[1], R), O(j, S), (j[31] ^= fe(C) << 7)
      }
      function O(j, b) {
        var C,
          S,
          R,
          P = ke(),
          B = ke()
        for (C = 0; C < 16; ++C) B[C] = b[C]
        for (_e(B), _e(B), _e(B), S = 0; S < 2; ++S) {
          for (P[0] = B[0] - 65517, C = 1; C < 15; ++C)
            (P[C] = B[C] - 65535 - ((P[C - 1] >> 16) & 1)), (P[C - 1] &= 65535)
          ;(P[15] = B[15] - 32767 - ((P[14] >> 16) & 1)), (R = (P[15] >> 16) & 1), (P[14] &= 65535), Ne(B, P, 1 - R)
        }
        for (C = 0; C < 16; C++) (j[2 * C] = B[C] & 255), (j[2 * C + 1] = B[C] >> 8)
      }
      function x(j, b) {
        var C = ke(),
          S = ke(),
          R = ke(),
          P = ke(),
          B = ke(),
          D = ke(),
          $ = ke()
        return (
          le(j[2], p),
          L(j[1], b),
          ge(R, j[1]),
          re(P, R, y),
          be(R, R, j[2]),
          oe(P, j[2], P),
          ge(B, P),
          ge(D, B),
          re($, D, B),
          re(C, $, R),
          re(C, C, P),
          K(C, C),
          re(C, C, R),
          re(C, C, P),
          re(C, C, P),
          re(j[0], C, P),
          ge(S, j[0]),
          re(S, S, P),
          J(S, R) && re(j[0], j[0], A),
          ge(S, j[0]),
          re(S, S, P),
          J(S, R) ? -1 : (fe(j[0]) === b[31] >> 7 && be(j[0], f, j[0]), re(j[3], j[0], j[1]), 0)
        )
      }
      function L(j, b) {
        var C
        for (C = 0; C < 16; ++C) j[C] = b[2 * C] + (b[2 * C + 1] << 8)
        j[15] &= 32767
      }
      function K(j, b) {
        var C = ke(),
          S
        for (S = 0; S < 16; ++S) C[S] = b[S]
        for (S = 250; S >= 0; --S) ge(C, C), S !== 1 && re(C, C, b)
        for (S = 0; S < 16; ++S) j[S] = C[S]
      }
      function J(j, b) {
        var C = new l(32),
          S = new l(32)
        return O(C, j), O(S, b), Z(C, 0, S, 0)
      }
      function Z(j, b, C, S) {
        return Q(j, b, C, S, 32)
      }
      function Q(j, b, C, S, R) {
        var P,
          B = 0
        for (P = 0; P < R; ++P) B |= j[b + P] ^ C[S + P]
        return (1 & ((B - 1) >>> 8)) - 1
      }
      function fe(j) {
        var b = new l(32)
        return O(b, j), b[0] & 1
      }
      function ie(j, b, C) {
        var S, R
        for (le(j[0], f), le(j[1], p), le(j[2], p), le(j[3], f), R = 255; R >= 0; --R)
          (S = (C[(R / 8) | 0] >> (R & 7)) & 1), q(j, b, S), M(b, j), M(j, j), q(j, b, S)
      }
      function W(j, b) {
        var C = [ke(), ke(), ke(), ke()]
        le(C[0], h), le(C[1], m), le(C[2], p), re(C[3], h, m), ie(j, C, b)
      }
      function le(j, b) {
        var C
        for (C = 0; C < 16; C++) j[C] = b[C] | 0
      }
      function xe(j, b) {
        var C = ke(),
          S
        for (S = 0; S < 16; ++S) C[S] = b[S]
        for (S = 253; S >= 0; --S) ge(C, C), S !== 2 && S !== 4 && re(C, C, b)
        for (S = 0; S < 16; ++S) j[S] = C[S]
      }
      function _e(j) {
        var b,
          C,
          S = 1
        for (b = 0; b < 16; ++b) (C = j[b] + S + 65535), (S = Math.floor(C / 65536)), (j[b] = C - S * 65536)
        j[0] += S - 1 + 37 * (S - 1)
      }
      function Ne(j, b, C) {
        for (var S, R = ~(C - 1), P = 0; P < 16; ++P) (S = R & (j[P] ^ b[P])), (j[P] ^= S), (b[P] ^= S)
      }
      function ke(j) {
        var b,
          C = new Float64Array(16)
        if (j) for (b = 0; b < j.length; ++b) C[b] = j[b]
        return C
      }
      function oe(j, b, C) {
        for (var S = 0; S < 16; ++S) j[S] = b[S] + C[S]
      }
      function be(j, b, C) {
        for (var S = 0; S < 16; ++S) j[S] = b[S] - C[S]
      }
      function ge(j, b) {
        re(j, b, b)
      }
      function re(j, b, C) {
        var S,
          R,
          P = 0,
          B = 0,
          D = 0,
          $ = 0,
          g = 0,
          N = 0,
          U = 0,
          X = 0,
          ne = 0,
          ee = 0,
          ae = 0,
          Y = 0,
          z = 0,
          H = 0,
          se = 0,
          me = 0,
          we = 0,
          Ee = 0,
          Me = 0,
          Be = 0,
          je = 0,
          Pe = 0,
          Oe = 0,
          ht = 0,
          Qe = 0,
          et = 0,
          Mt = 0,
          ut = 0,
          at = 0,
          Pt = 0,
          ft = 0,
          We = C[0],
          gt = C[1],
          Ge = C[2],
          He = C[3],
          wt = C[4],
          tt = C[5],
          Xe = C[6],
          _t = C[7],
          nt = C[8],
          it = C[9],
          xt = C[10],
          st = C[11],
          ot = C[12],
          Rt = C[13],
          Ze = C[14],
          Ye = C[15]
        ;(S = b[0]),
          (P += S * We),
          (B += S * gt),
          (D += S * Ge),
          ($ += S * He),
          (g += S * wt),
          (N += S * tt),
          (U += S * Xe),
          (X += S * _t),
          (ne += S * nt),
          (ee += S * it),
          (ae += S * xt),
          (Y += S * st),
          (z += S * ot),
          (H += S * Rt),
          (se += S * Ze),
          (me += S * Ye),
          (S = b[1]),
          (B += S * We),
          (D += S * gt),
          ($ += S * Ge),
          (g += S * He),
          (N += S * wt),
          (U += S * tt),
          (X += S * Xe),
          (ne += S * _t),
          (ee += S * nt),
          (ae += S * it),
          (Y += S * xt),
          (z += S * st),
          (H += S * ot),
          (se += S * Rt),
          (me += S * Ze),
          (we += S * Ye),
          (S = b[2]),
          (D += S * We),
          ($ += S * gt),
          (g += S * Ge),
          (N += S * He),
          (U += S * wt),
          (X += S * tt),
          (ne += S * Xe),
          (ee += S * _t),
          (ae += S * nt),
          (Y += S * it),
          (z += S * xt),
          (H += S * st),
          (se += S * ot),
          (me += S * Rt),
          (we += S * Ze),
          (Ee += S * Ye),
          (S = b[3]),
          ($ += S * We),
          (g += S * gt),
          (N += S * Ge),
          (U += S * He),
          (X += S * wt),
          (ne += S * tt),
          (ee += S * Xe),
          (ae += S * _t),
          (Y += S * nt),
          (z += S * it),
          (H += S * xt),
          (se += S * st),
          (me += S * ot),
          (we += S * Rt),
          (Ee += S * Ze),
          (Me += S * Ye),
          (S = b[4]),
          (g += S * We),
          (N += S * gt),
          (U += S * Ge),
          (X += S * He),
          (ne += S * wt),
          (ee += S * tt),
          (ae += S * Xe),
          (Y += S * _t),
          (z += S * nt),
          (H += S * it),
          (se += S * xt),
          (me += S * st),
          (we += S * ot),
          (Ee += S * Rt),
          (Me += S * Ze),
          (Be += S * Ye),
          (S = b[5]),
          (N += S * We),
          (U += S * gt),
          (X += S * Ge),
          (ne += S * He),
          (ee += S * wt),
          (ae += S * tt),
          (Y += S * Xe),
          (z += S * _t),
          (H += S * nt),
          (se += S * it),
          (me += S * xt),
          (we += S * st),
          (Ee += S * ot),
          (Me += S * Rt),
          (Be += S * Ze),
          (je += S * Ye),
          (S = b[6]),
          (U += S * We),
          (X += S * gt),
          (ne += S * Ge),
          (ee += S * He),
          (ae += S * wt),
          (Y += S * tt),
          (z += S * Xe),
          (H += S * _t),
          (se += S * nt),
          (me += S * it),
          (we += S * xt),
          (Ee += S * st),
          (Me += S * ot),
          (Be += S * Rt),
          (je += S * Ze),
          (Pe += S * Ye),
          (S = b[7]),
          (X += S * We),
          (ne += S * gt),
          (ee += S * Ge),
          (ae += S * He),
          (Y += S * wt),
          (z += S * tt),
          (H += S * Xe),
          (se += S * _t),
          (me += S * nt),
          (we += S * it),
          (Ee += S * xt),
          (Me += S * st),
          (Be += S * ot),
          (je += S * Rt),
          (Pe += S * Ze),
          (Oe += S * Ye),
          (S = b[8]),
          (ne += S * We),
          (ee += S * gt),
          (ae += S * Ge),
          (Y += S * He),
          (z += S * wt),
          (H += S * tt),
          (se += S * Xe),
          (me += S * _t),
          (we += S * nt),
          (Ee += S * it),
          (Me += S * xt),
          (Be += S * st),
          (je += S * ot),
          (Pe += S * Rt),
          (Oe += S * Ze),
          (ht += S * Ye),
          (S = b[9]),
          (ee += S * We),
          (ae += S * gt),
          (Y += S * Ge),
          (z += S * He),
          (H += S * wt),
          (se += S * tt),
          (me += S * Xe),
          (we += S * _t),
          (Ee += S * nt),
          (Me += S * it),
          (Be += S * xt),
          (je += S * st),
          (Pe += S * ot),
          (Oe += S * Rt),
          (ht += S * Ze),
          (Qe += S * Ye),
          (S = b[10]),
          (ae += S * We),
          (Y += S * gt),
          (z += S * Ge),
          (H += S * He),
          (se += S * wt),
          (me += S * tt),
          (we += S * Xe),
          (Ee += S * _t),
          (Me += S * nt),
          (Be += S * it),
          (je += S * xt),
          (Pe += S * st),
          (Oe += S * ot),
          (ht += S * Rt),
          (Qe += S * Ze),
          (et += S * Ye),
          (S = b[11]),
          (Y += S * We),
          (z += S * gt),
          (H += S * Ge),
          (se += S * He),
          (me += S * wt),
          (we += S * tt),
          (Ee += S * Xe),
          (Me += S * _t),
          (Be += S * nt),
          (je += S * it),
          (Pe += S * xt),
          (Oe += S * st),
          (ht += S * ot),
          (Qe += S * Rt),
          (et += S * Ze),
          (Mt += S * Ye),
          (S = b[12]),
          (z += S * We),
          (H += S * gt),
          (se += S * Ge),
          (me += S * He),
          (we += S * wt),
          (Ee += S * tt),
          (Me += S * Xe),
          (Be += S * _t),
          (je += S * nt),
          (Pe += S * it),
          (Oe += S * xt),
          (ht += S * st),
          (Qe += S * ot),
          (et += S * Rt),
          (Mt += S * Ze),
          (ut += S * Ye),
          (S = b[13]),
          (H += S * We),
          (se += S * gt),
          (me += S * Ge),
          (we += S * He),
          (Ee += S * wt),
          (Me += S * tt),
          (Be += S * Xe),
          (je += S * _t),
          (Pe += S * nt),
          (Oe += S * it),
          (ht += S * xt),
          (Qe += S * st),
          (et += S * ot),
          (Mt += S * Rt),
          (ut += S * Ze),
          (at += S * Ye),
          (S = b[14]),
          (se += S * We),
          (me += S * gt),
          (we += S * Ge),
          (Ee += S * He),
          (Me += S * wt),
          (Be += S * tt),
          (je += S * Xe),
          (Pe += S * _t),
          (Oe += S * nt),
          (ht += S * it),
          (Qe += S * xt),
          (et += S * st),
          (Mt += S * ot),
          (ut += S * Rt),
          (at += S * Ze),
          (Pt += S * Ye),
          (S = b[15]),
          (me += S * We),
          (we += S * gt),
          (Ee += S * Ge),
          (Me += S * He),
          (Be += S * wt),
          (je += S * tt),
          (Pe += S * Xe),
          (Oe += S * _t),
          (ht += S * nt),
          (Qe += S * it),
          (et += S * xt),
          (Mt += S * st),
          (ut += S * ot),
          (at += S * Rt),
          (Pt += S * Ze),
          (ft += S * Ye),
          (P += 38 * we),
          (B += 38 * Ee),
          (D += 38 * Me),
          ($ += 38 * Be),
          (g += 38 * je),
          (N += 38 * Pe),
          (U += 38 * Oe),
          (X += 38 * ht),
          (ne += 38 * Qe),
          (ee += 38 * et),
          (ae += 38 * Mt),
          (Y += 38 * ut),
          (z += 38 * at),
          (H += 38 * Pt),
          (se += 38 * ft),
          (R = 1),
          (S = P + R + 65535),
          (R = Math.floor(S / 65536)),
          (P = S - R * 65536),
          (S = B + R + 65535),
          (R = Math.floor(S / 65536)),
          (B = S - R * 65536),
          (S = D + R + 65535),
          (R = Math.floor(S / 65536)),
          (D = S - R * 65536),
          (S = $ + R + 65535),
          (R = Math.floor(S / 65536)),
          ($ = S - R * 65536),
          (S = g + R + 65535),
          (R = Math.floor(S / 65536)),
          (g = S - R * 65536),
          (S = N + R + 65535),
          (R = Math.floor(S / 65536)),
          (N = S - R * 65536),
          (S = U + R + 65535),
          (R = Math.floor(S / 65536)),
          (U = S - R * 65536),
          (S = X + R + 65535),
          (R = Math.floor(S / 65536)),
          (X = S - R * 65536),
          (S = ne + R + 65535),
          (R = Math.floor(S / 65536)),
          (ne = S - R * 65536),
          (S = ee + R + 65535),
          (R = Math.floor(S / 65536)),
          (ee = S - R * 65536),
          (S = ae + R + 65535),
          (R = Math.floor(S / 65536)),
          (ae = S - R * 65536),
          (S = Y + R + 65535),
          (R = Math.floor(S / 65536)),
          (Y = S - R * 65536),
          (S = z + R + 65535),
          (R = Math.floor(S / 65536)),
          (z = S - R * 65536),
          (S = H + R + 65535),
          (R = Math.floor(S / 65536)),
          (H = S - R * 65536),
          (S = se + R + 65535),
          (R = Math.floor(S / 65536)),
          (se = S - R * 65536),
          (S = me + R + 65535),
          (R = Math.floor(S / 65536)),
          (me = S - R * 65536),
          (P += R - 1 + 37 * (R - 1)),
          (R = 1),
          (S = P + R + 65535),
          (R = Math.floor(S / 65536)),
          (P = S - R * 65536),
          (S = B + R + 65535),
          (R = Math.floor(S / 65536)),
          (B = S - R * 65536),
          (S = D + R + 65535),
          (R = Math.floor(S / 65536)),
          (D = S - R * 65536),
          (S = $ + R + 65535),
          (R = Math.floor(S / 65536)),
          ($ = S - R * 65536),
          (S = g + R + 65535),
          (R = Math.floor(S / 65536)),
          (g = S - R * 65536),
          (S = N + R + 65535),
          (R = Math.floor(S / 65536)),
          (N = S - R * 65536),
          (S = U + R + 65535),
          (R = Math.floor(S / 65536)),
          (U = S - R * 65536),
          (S = X + R + 65535),
          (R = Math.floor(S / 65536)),
          (X = S - R * 65536),
          (S = ne + R + 65535),
          (R = Math.floor(S / 65536)),
          (ne = S - R * 65536),
          (S = ee + R + 65535),
          (R = Math.floor(S / 65536)),
          (ee = S - R * 65536),
          (S = ae + R + 65535),
          (R = Math.floor(S / 65536)),
          (ae = S - R * 65536),
          (S = Y + R + 65535),
          (R = Math.floor(S / 65536)),
          (Y = S - R * 65536),
          (S = z + R + 65535),
          (R = Math.floor(S / 65536)),
          (z = S - R * 65536),
          (S = H + R + 65535),
          (R = Math.floor(S / 65536)),
          (H = S - R * 65536),
          (S = se + R + 65535),
          (R = Math.floor(S / 65536)),
          (se = S - R * 65536),
          (S = me + R + 65535),
          (R = Math.floor(S / 65536)),
          (me = S - R * 65536),
          (P += R - 1 + 37 * (R - 1)),
          (j[0] = P),
          (j[1] = B),
          (j[2] = D),
          (j[3] = $),
          (j[4] = g),
          (j[5] = N),
          (j[6] = U),
          (j[7] = X),
          (j[8] = ne),
          (j[9] = ee),
          (j[10] = ae),
          (j[11] = Y),
          (j[12] = z),
          (j[13] = H),
          (j[14] = se),
          (j[15] = me)
      }
    }
  }),
  lO = te({
    'node_modules/iso-random-stream/src/random.browser.js'(e, r) {
      V(), F()
      var t = 65536
      function n(i) {
        let s = new Uint8Array(i),
          u = 0
        if (i > 0)
          if (i > t)
            for (; u < i; )
              u + t > i
                ? (crypto.getRandomValues(s.subarray(u, u + (i - u))), (u += i - u))
                : (crypto.getRandomValues(s.subarray(u, u + t)), (u += t))
          else crypto.getRandomValues(s)
        return s
      }
      r.exports = n
    }
  }),
  p1 = te({
    'node_modules/libp2p-crypto/src/random-bytes.js'(e, r) {
      V(), F()
      var t = lO(),
        n = pt()
      r.exports = function (i) {
        if (isNaN(i) || i <= 0)
          throw n(new Error('random bytes length must be a Number bigger than 0'), 'ERR_INVALID_LENGTH')
        return t(i)
      }
    }
  }),
  m1 = te({
    'node_modules/libp2p-crypto/src/util.js'(e) {
      V(), F(), zt(), rf()
      var r = yt(),
        { fromString: t } = (gn(), un),
        { toString: n } = (On(), vn),
        { concat: i } = (hs(), Li)
      ;(e.bigIntegerToUintBase64url = (s, u) => {
        let o = Uint8Array.from(s.abs().toByteArray())
        if (((o = o[0] === 0 ? o.slice(1) : o), u != null)) {
          if (o.length > u) throw new Error('byte array longer than desired length')
          o = i([new Uint8Array(u - o.length), o])
        }
        return n(o, 'base64url')
      }),
        (e.base64urlToBigInteger = (s) => {
          let u = e.base64urlToBuffer(s)
          return new r.jsbn.BigInteger(n(u, 'base16'), 16)
        }),
        (e.base64urlToBuffer = (s, u) => {
          let o = t(s, 'base64urlpad')
          if (u != null) {
            if (o.length > u) throw new Error('byte array longer than desired length')
            o = i([new Uint8Array(u - o.length), o])
          }
          return o
        })
    }
  }),
  fO = te({
    'node_modules/libp2p-crypto/src/keys/rsa-utils.js'(e) {
      V(), F(), qi(), nf()
      var r = yt(),
        { bigIntegerToUintBase64url: t, base64urlToBigInteger: n } = m1(),
        { fromString: i } = (gn(), un),
        { toString: s } = (On(), vn)
      ;(e.pkcs1ToJwk = function (u) {
        let o = r.asn1.fromDer(s(u, 'ascii')),
          l = r.pki.privateKeyFromAsn1(o)
        return {
          kty: 'RSA',
          n: t(l.n),
          e: t(l.e),
          d: t(l.d),
          p: t(l.p),
          q: t(l.q),
          dp: t(l.dP),
          dq: t(l.dQ),
          qi: t(l.qInv),
          alg: 'RS256',
          kid: '2011-04-29'
        }
      }),
        (e.jwkToPkcs1 = function (u) {
          let o = r.pki.privateKeyToAsn1({
            n: n(u.n),
            e: n(u.e),
            d: n(u.d),
            p: n(u.p),
            q: n(u.q),
            dP: n(u.dp),
            dQ: n(u.dq),
            qInv: n(u.qi)
          })
          return i(r.asn1.toDer(o).getBytes(), 'ascii')
        }),
        (e.pkixToJwk = function (u) {
          let o = r.asn1.fromDer(s(u, 'ascii')),
            l = r.pki.publicKeyFromAsn1(o)
          return { kty: 'RSA', n: t(l.n), e: t(l.e), alg: 'RS256', kid: '2011-04-29' }
        }),
        (e.jwkToPkix = function (u) {
          let o = r.pki.publicKeyToAsn1({ n: n(u.n), e: n(u.e) })
          return i(r.asn1.toDer(o).getBytes(), 'ascii')
        })
    }
  }),
  dO = te({
    'node_modules/libp2p-crypto/src/keys/jwk2pem.js'(e, r) {
      V(), F(), nf()
      var t = yt(),
        { base64urlToBigInteger: n } = m1()
      function i(o, l) {
        return l.map((a) => n(o[a]))
      }
      function s(o) {
        return t.pki.setRsaPrivateKey(...i(o, ['n', 'e', 'd', 'p', 'q', 'dp', 'dq', 'qi']))
      }
      function u(o) {
        return t.pki.setRsaPublicKey(...i(o, ['n', 'e']))
      }
      r.exports = { jwk2pub: u, jwk2priv: s }
    }
  }),
  hO = te({
    'node_modules/libp2p-crypto/src/keys/rsa-browser.js'(e) {
      V(), F()
      var r = sf(),
        t = p1(),
        { toString: n } = (On(), vn),
        { fromString: i } = (gn(), un)
      ;(e.utils = fO()),
        (e.generateKey = async function (c) {
          let f = await r
              .get()
              .subtle.generateKey(
                {
                  name: 'RSASSA-PKCS1-v1_5',
                  modulusLength: c,
                  publicExponent: new Uint8Array([1, 0, 1]),
                  hash: { name: 'SHA-256' }
                },
                !0,
                ['sign', 'verify']
              ),
            p = await s(f)
          return { privateKey: p[0], publicKey: p[1] }
        }),
        (e.unmarshalPrivateKey = async function (c) {
          let p = [
              await r
                .get()
                .subtle.importKey('jwk', c, { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-256' } }, !0, ['sign']),
              await u(c)
            ],
            y = await s({ privateKey: p[0], publicKey: p[1] })
          return { privateKey: y[0], publicKey: y[1] }
        }),
        (e.getRandomValues = t),
        (e.hashAndSign = async function (c, f) {
          let p = await r
              .get()
              .subtle.importKey('jwk', c, { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-256' } }, !1, ['sign']),
            y = await r.get().subtle.sign({ name: 'RSASSA-PKCS1-v1_5' }, p, Uint8Array.from(f))
          return new Uint8Array(y, y.byteOffset, y.byteLength)
        }),
        (e.hashAndVerify = async function (c, f, p) {
          let y = await r
            .get()
            .subtle.importKey('jwk', c, { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-256' } }, !1, ['verify'])
          return r.get().subtle.verify({ name: 'RSASSA-PKCS1-v1_5' }, y, f, p)
        })
      function s(c) {
        return Promise.all([
          r.get().subtle.exportKey('jwk', c.privateKey),
          r.get().subtle.exportKey('jwk', c.publicKey)
        ])
      }
      function u(c) {
        return r
          .get()
          .subtle.importKey(
            'jwk',
            { kty: c.kty, n: c.n, e: c.e },
            { name: 'RSASSA-PKCS1-v1_5', hash: { name: 'SHA-256' } },
            !0,
            ['verify']
          )
      }
      var { jwk2pub: o, jwk2priv: l } = dO()
      function a(c, f, p, y) {
        let d = f ? o(c) : l(c),
          h = n(Uint8Array.from(p), 'ascii'),
          m = y(h, d)
        return i(m, 'ascii')
      }
      ;(e.encrypt = function (c, f) {
        return a(c, !0, f, (p, y) => y.encrypt(p))
      }),
        (e.decrypt = function (c, f) {
          return a(c, !1, f, (p, y) => y.decrypt(p))
        })
    }
  }),
  b1 = te({
    'node_modules/libp2p-crypto/src/keys/exporter.js'(e, r) {
      V(), F()
      var { base64: t } = (m9(), s1),
        n = b9()
      r.exports = {
        export: async function (i, s) {
          let o = await n.create().encrypt(i, s)
          return t.encode(o)
        }
      }
    }
  }),
  pO = te({
    'node_modules/libp2p-crypto/src/keys/rsa-class.js'(e, r) {
      V(), F()
      var { sha256: t } = (af(), zc),
        n = pt(),
        { equals: i } = (To(), ps),
        { toString: s } = (On(), vn)
      h1(), K9()
      var u = yt(),
        o = hO(),
        l = Yp(),
        a = b1(),
        c = class {
          constructor(m) {
            this._key = m
          }
          async verify(m, _) {
            return o.hashAndVerify(this._key, _, m)
          }
          marshal() {
            return o.utils.jwkToPkix(this._key)
          }
          get bytes() {
            return l.PublicKey.encode({ Type: l.KeyType.RSA, Data: this.marshal() }).finish()
          }
          encrypt(m) {
            return o.encrypt(this._key, m)
          }
          equals(m) {
            return i(this.bytes, m.bytes)
          }
          async hash() {
            let { bytes: m } = await t.digest(this.bytes)
            return m
          }
        },
        f = class {
          constructor(m, _) {
            ;(this._key = m), (this._publicKey = _)
          }
          genSecret() {
            return o.getRandomValues(16)
          }
          async sign(m) {
            return o.hashAndSign(this._key, m)
          }
          get public() {
            if (!this._publicKey) throw n(new Error('public key not provided'), 'ERR_PUBKEY_NOT_PROVIDED')
            return new c(this._publicKey)
          }
          decrypt(m) {
            return o.decrypt(this._key, m)
          }
          marshal() {
            return o.utils.jwkToPkcs1(this._key)
          }
          get bytes() {
            return l.PrivateKey.encode({ Type: l.KeyType.RSA, Data: this.marshal() }).finish()
          }
          equals(m) {
            return i(this.bytes, m.bytes)
          }
          async hash() {
            let { bytes: m } = await t.digest(this.bytes)
            return m
          }
          async id() {
            let m = await this.public.hash()
            return s(m, 'base58btc')
          }
          async export(m, _ = 'pkcs-8') {
            if (_ === 'pkcs-8') {
              let A = new u.util.ByteBuffer(this.marshal()),
                T = u.asn1.fromDer(A),
                E = u.pki.privateKeyFromAsn1(T),
                k = { algorithm: 'aes256', count: 1e4, saltSize: 128 / 8, prfAlgorithm: 'sha512' }
              return u.pki.encryptRsaPrivateKey(E, m, k)
            } else {
              if (_ === 'libp2p-key') return a.export(this.bytes, m)
              throw n(new Error(`export format '${_}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')
            }
          }
        }
      async function p(m) {
        let _ = o.utils.pkcs1ToJwk(m),
          A = await o.unmarshalPrivateKey(_)
        return new f(A.privateKey, A.publicKey)
      }
      function y(m) {
        let _ = o.utils.pkixToJwk(m)
        return new c(_)
      }
      async function d(m) {
        let _ = await o.unmarshalPrivateKey(m)
        return new f(_.privateKey, _.publicKey)
      }
      async function h(m) {
        let _ = await o.generateKey(m)
        return new f(_.privateKey, _.publicKey)
      }
      r.exports = {
        RsaPublicKey: c,
        RsaPrivateKey: f,
        unmarshalRsaPublicKey: y,
        unmarshalRsaPrivateKey: p,
        generateKeyPair: h,
        fromJwk: d
      }
    }
  }),
  F9 = {}
Re(F9, { base58btc: () => V9, base58flickr: () => H9 })
var V9,
  H9,
  mO = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        l9(),
        (V9 = i1({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (H9 = i1({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  $9 = {}
Re($9, { identity: () => G9 })
var G9,
  bO = Ie({
    'node_modules/libp2p-crypto/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), q9(), t1(), (G9 = of({ name: 'identity', code: 0, encode: (e) => e1(e) }))
    }
  }),
  yO = te({
    'node_modules/libp2p-crypto/src/keys/ed25519.js'(e) {
      V(), F(), K9()
      var r = yt()
      ;(e.publicKeyLength = r.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH),
        (e.privateKeyLength = r.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH),
        (e.generateKey = async function () {
          return r.pki.ed25519.generateKeyPair()
        }),
        (e.generateKeyFromSeed = async function (t) {
          return r.pki.ed25519.generateKeyPair({ seed: t })
        }),
        (e.hashAndSign = async function (t, n) {
          return r.pki.ed25519.sign({ message: n, privateKey: t })
        }),
        (e.hashAndVerify = async function (t, n, i) {
          return r.pki.ed25519.verify({ signature: n, message: i, publicKey: t })
        })
    }
  }),
  vO = te({
    'node_modules/libp2p-crypto/src/keys/ed25519-class.js'(e, r) {
      V(), F()
      var t = pt(),
        { equals: n } = (To(), ps),
        { sha256: i } = (af(), zc),
        { base58btc: s } = (mO(), F9),
        { identity: u } = (bO(), $9),
        o = yO(),
        l = Yp(),
        a = b1(),
        c = class {
          constructor(_) {
            this._key = m(_, o.publicKeyLength)
          }
          async verify(_, A) {
            return o.hashAndVerify(this._key, A, _)
          }
          marshal() {
            return this._key
          }
          get bytes() {
            return l.PublicKey.encode({ Type: l.KeyType.Ed25519, Data: this.marshal() }).finish()
          }
          equals(_) {
            return n(this.bytes, _.bytes)
          }
          async hash() {
            let { bytes: _ } = await i.digest(this.bytes)
            return _
          }
        },
        f = class {
          constructor(_, A) {
            ;(this._key = m(_, o.privateKeyLength)), (this._publicKey = m(A, o.publicKeyLength))
          }
          async sign(_) {
            return o.hashAndSign(this._key, _)
          }
          get public() {
            return new c(this._publicKey)
          }
          marshal() {
            return this._key
          }
          get bytes() {
            return l.PrivateKey.encode({ Type: l.KeyType.Ed25519, Data: this.marshal() }).finish()
          }
          equals(_) {
            return n(this.bytes, _.bytes)
          }
          async hash() {
            let { bytes: _ } = await i.digest(this.bytes)
            return _
          }
          async id() {
            let _ = await u.digest(this.public.bytes)
            return s.encode(_.bytes).substring(1)
          }
          async export(_, A = 'libp2p-key') {
            if (A === 'libp2p-key') return a.export(this.bytes, _)
            throw t(new Error(`export format '${A}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')
          }
        }
      function p(_) {
        if (_.length > o.privateKeyLength) {
          _ = m(_, o.privateKeyLength + o.publicKeyLength)
          let E = _.slice(0, o.privateKeyLength),
            k = _.slice(o.privateKeyLength, _.length)
          return new f(E, k)
        }
        _ = m(_, o.privateKeyLength)
        let A = _.slice(0, o.privateKeyLength),
          T = _.slice(o.publicKeyLength)
        return new f(A, T)
      }
      function y(_) {
        return (_ = m(_, o.publicKeyLength)), new c(_)
      }
      async function d() {
        let { privateKey: _, publicKey: A } = await o.generateKey()
        return new f(_, A)
      }
      async function h(_) {
        let { privateKey: A, publicKey: T } = await o.generateKeyFromSeed(_)
        return new f(A, T)
      }
      function m(_, A) {
        if (((_ = Uint8Array.from(_ || [])), _.length !== A))
          throw t(new Error(`Key must be a Uint8Array of length ${A}, got ${_.length}`), 'ERR_INVALID_KEY_TYPE')
        return _
      }
      r.exports = {
        Ed25519PublicKey: c,
        Ed25519PrivateKey: f,
        unmarshalEd25519PrivateKey: p,
        unmarshalEd25519PublicKey: y,
        generateKeyPair: d,
        generateKeyPairFromSeed: h
      }
    }
  }),
  gO = te({
    'node_modules/secp256k1/lib/index.js'(e, r) {
      V(), F()
      var t = {
        IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
        TWEAK_ADD: 'The tweak was out of range or the resulted private key is invalid',
        TWEAK_MUL: 'The tweak was out of range or equal to zero',
        CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
        SECKEY_INVALID: 'Private Key is invalid',
        PUBKEY_PARSE: 'Public Key could not be parsed',
        PUBKEY_SERIALIZE: 'Public Key serialization error',
        PUBKEY_COMBINE: 'The sum of the public keys is not valid',
        SIG_PARSE: 'Signature could not be parsed',
        SIGN: 'The nonce generation function failed, or the private key was invalid',
        RECOVER: 'Public key could not be recover',
        ECDH: 'Scalar was invalid (zero or overflow)'
      }
      function n(l, a) {
        if (!l) throw new Error(a)
      }
      function i(l, a, c) {
        if ((n(a instanceof Uint8Array, `Expected ${l} to be an Uint8Array`), c !== void 0))
          if (Array.isArray(c)) {
            let f = c.join(', '),
              p = `Expected ${l} to be an Uint8Array with length [${f}]`
            n(c.includes(a.length), p)
          } else {
            let f = `Expected ${l} to be an Uint8Array with length ${c}`
            n(a.length === c, f)
          }
      }
      function s(l) {
        n(o(l) === 'Boolean', 'Expected compressed to be a Boolean')
      }
      function u(l = (c) => new Uint8Array(c), a) {
        return typeof l == 'function' && (l = l(a)), i('output', l, a), l
      }
      function o(l) {
        return Object.prototype.toString.call(l).slice(8, -1)
      }
      r.exports = (l) => ({
        contextRandomize(a) {
          switch (
            (n(a === null || a instanceof Uint8Array, 'Expected seed to be an Uint8Array or null'),
            a !== null && i('seed', a, 32),
            l.contextRandomize(a))
          ) {
            case 1:
              throw new Error(t.CONTEXT_RANDOMIZE_UNKNOW)
          }
        },
        privateKeyVerify(a) {
          return i('private key', a, 32), l.privateKeyVerify(a) === 0
        },
        privateKeyNegate(a) {
          switch ((i('private key', a, 32), l.privateKeyNegate(a))) {
            case 0:
              return a
            case 1:
              throw new Error(t.IMPOSSIBLE_CASE)
          }
        },
        privateKeyTweakAdd(a, c) {
          switch ((i('private key', a, 32), i('tweak', c, 32), l.privateKeyTweakAdd(a, c))) {
            case 0:
              return a
            case 1:
              throw new Error(t.TWEAK_ADD)
          }
        },
        privateKeyTweakMul(a, c) {
          switch ((i('private key', a, 32), i('tweak', c, 32), l.privateKeyTweakMul(a, c))) {
            case 0:
              return a
            case 1:
              throw new Error(t.TWEAK_MUL)
          }
        },
        publicKeyVerify(a) {
          return i('public key', a, [33, 65]), l.publicKeyVerify(a) === 0
        },
        publicKeyCreate(a, c = !0, f) {
          switch ((i('private key', a, 32), s(c), (f = u(f, c ? 33 : 65)), l.publicKeyCreate(f, a))) {
            case 0:
              return f
            case 1:
              throw new Error(t.SECKEY_INVALID)
            case 2:
              throw new Error(t.PUBKEY_SERIALIZE)
          }
        },
        publicKeyConvert(a, c = !0, f) {
          switch ((i('public key', a, [33, 65]), s(c), (f = u(f, c ? 33 : 65)), l.publicKeyConvert(f, a))) {
            case 0:
              return f
            case 1:
              throw new Error(t.PUBKEY_PARSE)
            case 2:
              throw new Error(t.PUBKEY_SERIALIZE)
          }
        },
        publicKeyNegate(a, c = !0, f) {
          switch ((i('public key', a, [33, 65]), s(c), (f = u(f, c ? 33 : 65)), l.publicKeyNegate(f, a))) {
            case 0:
              return f
            case 1:
              throw new Error(t.PUBKEY_PARSE)
            case 2:
              throw new Error(t.IMPOSSIBLE_CASE)
            case 3:
              throw new Error(t.PUBKEY_SERIALIZE)
          }
        },
        publicKeyCombine(a, c = !0, f) {
          n(Array.isArray(a), 'Expected public keys to be an Array'),
            n(a.length > 0, 'Expected public keys array will have more than zero items')
          for (let p of a) i('public key', p, [33, 65])
          switch ((s(c), (f = u(f, c ? 33 : 65)), l.publicKeyCombine(f, a))) {
            case 0:
              return f
            case 1:
              throw new Error(t.PUBKEY_PARSE)
            case 2:
              throw new Error(t.PUBKEY_COMBINE)
            case 3:
              throw new Error(t.PUBKEY_SERIALIZE)
          }
        },
        publicKeyTweakAdd(a, c, f = !0, p) {
          switch (
            (i('public key', a, [33, 65]),
            i('tweak', c, 32),
            s(f),
            (p = u(p, f ? 33 : 65)),
            l.publicKeyTweakAdd(p, a, c))
          ) {
            case 0:
              return p
            case 1:
              throw new Error(t.PUBKEY_PARSE)
            case 2:
              throw new Error(t.TWEAK_ADD)
          }
        },
        publicKeyTweakMul(a, c, f = !0, p) {
          switch (
            (i('public key', a, [33, 65]),
            i('tweak', c, 32),
            s(f),
            (p = u(p, f ? 33 : 65)),
            l.publicKeyTweakMul(p, a, c))
          ) {
            case 0:
              return p
            case 1:
              throw new Error(t.PUBKEY_PARSE)
            case 2:
              throw new Error(t.TWEAK_MUL)
          }
        },
        signatureNormalize(a) {
          switch ((i('signature', a, 64), l.signatureNormalize(a))) {
            case 0:
              return a
            case 1:
              throw new Error(t.SIG_PARSE)
          }
        },
        signatureExport(a, c) {
          i('signature', a, 64), (c = u(c, 72))
          let f = { output: c, outputlen: 72 }
          switch (l.signatureExport(f, a)) {
            case 0:
              return c.slice(0, f.outputlen)
            case 1:
              throw new Error(t.SIG_PARSE)
            case 2:
              throw new Error(t.IMPOSSIBLE_CASE)
          }
        },
        signatureImport(a, c) {
          switch ((i('signature', a), (c = u(c, 64)), l.signatureImport(c, a))) {
            case 0:
              return c
            case 1:
              throw new Error(t.SIG_PARSE)
            case 2:
              throw new Error(t.IMPOSSIBLE_CASE)
          }
        },
        ecdsaSign(a, c, f = {}, p) {
          i('message', a, 32),
            i('private key', c, 32),
            n(o(f) === 'Object', 'Expected options to be an Object'),
            f.data !== void 0 && i('options.data', f.data),
            f.noncefn !== void 0 && n(o(f.noncefn) === 'Function', 'Expected options.noncefn to be a Function'),
            (p = u(p, 64))
          let y = { signature: p, recid: null }
          switch (l.ecdsaSign(y, a, c, f.data, f.noncefn)) {
            case 0:
              return y
            case 1:
              throw new Error(t.SIGN)
            case 2:
              throw new Error(t.IMPOSSIBLE_CASE)
          }
        },
        ecdsaVerify(a, c, f) {
          switch ((i('signature', a, 64), i('message', c, 32), i('public key', f, [33, 65]), l.ecdsaVerify(a, c, f))) {
            case 0:
              return !0
            case 3:
              return !1
            case 1:
              throw new Error(t.SIG_PARSE)
            case 2:
              throw new Error(t.PUBKEY_PARSE)
          }
        },
        ecdsaRecover(a, c, f, p = !0, y) {
          switch (
            (i('signature', a, 64),
            n(o(c) === 'Number' && c >= 0 && c <= 3, 'Expected recovery id to be a Number within interval [0, 3]'),
            i('message', f, 32),
            s(p),
            (y = u(y, p ? 33 : 65)),
            l.ecdsaRecover(y, a, c, f))
          ) {
            case 0:
              return y
            case 1:
              throw new Error(t.SIG_PARSE)
            case 2:
              throw new Error(t.RECOVER)
            case 3:
              throw new Error(t.IMPOSSIBLE_CASE)
          }
        },
        ecdh(a, c, f = {}, p) {
          switch (
            (i('public key', a, [33, 65]),
            i('private key', c, 32),
            n(o(f) === 'Object', 'Expected options to be an Object'),
            f.data !== void 0 && i('options.data', f.data),
            f.hashfn !== void 0
              ? (n(o(f.hashfn) === 'Function', 'Expected options.hashfn to be a Function'),
                f.xbuf !== void 0 && i('options.xbuf', f.xbuf, 32),
                f.ybuf !== void 0 && i('options.ybuf', f.ybuf, 32),
                i('output', p))
              : (p = u(p, 32)),
            l.ecdh(p, a, c, f.data, f.hashfn, f.xbuf, f.ybuf))
          ) {
            case 0:
              return p
            case 1:
              throw new Error(t.PUBKEY_PARSE)
            case 2:
              throw new Error(t.ECDH)
          }
        }
      })
    }
  }),
  wO = te({
    'node_modules/elliptic/package.json'(e, r) {
      r.exports = {
        _args: [['elliptic@6.5.4', '/home/farhoud/workspace/functionland/box/packages/graph']],
        _from: 'elliptic@6.5.4',
        _id: 'elliptic@6.5.4',
        _inBundle: !1,
        _integrity: 'sha512-iLhC6ULemrljPZb+QutR5TQGB+pdW6KGD5RSegS+8sorOZT+rdQFbsQFJgvN3eRqNALqJer4oQ16YvJHlU8hzQ==',
        _location: '/elliptic',
        _phantomChildren: {},
        _requested: {
          type: 'version',
          registry: !0,
          raw: 'elliptic@6.5.4',
          name: 'elliptic',
          escapedName: 'elliptic',
          rawSpec: '6.5.4',
          saveSpec: null,
          fetchSpec: '6.5.4'
        },
        _requiredBy: ['/secp256k1'],
        _resolved: 'https://registry.npmjs.org/elliptic/-/elliptic-6.5.4.tgz',
        _spec: '6.5.4',
        _where: '/home/farhoud/workspace/functionland/box/packages/graph',
        author: { name: 'Fedor Indutny', email: 'fedor@indutny.com' },
        bugs: { url: 'https://github.com/indutny/elliptic/issues' },
        dependencies: {
          'bn.js': '^4.11.9',
          brorand: '^1.1.0',
          'hash.js': '^1.0.0',
          'hmac-drbg': '^1.0.1',
          inherits: '^2.0.4',
          'minimalistic-assert': '^1.0.1',
          'minimalistic-crypto-utils': '^1.0.1'
        },
        description: 'EC cryptography',
        devDependencies: {
          brfs: '^2.0.2',
          coveralls: '^3.1.0',
          eslint: '^7.6.0',
          grunt: '^1.2.1',
          'grunt-browserify': '^5.3.0',
          'grunt-cli': '^1.3.2',
          'grunt-contrib-connect': '^3.0.0',
          'grunt-contrib-copy': '^1.0.0',
          'grunt-contrib-uglify': '^5.0.0',
          'grunt-mocha-istanbul': '^5.0.2',
          'grunt-saucelabs': '^9.0.1',
          istanbul: '^0.4.5',
          mocha: '^8.0.1'
        },
        files: ['lib'],
        homepage: 'https://github.com/indutny/elliptic',
        keywords: ['EC', 'Elliptic', 'curve', 'Cryptography'],
        license: 'MIT',
        main: 'lib/elliptic.js',
        name: 'elliptic',
        repository: { type: 'git', url: 'git+ssh://git@github.com/indutny/elliptic.git' },
        scripts: {
          lint: 'eslint lib test',
          'lint:fix': 'npm run lint -- --fix',
          test: 'npm run lint && npm run unit',
          unit: 'istanbul test _mocha --reporter=spec test/index.js',
          version: 'grunt dist && git add dist/'
        },
        version: '6.5.4'
      }
    }
  }),
  _O = te({
    '(disabled):node_modules/buffer/index.js'() {
      V(), F()
    }
  }),
  ai = te({
    'node_modules/bn.js/lib/bn.js'(e, r) {
      V(),
        F(),
        (function (t, n) {
          'use strict'
          function i(O, x) {
            if (!O) throw new Error(x || 'Assertion failed')
          }
          function s(O, x) {
            O.super_ = x
            var L = function () {}
            ;(L.prototype = x.prototype), (O.prototype = new L()), (O.prototype.constructor = O)
          }
          function u(O, x, L) {
            if (u.isBN(O)) return O
            ;(this.negative = 0),
              (this.words = null),
              (this.length = 0),
              (this.red = null),
              O !== null && ((x === 'le' || x === 'be') && ((L = x), (x = 10)), this._init(O || 0, x || 10, L || 'be'))
          }
          typeof t == 'object' ? (t.exports = u) : (n.BN = u), (u.BN = u), (u.wordSize = 26)
          var o
          try {
            typeof window != 'undefined' && typeof window.Buffer != 'undefined'
              ? (o = window.Buffer)
              : (o = _O().Buffer)
          } catch (O) {}
          ;(u.isBN = function (x) {
            return x instanceof u
              ? !0
              : x !== null && typeof x == 'object' && x.constructor.wordSize === u.wordSize && Array.isArray(x.words)
          }),
            (u.max = function (x, L) {
              return x.cmp(L) > 0 ? x : L
            }),
            (u.min = function (x, L) {
              return x.cmp(L) < 0 ? x : L
            }),
            (u.prototype._init = function (x, L, K) {
              if (typeof x == 'number') return this._initNumber(x, L, K)
              if (typeof x == 'object') return this._initArray(x, L, K)
              L === 'hex' && (L = 16), i(L === (L | 0) && L >= 2 && L <= 36), (x = x.toString().replace(/\s+/g, ''))
              var J = 0
              x[0] === '-' && (J++, (this.negative = 1)),
                J < x.length &&
                  (L === 16
                    ? this._parseHex(x, J, K)
                    : (this._parseBase(x, L, J), K === 'le' && this._initArray(this.toArray(), L, K)))
            }),
            (u.prototype._initNumber = function (x, L, K) {
              x < 0 && ((this.negative = 1), (x = -x)),
                x < 67108864
                  ? ((this.words = [x & 67108863]), (this.length = 1))
                  : x < 4503599627370496
                  ? ((this.words = [x & 67108863, (x / 67108864) & 67108863]), (this.length = 2))
                  : (i(x < 9007199254740992),
                    (this.words = [x & 67108863, (x / 67108864) & 67108863, 1]),
                    (this.length = 3)),
                K === 'le' && this._initArray(this.toArray(), L, K)
            }),
            (u.prototype._initArray = function (x, L, K) {
              if ((i(typeof x.length == 'number'), x.length <= 0)) return (this.words = [0]), (this.length = 1), this
              ;(this.length = Math.ceil(x.length / 3)), (this.words = new Array(this.length))
              for (var J = 0; J < this.length; J++) this.words[J] = 0
              var Z,
                Q,
                fe = 0
              if (K === 'be')
                for (J = x.length - 1, Z = 0; J >= 0; J -= 3)
                  (Q = x[J] | (x[J - 1] << 8) | (x[J - 2] << 16)),
                    (this.words[Z] |= (Q << fe) & 67108863),
                    (this.words[Z + 1] = (Q >>> (26 - fe)) & 67108863),
                    (fe += 24),
                    fe >= 26 && ((fe -= 26), Z++)
              else if (K === 'le')
                for (J = 0, Z = 0; J < x.length; J += 3)
                  (Q = x[J] | (x[J + 1] << 8) | (x[J + 2] << 16)),
                    (this.words[Z] |= (Q << fe) & 67108863),
                    (this.words[Z + 1] = (Q >>> (26 - fe)) & 67108863),
                    (fe += 24),
                    fe >= 26 && ((fe -= 26), Z++)
              return this.strip()
            })
          function l(O, x) {
            var L = O.charCodeAt(x)
            return L >= 65 && L <= 70 ? L - 55 : L >= 97 && L <= 102 ? L - 87 : (L - 48) & 15
          }
          function a(O, x, L) {
            var K = l(O, L)
            return L - 1 >= x && (K |= l(O, L - 1) << 4), K
          }
          u.prototype._parseHex = function (x, L, K) {
            ;(this.length = Math.ceil((x.length - L) / 6)), (this.words = new Array(this.length))
            for (var J = 0; J < this.length; J++) this.words[J] = 0
            var Z = 0,
              Q = 0,
              fe
            if (K === 'be')
              for (J = x.length - 1; J >= L; J -= 2)
                (fe = a(x, L, J) << Z),
                  (this.words[Q] |= fe & 67108863),
                  Z >= 18 ? ((Z -= 18), (Q += 1), (this.words[Q] |= fe >>> 26)) : (Z += 8)
            else {
              var ie = x.length - L
              for (J = ie % 2 == 0 ? L + 1 : L; J < x.length; J += 2)
                (fe = a(x, L, J) << Z),
                  (this.words[Q] |= fe & 67108863),
                  Z >= 18 ? ((Z -= 18), (Q += 1), (this.words[Q] |= fe >>> 26)) : (Z += 8)
            }
            this.strip()
          }
          function c(O, x, L, K) {
            for (var J = 0, Z = Math.min(O.length, L), Q = x; Q < Z; Q++) {
              var fe = O.charCodeAt(Q) - 48
              ;(J *= K), fe >= 49 ? (J += fe - 49 + 10) : fe >= 17 ? (J += fe - 17 + 10) : (J += fe)
            }
            return J
          }
          ;(u.prototype._parseBase = function (x, L, K) {
            ;(this.words = [0]), (this.length = 1)
            for (var J = 0, Z = 1; Z <= 67108863; Z *= L) J++
            J--, (Z = (Z / L) | 0)
            for (var Q = x.length - K, fe = Q % J, ie = Math.min(Q, Q - fe) + K, W = 0, le = K; le < ie; le += J)
              (W = c(x, le, le + J, L)),
                this.imuln(Z),
                this.words[0] + W < 67108864 ? (this.words[0] += W) : this._iaddn(W)
            if (fe !== 0) {
              var xe = 1
              for (W = c(x, le, x.length, L), le = 0; le < fe; le++) xe *= L
              this.imuln(xe), this.words[0] + W < 67108864 ? (this.words[0] += W) : this._iaddn(W)
            }
            this.strip()
          }),
            (u.prototype.copy = function (x) {
              x.words = new Array(this.length)
              for (var L = 0; L < this.length; L++) x.words[L] = this.words[L]
              ;(x.length = this.length), (x.negative = this.negative), (x.red = this.red)
            }),
            (u.prototype.clone = function () {
              var x = new u(null)
              return this.copy(x), x
            }),
            (u.prototype._expand = function (x) {
              for (; this.length < x; ) this.words[this.length++] = 0
              return this
            }),
            (u.prototype.strip = function () {
              for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--
              return this._normSign()
            }),
            (u.prototype._normSign = function () {
              return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
            }),
            (u.prototype.inspect = function () {
              return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>'
            })
          var f = [
              '',
              '0',
              '00',
              '000',
              '0000',
              '00000',
              '000000',
              '0000000',
              '00000000',
              '000000000',
              '0000000000',
              '00000000000',
              '000000000000',
              '0000000000000',
              '00000000000000',
              '000000000000000',
              '0000000000000000',
              '00000000000000000',
              '000000000000000000',
              '0000000000000000000',
              '00000000000000000000',
              '000000000000000000000',
              '0000000000000000000000',
              '00000000000000000000000',
              '000000000000000000000000',
              '0000000000000000000000000'
            ],
            p = [
              0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
              5, 5, 5
            ],
            y = [
              0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171,
              35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632,
              6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393,
              45435424, 52521875, 60466176
            ]
          ;(u.prototype.toString = function (x, L) {
            ;(x = x || 10), (L = L | 0 || 1)
            var K
            if (x === 16 || x === 'hex') {
              K = ''
              for (var J = 0, Z = 0, Q = 0; Q < this.length; Q++) {
                var fe = this.words[Q],
                  ie = (((fe << J) | Z) & 16777215).toString(16)
                ;(Z = (fe >>> (24 - J)) & 16777215),
                  Z !== 0 || Q !== this.length - 1 ? (K = f[6 - ie.length] + ie + K) : (K = ie + K),
                  (J += 2),
                  J >= 26 && ((J -= 26), Q--)
              }
              for (Z !== 0 && (K = Z.toString(16) + K); K.length % L != 0; ) K = '0' + K
              return this.negative !== 0 && (K = '-' + K), K
            }
            if (x === (x | 0) && x >= 2 && x <= 36) {
              var W = p[x],
                le = y[x]
              K = ''
              var xe = this.clone()
              for (xe.negative = 0; !xe.isZero(); ) {
                var _e = xe.modn(le).toString(x)
                ;(xe = xe.idivn(le)), xe.isZero() ? (K = _e + K) : (K = f[W - _e.length] + _e + K)
              }
              for (this.isZero() && (K = '0' + K); K.length % L != 0; ) K = '0' + K
              return this.negative !== 0 && (K = '-' + K), K
            }
            i(!1, 'Base should be between 2 and 36')
          }),
            (u.prototype.toNumber = function () {
              var x = this.words[0]
              return (
                this.length === 2
                  ? (x += this.words[1] * 67108864)
                  : this.length === 3 && this.words[2] === 1
                  ? (x += 4503599627370496 + this.words[1] * 67108864)
                  : this.length > 2 && i(!1, 'Number can only safely store up to 53 bits'),
                this.negative !== 0 ? -x : x
              )
            }),
            (u.prototype.toJSON = function () {
              return this.toString(16)
            }),
            (u.prototype.toBuffer = function (x, L) {
              return i(typeof o != 'undefined'), this.toArrayLike(o, x, L)
            }),
            (u.prototype.toArray = function (x, L) {
              return this.toArrayLike(Array, x, L)
            }),
            (u.prototype.toArrayLike = function (x, L, K) {
              var J = this.byteLength(),
                Z = K || Math.max(1, J)
              i(J <= Z, 'byte array longer than desired length'), i(Z > 0, 'Requested array length <= 0'), this.strip()
              var Q = L === 'le',
                fe = new x(Z),
                ie,
                W,
                le = this.clone()
              if (Q) {
                for (W = 0; !le.isZero(); W++) (ie = le.andln(255)), le.iushrn(8), (fe[W] = ie)
                for (; W < Z; W++) fe[W] = 0
              } else {
                for (W = 0; W < Z - J; W++) fe[W] = 0
                for (W = 0; !le.isZero(); W++) (ie = le.andln(255)), le.iushrn(8), (fe[Z - W - 1] = ie)
              }
              return fe
            }),
            Math.clz32
              ? (u.prototype._countBits = function (x) {
                  return 32 - Math.clz32(x)
                })
              : (u.prototype._countBits = function (x) {
                  var L = x,
                    K = 0
                  return (
                    L >= 4096 && ((K += 13), (L >>>= 13)),
                    L >= 64 && ((K += 7), (L >>>= 7)),
                    L >= 8 && ((K += 4), (L >>>= 4)),
                    L >= 2 && ((K += 2), (L >>>= 2)),
                    K + L
                  )
                }),
            (u.prototype._zeroBits = function (x) {
              if (x === 0) return 26
              var L = x,
                K = 0
              return (
                (L & 8191) == 0 && ((K += 13), (L >>>= 13)),
                (L & 127) == 0 && ((K += 7), (L >>>= 7)),
                (L & 15) == 0 && ((K += 4), (L >>>= 4)),
                (L & 3) == 0 && ((K += 2), (L >>>= 2)),
                (L & 1) == 0 && K++,
                K
              )
            }),
            (u.prototype.bitLength = function () {
              var x = this.words[this.length - 1],
                L = this._countBits(x)
              return (this.length - 1) * 26 + L
            })
          function d(O) {
            for (var x = new Array(O.bitLength()), L = 0; L < x.length; L++) {
              var K = (L / 26) | 0,
                J = L % 26
              x[L] = (O.words[K] & (1 << J)) >>> J
            }
            return x
          }
          ;(u.prototype.zeroBits = function () {
            if (this.isZero()) return 0
            for (var x = 0, L = 0; L < this.length; L++) {
              var K = this._zeroBits(this.words[L])
              if (((x += K), K !== 26)) break
            }
            return x
          }),
            (u.prototype.byteLength = function () {
              return Math.ceil(this.bitLength() / 8)
            }),
            (u.prototype.toTwos = function (x) {
              return this.negative !== 0 ? this.abs().inotn(x).iaddn(1) : this.clone()
            }),
            (u.prototype.fromTwos = function (x) {
              return this.testn(x - 1) ? this.notn(x).iaddn(1).ineg() : this.clone()
            }),
            (u.prototype.isNeg = function () {
              return this.negative !== 0
            }),
            (u.prototype.neg = function () {
              return this.clone().ineg()
            }),
            (u.prototype.ineg = function () {
              return this.isZero() || (this.negative ^= 1), this
            }),
            (u.prototype.iuor = function (x) {
              for (; this.length < x.length; ) this.words[this.length++] = 0
              for (var L = 0; L < x.length; L++) this.words[L] = this.words[L] | x.words[L]
              return this.strip()
            }),
            (u.prototype.ior = function (x) {
              return i((this.negative | x.negative) == 0), this.iuor(x)
            }),
            (u.prototype.or = function (x) {
              return this.length > x.length ? this.clone().ior(x) : x.clone().ior(this)
            }),
            (u.prototype.uor = function (x) {
              return this.length > x.length ? this.clone().iuor(x) : x.clone().iuor(this)
            }),
            (u.prototype.iuand = function (x) {
              var L
              this.length > x.length ? (L = x) : (L = this)
              for (var K = 0; K < L.length; K++) this.words[K] = this.words[K] & x.words[K]
              return (this.length = L.length), this.strip()
            }),
            (u.prototype.iand = function (x) {
              return i((this.negative | x.negative) == 0), this.iuand(x)
            }),
            (u.prototype.and = function (x) {
              return this.length > x.length ? this.clone().iand(x) : x.clone().iand(this)
            }),
            (u.prototype.uand = function (x) {
              return this.length > x.length ? this.clone().iuand(x) : x.clone().iuand(this)
            }),
            (u.prototype.iuxor = function (x) {
              var L, K
              this.length > x.length ? ((L = this), (K = x)) : ((L = x), (K = this))
              for (var J = 0; J < K.length; J++) this.words[J] = L.words[J] ^ K.words[J]
              if (this !== L) for (; J < L.length; J++) this.words[J] = L.words[J]
              return (this.length = L.length), this.strip()
            }),
            (u.prototype.ixor = function (x) {
              return i((this.negative | x.negative) == 0), this.iuxor(x)
            }),
            (u.prototype.xor = function (x) {
              return this.length > x.length ? this.clone().ixor(x) : x.clone().ixor(this)
            }),
            (u.prototype.uxor = function (x) {
              return this.length > x.length ? this.clone().iuxor(x) : x.clone().iuxor(this)
            }),
            (u.prototype.inotn = function (x) {
              i(typeof x == 'number' && x >= 0)
              var L = Math.ceil(x / 26) | 0,
                K = x % 26
              this._expand(L), K > 0 && L--
              for (var J = 0; J < L; J++) this.words[J] = ~this.words[J] & 67108863
              return K > 0 && (this.words[J] = ~this.words[J] & (67108863 >> (26 - K))), this.strip()
            }),
            (u.prototype.notn = function (x) {
              return this.clone().inotn(x)
            }),
            (u.prototype.setn = function (x, L) {
              i(typeof x == 'number' && x >= 0)
              var K = (x / 26) | 0,
                J = x % 26
              return (
                this._expand(K + 1),
                L ? (this.words[K] = this.words[K] | (1 << J)) : (this.words[K] = this.words[K] & ~(1 << J)),
                this.strip()
              )
            }),
            (u.prototype.iadd = function (x) {
              var L
              if (this.negative !== 0 && x.negative === 0)
                return (this.negative = 0), (L = this.isub(x)), (this.negative ^= 1), this._normSign()
              if (this.negative === 0 && x.negative !== 0)
                return (x.negative = 0), (L = this.isub(x)), (x.negative = 1), L._normSign()
              var K, J
              this.length > x.length ? ((K = this), (J = x)) : ((K = x), (J = this))
              for (var Z = 0, Q = 0; Q < J.length; Q++)
                (L = (K.words[Q] | 0) + (J.words[Q] | 0) + Z), (this.words[Q] = L & 67108863), (Z = L >>> 26)
              for (; Z !== 0 && Q < K.length; Q++)
                (L = (K.words[Q] | 0) + Z), (this.words[Q] = L & 67108863), (Z = L >>> 26)
              if (((this.length = K.length), Z !== 0)) (this.words[this.length] = Z), this.length++
              else if (K !== this) for (; Q < K.length; Q++) this.words[Q] = K.words[Q]
              return this
            }),
            (u.prototype.add = function (x) {
              var L
              return x.negative !== 0 && this.negative === 0
                ? ((x.negative = 0), (L = this.sub(x)), (x.negative ^= 1), L)
                : x.negative === 0 && this.negative !== 0
                ? ((this.negative = 0), (L = x.sub(this)), (this.negative = 1), L)
                : this.length > x.length
                ? this.clone().iadd(x)
                : x.clone().iadd(this)
            }),
            (u.prototype.isub = function (x) {
              if (x.negative !== 0) {
                x.negative = 0
                var L = this.iadd(x)
                return (x.negative = 1), L._normSign()
              } else if (this.negative !== 0)
                return (this.negative = 0), this.iadd(x), (this.negative = 1), this._normSign()
              var K = this.cmp(x)
              if (K === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this
              var J, Z
              K > 0 ? ((J = this), (Z = x)) : ((J = x), (Z = this))
              for (var Q = 0, fe = 0; fe < Z.length; fe++)
                (L = (J.words[fe] | 0) - (Z.words[fe] | 0) + Q), (Q = L >> 26), (this.words[fe] = L & 67108863)
              for (; Q !== 0 && fe < J.length; fe++)
                (L = (J.words[fe] | 0) + Q), (Q = L >> 26), (this.words[fe] = L & 67108863)
              if (Q === 0 && fe < J.length && J !== this) for (; fe < J.length; fe++) this.words[fe] = J.words[fe]
              return (this.length = Math.max(this.length, fe)), J !== this && (this.negative = 1), this.strip()
            }),
            (u.prototype.sub = function (x) {
              return this.clone().isub(x)
            })
          function h(O, x, L) {
            L.negative = x.negative ^ O.negative
            var K = (O.length + x.length) | 0
            ;(L.length = K), (K = (K - 1) | 0)
            var J = O.words[0] | 0,
              Z = x.words[0] | 0,
              Q = J * Z,
              fe = Q & 67108863,
              ie = (Q / 67108864) | 0
            L.words[0] = fe
            for (var W = 1; W < K; W++) {
              for (
                var le = ie >>> 26,
                  xe = ie & 67108863,
                  _e = Math.min(W, x.length - 1),
                  Ne = Math.max(0, W - O.length + 1);
                Ne <= _e;
                Ne++
              ) {
                var ke = (W - Ne) | 0
                ;(J = O.words[ke] | 0),
                  (Z = x.words[Ne] | 0),
                  (Q = J * Z + xe),
                  (le += (Q / 67108864) | 0),
                  (xe = Q & 67108863)
              }
              ;(L.words[W] = xe | 0), (ie = le | 0)
            }
            return ie !== 0 ? (L.words[W] = ie | 0) : L.length--, L.strip()
          }
          var m = function (x, L, K) {
            var J = x.words,
              Z = L.words,
              Q = K.words,
              fe = 0,
              ie,
              W,
              le,
              xe = J[0] | 0,
              _e = xe & 8191,
              Ne = xe >>> 13,
              ke = J[1] | 0,
              oe = ke & 8191,
              be = ke >>> 13,
              ge = J[2] | 0,
              re = ge & 8191,
              j = ge >>> 13,
              b = J[3] | 0,
              C = b & 8191,
              S = b >>> 13,
              R = J[4] | 0,
              P = R & 8191,
              B = R >>> 13,
              D = J[5] | 0,
              $ = D & 8191,
              g = D >>> 13,
              N = J[6] | 0,
              U = N & 8191,
              X = N >>> 13,
              ne = J[7] | 0,
              ee = ne & 8191,
              ae = ne >>> 13,
              Y = J[8] | 0,
              z = Y & 8191,
              H = Y >>> 13,
              se = J[9] | 0,
              me = se & 8191,
              we = se >>> 13,
              Ee = Z[0] | 0,
              Me = Ee & 8191,
              Be = Ee >>> 13,
              je = Z[1] | 0,
              Pe = je & 8191,
              Oe = je >>> 13,
              ht = Z[2] | 0,
              Qe = ht & 8191,
              et = ht >>> 13,
              Mt = Z[3] | 0,
              ut = Mt & 8191,
              at = Mt >>> 13,
              Pt = Z[4] | 0,
              ft = Pt & 8191,
              We = Pt >>> 13,
              gt = Z[5] | 0,
              Ge = gt & 8191,
              He = gt >>> 13,
              wt = Z[6] | 0,
              tt = wt & 8191,
              Xe = wt >>> 13,
              _t = Z[7] | 0,
              nt = _t & 8191,
              it = _t >>> 13,
              xt = Z[8] | 0,
              st = xt & 8191,
              ot = xt >>> 13,
              Rt = Z[9] | 0,
              Ze = Rt & 8191,
              Ye = Rt >>> 13
            ;(K.negative = x.negative ^ L.negative),
              (K.length = 19),
              (ie = Math.imul(_e, Me)),
              (W = Math.imul(_e, Be)),
              (W = (W + Math.imul(Ne, Me)) | 0),
              (le = Math.imul(Ne, Be))
            var Er = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Er >>> 26)) | 0),
              (Er &= 67108863),
              (ie = Math.imul(oe, Me)),
              (W = Math.imul(oe, Be)),
              (W = (W + Math.imul(be, Me)) | 0),
              (le = Math.imul(be, Be)),
              (ie = (ie + Math.imul(_e, Pe)) | 0),
              (W = (W + Math.imul(_e, Oe)) | 0),
              (W = (W + Math.imul(Ne, Pe)) | 0),
              (le = (le + Math.imul(Ne, Oe)) | 0)
            var Et = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Et >>> 26)) | 0),
              (Et &= 67108863),
              (ie = Math.imul(re, Me)),
              (W = Math.imul(re, Be)),
              (W = (W + Math.imul(j, Me)) | 0),
              (le = Math.imul(j, Be)),
              (ie = (ie + Math.imul(oe, Pe)) | 0),
              (W = (W + Math.imul(oe, Oe)) | 0),
              (W = (W + Math.imul(be, Pe)) | 0),
              (le = (le + Math.imul(be, Oe)) | 0),
              (ie = (ie + Math.imul(_e, Qe)) | 0),
              (W = (W + Math.imul(_e, et)) | 0),
              (W = (W + Math.imul(Ne, Qe)) | 0),
              (le = (le + Math.imul(Ne, et)) | 0)
            var St = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (St >>> 26)) | 0),
              (St &= 67108863),
              (ie = Math.imul(C, Me)),
              (W = Math.imul(C, Be)),
              (W = (W + Math.imul(S, Me)) | 0),
              (le = Math.imul(S, Be)),
              (ie = (ie + Math.imul(re, Pe)) | 0),
              (W = (W + Math.imul(re, Oe)) | 0),
              (W = (W + Math.imul(j, Pe)) | 0),
              (le = (le + Math.imul(j, Oe)) | 0),
              (ie = (ie + Math.imul(oe, Qe)) | 0),
              (W = (W + Math.imul(oe, et)) | 0),
              (W = (W + Math.imul(be, Qe)) | 0),
              (le = (le + Math.imul(be, et)) | 0),
              (ie = (ie + Math.imul(_e, ut)) | 0),
              (W = (W + Math.imul(_e, at)) | 0),
              (W = (W + Math.imul(Ne, ut)) | 0),
              (le = (le + Math.imul(Ne, at)) | 0)
            var Dr = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Dr >>> 26)) | 0),
              (Dr &= 67108863),
              (ie = Math.imul(P, Me)),
              (W = Math.imul(P, Be)),
              (W = (W + Math.imul(B, Me)) | 0),
              (le = Math.imul(B, Be)),
              (ie = (ie + Math.imul(C, Pe)) | 0),
              (W = (W + Math.imul(C, Oe)) | 0),
              (W = (W + Math.imul(S, Pe)) | 0),
              (le = (le + Math.imul(S, Oe)) | 0),
              (ie = (ie + Math.imul(re, Qe)) | 0),
              (W = (W + Math.imul(re, et)) | 0),
              (W = (W + Math.imul(j, Qe)) | 0),
              (le = (le + Math.imul(j, et)) | 0),
              (ie = (ie + Math.imul(oe, ut)) | 0),
              (W = (W + Math.imul(oe, at)) | 0),
              (W = (W + Math.imul(be, ut)) | 0),
              (le = (le + Math.imul(be, at)) | 0),
              (ie = (ie + Math.imul(_e, ft)) | 0),
              (W = (W + Math.imul(_e, We)) | 0),
              (W = (W + Math.imul(Ne, ft)) | 0),
              (le = (le + Math.imul(Ne, We)) | 0)
            var At = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (At >>> 26)) | 0),
              (At &= 67108863),
              (ie = Math.imul($, Me)),
              (W = Math.imul($, Be)),
              (W = (W + Math.imul(g, Me)) | 0),
              (le = Math.imul(g, Be)),
              (ie = (ie + Math.imul(P, Pe)) | 0),
              (W = (W + Math.imul(P, Oe)) | 0),
              (W = (W + Math.imul(B, Pe)) | 0),
              (le = (le + Math.imul(B, Oe)) | 0),
              (ie = (ie + Math.imul(C, Qe)) | 0),
              (W = (W + Math.imul(C, et)) | 0),
              (W = (W + Math.imul(S, Qe)) | 0),
              (le = (le + Math.imul(S, et)) | 0),
              (ie = (ie + Math.imul(re, ut)) | 0),
              (W = (W + Math.imul(re, at)) | 0),
              (W = (W + Math.imul(j, ut)) | 0),
              (le = (le + Math.imul(j, at)) | 0),
              (ie = (ie + Math.imul(oe, ft)) | 0),
              (W = (W + Math.imul(oe, We)) | 0),
              (W = (W + Math.imul(be, ft)) | 0),
              (le = (le + Math.imul(be, We)) | 0),
              (ie = (ie + Math.imul(_e, Ge)) | 0),
              (W = (W + Math.imul(_e, He)) | 0),
              (W = (W + Math.imul(Ne, Ge)) | 0),
              (le = (le + Math.imul(Ne, He)) | 0)
            var vt = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (vt >>> 26)) | 0),
              (vt &= 67108863),
              (ie = Math.imul(U, Me)),
              (W = Math.imul(U, Be)),
              (W = (W + Math.imul(X, Me)) | 0),
              (le = Math.imul(X, Be)),
              (ie = (ie + Math.imul($, Pe)) | 0),
              (W = (W + Math.imul($, Oe)) | 0),
              (W = (W + Math.imul(g, Pe)) | 0),
              (le = (le + Math.imul(g, Oe)) | 0),
              (ie = (ie + Math.imul(P, Qe)) | 0),
              (W = (W + Math.imul(P, et)) | 0),
              (W = (W + Math.imul(B, Qe)) | 0),
              (le = (le + Math.imul(B, et)) | 0),
              (ie = (ie + Math.imul(C, ut)) | 0),
              (W = (W + Math.imul(C, at)) | 0),
              (W = (W + Math.imul(S, ut)) | 0),
              (le = (le + Math.imul(S, at)) | 0),
              (ie = (ie + Math.imul(re, ft)) | 0),
              (W = (W + Math.imul(re, We)) | 0),
              (W = (W + Math.imul(j, ft)) | 0),
              (le = (le + Math.imul(j, We)) | 0),
              (ie = (ie + Math.imul(oe, Ge)) | 0),
              (W = (W + Math.imul(oe, He)) | 0),
              (W = (W + Math.imul(be, Ge)) | 0),
              (le = (le + Math.imul(be, He)) | 0),
              (ie = (ie + Math.imul(_e, tt)) | 0),
              (W = (W + Math.imul(_e, Xe)) | 0),
              (W = (W + Math.imul(Ne, tt)) | 0),
              (le = (le + Math.imul(Ne, Xe)) | 0)
            var Yt = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Yt >>> 26)) | 0),
              (Yt &= 67108863),
              (ie = Math.imul(ee, Me)),
              (W = Math.imul(ee, Be)),
              (W = (W + Math.imul(ae, Me)) | 0),
              (le = Math.imul(ae, Be)),
              (ie = (ie + Math.imul(U, Pe)) | 0),
              (W = (W + Math.imul(U, Oe)) | 0),
              (W = (W + Math.imul(X, Pe)) | 0),
              (le = (le + Math.imul(X, Oe)) | 0),
              (ie = (ie + Math.imul($, Qe)) | 0),
              (W = (W + Math.imul($, et)) | 0),
              (W = (W + Math.imul(g, Qe)) | 0),
              (le = (le + Math.imul(g, et)) | 0),
              (ie = (ie + Math.imul(P, ut)) | 0),
              (W = (W + Math.imul(P, at)) | 0),
              (W = (W + Math.imul(B, ut)) | 0),
              (le = (le + Math.imul(B, at)) | 0),
              (ie = (ie + Math.imul(C, ft)) | 0),
              (W = (W + Math.imul(C, We)) | 0),
              (W = (W + Math.imul(S, ft)) | 0),
              (le = (le + Math.imul(S, We)) | 0),
              (ie = (ie + Math.imul(re, Ge)) | 0),
              (W = (W + Math.imul(re, He)) | 0),
              (W = (W + Math.imul(j, Ge)) | 0),
              (le = (le + Math.imul(j, He)) | 0),
              (ie = (ie + Math.imul(oe, tt)) | 0),
              (W = (W + Math.imul(oe, Xe)) | 0),
              (W = (W + Math.imul(be, tt)) | 0),
              (le = (le + Math.imul(be, Xe)) | 0),
              (ie = (ie + Math.imul(_e, nt)) | 0),
              (W = (W + Math.imul(_e, it)) | 0),
              (W = (W + Math.imul(Ne, nt)) | 0),
              (le = (le + Math.imul(Ne, it)) | 0)
            var It = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (It >>> 26)) | 0),
              (It &= 67108863),
              (ie = Math.imul(z, Me)),
              (W = Math.imul(z, Be)),
              (W = (W + Math.imul(H, Me)) | 0),
              (le = Math.imul(H, Be)),
              (ie = (ie + Math.imul(ee, Pe)) | 0),
              (W = (W + Math.imul(ee, Oe)) | 0),
              (W = (W + Math.imul(ae, Pe)) | 0),
              (le = (le + Math.imul(ae, Oe)) | 0),
              (ie = (ie + Math.imul(U, Qe)) | 0),
              (W = (W + Math.imul(U, et)) | 0),
              (W = (W + Math.imul(X, Qe)) | 0),
              (le = (le + Math.imul(X, et)) | 0),
              (ie = (ie + Math.imul($, ut)) | 0),
              (W = (W + Math.imul($, at)) | 0),
              (W = (W + Math.imul(g, ut)) | 0),
              (le = (le + Math.imul(g, at)) | 0),
              (ie = (ie + Math.imul(P, ft)) | 0),
              (W = (W + Math.imul(P, We)) | 0),
              (W = (W + Math.imul(B, ft)) | 0),
              (le = (le + Math.imul(B, We)) | 0),
              (ie = (ie + Math.imul(C, Ge)) | 0),
              (W = (W + Math.imul(C, He)) | 0),
              (W = (W + Math.imul(S, Ge)) | 0),
              (le = (le + Math.imul(S, He)) | 0),
              (ie = (ie + Math.imul(re, tt)) | 0),
              (W = (W + Math.imul(re, Xe)) | 0),
              (W = (W + Math.imul(j, tt)) | 0),
              (le = (le + Math.imul(j, Xe)) | 0),
              (ie = (ie + Math.imul(oe, nt)) | 0),
              (W = (W + Math.imul(oe, it)) | 0),
              (W = (W + Math.imul(be, nt)) | 0),
              (le = (le + Math.imul(be, it)) | 0),
              (ie = (ie + Math.imul(_e, st)) | 0),
              (W = (W + Math.imul(_e, ot)) | 0),
              (W = (W + Math.imul(Ne, st)) | 0),
              (le = (le + Math.imul(Ne, ot)) | 0)
            var Ot = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Ot >>> 26)) | 0),
              (Ot &= 67108863),
              (ie = Math.imul(me, Me)),
              (W = Math.imul(me, Be)),
              (W = (W + Math.imul(we, Me)) | 0),
              (le = Math.imul(we, Be)),
              (ie = (ie + Math.imul(z, Pe)) | 0),
              (W = (W + Math.imul(z, Oe)) | 0),
              (W = (W + Math.imul(H, Pe)) | 0),
              (le = (le + Math.imul(H, Oe)) | 0),
              (ie = (ie + Math.imul(ee, Qe)) | 0),
              (W = (W + Math.imul(ee, et)) | 0),
              (W = (W + Math.imul(ae, Qe)) | 0),
              (le = (le + Math.imul(ae, et)) | 0),
              (ie = (ie + Math.imul(U, ut)) | 0),
              (W = (W + Math.imul(U, at)) | 0),
              (W = (W + Math.imul(X, ut)) | 0),
              (le = (le + Math.imul(X, at)) | 0),
              (ie = (ie + Math.imul($, ft)) | 0),
              (W = (W + Math.imul($, We)) | 0),
              (W = (W + Math.imul(g, ft)) | 0),
              (le = (le + Math.imul(g, We)) | 0),
              (ie = (ie + Math.imul(P, Ge)) | 0),
              (W = (W + Math.imul(P, He)) | 0),
              (W = (W + Math.imul(B, Ge)) | 0),
              (le = (le + Math.imul(B, He)) | 0),
              (ie = (ie + Math.imul(C, tt)) | 0),
              (W = (W + Math.imul(C, Xe)) | 0),
              (W = (W + Math.imul(S, tt)) | 0),
              (le = (le + Math.imul(S, Xe)) | 0),
              (ie = (ie + Math.imul(re, nt)) | 0),
              (W = (W + Math.imul(re, it)) | 0),
              (W = (W + Math.imul(j, nt)) | 0),
              (le = (le + Math.imul(j, it)) | 0),
              (ie = (ie + Math.imul(oe, st)) | 0),
              (W = (W + Math.imul(oe, ot)) | 0),
              (W = (W + Math.imul(be, st)) | 0),
              (le = (le + Math.imul(be, ot)) | 0),
              (ie = (ie + Math.imul(_e, Ze)) | 0),
              (W = (W + Math.imul(_e, Ye)) | 0),
              (W = (W + Math.imul(Ne, Ze)) | 0),
              (le = (le + Math.imul(Ne, Ye)) | 0)
            var En = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (En >>> 26)) | 0),
              (En &= 67108863),
              (ie = Math.imul(me, Pe)),
              (W = Math.imul(me, Oe)),
              (W = (W + Math.imul(we, Pe)) | 0),
              (le = Math.imul(we, Oe)),
              (ie = (ie + Math.imul(z, Qe)) | 0),
              (W = (W + Math.imul(z, et)) | 0),
              (W = (W + Math.imul(H, Qe)) | 0),
              (le = (le + Math.imul(H, et)) | 0),
              (ie = (ie + Math.imul(ee, ut)) | 0),
              (W = (W + Math.imul(ee, at)) | 0),
              (W = (W + Math.imul(ae, ut)) | 0),
              (le = (le + Math.imul(ae, at)) | 0),
              (ie = (ie + Math.imul(U, ft)) | 0),
              (W = (W + Math.imul(U, We)) | 0),
              (W = (W + Math.imul(X, ft)) | 0),
              (le = (le + Math.imul(X, We)) | 0),
              (ie = (ie + Math.imul($, Ge)) | 0),
              (W = (W + Math.imul($, He)) | 0),
              (W = (W + Math.imul(g, Ge)) | 0),
              (le = (le + Math.imul(g, He)) | 0),
              (ie = (ie + Math.imul(P, tt)) | 0),
              (W = (W + Math.imul(P, Xe)) | 0),
              (W = (W + Math.imul(B, tt)) | 0),
              (le = (le + Math.imul(B, Xe)) | 0),
              (ie = (ie + Math.imul(C, nt)) | 0),
              (W = (W + Math.imul(C, it)) | 0),
              (W = (W + Math.imul(S, nt)) | 0),
              (le = (le + Math.imul(S, it)) | 0),
              (ie = (ie + Math.imul(re, st)) | 0),
              (W = (W + Math.imul(re, ot)) | 0),
              (W = (W + Math.imul(j, st)) | 0),
              (le = (le + Math.imul(j, ot)) | 0),
              (ie = (ie + Math.imul(oe, Ze)) | 0),
              (W = (W + Math.imul(oe, Ye)) | 0),
              (W = (W + Math.imul(be, Ze)) | 0),
              (le = (le + Math.imul(be, Ye)) | 0)
            var Dt = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Dt >>> 26)) | 0),
              (Dt &= 67108863),
              (ie = Math.imul(me, Qe)),
              (W = Math.imul(me, et)),
              (W = (W + Math.imul(we, Qe)) | 0),
              (le = Math.imul(we, et)),
              (ie = (ie + Math.imul(z, ut)) | 0),
              (W = (W + Math.imul(z, at)) | 0),
              (W = (W + Math.imul(H, ut)) | 0),
              (le = (le + Math.imul(H, at)) | 0),
              (ie = (ie + Math.imul(ee, ft)) | 0),
              (W = (W + Math.imul(ee, We)) | 0),
              (W = (W + Math.imul(ae, ft)) | 0),
              (le = (le + Math.imul(ae, We)) | 0),
              (ie = (ie + Math.imul(U, Ge)) | 0),
              (W = (W + Math.imul(U, He)) | 0),
              (W = (W + Math.imul(X, Ge)) | 0),
              (le = (le + Math.imul(X, He)) | 0),
              (ie = (ie + Math.imul($, tt)) | 0),
              (W = (W + Math.imul($, Xe)) | 0),
              (W = (W + Math.imul(g, tt)) | 0),
              (le = (le + Math.imul(g, Xe)) | 0),
              (ie = (ie + Math.imul(P, nt)) | 0),
              (W = (W + Math.imul(P, it)) | 0),
              (W = (W + Math.imul(B, nt)) | 0),
              (le = (le + Math.imul(B, it)) | 0),
              (ie = (ie + Math.imul(C, st)) | 0),
              (W = (W + Math.imul(C, ot)) | 0),
              (W = (W + Math.imul(S, st)) | 0),
              (le = (le + Math.imul(S, ot)) | 0),
              (ie = (ie + Math.imul(re, Ze)) | 0),
              (W = (W + Math.imul(re, Ye)) | 0),
              (W = (W + Math.imul(j, Ze)) | 0),
              (le = (le + Math.imul(j, Ye)) | 0)
            var Lt = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Lt >>> 26)) | 0),
              (Lt &= 67108863),
              (ie = Math.imul(me, ut)),
              (W = Math.imul(me, at)),
              (W = (W + Math.imul(we, ut)) | 0),
              (le = Math.imul(we, at)),
              (ie = (ie + Math.imul(z, ft)) | 0),
              (W = (W + Math.imul(z, We)) | 0),
              (W = (W + Math.imul(H, ft)) | 0),
              (le = (le + Math.imul(H, We)) | 0),
              (ie = (ie + Math.imul(ee, Ge)) | 0),
              (W = (W + Math.imul(ee, He)) | 0),
              (W = (W + Math.imul(ae, Ge)) | 0),
              (le = (le + Math.imul(ae, He)) | 0),
              (ie = (ie + Math.imul(U, tt)) | 0),
              (W = (W + Math.imul(U, Xe)) | 0),
              (W = (W + Math.imul(X, tt)) | 0),
              (le = (le + Math.imul(X, Xe)) | 0),
              (ie = (ie + Math.imul($, nt)) | 0),
              (W = (W + Math.imul($, it)) | 0),
              (W = (W + Math.imul(g, nt)) | 0),
              (le = (le + Math.imul(g, it)) | 0),
              (ie = (ie + Math.imul(P, st)) | 0),
              (W = (W + Math.imul(P, ot)) | 0),
              (W = (W + Math.imul(B, st)) | 0),
              (le = (le + Math.imul(B, ot)) | 0),
              (ie = (ie + Math.imul(C, Ze)) | 0),
              (W = (W + Math.imul(C, Ye)) | 0),
              (W = (W + Math.imul(S, Ze)) | 0),
              (le = (le + Math.imul(S, Ye)) | 0)
            var Sn = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Sn >>> 26)) | 0),
              (Sn &= 67108863),
              (ie = Math.imul(me, ft)),
              (W = Math.imul(me, We)),
              (W = (W + Math.imul(we, ft)) | 0),
              (le = Math.imul(we, We)),
              (ie = (ie + Math.imul(z, Ge)) | 0),
              (W = (W + Math.imul(z, He)) | 0),
              (W = (W + Math.imul(H, Ge)) | 0),
              (le = (le + Math.imul(H, He)) | 0),
              (ie = (ie + Math.imul(ee, tt)) | 0),
              (W = (W + Math.imul(ee, Xe)) | 0),
              (W = (W + Math.imul(ae, tt)) | 0),
              (le = (le + Math.imul(ae, Xe)) | 0),
              (ie = (ie + Math.imul(U, nt)) | 0),
              (W = (W + Math.imul(U, it)) | 0),
              (W = (W + Math.imul(X, nt)) | 0),
              (le = (le + Math.imul(X, it)) | 0),
              (ie = (ie + Math.imul($, st)) | 0),
              (W = (W + Math.imul($, ot)) | 0),
              (W = (W + Math.imul(g, st)) | 0),
              (le = (le + Math.imul(g, ot)) | 0),
              (ie = (ie + Math.imul(P, Ze)) | 0),
              (W = (W + Math.imul(P, Ye)) | 0),
              (W = (W + Math.imul(B, Ze)) | 0),
              (le = (le + Math.imul(B, Ye)) | 0)
            var Ut = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Ut >>> 26)) | 0),
              (Ut &= 67108863),
              (ie = Math.imul(me, Ge)),
              (W = Math.imul(me, He)),
              (W = (W + Math.imul(we, Ge)) | 0),
              (le = Math.imul(we, He)),
              (ie = (ie + Math.imul(z, tt)) | 0),
              (W = (W + Math.imul(z, Xe)) | 0),
              (W = (W + Math.imul(H, tt)) | 0),
              (le = (le + Math.imul(H, Xe)) | 0),
              (ie = (ie + Math.imul(ee, nt)) | 0),
              (W = (W + Math.imul(ee, it)) | 0),
              (W = (W + Math.imul(ae, nt)) | 0),
              (le = (le + Math.imul(ae, it)) | 0),
              (ie = (ie + Math.imul(U, st)) | 0),
              (W = (W + Math.imul(U, ot)) | 0),
              (W = (W + Math.imul(X, st)) | 0),
              (le = (le + Math.imul(X, ot)) | 0),
              (ie = (ie + Math.imul($, Ze)) | 0),
              (W = (W + Math.imul($, Ye)) | 0),
              (W = (W + Math.imul(g, Ze)) | 0),
              (le = (le + Math.imul(g, Ye)) | 0)
            var qt = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (qt >>> 26)) | 0),
              (qt &= 67108863),
              (ie = Math.imul(me, tt)),
              (W = Math.imul(me, Xe)),
              (W = (W + Math.imul(we, tt)) | 0),
              (le = Math.imul(we, Xe)),
              (ie = (ie + Math.imul(z, nt)) | 0),
              (W = (W + Math.imul(z, it)) | 0),
              (W = (W + Math.imul(H, nt)) | 0),
              (le = (le + Math.imul(H, it)) | 0),
              (ie = (ie + Math.imul(ee, st)) | 0),
              (W = (W + Math.imul(ee, ot)) | 0),
              (W = (W + Math.imul(ae, st)) | 0),
              (le = (le + Math.imul(ae, ot)) | 0),
              (ie = (ie + Math.imul(U, Ze)) | 0),
              (W = (W + Math.imul(U, Ye)) | 0),
              (W = (W + Math.imul(X, Ze)) | 0),
              (le = (le + Math.imul(X, Ye)) | 0)
            var dt = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (dt >>> 26)) | 0),
              (dt &= 67108863),
              (ie = Math.imul(me, nt)),
              (W = Math.imul(me, it)),
              (W = (W + Math.imul(we, nt)) | 0),
              (le = Math.imul(we, it)),
              (ie = (ie + Math.imul(z, st)) | 0),
              (W = (W + Math.imul(z, ot)) | 0),
              (W = (W + Math.imul(H, st)) | 0),
              (le = (le + Math.imul(H, ot)) | 0),
              (ie = (ie + Math.imul(ee, Ze)) | 0),
              (W = (W + Math.imul(ee, Ye)) | 0),
              (W = (W + Math.imul(ae, Ze)) | 0),
              (le = (le + Math.imul(ae, Ye)) | 0)
            var Se = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (Se >>> 26)) | 0),
              (Se &= 67108863),
              (ie = Math.imul(me, st)),
              (W = Math.imul(me, ot)),
              (W = (W + Math.imul(we, st)) | 0),
              (le = Math.imul(we, ot)),
              (ie = (ie + Math.imul(z, Ze)) | 0),
              (W = (W + Math.imul(z, Ye)) | 0),
              (W = (W + Math.imul(H, Ze)) | 0),
              (le = (le + Math.imul(H, Ye)) | 0)
            var ue = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            ;(fe = (((le + (W >>> 13)) | 0) + (ue >>> 26)) | 0),
              (ue &= 67108863),
              (ie = Math.imul(me, Ze)),
              (W = Math.imul(me, Ye)),
              (W = (W + Math.imul(we, Ze)) | 0),
              (le = Math.imul(we, Ye))
            var Ae = (((fe + ie) | 0) + ((W & 8191) << 13)) | 0
            return (
              (fe = (((le + (W >>> 13)) | 0) + (Ae >>> 26)) | 0),
              (Ae &= 67108863),
              (Q[0] = Er),
              (Q[1] = Et),
              (Q[2] = St),
              (Q[3] = Dr),
              (Q[4] = At),
              (Q[5] = vt),
              (Q[6] = Yt),
              (Q[7] = It),
              (Q[8] = Ot),
              (Q[9] = En),
              (Q[10] = Dt),
              (Q[11] = Lt),
              (Q[12] = Sn),
              (Q[13] = Ut),
              (Q[14] = qt),
              (Q[15] = dt),
              (Q[16] = Se),
              (Q[17] = ue),
              (Q[18] = Ae),
              fe !== 0 && ((Q[19] = fe), K.length++),
              K
            )
          }
          Math.imul || (m = h)
          function _(O, x, L) {
            ;(L.negative = x.negative ^ O.negative), (L.length = O.length + x.length)
            for (var K = 0, J = 0, Z = 0; Z < L.length - 1; Z++) {
              var Q = J
              J = 0
              for (
                var fe = K & 67108863, ie = Math.min(Z, x.length - 1), W = Math.max(0, Z - O.length + 1);
                W <= ie;
                W++
              ) {
                var le = Z - W,
                  xe = O.words[le] | 0,
                  _e = x.words[W] | 0,
                  Ne = xe * _e,
                  ke = Ne & 67108863
                ;(Q = (Q + ((Ne / 67108864) | 0)) | 0),
                  (ke = (ke + fe) | 0),
                  (fe = ke & 67108863),
                  (Q = (Q + (ke >>> 26)) | 0),
                  (J += Q >>> 26),
                  (Q &= 67108863)
              }
              ;(L.words[Z] = fe), (K = Q), (Q = J)
            }
            return K !== 0 ? (L.words[Z] = K) : L.length--, L.strip()
          }
          function A(O, x, L) {
            var K = new T()
            return K.mulp(O, x, L)
          }
          u.prototype.mulTo = function (x, L) {
            var K,
              J = this.length + x.length
            return (
              this.length === 10 && x.length === 10
                ? (K = m(this, x, L))
                : J < 63
                ? (K = h(this, x, L))
                : J < 1024
                ? (K = _(this, x, L))
                : (K = A(this, x, L)),
              K
            )
          }
          function T(O, x) {
            ;(this.x = O), (this.y = x)
          }
          ;(T.prototype.makeRBT = function (x) {
            for (var L = new Array(x), K = u.prototype._countBits(x) - 1, J = 0; J < x; J++) L[J] = this.revBin(J, K, x)
            return L
          }),
            (T.prototype.revBin = function (x, L, K) {
              if (x === 0 || x === K - 1) return x
              for (var J = 0, Z = 0; Z < L; Z++) (J |= (x & 1) << (L - Z - 1)), (x >>= 1)
              return J
            }),
            (T.prototype.permute = function (x, L, K, J, Z, Q) {
              for (var fe = 0; fe < Q; fe++) (J[fe] = L[x[fe]]), (Z[fe] = K[x[fe]])
            }),
            (T.prototype.transform = function (x, L, K, J, Z, Q) {
              this.permute(Q, x, L, K, J, Z)
              for (var fe = 1; fe < Z; fe <<= 1)
                for (
                  var ie = fe << 1, W = Math.cos((2 * Math.PI) / ie), le = Math.sin((2 * Math.PI) / ie), xe = 0;
                  xe < Z;
                  xe += ie
                )
                  for (var _e = W, Ne = le, ke = 0; ke < fe; ke++) {
                    var oe = K[xe + ke],
                      be = J[xe + ke],
                      ge = K[xe + ke + fe],
                      re = J[xe + ke + fe],
                      j = _e * ge - Ne * re
                    ;(re = _e * re + Ne * ge),
                      (ge = j),
                      (K[xe + ke] = oe + ge),
                      (J[xe + ke] = be + re),
                      (K[xe + ke + fe] = oe - ge),
                      (J[xe + ke + fe] = be - re),
                      ke !== ie && ((j = W * _e - le * Ne), (Ne = W * Ne + le * _e), (_e = j))
                  }
            }),
            (T.prototype.guessLen13b = function (x, L) {
              var K = Math.max(L, x) | 1,
                J = K & 1,
                Z = 0
              for (K = (K / 2) | 0; K; K = K >>> 1) Z++
              return 1 << (Z + 1 + J)
            }),
            (T.prototype.conjugate = function (x, L, K) {
              if (!(K <= 1))
                for (var J = 0; J < K / 2; J++) {
                  var Z = x[J]
                  ;(x[J] = x[K - J - 1]), (x[K - J - 1] = Z), (Z = L[J]), (L[J] = -L[K - J - 1]), (L[K - J - 1] = -Z)
                }
            }),
            (T.prototype.normalize13b = function (x, L) {
              for (var K = 0, J = 0; J < L / 2; J++) {
                var Z = Math.round(x[2 * J + 1] / L) * 8192 + Math.round(x[2 * J] / L) + K
                ;(x[J] = Z & 67108863), Z < 67108864 ? (K = 0) : (K = (Z / 67108864) | 0)
              }
              return x
            }),
            (T.prototype.convert13b = function (x, L, K, J) {
              for (var Z = 0, Q = 0; Q < L; Q++)
                (Z = Z + (x[Q] | 0)), (K[2 * Q] = Z & 8191), (Z = Z >>> 13), (K[2 * Q + 1] = Z & 8191), (Z = Z >>> 13)
              for (Q = 2 * L; Q < J; ++Q) K[Q] = 0
              i(Z === 0), i((Z & ~8191) == 0)
            }),
            (T.prototype.stub = function (x) {
              for (var L = new Array(x), K = 0; K < x; K++) L[K] = 0
              return L
            }),
            (T.prototype.mulp = function (x, L, K) {
              var J = 2 * this.guessLen13b(x.length, L.length),
                Z = this.makeRBT(J),
                Q = this.stub(J),
                fe = new Array(J),
                ie = new Array(J),
                W = new Array(J),
                le = new Array(J),
                xe = new Array(J),
                _e = new Array(J),
                Ne = K.words
              ;(Ne.length = J),
                this.convert13b(x.words, x.length, fe, J),
                this.convert13b(L.words, L.length, le, J),
                this.transform(fe, Q, ie, W, J, Z),
                this.transform(le, Q, xe, _e, J, Z)
              for (var ke = 0; ke < J; ke++) {
                var oe = ie[ke] * xe[ke] - W[ke] * _e[ke]
                ;(W[ke] = ie[ke] * _e[ke] + W[ke] * xe[ke]), (ie[ke] = oe)
              }
              return (
                this.conjugate(ie, W, J),
                this.transform(ie, W, Ne, Q, J, Z),
                this.conjugate(Ne, Q, J),
                this.normalize13b(Ne, J),
                (K.negative = x.negative ^ L.negative),
                (K.length = x.length + L.length),
                K.strip()
              )
            }),
            (u.prototype.mul = function (x) {
              var L = new u(null)
              return (L.words = new Array(this.length + x.length)), this.mulTo(x, L)
            }),
            (u.prototype.mulf = function (x) {
              var L = new u(null)
              return (L.words = new Array(this.length + x.length)), A(this, x, L)
            }),
            (u.prototype.imul = function (x) {
              return this.clone().mulTo(x, this)
            }),
            (u.prototype.imuln = function (x) {
              i(typeof x == 'number'), i(x < 67108864)
              for (var L = 0, K = 0; K < this.length; K++) {
                var J = (this.words[K] | 0) * x,
                  Z = (J & 67108863) + (L & 67108863)
                ;(L >>= 26), (L += (J / 67108864) | 0), (L += Z >>> 26), (this.words[K] = Z & 67108863)
              }
              return L !== 0 && ((this.words[K] = L), this.length++), this
            }),
            (u.prototype.muln = function (x) {
              return this.clone().imuln(x)
            }),
            (u.prototype.sqr = function () {
              return this.mul(this)
            }),
            (u.prototype.isqr = function () {
              return this.imul(this.clone())
            }),
            (u.prototype.pow = function (x) {
              var L = d(x)
              if (L.length === 0) return new u(1)
              for (var K = this, J = 0; J < L.length && L[J] === 0; J++, K = K.sqr());
              if (++J < L.length) for (var Z = K.sqr(); J < L.length; J++, Z = Z.sqr()) L[J] !== 0 && (K = K.mul(Z))
              return K
            }),
            (u.prototype.iushln = function (x) {
              i(typeof x == 'number' && x >= 0)
              var L = x % 26,
                K = (x - L) / 26,
                J = (67108863 >>> (26 - L)) << (26 - L),
                Z
              if (L !== 0) {
                var Q = 0
                for (Z = 0; Z < this.length; Z++) {
                  var fe = this.words[Z] & J,
                    ie = ((this.words[Z] | 0) - fe) << L
                  ;(this.words[Z] = ie | Q), (Q = fe >>> (26 - L))
                }
                Q && ((this.words[Z] = Q), this.length++)
              }
              if (K !== 0) {
                for (Z = this.length - 1; Z >= 0; Z--) this.words[Z + K] = this.words[Z]
                for (Z = 0; Z < K; Z++) this.words[Z] = 0
                this.length += K
              }
              return this.strip()
            }),
            (u.prototype.ishln = function (x) {
              return i(this.negative === 0), this.iushln(x)
            }),
            (u.prototype.iushrn = function (x, L, K) {
              i(typeof x == 'number' && x >= 0)
              var J
              L ? (J = (L - (L % 26)) / 26) : (J = 0)
              var Z = x % 26,
                Q = Math.min((x - Z) / 26, this.length),
                fe = 67108863 ^ ((67108863 >>> Z) << Z),
                ie = K
              if (((J -= Q), (J = Math.max(0, J)), ie)) {
                for (var W = 0; W < Q; W++) ie.words[W] = this.words[W]
                ie.length = Q
              }
              if (Q !== 0)
                if (this.length > Q)
                  for (this.length -= Q, W = 0; W < this.length; W++) this.words[W] = this.words[W + Q]
                else (this.words[0] = 0), (this.length = 1)
              var le = 0
              for (W = this.length - 1; W >= 0 && (le !== 0 || W >= J); W--) {
                var xe = this.words[W] | 0
                ;(this.words[W] = (le << (26 - Z)) | (xe >>> Z)), (le = xe & fe)
              }
              return (
                ie && le !== 0 && (ie.words[ie.length++] = le),
                this.length === 0 && ((this.words[0] = 0), (this.length = 1)),
                this.strip()
              )
            }),
            (u.prototype.ishrn = function (x, L, K) {
              return i(this.negative === 0), this.iushrn(x, L, K)
            }),
            (u.prototype.shln = function (x) {
              return this.clone().ishln(x)
            }),
            (u.prototype.ushln = function (x) {
              return this.clone().iushln(x)
            }),
            (u.prototype.shrn = function (x) {
              return this.clone().ishrn(x)
            }),
            (u.prototype.ushrn = function (x) {
              return this.clone().iushrn(x)
            }),
            (u.prototype.testn = function (x) {
              i(typeof x == 'number' && x >= 0)
              var L = x % 26,
                K = (x - L) / 26,
                J = 1 << L
              if (this.length <= K) return !1
              var Z = this.words[K]
              return !!(Z & J)
            }),
            (u.prototype.imaskn = function (x) {
              i(typeof x == 'number' && x >= 0)
              var L = x % 26,
                K = (x - L) / 26
              if ((i(this.negative === 0, 'imaskn works only with positive numbers'), this.length <= K)) return this
              if ((L !== 0 && K++, (this.length = Math.min(K, this.length)), L !== 0)) {
                var J = 67108863 ^ ((67108863 >>> L) << L)
                this.words[this.length - 1] &= J
              }
              return this.strip()
            }),
            (u.prototype.maskn = function (x) {
              return this.clone().imaskn(x)
            }),
            (u.prototype.iaddn = function (x) {
              return (
                i(typeof x == 'number'),
                i(x < 67108864),
                x < 0
                  ? this.isubn(-x)
                  : this.negative !== 0
                  ? this.length === 1 && (this.words[0] | 0) < x
                    ? ((this.words[0] = x - (this.words[0] | 0)), (this.negative = 0), this)
                    : ((this.negative = 0), this.isubn(x), (this.negative = 1), this)
                  : this._iaddn(x)
              )
            }),
            (u.prototype._iaddn = function (x) {
              this.words[0] += x
              for (var L = 0; L < this.length && this.words[L] >= 67108864; L++)
                (this.words[L] -= 67108864), L === this.length - 1 ? (this.words[L + 1] = 1) : this.words[L + 1]++
              return (this.length = Math.max(this.length, L + 1)), this
            }),
            (u.prototype.isubn = function (x) {
              if ((i(typeof x == 'number'), i(x < 67108864), x < 0)) return this.iaddn(-x)
              if (this.negative !== 0) return (this.negative = 0), this.iaddn(x), (this.negative = 1), this
              if (((this.words[0] -= x), this.length === 1 && this.words[0] < 0))
                (this.words[0] = -this.words[0]), (this.negative = 1)
              else
                for (var L = 0; L < this.length && this.words[L] < 0; L++)
                  (this.words[L] += 67108864), (this.words[L + 1] -= 1)
              return this.strip()
            }),
            (u.prototype.addn = function (x) {
              return this.clone().iaddn(x)
            }),
            (u.prototype.subn = function (x) {
              return this.clone().isubn(x)
            }),
            (u.prototype.iabs = function () {
              return (this.negative = 0), this
            }),
            (u.prototype.abs = function () {
              return this.clone().iabs()
            }),
            (u.prototype._ishlnsubmul = function (x, L, K) {
              var J = x.length + K,
                Z
              this._expand(J)
              var Q,
                fe = 0
              for (Z = 0; Z < x.length; Z++) {
                Q = (this.words[Z + K] | 0) + fe
                var ie = (x.words[Z] | 0) * L
                ;(Q -= ie & 67108863), (fe = (Q >> 26) - ((ie / 67108864) | 0)), (this.words[Z + K] = Q & 67108863)
              }
              for (; Z < this.length - K; Z++)
                (Q = (this.words[Z + K] | 0) + fe), (fe = Q >> 26), (this.words[Z + K] = Q & 67108863)
              if (fe === 0) return this.strip()
              for (i(fe === -1), fe = 0, Z = 0; Z < this.length; Z++)
                (Q = -(this.words[Z] | 0) + fe), (fe = Q >> 26), (this.words[Z] = Q & 67108863)
              return (this.negative = 1), this.strip()
            }),
            (u.prototype._wordDiv = function (x, L) {
              var K = this.length - x.length,
                J = this.clone(),
                Z = x,
                Q = Z.words[Z.length - 1] | 0,
                fe = this._countBits(Q)
              ;(K = 26 - fe), K !== 0 && ((Z = Z.ushln(K)), J.iushln(K), (Q = Z.words[Z.length - 1] | 0))
              var ie = J.length - Z.length,
                W
              if (L !== 'mod') {
                ;(W = new u(null)), (W.length = ie + 1), (W.words = new Array(W.length))
                for (var le = 0; le < W.length; le++) W.words[le] = 0
              }
              var xe = J.clone()._ishlnsubmul(Z, 1, ie)
              xe.negative === 0 && ((J = xe), W && (W.words[ie] = 1))
              for (var _e = ie - 1; _e >= 0; _e--) {
                var Ne = (J.words[Z.length + _e] | 0) * 67108864 + (J.words[Z.length + _e - 1] | 0)
                for (Ne = Math.min((Ne / Q) | 0, 67108863), J._ishlnsubmul(Z, Ne, _e); J.negative !== 0; )
                  Ne--, (J.negative = 0), J._ishlnsubmul(Z, 1, _e), J.isZero() || (J.negative ^= 1)
                W && (W.words[_e] = Ne)
              }
              return W && W.strip(), J.strip(), L !== 'div' && K !== 0 && J.iushrn(K), { div: W || null, mod: J }
            }),
            (u.prototype.divmod = function (x, L, K) {
              if ((i(!x.isZero()), this.isZero())) return { div: new u(0), mod: new u(0) }
              var J, Z, Q
              return this.negative !== 0 && x.negative === 0
                ? ((Q = this.neg().divmod(x, L)),
                  L !== 'mod' && (J = Q.div.neg()),
                  L !== 'div' && ((Z = Q.mod.neg()), K && Z.negative !== 0 && Z.iadd(x)),
                  { div: J, mod: Z })
                : this.negative === 0 && x.negative !== 0
                ? ((Q = this.divmod(x.neg(), L)), L !== 'mod' && (J = Q.div.neg()), { div: J, mod: Q.mod })
                : (this.negative & x.negative) != 0
                ? ((Q = this.neg().divmod(x.neg(), L)),
                  L !== 'div' && ((Z = Q.mod.neg()), K && Z.negative !== 0 && Z.isub(x)),
                  { div: Q.div, mod: Z })
                : x.length > this.length || this.cmp(x) < 0
                ? { div: new u(0), mod: this }
                : x.length === 1
                ? L === 'div'
                  ? { div: this.divn(x.words[0]), mod: null }
                  : L === 'mod'
                  ? { div: null, mod: new u(this.modn(x.words[0])) }
                  : { div: this.divn(x.words[0]), mod: new u(this.modn(x.words[0])) }
                : this._wordDiv(x, L)
            }),
            (u.prototype.div = function (x) {
              return this.divmod(x, 'div', !1).div
            }),
            (u.prototype.mod = function (x) {
              return this.divmod(x, 'mod', !1).mod
            }),
            (u.prototype.umod = function (x) {
              return this.divmod(x, 'mod', !0).mod
            }),
            (u.prototype.divRound = function (x) {
              var L = this.divmod(x)
              if (L.mod.isZero()) return L.div
              var K = L.div.negative !== 0 ? L.mod.isub(x) : L.mod,
                J = x.ushrn(1),
                Z = x.andln(1),
                Q = K.cmp(J)
              return Q < 0 || (Z === 1 && Q === 0) ? L.div : L.div.negative !== 0 ? L.div.isubn(1) : L.div.iaddn(1)
            }),
            (u.prototype.modn = function (x) {
              i(x <= 67108863)
              for (var L = (1 << 26) % x, K = 0, J = this.length - 1; J >= 0; J--) K = (L * K + (this.words[J] | 0)) % x
              return K
            }),
            (u.prototype.idivn = function (x) {
              i(x <= 67108863)
              for (var L = 0, K = this.length - 1; K >= 0; K--) {
                var J = (this.words[K] | 0) + L * 67108864
                ;(this.words[K] = (J / x) | 0), (L = J % x)
              }
              return this.strip()
            }),
            (u.prototype.divn = function (x) {
              return this.clone().idivn(x)
            }),
            (u.prototype.egcd = function (x) {
              i(x.negative === 0), i(!x.isZero())
              var L = this,
                K = x.clone()
              L.negative !== 0 ? (L = L.umod(x)) : (L = L.clone())
              for (var J = new u(1), Z = new u(0), Q = new u(0), fe = new u(1), ie = 0; L.isEven() && K.isEven(); )
                L.iushrn(1), K.iushrn(1), ++ie
              for (var W = K.clone(), le = L.clone(); !L.isZero(); ) {
                for (var xe = 0, _e = 1; (L.words[0] & _e) == 0 && xe < 26; ++xe, _e <<= 1);
                if (xe > 0)
                  for (L.iushrn(xe); xe-- > 0; )
                    (J.isOdd() || Z.isOdd()) && (J.iadd(W), Z.isub(le)), J.iushrn(1), Z.iushrn(1)
                for (var Ne = 0, ke = 1; (K.words[0] & ke) == 0 && Ne < 26; ++Ne, ke <<= 1);
                if (Ne > 0)
                  for (K.iushrn(Ne); Ne-- > 0; )
                    (Q.isOdd() || fe.isOdd()) && (Q.iadd(W), fe.isub(le)), Q.iushrn(1), fe.iushrn(1)
                L.cmp(K) >= 0 ? (L.isub(K), J.isub(Q), Z.isub(fe)) : (K.isub(L), Q.isub(J), fe.isub(Z))
              }
              return { a: Q, b: fe, gcd: K.iushln(ie) }
            }),
            (u.prototype._invmp = function (x) {
              i(x.negative === 0), i(!x.isZero())
              var L = this,
                K = x.clone()
              L.negative !== 0 ? (L = L.umod(x)) : (L = L.clone())
              for (var J = new u(1), Z = new u(0), Q = K.clone(); L.cmpn(1) > 0 && K.cmpn(1) > 0; ) {
                for (var fe = 0, ie = 1; (L.words[0] & ie) == 0 && fe < 26; ++fe, ie <<= 1);
                if (fe > 0) for (L.iushrn(fe); fe-- > 0; ) J.isOdd() && J.iadd(Q), J.iushrn(1)
                for (var W = 0, le = 1; (K.words[0] & le) == 0 && W < 26; ++W, le <<= 1);
                if (W > 0) for (K.iushrn(W); W-- > 0; ) Z.isOdd() && Z.iadd(Q), Z.iushrn(1)
                L.cmp(K) >= 0 ? (L.isub(K), J.isub(Z)) : (K.isub(L), Z.isub(J))
              }
              var xe
              return L.cmpn(1) === 0 ? (xe = J) : (xe = Z), xe.cmpn(0) < 0 && xe.iadd(x), xe
            }),
            (u.prototype.gcd = function (x) {
              if (this.isZero()) return x.abs()
              if (x.isZero()) return this.abs()
              var L = this.clone(),
                K = x.clone()
              ;(L.negative = 0), (K.negative = 0)
              for (var J = 0; L.isEven() && K.isEven(); J++) L.iushrn(1), K.iushrn(1)
              do {
                for (; L.isEven(); ) L.iushrn(1)
                for (; K.isEven(); ) K.iushrn(1)
                var Z = L.cmp(K)
                if (Z < 0) {
                  var Q = L
                  ;(L = K), (K = Q)
                } else if (Z === 0 || K.cmpn(1) === 0) break
                L.isub(K)
              } while (!0)
              return K.iushln(J)
            }),
            (u.prototype.invm = function (x) {
              return this.egcd(x).a.umod(x)
            }),
            (u.prototype.isEven = function () {
              return (this.words[0] & 1) == 0
            }),
            (u.prototype.isOdd = function () {
              return (this.words[0] & 1) == 1
            }),
            (u.prototype.andln = function (x) {
              return this.words[0] & x
            }),
            (u.prototype.bincn = function (x) {
              i(typeof x == 'number')
              var L = x % 26,
                K = (x - L) / 26,
                J = 1 << L
              if (this.length <= K) return this._expand(K + 1), (this.words[K] |= J), this
              for (var Z = J, Q = K; Z !== 0 && Q < this.length; Q++) {
                var fe = this.words[Q] | 0
                ;(fe += Z), (Z = fe >>> 26), (fe &= 67108863), (this.words[Q] = fe)
              }
              return Z !== 0 && ((this.words[Q] = Z), this.length++), this
            }),
            (u.prototype.isZero = function () {
              return this.length === 1 && this.words[0] === 0
            }),
            (u.prototype.cmpn = function (x) {
              var L = x < 0
              if (this.negative !== 0 && !L) return -1
              if (this.negative === 0 && L) return 1
              this.strip()
              var K
              if (this.length > 1) K = 1
              else {
                L && (x = -x), i(x <= 67108863, 'Number is too big')
                var J = this.words[0] | 0
                K = J === x ? 0 : J < x ? -1 : 1
              }
              return this.negative !== 0 ? -K | 0 : K
            }),
            (u.prototype.cmp = function (x) {
              if (this.negative !== 0 && x.negative === 0) return -1
              if (this.negative === 0 && x.negative !== 0) return 1
              var L = this.ucmp(x)
              return this.negative !== 0 ? -L | 0 : L
            }),
            (u.prototype.ucmp = function (x) {
              if (this.length > x.length) return 1
              if (this.length < x.length) return -1
              for (var L = 0, K = this.length - 1; K >= 0; K--) {
                var J = this.words[K] | 0,
                  Z = x.words[K] | 0
                if (J !== Z) {
                  J < Z ? (L = -1) : J > Z && (L = 1)
                  break
                }
              }
              return L
            }),
            (u.prototype.gtn = function (x) {
              return this.cmpn(x) === 1
            }),
            (u.prototype.gt = function (x) {
              return this.cmp(x) === 1
            }),
            (u.prototype.gten = function (x) {
              return this.cmpn(x) >= 0
            }),
            (u.prototype.gte = function (x) {
              return this.cmp(x) >= 0
            }),
            (u.prototype.ltn = function (x) {
              return this.cmpn(x) === -1
            }),
            (u.prototype.lt = function (x) {
              return this.cmp(x) === -1
            }),
            (u.prototype.lten = function (x) {
              return this.cmpn(x) <= 0
            }),
            (u.prototype.lte = function (x) {
              return this.cmp(x) <= 0
            }),
            (u.prototype.eqn = function (x) {
              return this.cmpn(x) === 0
            }),
            (u.prototype.eq = function (x) {
              return this.cmp(x) === 0
            }),
            (u.red = function (x) {
              return new q(x)
            }),
            (u.prototype.toRed = function (x) {
              return (
                i(!this.red, 'Already a number in reduction context'),
                i(this.negative === 0, 'red works only with positives'),
                x.convertTo(this)._forceRed(x)
              )
            }),
            (u.prototype.fromRed = function () {
              return i(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this)
            }),
            (u.prototype._forceRed = function (x) {
              return (this.red = x), this
            }),
            (u.prototype.forceRed = function (x) {
              return i(!this.red, 'Already a number in reduction context'), this._forceRed(x)
            }),
            (u.prototype.redAdd = function (x) {
              return i(this.red, 'redAdd works only with red numbers'), this.red.add(this, x)
            }),
            (u.prototype.redIAdd = function (x) {
              return i(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, x)
            }),
            (u.prototype.redSub = function (x) {
              return i(this.red, 'redSub works only with red numbers'), this.red.sub(this, x)
            }),
            (u.prototype.redISub = function (x) {
              return i(this.red, 'redISub works only with red numbers'), this.red.isub(this, x)
            }),
            (u.prototype.redShl = function (x) {
              return i(this.red, 'redShl works only with red numbers'), this.red.shl(this, x)
            }),
            (u.prototype.redMul = function (x) {
              return (
                i(this.red, 'redMul works only with red numbers'), this.red._verify2(this, x), this.red.mul(this, x)
              )
            }),
            (u.prototype.redIMul = function (x) {
              return (
                i(this.red, 'redMul works only with red numbers'), this.red._verify2(this, x), this.red.imul(this, x)
              )
            }),
            (u.prototype.redSqr = function () {
              return i(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this)
            }),
            (u.prototype.redISqr = function () {
              return i(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this)
            }),
            (u.prototype.redSqrt = function () {
              return i(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this)
            }),
            (u.prototype.redInvm = function () {
              return i(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this)
            }),
            (u.prototype.redNeg = function () {
              return i(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this)
            }),
            (u.prototype.redPow = function (x) {
              return i(this.red && !x.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, x)
            })
          var E = { k256: null, p224: null, p192: null, p25519: null }
          function k(O, x) {
            ;(this.name = O),
              (this.p = new u(x, 16)),
              (this.n = this.p.bitLength()),
              (this.k = new u(1).iushln(this.n).isub(this.p)),
              (this.tmp = this._tmp())
          }
          ;(k.prototype._tmp = function () {
            var x = new u(null)
            return (x.words = new Array(Math.ceil(this.n / 13))), x
          }),
            (k.prototype.ireduce = function (x) {
              var L = x,
                K
              do this.split(L, this.tmp), (L = this.imulK(L)), (L = L.iadd(this.tmp)), (K = L.bitLength())
              while (K > this.n)
              var J = K < this.n ? -1 : L.ucmp(this.p)
              return (
                J === 0
                  ? ((L.words[0] = 0), (L.length = 1))
                  : J > 0
                  ? L.isub(this.p)
                  : L.strip !== void 0
                  ? L.strip()
                  : L._strip(),
                L
              )
            }),
            (k.prototype.split = function (x, L) {
              x.iushrn(this.n, 0, L)
            }),
            (k.prototype.imulK = function (x) {
              return x.imul(this.k)
            })
          function w() {
            k.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f')
          }
          s(w, k),
            (w.prototype.split = function (x, L) {
              for (var K = 4194303, J = Math.min(x.length, 9), Z = 0; Z < J; Z++) L.words[Z] = x.words[Z]
              if (((L.length = J), x.length <= 9)) {
                ;(x.words[0] = 0), (x.length = 1)
                return
              }
              var Q = x.words[9]
              for (L.words[L.length++] = Q & K, Z = 10; Z < x.length; Z++) {
                var fe = x.words[Z] | 0
                ;(x.words[Z - 10] = ((fe & K) << 4) | (Q >>> 22)), (Q = fe)
              }
              ;(Q >>>= 22), (x.words[Z - 10] = Q), Q === 0 && x.length > 10 ? (x.length -= 10) : (x.length -= 9)
            }),
            (w.prototype.imulK = function (x) {
              ;(x.words[x.length] = 0), (x.words[x.length + 1] = 0), (x.length += 2)
              for (var L = 0, K = 0; K < x.length; K++) {
                var J = x.words[K] | 0
                ;(L += J * 977), (x.words[K] = L & 67108863), (L = J * 64 + ((L / 67108864) | 0))
              }
              return x.words[x.length - 1] === 0 && (x.length--, x.words[x.length - 1] === 0 && x.length--), x
            })
          function v() {
            k.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001')
          }
          s(v, k)
          function I() {
            k.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff')
          }
          s(I, k)
          function M() {
            k.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed')
          }
          s(M, k),
            (M.prototype.imulK = function (x) {
              for (var L = 0, K = 0; K < x.length; K++) {
                var J = (x.words[K] | 0) * 19 + L,
                  Z = J & 67108863
                ;(J >>>= 26), (x.words[K] = Z), (L = J)
              }
              return L !== 0 && (x.words[x.length++] = L), x
            }),
            (u._prime = function (x) {
              if (E[x]) return E[x]
              var L
              if (x === 'k256') L = new w()
              else if (x === 'p224') L = new v()
              else if (x === 'p192') L = new I()
              else if (x === 'p25519') L = new M()
              else throw new Error('Unknown prime ' + x)
              return (E[x] = L), L
            })
          function q(O) {
            if (typeof O == 'string') {
              var x = u._prime(O)
              ;(this.m = x.p), (this.prime = x)
            } else i(O.gtn(1), 'modulus must be greater than 1'), (this.m = O), (this.prime = null)
          }
          ;(q.prototype._verify1 = function (x) {
            i(x.negative === 0, 'red works only with positives'), i(x.red, 'red works only with red numbers')
          }),
            (q.prototype._verify2 = function (x, L) {
              i((x.negative | L.negative) == 0, 'red works only with positives'),
                i(x.red && x.red === L.red, 'red works only with red numbers')
            }),
            (q.prototype.imod = function (x) {
              return this.prime ? this.prime.ireduce(x)._forceRed(this) : x.umod(this.m)._forceRed(this)
            }),
            (q.prototype.neg = function (x) {
              return x.isZero() ? x.clone() : this.m.sub(x)._forceRed(this)
            }),
            (q.prototype.add = function (x, L) {
              this._verify2(x, L)
              var K = x.add(L)
              return K.cmp(this.m) >= 0 && K.isub(this.m), K._forceRed(this)
            }),
            (q.prototype.iadd = function (x, L) {
              this._verify2(x, L)
              var K = x.iadd(L)
              return K.cmp(this.m) >= 0 && K.isub(this.m), K
            }),
            (q.prototype.sub = function (x, L) {
              this._verify2(x, L)
              var K = x.sub(L)
              return K.cmpn(0) < 0 && K.iadd(this.m), K._forceRed(this)
            }),
            (q.prototype.isub = function (x, L) {
              this._verify2(x, L)
              var K = x.isub(L)
              return K.cmpn(0) < 0 && K.iadd(this.m), K
            }),
            (q.prototype.shl = function (x, L) {
              return this._verify1(x), this.imod(x.ushln(L))
            }),
            (q.prototype.imul = function (x, L) {
              return this._verify2(x, L), this.imod(x.imul(L))
            }),
            (q.prototype.mul = function (x, L) {
              return this._verify2(x, L), this.imod(x.mul(L))
            }),
            (q.prototype.isqr = function (x) {
              return this.imul(x, x.clone())
            }),
            (q.prototype.sqr = function (x) {
              return this.mul(x, x)
            }),
            (q.prototype.sqrt = function (x) {
              if (x.isZero()) return x.clone()
              var L = this.m.andln(3)
              if ((i(L % 2 == 1), L === 3)) {
                var K = this.m.add(new u(1)).iushrn(2)
                return this.pow(x, K)
              }
              for (var J = this.m.subn(1), Z = 0; !J.isZero() && J.andln(1) === 0; ) Z++, J.iushrn(1)
              i(!J.isZero())
              var Q = new u(1).toRed(this),
                fe = Q.redNeg(),
                ie = this.m.subn(1).iushrn(1),
                W = this.m.bitLength()
              for (W = new u(2 * W * W).toRed(this); this.pow(W, ie).cmp(fe) !== 0; ) W.redIAdd(fe)
              for (
                var le = this.pow(W, J), xe = this.pow(x, J.addn(1).iushrn(1)), _e = this.pow(x, J), Ne = Z;
                _e.cmp(Q) !== 0;

              ) {
                for (var ke = _e, oe = 0; ke.cmp(Q) !== 0; oe++) ke = ke.redSqr()
                i(oe < Ne)
                var be = this.pow(le, new u(1).iushln(Ne - oe - 1))
                ;(xe = xe.redMul(be)), (le = be.redSqr()), (_e = _e.redMul(le)), (Ne = oe)
              }
              return xe
            }),
            (q.prototype.invm = function (x) {
              var L = x._invmp(this.m)
              return L.negative !== 0 ? ((L.negative = 0), this.imod(L).redNeg()) : this.imod(L)
            }),
            (q.prototype.pow = function (x, L) {
              if (L.isZero()) return new u(1).toRed(this)
              if (L.cmpn(1) === 0) return x.clone()
              var K = 4,
                J = new Array(1 << K)
              ;(J[0] = new u(1).toRed(this)), (J[1] = x)
              for (var Z = 2; Z < J.length; Z++) J[Z] = this.mul(J[Z - 1], x)
              var Q = J[0],
                fe = 0,
                ie = 0,
                W = L.bitLength() % 26
              for (W === 0 && (W = 26), Z = L.length - 1; Z >= 0; Z--) {
                for (var le = L.words[Z], xe = W - 1; xe >= 0; xe--) {
                  var _e = (le >> xe) & 1
                  if ((Q !== J[0] && (Q = this.sqr(Q)), _e === 0 && fe === 0)) {
                    ie = 0
                    continue
                  }
                  ;(fe <<= 1),
                    (fe |= _e),
                    ie++,
                    !(ie !== K && (Z !== 0 || xe !== 0)) && ((Q = this.mul(Q, J[fe])), (ie = 0), (fe = 0))
                }
                W = 26
              }
              return Q
            }),
            (q.prototype.convertTo = function (x) {
              var L = x.umod(this.m)
              return L === x ? L.clone() : L
            }),
            (q.prototype.convertFrom = function (x) {
              var L = x.clone()
              return (L.red = null), L
            }),
            (u.mont = function (x) {
              return new G(x)
            })
          function G(O) {
            q.call(this, O),
              (this.shift = this.m.bitLength()),
              this.shift % 26 != 0 && (this.shift += 26 - (this.shift % 26)),
              (this.r = new u(1).iushln(this.shift)),
              (this.r2 = this.imod(this.r.sqr())),
              (this.rinv = this.r._invmp(this.m)),
              (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
              (this.minv = this.minv.umod(this.r)),
              (this.minv = this.r.sub(this.minv))
          }
          s(G, q),
            (G.prototype.convertTo = function (x) {
              return this.imod(x.ushln(this.shift))
            }),
            (G.prototype.convertFrom = function (x) {
              var L = this.imod(x.mul(this.rinv))
              return (L.red = null), L
            }),
            (G.prototype.imul = function (x, L) {
              if (x.isZero() || L.isZero()) return (x.words[0] = 0), (x.length = 1), x
              var K = x.imul(L),
                J = K.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                Z = K.isub(J).iushrn(this.shift),
                Q = Z
              return (
                Z.cmp(this.m) >= 0 ? (Q = Z.isub(this.m)) : Z.cmpn(0) < 0 && (Q = Z.iadd(this.m)), Q._forceRed(this)
              )
            }),
            (G.prototype.mul = function (x, L) {
              if (x.isZero() || L.isZero()) return new u(0)._forceRed(this)
              var K = x.mul(L),
                J = K.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
                Z = K.isub(J).iushrn(this.shift),
                Q = Z
              return (
                Z.cmp(this.m) >= 0 ? (Q = Z.isub(this.m)) : Z.cmpn(0) < 0 && (Q = Z.iadd(this.m)), Q._forceRed(this)
              )
            }),
            (G.prototype.invm = function (x) {
              var L = this.imod(x._invmp(this.m).mul(this.r2))
              return L._forceRed(this)
            })
        })(typeof r == 'undefined' || r, e)
    }
  }),
  As = te({
    'node_modules/minimalistic-assert/index.js'(e, r) {
      V(), F(), (r.exports = t)
      function t(n, i) {
        if (!n) throw new Error(i || 'Assertion failed')
      }
      t.equal = function (i, s, u) {
        if (i != s) throw new Error(u || 'Assertion failed: ' + i + ' != ' + s)
      }
    }
  }),
  W9 = te({
    'node_modules/minimalistic-crypto-utils/lib/utils.js'(e) {
      V(), F()
      var r = e
      function t(s, u) {
        if (Array.isArray(s)) return s.slice()
        if (!s) return []
        var o = []
        if (typeof s != 'string') {
          for (var l = 0; l < s.length; l++) o[l] = s[l] | 0
          return o
        }
        if (u === 'hex') {
          ;(s = s.replace(/[^a-z0-9]+/gi, '')), s.length % 2 != 0 && (s = '0' + s)
          for (var l = 0; l < s.length; l += 2) o.push(parseInt(s[l] + s[l + 1], 16))
        } else
          for (var l = 0; l < s.length; l++) {
            var a = s.charCodeAt(l),
              c = a >> 8,
              f = a & 255
            c ? o.push(c, f) : o.push(f)
          }
        return o
      }
      r.toArray = t
      function n(s) {
        return s.length === 1 ? '0' + s : s
      }
      r.zero2 = n
      function i(s) {
        for (var u = '', o = 0; o < s.length; o++) u += n(s[o].toString(16))
        return u
      }
      ;(r.toHex = i),
        (r.encode = function (u, o) {
          return o === 'hex' ? i(u) : u
        })
    }
  }),
  fn = te({
    'node_modules/elliptic/lib/elliptic/utils.js'(e) {
      V(), F()
      var r = e,
        t = ai(),
        n = As(),
        i = W9()
      ;(r.assert = n), (r.toArray = i.toArray), (r.zero2 = i.zero2), (r.toHex = i.toHex), (r.encode = i.encode)
      function s(c, f, p) {
        var y = new Array(Math.max(c.bitLength(), p) + 1)
        y.fill(0)
        for (var d = 1 << (f + 1), h = c.clone(), m = 0; m < y.length; m++) {
          var _,
            A = h.andln(d - 1)
          h.isOdd() ? (A > (d >> 1) - 1 ? (_ = (d >> 1) - A) : (_ = A), h.isubn(_)) : (_ = 0), (y[m] = _), h.iushrn(1)
        }
        return y
      }
      r.getNAF = s
      function u(c, f) {
        var p = [[], []]
        ;(c = c.clone()), (f = f.clone())
        for (var y = 0, d = 0, h; c.cmpn(-y) > 0 || f.cmpn(-d) > 0; ) {
          var m = (c.andln(3) + y) & 3,
            _ = (f.andln(3) + d) & 3
          m === 3 && (m = -1), _ === 3 && (_ = -1)
          var A
          ;(m & 1) == 0 ? (A = 0) : ((h = (c.andln(7) + y) & 7), (h === 3 || h === 5) && _ === 2 ? (A = -m) : (A = m)),
            p[0].push(A)
          var T
          ;(_ & 1) == 0 ? (T = 0) : ((h = (f.andln(7) + d) & 7), (h === 3 || h === 5) && m === 2 ? (T = -_) : (T = _)),
            p[1].push(T),
            2 * y === A + 1 && (y = 1 - y),
            2 * d === T + 1 && (d = 1 - d),
            c.iushrn(1),
            f.iushrn(1)
        }
        return p
      }
      r.getJSF = u
      function o(c, f, p) {
        var y = '_' + f
        c.prototype[f] = function () {
          return this[y] !== void 0 ? this[y] : (this[y] = p.call(this))
        }
      }
      r.cachedProperty = o
      function l(c) {
        return typeof c == 'string' ? r.toArray(c, 'hex') : c
      }
      r.parseBytes = l
      function a(c) {
        return new t(c, 'hex', 'le')
      }
      r.intFromLE = a
    }
  }),
  J9 = te({
    'node_modules/brorand/index.js'(e, r) {
      V(), F()
      var t
      r.exports = function (u) {
        return t || (t = new n(null)), t.generate(u)
      }
      function n(s) {
        this.rand = s
      }
      if (
        ((r.exports.Rand = n),
        (n.prototype.generate = function (u) {
          return this._rand(u)
        }),
        (n.prototype._rand = function (u) {
          if (this.rand.getBytes) return this.rand.getBytes(u)
          for (var o = new Uint8Array(u), l = 0; l < o.length; l++) o[l] = this.rand.getByte()
          return o
        }),
        typeof self == 'object')
      )
        self.crypto && self.crypto.getRandomValues
          ? (n.prototype._rand = function (u) {
              var o = new Uint8Array(u)
              return self.crypto.getRandomValues(o), o
            })
          : self.msCrypto && self.msCrypto.getRandomValues
          ? (n.prototype._rand = function (u) {
              var o = new Uint8Array(u)
              return self.msCrypto.getRandomValues(o), o
            })
          : typeof window == 'object' &&
            (n.prototype._rand = function () {
              throw new Error('Not implemented yet')
            })
      else
        try {
          if (((i = tf()), typeof i.randomBytes != 'function')) throw new Error('Not supported')
          n.prototype._rand = function (u) {
            return i.randomBytes(u)
          }
        } catch (s) {}
      var i
    }
  }),
  cf = te({
    'node_modules/elliptic/lib/elliptic/curve/base.js'(e, r) {
      V(), F()
      var t = ai(),
        n = fn(),
        i = n.getNAF,
        s = n.getJSF,
        u = n.assert
      function o(a, c) {
        ;(this.type = a),
          (this.p = new t(c.p, 16)),
          (this.red = c.prime ? t.red(c.prime) : t.mont(this.p)),
          (this.zero = new t(0).toRed(this.red)),
          (this.one = new t(1).toRed(this.red)),
          (this.two = new t(2).toRed(this.red)),
          (this.n = c.n && new t(c.n, 16)),
          (this.g = c.g && this.pointFromJSON(c.g, c.gRed)),
          (this._wnafT1 = new Array(4)),
          (this._wnafT2 = new Array(4)),
          (this._wnafT3 = new Array(4)),
          (this._wnafT4 = new Array(4)),
          (this._bitLength = this.n ? this.n.bitLength() : 0)
        var f = this.n && this.p.div(this.n)
        !f || f.cmpn(100) > 0 ? (this.redN = null) : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)))
      }
      ;(r.exports = o),
        (o.prototype.point = function () {
          throw new Error('Not implemented')
        }),
        (o.prototype.validate = function () {
          throw new Error('Not implemented')
        }),
        (o.prototype._fixedNafMul = function (c, f) {
          u(c.precomputed)
          var p = c._getDoubles(),
            y = i(f, 1, this._bitLength),
            d = (1 << (p.step + 1)) - (p.step % 2 == 0 ? 2 : 1)
          d /= 3
          var h = [],
            m,
            _
          for (m = 0; m < y.length; m += p.step) {
            _ = 0
            for (var A = m + p.step - 1; A >= m; A--) _ = (_ << 1) + y[A]
            h.push(_)
          }
          for (var T = this.jpoint(null, null, null), E = this.jpoint(null, null, null), k = d; k > 0; k--) {
            for (m = 0; m < h.length; m++)
              (_ = h[m]), _ === k ? (E = E.mixedAdd(p.points[m])) : _ === -k && (E = E.mixedAdd(p.points[m].neg()))
            T = T.add(E)
          }
          return T.toP()
        }),
        (o.prototype._wnafMul = function (c, f) {
          var p = 4,
            y = c._getNAFPoints(p)
          p = y.wnd
          for (
            var d = y.points, h = i(f, p, this._bitLength), m = this.jpoint(null, null, null), _ = h.length - 1;
            _ >= 0;
            _--
          ) {
            for (var A = 0; _ >= 0 && h[_] === 0; _--) A++
            if ((_ >= 0 && A++, (m = m.dblp(A)), _ < 0)) break
            var T = h[_]
            u(T !== 0),
              c.type === 'affine'
                ? T > 0
                  ? (m = m.mixedAdd(d[(T - 1) >> 1]))
                  : (m = m.mixedAdd(d[(-T - 1) >> 1].neg()))
                : T > 0
                ? (m = m.add(d[(T - 1) >> 1]))
                : (m = m.add(d[(-T - 1) >> 1].neg()))
          }
          return c.type === 'affine' ? m.toP() : m
        }),
        (o.prototype._wnafMulAdd = function (c, f, p, y, d) {
          var h = this._wnafT1,
            m = this._wnafT2,
            _ = this._wnafT3,
            A = 0,
            T,
            E,
            k
          for (T = 0; T < y; T++) {
            k = f[T]
            var w = k._getNAFPoints(c)
            ;(h[T] = w.wnd), (m[T] = w.points)
          }
          for (T = y - 1; T >= 1; T -= 2) {
            var v = T - 1,
              I = T
            if (h[v] !== 1 || h[I] !== 1) {
              ;(_[v] = i(p[v], h[v], this._bitLength)),
                (_[I] = i(p[I], h[I], this._bitLength)),
                (A = Math.max(_[v].length, A)),
                (A = Math.max(_[I].length, A))
              continue
            }
            var M = [f[v], null, null, f[I]]
            f[v].y.cmp(f[I].y) === 0
              ? ((M[1] = f[v].add(f[I])), (M[2] = f[v].toJ().mixedAdd(f[I].neg())))
              : f[v].y.cmp(f[I].y.redNeg()) === 0
              ? ((M[1] = f[v].toJ().mixedAdd(f[I])), (M[2] = f[v].add(f[I].neg())))
              : ((M[1] = f[v].toJ().mixedAdd(f[I])), (M[2] = f[v].toJ().mixedAdd(f[I].neg())))
            var q = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
              G = s(p[v], p[I])
            for (A = Math.max(G[0].length, A), _[v] = new Array(A), _[I] = new Array(A), E = 0; E < A; E++) {
              var O = G[0][E] | 0,
                x = G[1][E] | 0
              ;(_[v][E] = q[(O + 1) * 3 + (x + 1)]), (_[I][E] = 0), (m[v] = M)
            }
          }
          var L = this.jpoint(null, null, null),
            K = this._wnafT4
          for (T = A; T >= 0; T--) {
            for (var J = 0; T >= 0; ) {
              var Z = !0
              for (E = 0; E < y; E++) (K[E] = _[E][T] | 0), K[E] !== 0 && (Z = !1)
              if (!Z) break
              J++, T--
            }
            if ((T >= 0 && J++, (L = L.dblp(J)), T < 0)) break
            for (E = 0; E < y; E++) {
              var Q = K[E]
              Q !== 0 &&
                (Q > 0 ? (k = m[E][(Q - 1) >> 1]) : Q < 0 && (k = m[E][(-Q - 1) >> 1].neg()),
                k.type === 'affine' ? (L = L.mixedAdd(k)) : (L = L.add(k)))
            }
          }
          for (T = 0; T < y; T++) m[T] = null
          return d ? L : L.toP()
        })
      function l(a, c) {
        ;(this.curve = a), (this.type = c), (this.precomputed = null)
      }
      ;(o.BasePoint = l),
        (l.prototype.eq = function () {
          throw new Error('Not implemented')
        }),
        (l.prototype.validate = function () {
          return this.curve.validate(this)
        }),
        (o.prototype.decodePoint = function (c, f) {
          c = n.toArray(c, f)
          var p = this.p.byteLength()
          if ((c[0] === 4 || c[0] === 6 || c[0] === 7) && c.length - 1 == 2 * p) {
            c[0] === 6 ? u(c[c.length - 1] % 2 == 0) : c[0] === 7 && u(c[c.length - 1] % 2 == 1)
            var y = this.point(c.slice(1, 1 + p), c.slice(1 + p, 1 + 2 * p))
            return y
          } else if ((c[0] === 2 || c[0] === 3) && c.length - 1 === p)
            return this.pointFromX(c.slice(1, 1 + p), c[0] === 3)
          throw new Error('Unknown point format')
        }),
        (l.prototype.encodeCompressed = function (c) {
          return this.encode(c, !0)
        }),
        (l.prototype._encode = function (c) {
          var f = this.curve.p.byteLength(),
            p = this.getX().toArray('be', f)
          return c ? [this.getY().isEven() ? 2 : 3].concat(p) : [4].concat(p, this.getY().toArray('be', f))
        }),
        (l.prototype.encode = function (c, f) {
          return n.encode(this._encode(f), c)
        }),
        (l.prototype.precompute = function (c) {
          if (this.precomputed) return this
          var f = { doubles: null, naf: null, beta: null }
          return (
            (f.naf = this._getNAFPoints(8)),
            (f.doubles = this._getDoubles(4, c)),
            (f.beta = this._getBeta()),
            (this.precomputed = f),
            this
          )
        }),
        (l.prototype._hasDoubles = function (c) {
          if (!this.precomputed) return !1
          var f = this.precomputed.doubles
          return f ? f.points.length >= Math.ceil((c.bitLength() + 1) / f.step) : !1
        }),
        (l.prototype._getDoubles = function (c, f) {
          if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles
          for (var p = [this], y = this, d = 0; d < f; d += c) {
            for (var h = 0; h < c; h++) y = y.dbl()
            p.push(y)
          }
          return { step: c, points: p }
        }),
        (l.prototype._getNAFPoints = function (c) {
          if (this.precomputed && this.precomputed.naf) return this.precomputed.naf
          for (var f = [this], p = (1 << c) - 1, y = p === 1 ? null : this.dbl(), d = 1; d < p; d++)
            f[d] = f[d - 1].add(y)
          return { wnd: c, points: f }
        }),
        (l.prototype._getBeta = function () {
          return null
        }),
        (l.prototype.dblp = function (c) {
          for (var f = this, p = 0; p < c; p++) f = f.dbl()
          return f
        })
    }
  }),
  EO = te({
    'node_modules/elliptic/lib/elliptic/curve/short.js'(e, r) {
      V(), F()
      var t = fn(),
        n = ai(),
        i = ii(),
        s = cf(),
        u = t.assert
      function o(c) {
        s.call(this, 'short', c),
          (this.a = new n(c.a, 16).toRed(this.red)),
          (this.b = new n(c.b, 16).toRed(this.red)),
          (this.tinv = this.two.redInvm()),
          (this.zeroA = this.a.fromRed().cmpn(0) === 0),
          (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
          (this.endo = this._getEndomorphism(c)),
          (this._endoWnafT1 = new Array(4)),
          (this._endoWnafT2 = new Array(4))
      }
      i(o, s),
        (r.exports = o),
        (o.prototype._getEndomorphism = function (f) {
          if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
            var p, y
            if (f.beta) p = new n(f.beta, 16).toRed(this.red)
            else {
              var d = this._getEndoRoots(this.p)
              ;(p = d[0].cmp(d[1]) < 0 ? d[0] : d[1]), (p = p.toRed(this.red))
            }
            if (f.lambda) y = new n(f.lambda, 16)
            else {
              var h = this._getEndoRoots(this.n)
              this.g.mul(h[0]).x.cmp(this.g.x.redMul(p)) === 0
                ? (y = h[0])
                : ((y = h[1]), u(this.g.mul(y).x.cmp(this.g.x.redMul(p)) === 0))
            }
            var m
            return (
              f.basis
                ? (m = f.basis.map(function (_) {
                    return { a: new n(_.a, 16), b: new n(_.b, 16) }
                  }))
                : (m = this._getEndoBasis(y)),
              { beta: p, lambda: y, basis: m }
            )
          }
        }),
        (o.prototype._getEndoRoots = function (f) {
          var p = f === this.p ? this.red : n.mont(f),
            y = new n(2).toRed(p).redInvm(),
            d = y.redNeg(),
            h = new n(3).toRed(p).redNeg().redSqrt().redMul(y),
            m = d.redAdd(h).fromRed(),
            _ = d.redSub(h).fromRed()
          return [m, _]
        }),
        (o.prototype._getEndoBasis = function (f) {
          for (
            var p = this.n.ushrn(Math.floor(this.n.bitLength() / 2)),
              y = f,
              d = this.n.clone(),
              h = new n(1),
              m = new n(0),
              _ = new n(0),
              A = new n(1),
              T,
              E,
              k,
              w,
              v,
              I,
              M,
              q = 0,
              G,
              O;
            y.cmpn(0) !== 0;

          ) {
            var x = d.div(y)
            ;(G = d.sub(x.mul(y))), (O = _.sub(x.mul(h)))
            var L = A.sub(x.mul(m))
            if (!k && G.cmp(p) < 0) (T = M.neg()), (E = h), (k = G.neg()), (w = O)
            else if (k && ++q == 2) break
            ;(M = G), (d = y), (y = G), (_ = h), (h = O), (A = m), (m = L)
          }
          ;(v = G.neg()), (I = O)
          var K = k.sqr().add(w.sqr()),
            J = v.sqr().add(I.sqr())
          return (
            J.cmp(K) >= 0 && ((v = T), (I = E)),
            k.negative && ((k = k.neg()), (w = w.neg())),
            v.negative && ((v = v.neg()), (I = I.neg())),
            [
              { a: k, b: w },
              { a: v, b: I }
            ]
          )
        }),
        (o.prototype._endoSplit = function (f) {
          var p = this.endo.basis,
            y = p[0],
            d = p[1],
            h = d.b.mul(f).divRound(this.n),
            m = y.b.neg().mul(f).divRound(this.n),
            _ = h.mul(y.a),
            A = m.mul(d.a),
            T = h.mul(y.b),
            E = m.mul(d.b),
            k = f.sub(_).sub(A),
            w = T.add(E).neg()
          return { k1: k, k2: w }
        }),
        (o.prototype.pointFromX = function (f, p) {
          ;(f = new n(f, 16)), f.red || (f = f.toRed(this.red))
          var y = f.redSqr().redMul(f).redIAdd(f.redMul(this.a)).redIAdd(this.b),
            d = y.redSqrt()
          if (d.redSqr().redSub(y).cmp(this.zero) !== 0) throw new Error('invalid point')
          var h = d.fromRed().isOdd()
          return ((p && !h) || (!p && h)) && (d = d.redNeg()), this.point(f, d)
        }),
        (o.prototype.validate = function (f) {
          if (f.inf) return !0
          var p = f.x,
            y = f.y,
            d = this.a.redMul(p),
            h = p.redSqr().redMul(p).redIAdd(d).redIAdd(this.b)
          return y.redSqr().redISub(h).cmpn(0) === 0
        }),
        (o.prototype._endoWnafMulAdd = function (f, p, y) {
          for (var d = this._endoWnafT1, h = this._endoWnafT2, m = 0; m < f.length; m++) {
            var _ = this._endoSplit(p[m]),
              A = f[m],
              T = A._getBeta()
            _.k1.negative && (_.k1.ineg(), (A = A.neg(!0))),
              _.k2.negative && (_.k2.ineg(), (T = T.neg(!0))),
              (d[m * 2] = A),
              (d[m * 2 + 1] = T),
              (h[m * 2] = _.k1),
              (h[m * 2 + 1] = _.k2)
          }
          for (var E = this._wnafMulAdd(1, d, h, m * 2, y), k = 0; k < m * 2; k++) (d[k] = null), (h[k] = null)
          return E
        })
      function l(c, f, p, y) {
        s.BasePoint.call(this, c, 'affine'),
          f === null && p === null
            ? ((this.x = null), (this.y = null), (this.inf = !0))
            : ((this.x = new n(f, 16)),
              (this.y = new n(p, 16)),
              y && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              (this.inf = !1))
      }
      i(l, s.BasePoint),
        (o.prototype.point = function (f, p, y) {
          return new l(this, f, p, y)
        }),
        (o.prototype.pointFromJSON = function (f, p) {
          return l.fromJSON(this, f, p)
        }),
        (l.prototype._getBeta = function () {
          if (!!this.curve.endo) {
            var f = this.precomputed
            if (f && f.beta) return f.beta
            var p = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y)
            if (f) {
              var y = this.curve,
                d = function (h) {
                  return y.point(h.x.redMul(y.endo.beta), h.y)
                }
              ;(f.beta = p),
                (p.precomputed = {
                  beta: null,
                  naf: f.naf && { wnd: f.naf.wnd, points: f.naf.points.map(d) },
                  doubles: f.doubles && { step: f.doubles.step, points: f.doubles.points.map(d) }
                })
            }
            return p
          }
        }),
        (l.prototype.toJSON = function () {
          return this.precomputed
            ? [
                this.x,
                this.y,
                this.precomputed && {
                  doubles: this.precomputed.doubles && {
                    step: this.precomputed.doubles.step,
                    points: this.precomputed.doubles.points.slice(1)
                  },
                  naf: this.precomputed.naf && {
                    wnd: this.precomputed.naf.wnd,
                    points: this.precomputed.naf.points.slice(1)
                  }
                }
              ]
            : [this.x, this.y]
        }),
        (l.fromJSON = function (f, p, y) {
          typeof p == 'string' && (p = JSON.parse(p))
          var d = f.point(p[0], p[1], y)
          if (!p[2]) return d
          function h(_) {
            return f.point(_[0], _[1], y)
          }
          var m = p[2]
          return (
            (d.precomputed = {
              beta: null,
              doubles: m.doubles && { step: m.doubles.step, points: [d].concat(m.doubles.points.map(h)) },
              naf: m.naf && { wnd: m.naf.wnd, points: [d].concat(m.naf.points.map(h)) }
            }),
            d
          )
        }),
        (l.prototype.inspect = function () {
          return this.isInfinity()
            ? '<EC Point Infinity>'
            : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>'
        }),
        (l.prototype.isInfinity = function () {
          return this.inf
        }),
        (l.prototype.add = function (f) {
          if (this.inf) return f
          if (f.inf) return this
          if (this.eq(f)) return this.dbl()
          if (this.neg().eq(f)) return this.curve.point(null, null)
          if (this.x.cmp(f.x) === 0) return this.curve.point(null, null)
          var p = this.y.redSub(f.y)
          p.cmpn(0) !== 0 && (p = p.redMul(this.x.redSub(f.x).redInvm()))
          var y = p.redSqr().redISub(this.x).redISub(f.x),
            d = p.redMul(this.x.redSub(y)).redISub(this.y)
          return this.curve.point(y, d)
        }),
        (l.prototype.dbl = function () {
          if (this.inf) return this
          var f = this.y.redAdd(this.y)
          if (f.cmpn(0) === 0) return this.curve.point(null, null)
          var p = this.curve.a,
            y = this.x.redSqr(),
            d = f.redInvm(),
            h = y.redAdd(y).redIAdd(y).redIAdd(p).redMul(d),
            m = h.redSqr().redISub(this.x.redAdd(this.x)),
            _ = h.redMul(this.x.redSub(m)).redISub(this.y)
          return this.curve.point(m, _)
        }),
        (l.prototype.getX = function () {
          return this.x.fromRed()
        }),
        (l.prototype.getY = function () {
          return this.y.fromRed()
        }),
        (l.prototype.mul = function (f) {
          return (
            (f = new n(f, 16)),
            this.isInfinity()
              ? this
              : this._hasDoubles(f)
              ? this.curve._fixedNafMul(this, f)
              : this.curve.endo
              ? this.curve._endoWnafMulAdd([this], [f])
              : this.curve._wnafMul(this, f)
          )
        }),
        (l.prototype.mulAdd = function (f, p, y) {
          var d = [this, p],
            h = [f, y]
          return this.curve.endo ? this.curve._endoWnafMulAdd(d, h) : this.curve._wnafMulAdd(1, d, h, 2)
        }),
        (l.prototype.jmulAdd = function (f, p, y) {
          var d = [this, p],
            h = [f, y]
          return this.curve.endo ? this.curve._endoWnafMulAdd(d, h, !0) : this.curve._wnafMulAdd(1, d, h, 2, !0)
        }),
        (l.prototype.eq = function (f) {
          return this === f || (this.inf === f.inf && (this.inf || (this.x.cmp(f.x) === 0 && this.y.cmp(f.y) === 0)))
        }),
        (l.prototype.neg = function (f) {
          if (this.inf) return this
          var p = this.curve.point(this.x, this.y.redNeg())
          if (f && this.precomputed) {
            var y = this.precomputed,
              d = function (h) {
                return h.neg()
              }
            p.precomputed = {
              naf: y.naf && { wnd: y.naf.wnd, points: y.naf.points.map(d) },
              doubles: y.doubles && { step: y.doubles.step, points: y.doubles.points.map(d) }
            }
          }
          return p
        }),
        (l.prototype.toJ = function () {
          if (this.inf) return this.curve.jpoint(null, null, null)
          var f = this.curve.jpoint(this.x, this.y, this.curve.one)
          return f
        })
      function a(c, f, p, y) {
        s.BasePoint.call(this, c, 'jacobian'),
          f === null && p === null && y === null
            ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new n(0)))
            : ((this.x = new n(f, 16)), (this.y = new n(p, 16)), (this.z = new n(y, 16))),
          this.x.red || (this.x = this.x.toRed(this.curve.red)),
          this.y.red || (this.y = this.y.toRed(this.curve.red)),
          this.z.red || (this.z = this.z.toRed(this.curve.red)),
          (this.zOne = this.z === this.curve.one)
      }
      i(a, s.BasePoint),
        (o.prototype.jpoint = function (f, p, y) {
          return new a(this, f, p, y)
        }),
        (a.prototype.toP = function () {
          if (this.isInfinity()) return this.curve.point(null, null)
          var f = this.z.redInvm(),
            p = f.redSqr(),
            y = this.x.redMul(p),
            d = this.y.redMul(p).redMul(f)
          return this.curve.point(y, d)
        }),
        (a.prototype.neg = function () {
          return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
        }),
        (a.prototype.add = function (f) {
          if (this.isInfinity()) return f
          if (f.isInfinity()) return this
          var p = f.z.redSqr(),
            y = this.z.redSqr(),
            d = this.x.redMul(p),
            h = f.x.redMul(y),
            m = this.y.redMul(p.redMul(f.z)),
            _ = f.y.redMul(y.redMul(this.z)),
            A = d.redSub(h),
            T = m.redSub(_)
          if (A.cmpn(0) === 0) return T.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
          var E = A.redSqr(),
            k = E.redMul(A),
            w = d.redMul(E),
            v = T.redSqr().redIAdd(k).redISub(w).redISub(w),
            I = T.redMul(w.redISub(v)).redISub(m.redMul(k)),
            M = this.z.redMul(f.z).redMul(A)
          return this.curve.jpoint(v, I, M)
        }),
        (a.prototype.mixedAdd = function (f) {
          if (this.isInfinity()) return f.toJ()
          if (f.isInfinity()) return this
          var p = this.z.redSqr(),
            y = this.x,
            d = f.x.redMul(p),
            h = this.y,
            m = f.y.redMul(p).redMul(this.z),
            _ = y.redSub(d),
            A = h.redSub(m)
          if (_.cmpn(0) === 0) return A.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl()
          var T = _.redSqr(),
            E = T.redMul(_),
            k = y.redMul(T),
            w = A.redSqr().redIAdd(E).redISub(k).redISub(k),
            v = A.redMul(k.redISub(w)).redISub(h.redMul(E)),
            I = this.z.redMul(_)
          return this.curve.jpoint(w, v, I)
        }),
        (a.prototype.dblp = function (f) {
          if (f === 0) return this
          if (this.isInfinity()) return this
          if (!f) return this.dbl()
          var p
          if (this.curve.zeroA || this.curve.threeA) {
            var y = this
            for (p = 0; p < f; p++) y = y.dbl()
            return y
          }
          var d = this.curve.a,
            h = this.curve.tinv,
            m = this.x,
            _ = this.y,
            A = this.z,
            T = A.redSqr().redSqr(),
            E = _.redAdd(_)
          for (p = 0; p < f; p++) {
            var k = m.redSqr(),
              w = E.redSqr(),
              v = w.redSqr(),
              I = k.redAdd(k).redIAdd(k).redIAdd(d.redMul(T)),
              M = m.redMul(w),
              q = I.redSqr().redISub(M.redAdd(M)),
              G = M.redISub(q),
              O = I.redMul(G)
            O = O.redIAdd(O).redISub(v)
            var x = E.redMul(A)
            p + 1 < f && (T = T.redMul(v)), (m = q), (A = x), (E = O)
          }
          return this.curve.jpoint(m, E.redMul(h), A)
        }),
        (a.prototype.dbl = function () {
          return this.isInfinity()
            ? this
            : this.curve.zeroA
            ? this._zeroDbl()
            : this.curve.threeA
            ? this._threeDbl()
            : this._dbl()
        }),
        (a.prototype._zeroDbl = function () {
          var f, p, y
          if (this.zOne) {
            var d = this.x.redSqr(),
              h = this.y.redSqr(),
              m = h.redSqr(),
              _ = this.x.redAdd(h).redSqr().redISub(d).redISub(m)
            _ = _.redIAdd(_)
            var A = d.redAdd(d).redIAdd(d),
              T = A.redSqr().redISub(_).redISub(_),
              E = m.redIAdd(m)
            ;(E = E.redIAdd(E)),
              (E = E.redIAdd(E)),
              (f = T),
              (p = A.redMul(_.redISub(T)).redISub(E)),
              (y = this.y.redAdd(this.y))
          } else {
            var k = this.x.redSqr(),
              w = this.y.redSqr(),
              v = w.redSqr(),
              I = this.x.redAdd(w).redSqr().redISub(k).redISub(v)
            I = I.redIAdd(I)
            var M = k.redAdd(k).redIAdd(k),
              q = M.redSqr(),
              G = v.redIAdd(v)
            ;(G = G.redIAdd(G)),
              (G = G.redIAdd(G)),
              (f = q.redISub(I).redISub(I)),
              (p = M.redMul(I.redISub(f)).redISub(G)),
              (y = this.y.redMul(this.z)),
              (y = y.redIAdd(y))
          }
          return this.curve.jpoint(f, p, y)
        }),
        (a.prototype._threeDbl = function () {
          var f, p, y
          if (this.zOne) {
            var d = this.x.redSqr(),
              h = this.y.redSqr(),
              m = h.redSqr(),
              _ = this.x.redAdd(h).redSqr().redISub(d).redISub(m)
            _ = _.redIAdd(_)
            var A = d.redAdd(d).redIAdd(d).redIAdd(this.curve.a),
              T = A.redSqr().redISub(_).redISub(_)
            f = T
            var E = m.redIAdd(m)
            ;(E = E.redIAdd(E)),
              (E = E.redIAdd(E)),
              (p = A.redMul(_.redISub(T)).redISub(E)),
              (y = this.y.redAdd(this.y))
          } else {
            var k = this.z.redSqr(),
              w = this.y.redSqr(),
              v = this.x.redMul(w),
              I = this.x.redSub(k).redMul(this.x.redAdd(k))
            I = I.redAdd(I).redIAdd(I)
            var M = v.redIAdd(v)
            M = M.redIAdd(M)
            var q = M.redAdd(M)
            ;(f = I.redSqr().redISub(q)), (y = this.y.redAdd(this.z).redSqr().redISub(w).redISub(k))
            var G = w.redSqr()
            ;(G = G.redIAdd(G)), (G = G.redIAdd(G)), (G = G.redIAdd(G)), (p = I.redMul(M.redISub(f)).redISub(G))
          }
          return this.curve.jpoint(f, p, y)
        }),
        (a.prototype._dbl = function () {
          var f = this.curve.a,
            p = this.x,
            y = this.y,
            d = this.z,
            h = d.redSqr().redSqr(),
            m = p.redSqr(),
            _ = y.redSqr(),
            A = m.redAdd(m).redIAdd(m).redIAdd(f.redMul(h)),
            T = p.redAdd(p)
          T = T.redIAdd(T)
          var E = T.redMul(_),
            k = A.redSqr().redISub(E.redAdd(E)),
            w = E.redISub(k),
            v = _.redSqr()
          ;(v = v.redIAdd(v)), (v = v.redIAdd(v)), (v = v.redIAdd(v))
          var I = A.redMul(w).redISub(v),
            M = y.redAdd(y).redMul(d)
          return this.curve.jpoint(k, I, M)
        }),
        (a.prototype.trpl = function () {
          if (!this.curve.zeroA) return this.dbl().add(this)
          var f = this.x.redSqr(),
            p = this.y.redSqr(),
            y = this.z.redSqr(),
            d = p.redSqr(),
            h = f.redAdd(f).redIAdd(f),
            m = h.redSqr(),
            _ = this.x.redAdd(p).redSqr().redISub(f).redISub(d)
          ;(_ = _.redIAdd(_)), (_ = _.redAdd(_).redIAdd(_)), (_ = _.redISub(m))
          var A = _.redSqr(),
            T = d.redIAdd(d)
          ;(T = T.redIAdd(T)), (T = T.redIAdd(T)), (T = T.redIAdd(T))
          var E = h.redIAdd(_).redSqr().redISub(m).redISub(A).redISub(T),
            k = p.redMul(E)
          ;(k = k.redIAdd(k)), (k = k.redIAdd(k))
          var w = this.x.redMul(A).redISub(k)
          ;(w = w.redIAdd(w)), (w = w.redIAdd(w))
          var v = this.y.redMul(E.redMul(T.redISub(E)).redISub(_.redMul(A)))
          ;(v = v.redIAdd(v)), (v = v.redIAdd(v)), (v = v.redIAdd(v))
          var I = this.z.redAdd(_).redSqr().redISub(y).redISub(A)
          return this.curve.jpoint(w, v, I)
        }),
        (a.prototype.mul = function (f, p) {
          return (f = new n(f, p)), this.curve._wnafMul(this, f)
        }),
        (a.prototype.eq = function (f) {
          if (f.type === 'affine') return this.eq(f.toJ())
          if (this === f) return !0
          var p = this.z.redSqr(),
            y = f.z.redSqr()
          if (this.x.redMul(y).redISub(f.x.redMul(p)).cmpn(0) !== 0) return !1
          var d = p.redMul(this.z),
            h = y.redMul(f.z)
          return this.y.redMul(h).redISub(f.y.redMul(d)).cmpn(0) === 0
        }),
        (a.prototype.eqXToP = function (f) {
          var p = this.z.redSqr(),
            y = f.toRed(this.curve.red).redMul(p)
          if (this.x.cmp(y) === 0) return !0
          for (var d = f.clone(), h = this.curve.redN.redMul(p); ; ) {
            if ((d.iadd(this.curve.n), d.cmp(this.curve.p) >= 0)) return !1
            if ((y.redIAdd(h), this.x.cmp(y) === 0)) return !0
          }
        }),
        (a.prototype.inspect = function () {
          return this.isInfinity()
            ? '<EC JPoint Infinity>'
            : '<EC JPoint x: ' +
                this.x.toString(16, 2) +
                ' y: ' +
                this.y.toString(16, 2) +
                ' z: ' +
                this.z.toString(16, 2) +
                '>'
        }),
        (a.prototype.isInfinity = function () {
          return this.z.cmpn(0) === 0
        })
    }
  }),
  SO = te({
    'node_modules/elliptic/lib/elliptic/curve/mont.js'(e, r) {
      V(), F()
      var t = ai(),
        n = ii(),
        i = cf(),
        s = fn()
      function u(l) {
        i.call(this, 'mont', l),
          (this.a = new t(l.a, 16).toRed(this.red)),
          (this.b = new t(l.b, 16).toRed(this.red)),
          (this.i4 = new t(4).toRed(this.red).redInvm()),
          (this.two = new t(2).toRed(this.red)),
          (this.a24 = this.i4.redMul(this.a.redAdd(this.two)))
      }
      n(u, i),
        (r.exports = u),
        (u.prototype.validate = function (a) {
          var c = a.normalize().x,
            f = c.redSqr(),
            p = f.redMul(c).redAdd(f.redMul(this.a)).redAdd(c),
            y = p.redSqrt()
          return y.redSqr().cmp(p) === 0
        })
      function o(l, a, c) {
        i.BasePoint.call(this, l, 'projective'),
          a === null && c === null
            ? ((this.x = this.curve.one), (this.z = this.curve.zero))
            : ((this.x = new t(a, 16)),
              (this.z = new t(c, 16)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.z.red || (this.z = this.z.toRed(this.curve.red)))
      }
      n(o, i.BasePoint),
        (u.prototype.decodePoint = function (a, c) {
          return this.point(s.toArray(a, c), 1)
        }),
        (u.prototype.point = function (a, c) {
          return new o(this, a, c)
        }),
        (u.prototype.pointFromJSON = function (a) {
          return o.fromJSON(this, a)
        }),
        (o.prototype.precompute = function () {}),
        (o.prototype._encode = function () {
          return this.getX().toArray('be', this.curve.p.byteLength())
        }),
        (o.fromJSON = function (a, c) {
          return new o(a, c[0], c[1] || a.one)
        }),
        (o.prototype.inspect = function () {
          return this.isInfinity()
            ? '<EC Point Infinity>'
            : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>'
        }),
        (o.prototype.isInfinity = function () {
          return this.z.cmpn(0) === 0
        }),
        (o.prototype.dbl = function () {
          var a = this.x.redAdd(this.z),
            c = a.redSqr(),
            f = this.x.redSub(this.z),
            p = f.redSqr(),
            y = c.redSub(p),
            d = c.redMul(p),
            h = y.redMul(p.redAdd(this.curve.a24.redMul(y)))
          return this.curve.point(d, h)
        }),
        (o.prototype.add = function () {
          throw new Error('Not supported on Montgomery curve')
        }),
        (o.prototype.diffAdd = function (a, c) {
          var f = this.x.redAdd(this.z),
            p = this.x.redSub(this.z),
            y = a.x.redAdd(a.z),
            d = a.x.redSub(a.z),
            h = d.redMul(f),
            m = y.redMul(p),
            _ = c.z.redMul(h.redAdd(m).redSqr()),
            A = c.x.redMul(h.redISub(m).redSqr())
          return this.curve.point(_, A)
        }),
        (o.prototype.mul = function (a) {
          for (
            var c = a.clone(), f = this, p = this.curve.point(null, null), y = this, d = [];
            c.cmpn(0) !== 0;
            c.iushrn(1)
          )
            d.push(c.andln(1))
          for (var h = d.length - 1; h >= 0; h--)
            d[h] === 0 ? ((f = f.diffAdd(p, y)), (p = p.dbl())) : ((p = f.diffAdd(p, y)), (f = f.dbl()))
          return p
        }),
        (o.prototype.mulAdd = function () {
          throw new Error('Not supported on Montgomery curve')
        }),
        (o.prototype.jumlAdd = function () {
          throw new Error('Not supported on Montgomery curve')
        }),
        (o.prototype.eq = function (a) {
          return this.getX().cmp(a.getX()) === 0
        }),
        (o.prototype.normalize = function () {
          return (this.x = this.x.redMul(this.z.redInvm())), (this.z = this.curve.one), this
        }),
        (o.prototype.getX = function () {
          return this.normalize(), this.x.fromRed()
        })
    }
  }),
  AO = te({
    'node_modules/elliptic/lib/elliptic/curve/edwards.js'(e, r) {
      V(), F()
      var t = fn(),
        n = ai(),
        i = ii(),
        s = cf(),
        u = t.assert
      function o(a) {
        ;(this.twisted = (a.a | 0) != 1),
          (this.mOneA = this.twisted && (a.a | 0) == -1),
          (this.extended = this.mOneA),
          s.call(this, 'edwards', a),
          (this.a = new n(a.a, 16).umod(this.red.m)),
          (this.a = this.a.toRed(this.red)),
          (this.c = new n(a.c, 16).toRed(this.red)),
          (this.c2 = this.c.redSqr()),
          (this.d = new n(a.d, 16).toRed(this.red)),
          (this.dd = this.d.redAdd(this.d)),
          u(!this.twisted || this.c.fromRed().cmpn(1) === 0),
          (this.oneC = (a.c | 0) == 1)
      }
      i(o, s),
        (r.exports = o),
        (o.prototype._mulA = function (c) {
          return this.mOneA ? c.redNeg() : this.a.redMul(c)
        }),
        (o.prototype._mulC = function (c) {
          return this.oneC ? c : this.c.redMul(c)
        }),
        (o.prototype.jpoint = function (c, f, p, y) {
          return this.point(c, f, p, y)
        }),
        (o.prototype.pointFromX = function (c, f) {
          ;(c = new n(c, 16)), c.red || (c = c.toRed(this.red))
          var p = c.redSqr(),
            y = this.c2.redSub(this.a.redMul(p)),
            d = this.one.redSub(this.c2.redMul(this.d).redMul(p)),
            h = y.redMul(d.redInvm()),
            m = h.redSqrt()
          if (m.redSqr().redSub(h).cmp(this.zero) !== 0) throw new Error('invalid point')
          var _ = m.fromRed().isOdd()
          return ((f && !_) || (!f && _)) && (m = m.redNeg()), this.point(c, m)
        }),
        (o.prototype.pointFromY = function (c, f) {
          ;(c = new n(c, 16)), c.red || (c = c.toRed(this.red))
          var p = c.redSqr(),
            y = p.redSub(this.c2),
            d = p.redMul(this.d).redMul(this.c2).redSub(this.a),
            h = y.redMul(d.redInvm())
          if (h.cmp(this.zero) === 0) {
            if (f) throw new Error('invalid point')
            return this.point(this.zero, c)
          }
          var m = h.redSqrt()
          if (m.redSqr().redSub(h).cmp(this.zero) !== 0) throw new Error('invalid point')
          return m.fromRed().isOdd() !== f && (m = m.redNeg()), this.point(m, c)
        }),
        (o.prototype.validate = function (c) {
          if (c.isInfinity()) return !0
          c.normalize()
          var f = c.x.redSqr(),
            p = c.y.redSqr(),
            y = f.redMul(this.a).redAdd(p),
            d = this.c2.redMul(this.one.redAdd(this.d.redMul(f).redMul(p)))
          return y.cmp(d) === 0
        })
      function l(a, c, f, p, y) {
        s.BasePoint.call(this, a, 'projective'),
          c === null && f === null && p === null
            ? ((this.x = this.curve.zero),
              (this.y = this.curve.one),
              (this.z = this.curve.one),
              (this.t = this.curve.zero),
              (this.zOne = !0))
            : ((this.x = new n(c, 16)),
              (this.y = new n(f, 16)),
              (this.z = p ? new n(p, 16) : this.curve.one),
              (this.t = y && new n(y, 16)),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              this.z.red || (this.z = this.z.toRed(this.curve.red)),
              this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
              (this.zOne = this.z === this.curve.one),
              this.curve.extended &&
                !this.t &&
                ((this.t = this.x.redMul(this.y)), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))))
      }
      i(l, s.BasePoint),
        (o.prototype.pointFromJSON = function (c) {
          return l.fromJSON(this, c)
        }),
        (o.prototype.point = function (c, f, p, y) {
          return new l(this, c, f, p, y)
        }),
        (l.fromJSON = function (c, f) {
          return new l(c, f[0], f[1], f[2])
        }),
        (l.prototype.inspect = function () {
          return this.isInfinity()
            ? '<EC Point Infinity>'
            : '<EC Point x: ' +
                this.x.fromRed().toString(16, 2) +
                ' y: ' +
                this.y.fromRed().toString(16, 2) +
                ' z: ' +
                this.z.fromRed().toString(16, 2) +
                '>'
        }),
        (l.prototype.isInfinity = function () {
          return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || (this.zOne && this.y.cmp(this.curve.c) === 0))
        }),
        (l.prototype._extDbl = function () {
          var c = this.x.redSqr(),
            f = this.y.redSqr(),
            p = this.z.redSqr()
          p = p.redIAdd(p)
          var y = this.curve._mulA(c),
            d = this.x.redAdd(this.y).redSqr().redISub(c).redISub(f),
            h = y.redAdd(f),
            m = h.redSub(p),
            _ = y.redSub(f),
            A = d.redMul(m),
            T = h.redMul(_),
            E = d.redMul(_),
            k = m.redMul(h)
          return this.curve.point(A, T, k, E)
        }),
        (l.prototype._projDbl = function () {
          var c = this.x.redAdd(this.y).redSqr(),
            f = this.x.redSqr(),
            p = this.y.redSqr(),
            y,
            d,
            h,
            m,
            _,
            A
          if (this.curve.twisted) {
            m = this.curve._mulA(f)
            var T = m.redAdd(p)
            this.zOne
              ? ((y = c.redSub(f).redSub(p).redMul(T.redSub(this.curve.two))),
                (d = T.redMul(m.redSub(p))),
                (h = T.redSqr().redSub(T).redSub(T)))
              : ((_ = this.z.redSqr()),
                (A = T.redSub(_).redISub(_)),
                (y = c.redSub(f).redISub(p).redMul(A)),
                (d = T.redMul(m.redSub(p))),
                (h = T.redMul(A)))
          } else
            (m = f.redAdd(p)),
              (_ = this.curve._mulC(this.z).redSqr()),
              (A = m.redSub(_).redSub(_)),
              (y = this.curve._mulC(c.redISub(m)).redMul(A)),
              (d = this.curve._mulC(m).redMul(f.redISub(p))),
              (h = m.redMul(A))
          return this.curve.point(y, d, h)
        }),
        (l.prototype.dbl = function () {
          return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl()
        }),
        (l.prototype._extAdd = function (c) {
          var f = this.y.redSub(this.x).redMul(c.y.redSub(c.x)),
            p = this.y.redAdd(this.x).redMul(c.y.redAdd(c.x)),
            y = this.t.redMul(this.curve.dd).redMul(c.t),
            d = this.z.redMul(c.z.redAdd(c.z)),
            h = p.redSub(f),
            m = d.redSub(y),
            _ = d.redAdd(y),
            A = p.redAdd(f),
            T = h.redMul(m),
            E = _.redMul(A),
            k = h.redMul(A),
            w = m.redMul(_)
          return this.curve.point(T, E, w, k)
        }),
        (l.prototype._projAdd = function (c) {
          var f = this.z.redMul(c.z),
            p = f.redSqr(),
            y = this.x.redMul(c.x),
            d = this.y.redMul(c.y),
            h = this.curve.d.redMul(y).redMul(d),
            m = p.redSub(h),
            _ = p.redAdd(h),
            A = this.x.redAdd(this.y).redMul(c.x.redAdd(c.y)).redISub(y).redISub(d),
            T = f.redMul(m).redMul(A),
            E,
            k
          return (
            this.curve.twisted
              ? ((E = f.redMul(_).redMul(d.redSub(this.curve._mulA(y)))), (k = m.redMul(_)))
              : ((E = f.redMul(_).redMul(d.redSub(y))), (k = this.curve._mulC(m).redMul(_))),
            this.curve.point(T, E, k)
          )
        }),
        (l.prototype.add = function (c) {
          return this.isInfinity()
            ? c
            : c.isInfinity()
            ? this
            : this.curve.extended
            ? this._extAdd(c)
            : this._projAdd(c)
        }),
        (l.prototype.mul = function (c) {
          return this._hasDoubles(c) ? this.curve._fixedNafMul(this, c) : this.curve._wnafMul(this, c)
        }),
        (l.prototype.mulAdd = function (c, f, p) {
          return this.curve._wnafMulAdd(1, [this, f], [c, p], 2, !1)
        }),
        (l.prototype.jmulAdd = function (c, f, p) {
          return this.curve._wnafMulAdd(1, [this, f], [c, p], 2, !0)
        }),
        (l.prototype.normalize = function () {
          if (this.zOne) return this
          var c = this.z.redInvm()
          return (
            (this.x = this.x.redMul(c)),
            (this.y = this.y.redMul(c)),
            this.t && (this.t = this.t.redMul(c)),
            (this.z = this.curve.one),
            (this.zOne = !0),
            this
          )
        }),
        (l.prototype.neg = function () {
          return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg())
        }),
        (l.prototype.getX = function () {
          return this.normalize(), this.x.fromRed()
        }),
        (l.prototype.getY = function () {
          return this.normalize(), this.y.fromRed()
        }),
        (l.prototype.eq = function (c) {
          return this === c || (this.getX().cmp(c.getX()) === 0 && this.getY().cmp(c.getY()) === 0)
        }),
        (l.prototype.eqXToP = function (c) {
          var f = c.toRed(this.curve.red).redMul(this.z)
          if (this.x.cmp(f) === 0) return !0
          for (var p = c.clone(), y = this.curve.redN.redMul(this.z); ; ) {
            if ((p.iadd(this.curve.n), p.cmp(this.curve.p) >= 0)) return !1
            if ((f.redIAdd(y), this.x.cmp(f) === 0)) return !0
          }
        }),
        (l.prototype.toP = l.prototype.normalize),
        (l.prototype.mixedAdd = l.prototype.add)
    }
  }),
  X9 = te({
    'node_modules/elliptic/lib/elliptic/curve/index.js'(e) {
      V(), F()
      var r = e
      ;(r.base = cf()), (r.short = EO()), (r.mont = SO()), (r.edwards = AO())
    }
  }),
  qn = te({
    'node_modules/hash.js/lib/hash/utils.js'(e) {
      V(), F()
      var r = As(),
        t = ii()
      e.inherits = t
      function n(x, L) {
        return (x.charCodeAt(L) & 64512) != 55296 || L < 0 || L + 1 >= x.length
          ? !1
          : (x.charCodeAt(L + 1) & 64512) == 56320
      }
      function i(x, L) {
        if (Array.isArray(x)) return x.slice()
        if (!x) return []
        var K = []
        if (typeof x == 'string')
          if (L) {
            if (L === 'hex')
              for (x = x.replace(/[^a-z0-9]+/gi, ''), x.length % 2 != 0 && (x = '0' + x), Z = 0; Z < x.length; Z += 2)
                K.push(parseInt(x[Z] + x[Z + 1], 16))
          } else
            for (var J = 0, Z = 0; Z < x.length; Z++) {
              var Q = x.charCodeAt(Z)
              Q < 128
                ? (K[J++] = Q)
                : Q < 2048
                ? ((K[J++] = (Q >> 6) | 192), (K[J++] = (Q & 63) | 128))
                : n(x, Z)
                ? ((Q = 65536 + ((Q & 1023) << 10) + (x.charCodeAt(++Z) & 1023)),
                  (K[J++] = (Q >> 18) | 240),
                  (K[J++] = ((Q >> 12) & 63) | 128),
                  (K[J++] = ((Q >> 6) & 63) | 128),
                  (K[J++] = (Q & 63) | 128))
                : ((K[J++] = (Q >> 12) | 224), (K[J++] = ((Q >> 6) & 63) | 128), (K[J++] = (Q & 63) | 128))
            }
        else for (Z = 0; Z < x.length; Z++) K[Z] = x[Z] | 0
        return K
      }
      e.toArray = i
      function s(x) {
        for (var L = '', K = 0; K < x.length; K++) L += l(x[K].toString(16))
        return L
      }
      e.toHex = s
      function u(x) {
        var L = (x >>> 24) | ((x >>> 8) & 65280) | ((x << 8) & 16711680) | ((x & 255) << 24)
        return L >>> 0
      }
      e.htonl = u
      function o(x, L) {
        for (var K = '', J = 0; J < x.length; J++) {
          var Z = x[J]
          L === 'little' && (Z = u(Z)), (K += a(Z.toString(16)))
        }
        return K
      }
      e.toHex32 = o
      function l(x) {
        return x.length === 1 ? '0' + x : x
      }
      e.zero2 = l
      function a(x) {
        return x.length === 7
          ? '0' + x
          : x.length === 6
          ? '00' + x
          : x.length === 5
          ? '000' + x
          : x.length === 4
          ? '0000' + x
          : x.length === 3
          ? '00000' + x
          : x.length === 2
          ? '000000' + x
          : x.length === 1
          ? '0000000' + x
          : x
      }
      e.zero8 = a
      function c(x, L, K, J) {
        var Z = K - L
        r(Z % 4 == 0)
        for (var Q = new Array(Z / 4), fe = 0, ie = L; fe < Q.length; fe++, ie += 4) {
          var W
          J === 'big'
            ? (W = (x[ie] << 24) | (x[ie + 1] << 16) | (x[ie + 2] << 8) | x[ie + 3])
            : (W = (x[ie + 3] << 24) | (x[ie + 2] << 16) | (x[ie + 1] << 8) | x[ie]),
            (Q[fe] = W >>> 0)
        }
        return Q
      }
      e.join32 = c
      function f(x, L) {
        for (var K = new Array(x.length * 4), J = 0, Z = 0; J < x.length; J++, Z += 4) {
          var Q = x[J]
          L === 'big'
            ? ((K[Z] = Q >>> 24), (K[Z + 1] = (Q >>> 16) & 255), (K[Z + 2] = (Q >>> 8) & 255), (K[Z + 3] = Q & 255))
            : ((K[Z + 3] = Q >>> 24), (K[Z + 2] = (Q >>> 16) & 255), (K[Z + 1] = (Q >>> 8) & 255), (K[Z] = Q & 255))
        }
        return K
      }
      e.split32 = f
      function p(x, L) {
        return (x >>> L) | (x << (32 - L))
      }
      e.rotr32 = p
      function y(x, L) {
        return (x << L) | (x >>> (32 - L))
      }
      e.rotl32 = y
      function d(x, L) {
        return (x + L) >>> 0
      }
      e.sum32 = d
      function h(x, L, K) {
        return (x + L + K) >>> 0
      }
      e.sum32_3 = h
      function m(x, L, K, J) {
        return (x + L + K + J) >>> 0
      }
      e.sum32_4 = m
      function _(x, L, K, J, Z) {
        return (x + L + K + J + Z) >>> 0
      }
      e.sum32_5 = _
      function A(x, L, K, J) {
        var Z = x[L],
          Q = x[L + 1],
          fe = (J + Q) >>> 0,
          ie = (fe < J ? 1 : 0) + K + Z
        ;(x[L] = ie >>> 0), (x[L + 1] = fe)
      }
      e.sum64 = A
      function T(x, L, K, J) {
        var Z = (L + J) >>> 0,
          Q = (Z < L ? 1 : 0) + x + K
        return Q >>> 0
      }
      e.sum64_hi = T
      function E(x, L, K, J) {
        var Z = L + J
        return Z >>> 0
      }
      e.sum64_lo = E
      function k(x, L, K, J, Z, Q, fe, ie) {
        var W = 0,
          le = L
        ;(le = (le + J) >>> 0),
          (W += le < L ? 1 : 0),
          (le = (le + Q) >>> 0),
          (W += le < Q ? 1 : 0),
          (le = (le + ie) >>> 0),
          (W += le < ie ? 1 : 0)
        var xe = x + K + Z + fe + W
        return xe >>> 0
      }
      e.sum64_4_hi = k
      function w(x, L, K, J, Z, Q, fe, ie) {
        var W = L + J + Q + ie
        return W >>> 0
      }
      e.sum64_4_lo = w
      function v(x, L, K, J, Z, Q, fe, ie, W, le) {
        var xe = 0,
          _e = L
        ;(_e = (_e + J) >>> 0),
          (xe += _e < L ? 1 : 0),
          (_e = (_e + Q) >>> 0),
          (xe += _e < Q ? 1 : 0),
          (_e = (_e + ie) >>> 0),
          (xe += _e < ie ? 1 : 0),
          (_e = (_e + le) >>> 0),
          (xe += _e < le ? 1 : 0)
        var Ne = x + K + Z + fe + W + xe
        return Ne >>> 0
      }
      e.sum64_5_hi = v
      function I(x, L, K, J, Z, Q, fe, ie, W, le) {
        var xe = L + J + Q + ie + le
        return xe >>> 0
      }
      e.sum64_5_lo = I
      function M(x, L, K) {
        var J = (L << (32 - K)) | (x >>> K)
        return J >>> 0
      }
      e.rotr64_hi = M
      function q(x, L, K) {
        var J = (x << (32 - K)) | (L >>> K)
        return J >>> 0
      }
      e.rotr64_lo = q
      function G(x, L, K) {
        return x >>> K
      }
      e.shr64_hi = G
      function O(x, L, K) {
        var J = (x << (32 - K)) | (L >>> K)
        return J >>> 0
      }
      e.shr64_lo = O
    }
  }),
  Kc = te({
    'node_modules/hash.js/lib/hash/common.js'(e) {
      V(), F()
      var r = qn(),
        t = As()
      function n() {
        ;(this.pending = null),
          (this.pendingTotal = 0),
          (this.blockSize = this.constructor.blockSize),
          (this.outSize = this.constructor.outSize),
          (this.hmacStrength = this.constructor.hmacStrength),
          (this.padLength = this.constructor.padLength / 8),
          (this.endian = 'big'),
          (this._delta8 = this.blockSize / 8),
          (this._delta32 = this.blockSize / 32)
      }
      ;(e.BlockHash = n),
        (n.prototype.update = function (s, u) {
          if (
            ((s = r.toArray(s, u)),
            this.pending ? (this.pending = this.pending.concat(s)) : (this.pending = s),
            (this.pendingTotal += s.length),
            this.pending.length >= this._delta8)
          ) {
            s = this.pending
            var o = s.length % this._delta8
            ;(this.pending = s.slice(s.length - o, s.length)),
              this.pending.length === 0 && (this.pending = null),
              (s = r.join32(s, 0, s.length - o, this.endian))
            for (var l = 0; l < s.length; l += this._delta32) this._update(s, l, l + this._delta32)
          }
          return this
        }),
        (n.prototype.digest = function (s) {
          return this.update(this._pad()), t(this.pending === null), this._digest(s)
        }),
        (n.prototype._pad = function () {
          var s = this.pendingTotal,
            u = this._delta8,
            o = u - ((s + this.padLength) % u),
            l = new Array(o + this.padLength)
          l[0] = 128
          for (var a = 1; a < o; a++) l[a] = 0
          if (((s <<= 3), this.endian === 'big')) {
            for (var c = 8; c < this.padLength; c++) l[a++] = 0
            ;(l[a++] = 0),
              (l[a++] = 0),
              (l[a++] = 0),
              (l[a++] = 0),
              (l[a++] = (s >>> 24) & 255),
              (l[a++] = (s >>> 16) & 255),
              (l[a++] = (s >>> 8) & 255),
              (l[a++] = s & 255)
          } else
            for (
              l[a++] = s & 255,
                l[a++] = (s >>> 8) & 255,
                l[a++] = (s >>> 16) & 255,
                l[a++] = (s >>> 24) & 255,
                l[a++] = 0,
                l[a++] = 0,
                l[a++] = 0,
                l[a++] = 0,
                c = 8;
              c < this.padLength;
              c++
            )
              l[a++] = 0
          return l
        })
    }
  }),
  Y9 = te({
    'node_modules/hash.js/lib/hash/sha/common.js'(e) {
      V(), F()
      var r = qn(),
        t = r.rotr32
      function n(f, p, y, d) {
        if (f === 0) return i(p, y, d)
        if (f === 1 || f === 3) return u(p, y, d)
        if (f === 2) return s(p, y, d)
      }
      e.ft_1 = n
      function i(f, p, y) {
        return (f & p) ^ (~f & y)
      }
      e.ch32 = i
      function s(f, p, y) {
        return (f & p) ^ (f & y) ^ (p & y)
      }
      e.maj32 = s
      function u(f, p, y) {
        return f ^ p ^ y
      }
      e.p32 = u
      function o(f) {
        return t(f, 2) ^ t(f, 13) ^ t(f, 22)
      }
      e.s0_256 = o
      function l(f) {
        return t(f, 6) ^ t(f, 11) ^ t(f, 25)
      }
      e.s1_256 = l
      function a(f) {
        return t(f, 7) ^ t(f, 18) ^ (f >>> 3)
      }
      e.g0_256 = a
      function c(f) {
        return t(f, 17) ^ t(f, 19) ^ (f >>> 10)
      }
      e.g1_256 = c
    }
  }),
  IO = te({
    'node_modules/hash.js/lib/hash/sha/1.js'(e, r) {
      V(), F()
      var t = qn(),
        n = Kc(),
        i = Y9(),
        s = t.rotl32,
        u = t.sum32,
        o = t.sum32_5,
        l = i.ft_1,
        a = n.BlockHash,
        c = [1518500249, 1859775393, 2400959708, 3395469782]
      function f() {
        if (!(this instanceof f)) return new f()
        a.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.W = new Array(80))
      }
      t.inherits(f, a),
        (r.exports = f),
        (f.blockSize = 512),
        (f.outSize = 160),
        (f.hmacStrength = 80),
        (f.padLength = 64),
        (f.prototype._update = function (y, d) {
          for (var h = this.W, m = 0; m < 16; m++) h[m] = y[d + m]
          for (; m < h.length; m++) h[m] = s(h[m - 3] ^ h[m - 8] ^ h[m - 14] ^ h[m - 16], 1)
          var _ = this.h[0],
            A = this.h[1],
            T = this.h[2],
            E = this.h[3],
            k = this.h[4]
          for (m = 0; m < h.length; m++) {
            var w = ~~(m / 20),
              v = o(s(_, 5), l(w, A, T, E), k, h[m], c[w])
            ;(k = E), (E = T), (T = s(A, 30)), (A = _), (_ = v)
          }
          ;(this.h[0] = u(this.h[0], _)),
            (this.h[1] = u(this.h[1], A)),
            (this.h[2] = u(this.h[2], T)),
            (this.h[3] = u(this.h[3], E)),
            (this.h[4] = u(this.h[4], k))
        }),
        (f.prototype._digest = function (y) {
          return y === 'hex' ? t.toHex32(this.h, 'big') : t.split32(this.h, 'big')
        })
    }
  }),
  Z9 = te({
    'node_modules/hash.js/lib/hash/sha/256.js'(e, r) {
      V(), F()
      var t = qn(),
        n = Kc(),
        i = Y9(),
        s = As(),
        u = t.sum32,
        o = t.sum32_4,
        l = t.sum32_5,
        a = i.ch32,
        c = i.maj32,
        f = i.s0_256,
        p = i.s1_256,
        y = i.g0_256,
        d = i.g1_256,
        h = n.BlockHash,
        m = [
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080,
          310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
          264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808,
          3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
          1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817,
          3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
          1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
          3329325298
        ]
      function _() {
        if (!(this instanceof _)) return new _()
        h.call(this),
          (this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
          (this.k = m),
          (this.W = new Array(64))
      }
      t.inherits(_, h),
        (r.exports = _),
        (_.blockSize = 512),
        (_.outSize = 256),
        (_.hmacStrength = 192),
        (_.padLength = 64),
        (_.prototype._update = function (T, E) {
          for (var k = this.W, w = 0; w < 16; w++) k[w] = T[E + w]
          for (; w < k.length; w++) k[w] = o(d(k[w - 2]), k[w - 7], y(k[w - 15]), k[w - 16])
          var v = this.h[0],
            I = this.h[1],
            M = this.h[2],
            q = this.h[3],
            G = this.h[4],
            O = this.h[5],
            x = this.h[6],
            L = this.h[7]
          for (s(this.k.length === k.length), w = 0; w < k.length; w++) {
            var K = l(L, p(G), a(G, O, x), this.k[w], k[w]),
              J = u(f(v), c(v, I, M))
            ;(L = x), (x = O), (O = G), (G = u(q, K)), (q = M), (M = I), (I = v), (v = u(K, J))
          }
          ;(this.h[0] = u(this.h[0], v)),
            (this.h[1] = u(this.h[1], I)),
            (this.h[2] = u(this.h[2], M)),
            (this.h[3] = u(this.h[3], q)),
            (this.h[4] = u(this.h[4], G)),
            (this.h[5] = u(this.h[5], O)),
            (this.h[6] = u(this.h[6], x)),
            (this.h[7] = u(this.h[7], L))
        }),
        (_.prototype._digest = function (T) {
          return T === 'hex' ? t.toHex32(this.h, 'big') : t.split32(this.h, 'big')
        })
    }
  }),
  TO = te({
    'node_modules/hash.js/lib/hash/sha/224.js'(e, r) {
      V(), F()
      var t = qn(),
        n = Z9()
      function i() {
        if (!(this instanceof i)) return new i()
        n.call(this),
          (this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428])
      }
      t.inherits(i, n),
        (r.exports = i),
        (i.blockSize = 512),
        (i.outSize = 224),
        (i.hmacStrength = 192),
        (i.padLength = 64),
        (i.prototype._digest = function (u) {
          return u === 'hex' ? t.toHex32(this.h.slice(0, 7), 'big') : t.split32(this.h.slice(0, 7), 'big')
        })
    }
  }),
  Q9 = te({
    'node_modules/hash.js/lib/hash/sha/512.js'(e, r) {
      V(), F()
      var t = qn(),
        n = Kc(),
        i = As(),
        s = t.rotr64_hi,
        u = t.rotr64_lo,
        o = t.shr64_hi,
        l = t.shr64_lo,
        a = t.sum64,
        c = t.sum64_hi,
        f = t.sum64_lo,
        p = t.sum64_4_hi,
        y = t.sum64_4_lo,
        d = t.sum64_5_hi,
        h = t.sum64_5_lo,
        m = n.BlockHash,
        _ = [
          1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163,
          4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394,
          310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206,
          991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139,
          264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692,
          3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879,
          3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895,
          168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823,
          1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921,
          1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344,
          3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616,
          1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403,
          1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452,
          2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573,
          3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271,
          4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315,
          685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470,
          3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591
        ]
      function A() {
        if (!(this instanceof A)) return new A()
        m.call(this),
          (this.h = [
            1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119,
            2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209
          ]),
          (this.k = _),
          (this.W = new Array(160))
      }
      t.inherits(A, m),
        (r.exports = A),
        (A.blockSize = 1024),
        (A.outSize = 512),
        (A.hmacStrength = 192),
        (A.padLength = 128),
        (A.prototype._prepareBlock = function (J, Z) {
          for (var Q = this.W, fe = 0; fe < 32; fe++) Q[fe] = J[Z + fe]
          for (; fe < Q.length; fe += 2) {
            var ie = x(Q[fe - 4], Q[fe - 3]),
              W = L(Q[fe - 4], Q[fe - 3]),
              le = Q[fe - 14],
              xe = Q[fe - 13],
              _e = G(Q[fe - 30], Q[fe - 29]),
              Ne = O(Q[fe - 30], Q[fe - 29]),
              ke = Q[fe - 32],
              oe = Q[fe - 31]
            ;(Q[fe] = p(ie, W, le, xe, _e, Ne, ke, oe)), (Q[fe + 1] = y(ie, W, le, xe, _e, Ne, ke, oe))
          }
        }),
        (A.prototype._update = function (J, Z) {
          this._prepareBlock(J, Z)
          var Q = this.W,
            fe = this.h[0],
            ie = this.h[1],
            W = this.h[2],
            le = this.h[3],
            xe = this.h[4],
            _e = this.h[5],
            Ne = this.h[6],
            ke = this.h[7],
            oe = this.h[8],
            be = this.h[9],
            ge = this.h[10],
            re = this.h[11],
            j = this.h[12],
            b = this.h[13],
            C = this.h[14],
            S = this.h[15]
          i(this.k.length === Q.length)
          for (var R = 0; R < Q.length; R += 2) {
            var P = C,
              B = S,
              D = M(oe, be),
              $ = q(oe, be),
              g = T(oe, be, ge, re, j, b),
              N = E(oe, be, ge, re, j, b),
              U = this.k[R],
              X = this.k[R + 1],
              ne = Q[R],
              ee = Q[R + 1],
              ae = d(P, B, D, $, g, N, U, X, ne, ee),
              Y = h(P, B, D, $, g, N, U, X, ne, ee)
            ;(P = v(fe, ie)), (B = I(fe, ie)), (D = k(fe, ie, W, le, xe, _e)), ($ = w(fe, ie, W, le, xe, _e))
            var z = c(P, B, D, $),
              H = f(P, B, D, $)
            ;(C = j),
              (S = b),
              (j = ge),
              (b = re),
              (ge = oe),
              (re = be),
              (oe = c(Ne, ke, ae, Y)),
              (be = f(ke, ke, ae, Y)),
              (Ne = xe),
              (ke = _e),
              (xe = W),
              (_e = le),
              (W = fe),
              (le = ie),
              (fe = c(ae, Y, z, H)),
              (ie = f(ae, Y, z, H))
          }
          a(this.h, 0, fe, ie),
            a(this.h, 2, W, le),
            a(this.h, 4, xe, _e),
            a(this.h, 6, Ne, ke),
            a(this.h, 8, oe, be),
            a(this.h, 10, ge, re),
            a(this.h, 12, j, b),
            a(this.h, 14, C, S)
        }),
        (A.prototype._digest = function (J) {
          return J === 'hex' ? t.toHex32(this.h, 'big') : t.split32(this.h, 'big')
        })
      function T(K, J, Z, Q, fe) {
        var ie = (K & Z) ^ (~K & fe)
        return ie < 0 && (ie += 4294967296), ie
      }
      function E(K, J, Z, Q, fe, ie) {
        var W = (J & Q) ^ (~J & ie)
        return W < 0 && (W += 4294967296), W
      }
      function k(K, J, Z, Q, fe) {
        var ie = (K & Z) ^ (K & fe) ^ (Z & fe)
        return ie < 0 && (ie += 4294967296), ie
      }
      function w(K, J, Z, Q, fe, ie) {
        var W = (J & Q) ^ (J & ie) ^ (Q & ie)
        return W < 0 && (W += 4294967296), W
      }
      function v(K, J) {
        var Z = s(K, J, 28),
          Q = s(J, K, 2),
          fe = s(J, K, 7),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
      function I(K, J) {
        var Z = u(K, J, 28),
          Q = u(J, K, 2),
          fe = u(J, K, 7),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
      function M(K, J) {
        var Z = s(K, J, 14),
          Q = s(K, J, 18),
          fe = s(J, K, 9),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
      function q(K, J) {
        var Z = u(K, J, 14),
          Q = u(K, J, 18),
          fe = u(J, K, 9),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
      function G(K, J) {
        var Z = s(K, J, 1),
          Q = s(K, J, 8),
          fe = o(K, J, 7),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
      function O(K, J) {
        var Z = u(K, J, 1),
          Q = u(K, J, 8),
          fe = l(K, J, 7),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
      function x(K, J) {
        var Z = s(K, J, 19),
          Q = s(J, K, 29),
          fe = o(K, J, 6),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
      function L(K, J) {
        var Z = u(K, J, 19),
          Q = u(J, K, 29),
          fe = l(K, J, 6),
          ie = Z ^ Q ^ fe
        return ie < 0 && (ie += 4294967296), ie
      }
    }
  }),
  CO = te({
    'node_modules/hash.js/lib/hash/sha/384.js'(e, r) {
      V(), F()
      var t = qn(),
        n = Q9()
      function i() {
        if (!(this instanceof i)) return new i()
        n.call(this),
          (this.h = [
            3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415,
            4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428
          ])
      }
      t.inherits(i, n),
        (r.exports = i),
        (i.blockSize = 1024),
        (i.outSize = 384),
        (i.hmacStrength = 192),
        (i.padLength = 128),
        (i.prototype._digest = function (u) {
          return u === 'hex' ? t.toHex32(this.h.slice(0, 12), 'big') : t.split32(this.h.slice(0, 12), 'big')
        })
    }
  }),
  kO = te({
    'node_modules/hash.js/lib/hash/sha.js'(e) {
      V(), F(), (e.sha1 = IO()), (e.sha224 = TO()), (e.sha256 = Z9()), (e.sha384 = CO()), (e.sha512 = Q9())
    }
  }),
  MO = te({
    'node_modules/hash.js/lib/hash/ripemd.js'(e) {
      V(), F()
      var r = qn(),
        t = Kc(),
        n = r.rotl32,
        i = r.sum32,
        s = r.sum32_3,
        u = r.sum32_4,
        o = t.BlockHash
      function l() {
        if (!(this instanceof l)) return new l()
        o.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.endian = 'little')
      }
      r.inherits(l, o),
        (e.ripemd160 = l),
        (l.blockSize = 512),
        (l.outSize = 160),
        (l.hmacStrength = 192),
        (l.padLength = 64),
        (l.prototype._update = function (_, A) {
          for (
            var T = this.h[0],
              E = this.h[1],
              k = this.h[2],
              w = this.h[3],
              v = this.h[4],
              I = T,
              M = E,
              q = k,
              G = w,
              O = v,
              x = 0;
            x < 80;
            x++
          ) {
            var L = i(n(u(T, a(x, E, k, w), _[p[x] + A], c(x)), d[x]), v)
            ;(T = v),
              (v = w),
              (w = n(k, 10)),
              (k = E),
              (E = L),
              (L = i(n(u(I, a(79 - x, M, q, G), _[y[x] + A], f(x)), h[x]), O)),
              (I = O),
              (O = G),
              (G = n(q, 10)),
              (q = M),
              (M = L)
          }
          ;(L = s(this.h[1], k, G)),
            (this.h[1] = s(this.h[2], w, O)),
            (this.h[2] = s(this.h[3], v, I)),
            (this.h[3] = s(this.h[4], T, M)),
            (this.h[4] = s(this.h[0], E, q)),
            (this.h[0] = L)
        }),
        (l.prototype._digest = function (_) {
          return _ === 'hex' ? r.toHex32(this.h, 'little') : r.split32(this.h, 'little')
        })
      function a(m, _, A, T) {
        return m <= 15
          ? _ ^ A ^ T
          : m <= 31
          ? (_ & A) | (~_ & T)
          : m <= 47
          ? (_ | ~A) ^ T
          : m <= 63
          ? (_ & T) | (A & ~T)
          : _ ^ (A | ~T)
      }
      function c(m) {
        return m <= 15 ? 0 : m <= 31 ? 1518500249 : m <= 47 ? 1859775393 : m <= 63 ? 2400959708 : 2840853838
      }
      function f(m) {
        return m <= 15 ? 1352829926 : m <= 31 ? 1548603684 : m <= 47 ? 1836072691 : m <= 63 ? 2053994217 : 0
      }
      var p = [
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3,
          10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0,
          5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
        ],
        y = [
          5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
          15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
          12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
        ],
        d = [
          11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13,
          12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6,
          5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
        ],
        h = [
          8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13,
          11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5,
          15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
        ]
    }
  }),
  xO = te({
    'node_modules/hash.js/lib/hash/hmac.js'(e, r) {
      V(), F()
      var t = qn(),
        n = As()
      function i(s, u, o) {
        if (!(this instanceof i)) return new i(s, u, o)
        ;(this.Hash = s),
          (this.blockSize = s.blockSize / 8),
          (this.outSize = s.outSize / 8),
          (this.inner = null),
          (this.outer = null),
          this._init(t.toArray(u, o))
      }
      ;(r.exports = i),
        (i.prototype._init = function (u) {
          u.length > this.blockSize && (u = new this.Hash().update(u).digest()), n(u.length <= this.blockSize)
          for (var o = u.length; o < this.blockSize; o++) u.push(0)
          for (o = 0; o < u.length; o++) u[o] ^= 54
          for (this.inner = new this.Hash().update(u), o = 0; o < u.length; o++) u[o] ^= 106
          this.outer = new this.Hash().update(u)
        }),
        (i.prototype.update = function (u, o) {
          return this.inner.update(u, o), this
        }),
        (i.prototype.digest = function (u) {
          return this.outer.update(this.inner.digest()), this.outer.digest(u)
        })
    }
  }),
  y1 = te({
    'node_modules/hash.js/lib/hash.js'(e) {
      V(), F()
      var r = e
      ;(r.utils = qn()),
        (r.common = Kc()),
        (r.sha = kO()),
        (r.ripemd = MO()),
        (r.hmac = xO()),
        (r.sha1 = r.sha.sha1),
        (r.sha256 = r.sha.sha256),
        (r.sha224 = r.sha.sha224),
        (r.sha384 = r.sha.sha384),
        (r.sha512 = r.sha.sha512),
        (r.ripemd160 = r.ripemd.ripemd160)
    }
  }),
  RO = te({
    'node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js'(e, r) {
      V(),
        F(),
        (r.exports = {
          doubles: {
            step: 4,
            points: [
              [
                'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
                'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
              ],
              [
                '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
                '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
              ],
              [
                '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
                'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
              ],
              [
                '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
                '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
              ],
              [
                '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
                '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
              ],
              [
                '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
                '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
              ],
              [
                'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
                '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
              ],
              [
                '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
                'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
              ],
              [
                'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
                '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
              ],
              [
                'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
                'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
              ],
              [
                'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
                '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
              ],
              [
                '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
                '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
              ],
              [
                '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
                '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
              ],
              [
                '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
                '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
              ],
              [
                '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
                '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
              ],
              [
                '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
                '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
              ],
              [
                '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
                '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
              ],
              [
                '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
                '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
              ],
              [
                '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
                'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
              ],
              [
                'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
                '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
              ],
              [
                'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
                '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
              ],
              [
                '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
                '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
              ],
              [
                '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
                '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
              ],
              [
                'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
                '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
              ],
              [
                '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
                'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
              ],
              [
                'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
                '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
              ],
              [
                'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
                'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
              ],
              [
                'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
                '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
              ],
              [
                'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
                'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
              ],
              [
                'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
                '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
              ],
              [
                '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
                'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
              ],
              [
                '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
                '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
              ],
              [
                'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
                '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
              ],
              [
                '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
                'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
              ],
              [
                'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
                '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
              ],
              [
                'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
                '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
              ],
              [
                'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
                'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
              ],
              [
                '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
                '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
              ],
              [
                '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
                '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
              ],
              [
                '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
                'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
              ],
              [
                '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
                '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
              ],
              [
                'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
                '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
              ],
              [
                '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
                '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
              ],
              [
                '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
                'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
              ],
              [
                '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
                '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
              ],
              [
                'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
                '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
              ],
              [
                '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
                'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
              ],
              [
                'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
                'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
              ],
              [
                'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
                '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
              ],
              [
                '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
                'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
              ],
              [
                '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
                'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
              ],
              [
                'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
                '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
              ],
              [
                'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
                '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
              ],
              [
                'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
                '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
              ],
              [
                '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
                'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
              ],
              [
                '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
                '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
              ],
              [
                'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
                'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
              ],
              [
                '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
                'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
              ],
              [
                '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
                '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
              ],
              [
                '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
                '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
              ],
              [
                'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
                'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
              ],
              [
                '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
                '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
              ],
              [
                '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
                '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
              ],
              [
                'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
                '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
              ],
              [
                'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
                'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
              ]
            ]
          },
          naf: {
            wnd: 7,
            points: [
              [
                'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
                '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
              ],
              [
                '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
                'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
              ],
              [
                '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
                '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
              ],
              [
                'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
                'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
              ],
              [
                '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
                'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
              ],
              [
                'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
                'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
              ],
              [
                'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
                '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
              ],
              [
                'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
                '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
              ],
              [
                '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
                '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
              ],
              [
                '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
                '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
              ],
              [
                '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
                '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
              ],
              [
                '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
                '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
              ],
              [
                'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
                'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
              ],
              [
                'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
                '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
              ],
              [
                '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
                'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
              ],
              [
                '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
                'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
              ],
              [
                '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
                '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
              ],
              [
                '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
                '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
              ],
              [
                '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
                '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
              ],
              [
                '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
                'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
              ],
              [
                'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
                'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
              ],
              [
                '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
                '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
              ],
              [
                '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
                '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
              ],
              [
                'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
                'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
              ],
              [
                '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
                '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
              ],
              [
                'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
                'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
              ],
              [
                'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
                'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
              ],
              [
                '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
                '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
              ],
              [
                '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
                '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
              ],
              [
                '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
                '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
              ],
              [
                'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
                '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
              ],
              [
                '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
                '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
              ],
              [
                'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
                '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
              ],
              [
                '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
                'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
              ],
              [
                '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
                'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
              ],
              [
                'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
                'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
              ],
              [
                '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
                '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
              ],
              [
                '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
                'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
              ],
              [
                'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
                'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
              ],
              [
                '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
                '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
              ],
              [
                '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
                'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
              ],
              [
                '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
                '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
              ],
              [
                '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
                'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
              ],
              [
                'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
                '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
              ],
              [
                '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
                '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
              ],
              [
                '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
                'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
              ],
              [
                '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
                'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
              ],
              [
                'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
                'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
              ],
              [
                'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
                'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
              ],
              [
                '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
                '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
              ],
              [
                '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
                '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
              ],
              [
                'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
                '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
              ],
              [
                'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
                'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
              ],
              [
                '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
                '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
              ],
              [
                '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
                '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
              ],
              [
                'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
                '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
              ],
              [
                '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
                '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
              ],
              [
                'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
                'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
              ],
              [
                '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
                'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
              ],
              [
                '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
                '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
              ],
              [
                'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
                '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
              ],
              [
                'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
                '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
              ],
              [
                '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
                '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
              ],
              [
                '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
                '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
              ],
              [
                '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
                'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
              ],
              [
                '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
                'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
              ],
              [
                '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
                '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
              ],
              [
                '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
                '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
              ],
              [
                '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
                '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
              ],
              [
                '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
                'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
              ],
              [
                'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
                'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
              ],
              [
                '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
                'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
              ],
              [
                'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
                '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
              ],
              [
                'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
                '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
              ],
              [
                'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
                '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
              ],
              [
                'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
                '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
              ],
              [
                '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
                'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
              ],
              [
                '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
                '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
              ],
              [
                '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
                'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
              ],
              [
                'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
                'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
              ],
              [
                'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
                '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
              ],
              [
                'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
                'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
              ],
              [
                'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
                '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
              ],
              [
                '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
                '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
              ],
              [
                'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
                '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
              ],
              [
                'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
                '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
              ],
              [
                '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
                '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
              ],
              [
                '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
                'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
              ],
              [
                'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
                '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
              ],
              [
                'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
                '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
              ],
              [
                'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
                '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
              ],
              [
                '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
                '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
              ],
              [
                'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
                'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
              ],
              [
                '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
                'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
              ],
              [
                'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
                'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
              ],
              [
                'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
                '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
              ],
              [
                '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
                'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
              ],
              [
                'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
                '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
              ],
              [
                'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
                '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
              ],
              [
                'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
                '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
              ],
              [
                '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
                'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
              ],
              [
                '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
                'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
              ],
              [
                'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
                '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
              ],
              [
                '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
                'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
              ],
              [
                '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
                '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
              ],
              [
                '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
                'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
              ],
              [
                'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
                'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
              ],
              [
                '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
                'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
              ],
              [
                '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
                '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
              ],
              [
                '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
                'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
              ],
              [
                '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
                '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
              ],
              [
                'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
                'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
              ],
              [
                '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
                '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
              ],
              [
                'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
                '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
              ],
              [
                '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
                '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
              ],
              [
                'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
                'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
              ],
              [
                'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
                '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
              ],
              [
                'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
                'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
              ],
              [
                '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
                'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
              ],
              [
                '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
                '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
              ],
              [
                '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
                'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
              ],
              [
                '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
                '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
              ],
              [
                '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
                '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
              ],
              [
                '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
                'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
              ],
              [
                '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
                '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
              ],
              [
                '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
                '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
              ],
              [
                '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
                '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
              ]
            ]
          }
        })
    }
  }),
  v1 = te({
    'node_modules/elliptic/lib/elliptic/curves.js'(e) {
      V(), F()
      var r = e,
        t = y1(),
        n = X9(),
        i = fn(),
        s = i.assert
      function u(a) {
        a.type === 'short'
          ? (this.curve = new n.short(a))
          : a.type === 'edwards'
          ? (this.curve = new n.edwards(a))
          : (this.curve = new n.mont(a)),
          (this.g = this.curve.g),
          (this.n = this.curve.n),
          (this.hash = a.hash),
          s(this.g.validate(), 'Invalid curve'),
          s(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O')
      }
      r.PresetCurve = u
      function o(a, c) {
        Object.defineProperty(r, a, {
          configurable: !0,
          enumerable: !0,
          get: function () {
            var f = new u(c)
            return Object.defineProperty(r, a, { configurable: !0, enumerable: !0, value: f }), f
          }
        })
      }
      o('p192', {
        type: 'short',
        prime: 'p192',
        p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
        b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
        n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
        hash: t.sha256,
        gRed: !1,
        g: [
          '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
          '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
        ]
      }),
        o('p224', {
          type: 'short',
          prime: 'p224',
          p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
          a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
          b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
          n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
          hash: t.sha256,
          gRed: !1,
          g: [
            'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
            'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
          ]
        }),
        o('p256', {
          type: 'short',
          prime: null,
          p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
          a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
          b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
          n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
          hash: t.sha256,
          gRed: !1,
          g: [
            '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
            '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
          ]
        }),
        o('p384', {
          type: 'short',
          prime: null,
          p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff',
          a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc',
          b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
          n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
          hash: t.sha384,
          gRed: !1,
          g: [
            'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7',
            '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
          ]
        }),
        o('p521', {
          type: 'short',
          prime: null,
          p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff',
          a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc',
          b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
          n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
          hash: t.sha512,
          gRed: !1,
          g: [
            '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
            '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650'
          ]
        }),
        o('curve25519', {
          type: 'mont',
          prime: 'p25519',
          p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
          a: '76d06',
          b: '1',
          n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
          hash: t.sha256,
          gRed: !1,
          g: ['9']
        }),
        o('ed25519', {
          type: 'edwards',
          prime: 'p25519',
          p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
          a: '-1',
          c: '1',
          d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
          n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
          hash: t.sha256,
          gRed: !1,
          g: [
            '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
            '6666666666666666666666666666666666666666666666666666666666666658'
          ]
        })
      var l
      try {
        l = RO()
      } catch (a) {
        l = void 0
      }
      o('secp256k1', {
        type: 'short',
        prime: 'k256',
        p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
        a: '0',
        b: '7',
        n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
        h: '1',
        hash: t.sha256,
        beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
        lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
        basis: [
          { a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' },
          { a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' }
        ],
        gRed: !1,
        g: [
          '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
          '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
          l
        ]
      })
    }
  }),
  BO = te({
    'node_modules/hmac-drbg/lib/hmac-drbg.js'(e, r) {
      V(), F()
      var t = y1(),
        n = W9(),
        i = As()
      function s(u) {
        if (!(this instanceof s)) return new s(u)
        ;(this.hash = u.hash),
          (this.predResist = !!u.predResist),
          (this.outLen = this.hash.outSize),
          (this.minEntropy = u.minEntropy || this.hash.hmacStrength),
          (this._reseed = null),
          (this.reseedInterval = null),
          (this.K = null),
          (this.V = null)
        var o = n.toArray(u.entropy, u.entropyEnc || 'hex'),
          l = n.toArray(u.nonce, u.nonceEnc || 'hex'),
          a = n.toArray(u.pers, u.persEnc || 'hex')
        i(o.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'),
          this._init(o, l, a)
      }
      ;(r.exports = s),
        (s.prototype._init = function (o, l, a) {
          var c = o.concat(l).concat(a)
          ;(this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8))
          for (var f = 0; f < this.V.length; f++) (this.K[f] = 0), (this.V[f] = 1)
          this._update(c), (this._reseed = 1), (this.reseedInterval = 281474976710656)
        }),
        (s.prototype._hmac = function () {
          return new t.hmac(this.hash, this.K)
        }),
        (s.prototype._update = function (o) {
          var l = this._hmac().update(this.V).update([0])
          o && (l = l.update(o)),
            (this.K = l.digest()),
            (this.V = this._hmac().update(this.V).digest()),
            !!o &&
              ((this.K = this._hmac().update(this.V).update([1]).update(o).digest()),
              (this.V = this._hmac().update(this.V).digest()))
        }),
        (s.prototype.reseed = function (o, l, a, c) {
          typeof l != 'string' && ((c = a), (a = l), (l = null)),
            (o = n.toArray(o, l)),
            (a = n.toArray(a, c)),
            i(o.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'),
            this._update(o.concat(a || [])),
            (this._reseed = 1)
        }),
        (s.prototype.generate = function (o, l, a, c) {
          if (this._reseed > this.reseedInterval) throw new Error('Reseed is required')
          typeof l != 'string' && ((c = a), (a = l), (l = null)), a && ((a = n.toArray(a, c || 'hex')), this._update(a))
          for (var f = []; f.length < o; ) (this.V = this._hmac().update(this.V).digest()), (f = f.concat(this.V))
          var p = f.slice(0, o)
          return this._update(a), this._reseed++, n.encode(p, l)
        })
    }
  }),
  NO = te({
    'node_modules/elliptic/lib/elliptic/ec/key.js'(e, r) {
      V(), F()
      var t = ai(),
        n = fn(),
        i = n.assert
      function s(u, o) {
        ;(this.ec = u),
          (this.priv = null),
          (this.pub = null),
          o.priv && this._importPrivate(o.priv, o.privEnc),
          o.pub && this._importPublic(o.pub, o.pubEnc)
      }
      ;(r.exports = s),
        (s.fromPublic = function (o, l, a) {
          return l instanceof s ? l : new s(o, { pub: l, pubEnc: a })
        }),
        (s.fromPrivate = function (o, l, a) {
          return l instanceof s ? l : new s(o, { priv: l, privEnc: a })
        }),
        (s.prototype.validate = function () {
          var o = this.getPublic()
          return o.isInfinity()
            ? { result: !1, reason: 'Invalid public key' }
            : o.validate()
            ? o.mul(this.ec.curve.n).isInfinity()
              ? { result: !0, reason: null }
              : { result: !1, reason: 'Public key * N != O' }
            : { result: !1, reason: 'Public key is not a point' }
        }),
        (s.prototype.getPublic = function (o, l) {
          return (
            typeof o == 'string' && ((l = o), (o = null)),
            this.pub || (this.pub = this.ec.g.mul(this.priv)),
            l ? this.pub.encode(l, o) : this.pub
          )
        }),
        (s.prototype.getPrivate = function (o) {
          return o === 'hex' ? this.priv.toString(16, 2) : this.priv
        }),
        (s.prototype._importPrivate = function (o, l) {
          ;(this.priv = new t(o, l || 16)), (this.priv = this.priv.umod(this.ec.curve.n))
        }),
        (s.prototype._importPublic = function (o, l) {
          if (o.x || o.y) {
            this.ec.curve.type === 'mont'
              ? i(o.x, 'Need x coordinate')
              : (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') &&
                i(o.x && o.y, 'Need both x and y coordinate'),
              (this.pub = this.ec.curve.point(o.x, o.y))
            return
          }
          this.pub = this.ec.curve.decodePoint(o, l)
        }),
        (s.prototype.derive = function (o) {
          return o.validate() || i(o.validate(), 'public point not validated'), o.mul(this.priv).getX()
        }),
        (s.prototype.sign = function (o, l, a) {
          return this.ec.sign(o, this, l, a)
        }),
        (s.prototype.verify = function (o, l) {
          return this.ec.verify(o, l, this)
        }),
        (s.prototype.inspect = function () {
          return (
            '<Key priv: ' +
            (this.priv && this.priv.toString(16, 2)) +
            ' pub: ' +
            (this.pub && this.pub.inspect()) +
            ' >'
          )
        })
    }
  }),
  PO = te({
    'node_modules/elliptic/lib/elliptic/ec/signature.js'(e, r) {
      V(), F()
      var t = ai(),
        n = fn(),
        i = n.assert
      function s(c, f) {
        if (c instanceof s) return c
        this._importDER(c, f) ||
          (i(c.r && c.s, 'Signature without r or s'),
          (this.r = new t(c.r, 16)),
          (this.s = new t(c.s, 16)),
          c.recoveryParam === void 0 ? (this.recoveryParam = null) : (this.recoveryParam = c.recoveryParam))
      }
      r.exports = s
      function u() {
        this.place = 0
      }
      function o(c, f) {
        var p = c[f.place++]
        if (!(p & 128)) return p
        var y = p & 15
        if (y === 0 || y > 4) return !1
        for (var d = 0, h = 0, m = f.place; h < y; h++, m++) (d <<= 8), (d |= c[m]), (d >>>= 0)
        return d <= 127 ? !1 : ((f.place = m), d)
      }
      function l(c) {
        for (var f = 0, p = c.length - 1; !c[f] && !(c[f + 1] & 128) && f < p; ) f++
        return f === 0 ? c : c.slice(f)
      }
      s.prototype._importDER = function (f, p) {
        f = n.toArray(f, p)
        var y = new u()
        if (f[y.place++] !== 48) return !1
        var d = o(f, y)
        if (d === !1 || d + y.place !== f.length || f[y.place++] !== 2) return !1
        var h = o(f, y)
        if (h === !1) return !1
        var m = f.slice(y.place, h + y.place)
        if (((y.place += h), f[y.place++] !== 2)) return !1
        var _ = o(f, y)
        if (_ === !1 || f.length !== _ + y.place) return !1
        var A = f.slice(y.place, _ + y.place)
        if (m[0] === 0)
          if (m[1] & 128) m = m.slice(1)
          else return !1
        if (A[0] === 0)
          if (A[1] & 128) A = A.slice(1)
          else return !1
        return (this.r = new t(m)), (this.s = new t(A)), (this.recoveryParam = null), !0
      }
      function a(c, f) {
        if (f < 128) {
          c.push(f)
          return
        }
        var p = 1 + ((Math.log(f) / Math.LN2) >>> 3)
        for (c.push(p | 128); --p; ) c.push((f >>> (p << 3)) & 255)
        c.push(f)
      }
      s.prototype.toDER = function (f) {
        var p = this.r.toArray(),
          y = this.s.toArray()
        for (
          p[0] & 128 && (p = [0].concat(p)), y[0] & 128 && (y = [0].concat(y)), p = l(p), y = l(y);
          !y[0] && !(y[1] & 128);

        )
          y = y.slice(1)
        var d = [2]
        a(d, p.length), (d = d.concat(p)), d.push(2), a(d, y.length)
        var h = d.concat(y),
          m = [48]
        return a(m, h.length), (m = m.concat(h)), n.encode(m, f)
      }
    }
  }),
  OO = te({
    'node_modules/elliptic/lib/elliptic/ec/index.js'(e, r) {
      V(), F()
      var t = ai(),
        n = BO(),
        i = fn(),
        s = v1(),
        u = J9(),
        o = i.assert,
        l = NO(),
        a = PO()
      function c(f) {
        if (!(this instanceof c)) return new c(f)
        typeof f == 'string' && (o(Object.prototype.hasOwnProperty.call(s, f), 'Unknown curve ' + f), (f = s[f])),
          f instanceof s.PresetCurve && (f = { curve: f }),
          (this.curve = f.curve.curve),
          (this.n = this.curve.n),
          (this.nh = this.n.ushrn(1)),
          (this.g = this.curve.g),
          (this.g = f.curve.g),
          this.g.precompute(f.curve.n.bitLength() + 1),
          (this.hash = f.hash || f.curve.hash)
      }
      ;(r.exports = c),
        (c.prototype.keyPair = function (p) {
          return new l(this, p)
        }),
        (c.prototype.keyFromPrivate = function (p, y) {
          return l.fromPrivate(this, p, y)
        }),
        (c.prototype.keyFromPublic = function (p, y) {
          return l.fromPublic(this, p, y)
        }),
        (c.prototype.genKeyPair = function (p) {
          p || (p = {})
          for (
            var y = new n({
                hash: this.hash,
                pers: p.pers,
                persEnc: p.persEnc || 'utf8',
                entropy: p.entropy || u(this.hash.hmacStrength),
                entropyEnc: (p.entropy && p.entropyEnc) || 'utf8',
                nonce: this.n.toArray()
              }),
              d = this.n.byteLength(),
              h = this.n.sub(new t(2));
            ;

          ) {
            var m = new t(y.generate(d))
            if (!(m.cmp(h) > 0)) return m.iaddn(1), this.keyFromPrivate(m)
          }
        }),
        (c.prototype._truncateToN = function (p, y) {
          var d = p.byteLength() * 8 - this.n.bitLength()
          return d > 0 && (p = p.ushrn(d)), !y && p.cmp(this.n) >= 0 ? p.sub(this.n) : p
        }),
        (c.prototype.sign = function (p, y, d, h) {
          typeof d == 'object' && ((h = d), (d = null)),
            h || (h = {}),
            (y = this.keyFromPrivate(y, d)),
            (p = this._truncateToN(new t(p, 16)))
          for (
            var m = this.n.byteLength(),
              _ = y.getPrivate().toArray('be', m),
              A = p.toArray('be', m),
              T = new n({ hash: this.hash, entropy: _, nonce: A, pers: h.pers, persEnc: h.persEnc || 'utf8' }),
              E = this.n.sub(new t(1)),
              k = 0;
            ;
            k++
          ) {
            var w = h.k ? h.k(k) : new t(T.generate(this.n.byteLength()))
            if (((w = this._truncateToN(w, !0)), !(w.cmpn(1) <= 0 || w.cmp(E) >= 0))) {
              var v = this.g.mul(w)
              if (!v.isInfinity()) {
                var I = v.getX(),
                  M = I.umod(this.n)
                if (M.cmpn(0) !== 0) {
                  var q = w.invm(this.n).mul(M.mul(y.getPrivate()).iadd(p))
                  if (((q = q.umod(this.n)), q.cmpn(0) !== 0)) {
                    var G = (v.getY().isOdd() ? 1 : 0) | (I.cmp(M) !== 0 ? 2 : 0)
                    return (
                      h.canonical && q.cmp(this.nh) > 0 && ((q = this.n.sub(q)), (G ^= 1)),
                      new a({ r: M, s: q, recoveryParam: G })
                    )
                  }
                }
              }
            }
          }
        }),
        (c.prototype.verify = function (p, y, d, h) {
          ;(p = this._truncateToN(new t(p, 16))), (d = this.keyFromPublic(d, h)), (y = new a(y, 'hex'))
          var m = y.r,
            _ = y.s
          if (m.cmpn(1) < 0 || m.cmp(this.n) >= 0 || _.cmpn(1) < 0 || _.cmp(this.n) >= 0) return !1
          var A = _.invm(this.n),
            T = A.mul(p).umod(this.n),
            E = A.mul(m).umod(this.n),
            k
          return this.curve._maxwellTrick
            ? ((k = this.g.jmulAdd(T, d.getPublic(), E)), k.isInfinity() ? !1 : k.eqXToP(m))
            : ((k = this.g.mulAdd(T, d.getPublic(), E)), k.isInfinity() ? !1 : k.getX().umod(this.n).cmp(m) === 0)
        }),
        (c.prototype.recoverPubKey = function (f, p, y, d) {
          o((3 & y) === y, 'The recovery param is more than two bits'), (p = new a(p, d))
          var h = this.n,
            m = new t(f),
            _ = p.r,
            A = p.s,
            T = y & 1,
            E = y >> 1
          if (_.cmp(this.curve.p.umod(this.curve.n)) >= 0 && E) throw new Error('Unable to find sencond key candinate')
          E ? (_ = this.curve.pointFromX(_.add(this.curve.n), T)) : (_ = this.curve.pointFromX(_, T))
          var k = p.r.invm(h),
            w = h.sub(m).mul(k).umod(h),
            v = A.mul(k).umod(h)
          return this.g.mulAdd(w, _, v)
        }),
        (c.prototype.getKeyRecoveryParam = function (f, p, y, d) {
          if (((p = new a(p, d)), p.recoveryParam !== null)) return p.recoveryParam
          for (var h = 0; h < 4; h++) {
            var m
            try {
              m = this.recoverPubKey(f, p, h)
            } catch (_) {
              continue
            }
            if (m.eq(y)) return h
          }
          throw new Error('Unable to find valid recovery factor')
        })
    }
  }),
  DO = te({
    'node_modules/elliptic/lib/elliptic/eddsa/key.js'(e, r) {
      V(), F()
      var t = fn(),
        n = t.assert,
        i = t.parseBytes,
        s = t.cachedProperty
      function u(o, l) {
        ;(this.eddsa = o),
          (this._secret = i(l.secret)),
          o.isPoint(l.pub) ? (this._pub = l.pub) : (this._pubBytes = i(l.pub))
      }
      ;(u.fromPublic = function (l, a) {
        return a instanceof u ? a : new u(l, { pub: a })
      }),
        (u.fromSecret = function (l, a) {
          return a instanceof u ? a : new u(l, { secret: a })
        }),
        (u.prototype.secret = function () {
          return this._secret
        }),
        s(u, 'pubBytes', function () {
          return this.eddsa.encodePoint(this.pub())
        }),
        s(u, 'pub', function () {
          return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv())
        }),
        s(u, 'privBytes', function () {
          var l = this.eddsa,
            a = this.hash(),
            c = l.encodingLength - 1,
            f = a.slice(0, l.encodingLength)
          return (f[0] &= 248), (f[c] &= 127), (f[c] |= 64), f
        }),
        s(u, 'priv', function () {
          return this.eddsa.decodeInt(this.privBytes())
        }),
        s(u, 'hash', function () {
          return this.eddsa.hash().update(this.secret()).digest()
        }),
        s(u, 'messagePrefix', function () {
          return this.hash().slice(this.eddsa.encodingLength)
        }),
        (u.prototype.sign = function (l) {
          return n(this._secret, 'KeyPair can only verify'), this.eddsa.sign(l, this)
        }),
        (u.prototype.verify = function (l, a) {
          return this.eddsa.verify(l, a, this)
        }),
        (u.prototype.getSecret = function (l) {
          return n(this._secret, 'KeyPair is public only'), t.encode(this.secret(), l)
        }),
        (u.prototype.getPublic = function (l) {
          return t.encode(this.pubBytes(), l)
        }),
        (r.exports = u)
    }
  }),
  LO = te({
    'node_modules/elliptic/lib/elliptic/eddsa/signature.js'(e, r) {
      V(), F()
      var t = ai(),
        n = fn(),
        i = n.assert,
        s = n.cachedProperty,
        u = n.parseBytes
      function o(l, a) {
        ;(this.eddsa = l),
          typeof a != 'object' && (a = u(a)),
          Array.isArray(a) && (a = { R: a.slice(0, l.encodingLength), S: a.slice(l.encodingLength) }),
          i(a.R && a.S, 'Signature without R or S'),
          l.isPoint(a.R) && (this._R = a.R),
          a.S instanceof t && (this._S = a.S),
          (this._Rencoded = Array.isArray(a.R) ? a.R : a.Rencoded),
          (this._Sencoded = Array.isArray(a.S) ? a.S : a.Sencoded)
      }
      s(o, 'S', function () {
        return this.eddsa.decodeInt(this.Sencoded())
      }),
        s(o, 'R', function () {
          return this.eddsa.decodePoint(this.Rencoded())
        }),
        s(o, 'Rencoded', function () {
          return this.eddsa.encodePoint(this.R())
        }),
        s(o, 'Sencoded', function () {
          return this.eddsa.encodeInt(this.S())
        }),
        (o.prototype.toBytes = function () {
          return this.Rencoded().concat(this.Sencoded())
        }),
        (o.prototype.toHex = function () {
          return n.encode(this.toBytes(), 'hex').toUpperCase()
        }),
        (r.exports = o)
    }
  }),
  UO = te({
    'node_modules/elliptic/lib/elliptic/eddsa/index.js'(e, r) {
      V(), F()
      var t = y1(),
        n = v1(),
        i = fn(),
        s = i.assert,
        u = i.parseBytes,
        o = DO(),
        l = LO()
      function a(c) {
        if ((s(c === 'ed25519', 'only tested with ed25519 so far'), !(this instanceof a))) return new a(c)
        ;(c = n[c].curve),
          (this.curve = c),
          (this.g = c.g),
          this.g.precompute(c.n.bitLength() + 1),
          (this.pointClass = c.point().constructor),
          (this.encodingLength = Math.ceil(c.n.bitLength() / 8)),
          (this.hash = t.sha512)
      }
      ;(r.exports = a),
        (a.prototype.sign = function (f, p) {
          f = u(f)
          var y = this.keyFromSecret(p),
            d = this.hashInt(y.messagePrefix(), f),
            h = this.g.mul(d),
            m = this.encodePoint(h),
            _ = this.hashInt(m, y.pubBytes(), f).mul(y.priv()),
            A = d.add(_).umod(this.curve.n)
          return this.makeSignature({ R: h, S: A, Rencoded: m })
        }),
        (a.prototype.verify = function (f, p, y) {
          ;(f = u(f)), (p = this.makeSignature(p))
          var d = this.keyFromPublic(y),
            h = this.hashInt(p.Rencoded(), d.pubBytes(), f),
            m = this.g.mul(p.S()),
            _ = p.R().add(d.pub().mul(h))
          return _.eq(m)
        }),
        (a.prototype.hashInt = function () {
          for (var f = this.hash(), p = 0; p < arguments.length; p++) f.update(arguments[p])
          return i.intFromLE(f.digest()).umod(this.curve.n)
        }),
        (a.prototype.keyFromPublic = function (f) {
          return o.fromPublic(this, f)
        }),
        (a.prototype.keyFromSecret = function (f) {
          return o.fromSecret(this, f)
        }),
        (a.prototype.makeSignature = function (f) {
          return f instanceof l ? f : new l(this, f)
        }),
        (a.prototype.encodePoint = function (f) {
          var p = f.getY().toArray('le', this.encodingLength)
          return (p[this.encodingLength - 1] |= f.getX().isOdd() ? 128 : 0), p
        }),
        (a.prototype.decodePoint = function (f) {
          f = i.parseBytes(f)
          var p = f.length - 1,
            y = f.slice(0, p).concat(f[p] & ~128),
            d = (f[p] & 128) != 0,
            h = i.intFromLE(y)
          return this.curve.pointFromY(h, d)
        }),
        (a.prototype.encodeInt = function (f) {
          return f.toArray('le', this.encodingLength)
        }),
        (a.prototype.decodeInt = function (f) {
          return i.intFromLE(f)
        }),
        (a.prototype.isPoint = function (f) {
          return f instanceof this.pointClass
        })
    }
  }),
  qO = te({
    'node_modules/elliptic/lib/elliptic.js'(e) {
      V(), F()
      var r = e
      ;(r.version = wO().version),
        (r.utils = fn()),
        (r.rand = J9()),
        (r.curve = X9()),
        (r.curves = v1()),
        (r.ec = OO()),
        (r.eddsa = UO())
    }
  }),
  jO = te({
    'node_modules/secp256k1/lib/elliptic.js'(e, r) {
      V(), F()
      var t = qO().ec,
        n = new t('secp256k1'),
        i = n.curve,
        s = i.n.constructor
      function u(c, f) {
        let p = new s(f)
        if (p.cmp(i.p) >= 0) return null
        p = p.toRed(i.red)
        let y = p.redSqr().redIMul(p).redIAdd(i.b).redSqrt()
        return (c === 3) !== y.isOdd() && (y = y.redNeg()), n.keyPair({ pub: { x: p, y } })
      }
      function o(c, f, p) {
        let y = new s(f),
          d = new s(p)
        if (
          y.cmp(i.p) >= 0 ||
          d.cmp(i.p) >= 0 ||
          ((y = y.toRed(i.red)), (d = d.toRed(i.red)), (c === 6 || c === 7) && d.isOdd() !== (c === 7))
        )
          return null
        let h = y.redSqr().redIMul(y)
        return d.redSqr().redISub(h.redIAdd(i.b)).isZero() ? n.keyPair({ pub: { x: y, y: d } }) : null
      }
      function l(c) {
        let f = c[0]
        switch (f) {
          case 2:
          case 3:
            return c.length !== 33 ? null : u(f, c.subarray(1, 33))
          case 4:
          case 6:
          case 7:
            return c.length !== 65 ? null : o(f, c.subarray(1, 33), c.subarray(33, 65))
          default:
            return null
        }
      }
      function a(c, f) {
        let p = f.encode(null, c.length === 33)
        for (let y = 0; y < c.length; ++y) c[y] = p[y]
      }
      r.exports = {
        contextRandomize() {
          return 0
        },
        privateKeyVerify(c) {
          let f = new s(c)
          return f.cmp(i.n) < 0 && !f.isZero() ? 0 : 1
        },
        privateKeyNegate(c) {
          let f = new s(c),
            p = i.n.sub(f).umod(i.n).toArrayLike(Uint8Array, 'be', 32)
          return c.set(p), 0
        },
        privateKeyTweakAdd(c, f) {
          let p = new s(f)
          if (p.cmp(i.n) >= 0 || (p.iadd(new s(c)), p.cmp(i.n) >= 0 && p.isub(i.n), p.isZero())) return 1
          let y = p.toArrayLike(Uint8Array, 'be', 32)
          return c.set(y), 0
        },
        privateKeyTweakMul(c, f) {
          let p = new s(f)
          if (p.cmp(i.n) >= 0 || p.isZero()) return 1
          p.imul(new s(c)), p.cmp(i.n) >= 0 && (p = p.umod(i.n))
          let y = p.toArrayLike(Uint8Array, 'be', 32)
          return c.set(y), 0
        },
        publicKeyVerify(c) {
          return l(c) === null ? 1 : 0
        },
        publicKeyCreate(c, f) {
          let p = new s(f)
          if (p.cmp(i.n) >= 0 || p.isZero()) return 1
          let y = n.keyFromPrivate(f).getPublic()
          return a(c, y), 0
        },
        publicKeyConvert(c, f) {
          let p = l(f)
          if (p === null) return 1
          let y = p.getPublic()
          return a(c, y), 0
        },
        publicKeyNegate(c, f) {
          let p = l(f)
          if (p === null) return 1
          let y = p.getPublic()
          return (y.y = y.y.redNeg()), a(c, y), 0
        },
        publicKeyCombine(c, f) {
          let p = new Array(f.length)
          for (let d = 0; d < f.length; ++d) if (((p[d] = l(f[d])), p[d] === null)) return 1
          let y = p[0].getPublic()
          for (let d = 1; d < p.length; ++d) y = y.add(p[d].pub)
          return y.isInfinity() ? 2 : (a(c, y), 0)
        },
        publicKeyTweakAdd(c, f, p) {
          let y = l(f)
          if (y === null) return 1
          if (((p = new s(p)), p.cmp(i.n) >= 0)) return 2
          let d = y.getPublic().add(i.g.mul(p))
          return d.isInfinity() ? 2 : (a(c, d), 0)
        },
        publicKeyTweakMul(c, f, p) {
          let y = l(f)
          if (y === null) return 1
          if (((p = new s(p)), p.cmp(i.n) >= 0 || p.isZero())) return 2
          let d = y.getPublic().mul(p)
          return a(c, d), 0
        },
        signatureNormalize(c) {
          let f = new s(c.subarray(0, 32)),
            p = new s(c.subarray(32, 64))
          return f.cmp(i.n) >= 0 || p.cmp(i.n) >= 0
            ? 1
            : (p.cmp(n.nh) === 1 && c.set(i.n.sub(p).toArrayLike(Uint8Array, 'be', 32), 32), 0)
        },
        signatureExport(c, f) {
          let p = f.subarray(0, 32),
            y = f.subarray(32, 64)
          if (new s(p).cmp(i.n) >= 0 || new s(y).cmp(i.n) >= 0) return 1
          let { output: d } = c,
            h = d.subarray(4, 4 + 33)
          ;(h[0] = 0), h.set(p, 1)
          let m = 33,
            _ = 0
          for (; m > 1 && h[_] === 0 && !(h[_ + 1] & 128); --m, ++_);
          if (((h = h.subarray(_)), h[0] & 128 || (m > 1 && h[0] === 0 && !(h[1] & 128)))) return 1
          let A = d.subarray(6 + 33, 6 + 33 + 33)
          ;(A[0] = 0), A.set(y, 1)
          let T = 33,
            E = 0
          for (; T > 1 && A[E] === 0 && !(A[E + 1] & 128); --T, ++E);
          return (
            (A = A.subarray(E)),
            A[0] & 128 || (T > 1 && A[0] === 0 && !(A[1] & 128))
              ? 1
              : ((c.outputlen = 6 + m + T),
                (d[0] = 48),
                (d[1] = c.outputlen - 2),
                (d[2] = 2),
                (d[3] = h.length),
                d.set(h, 4),
                (d[4 + m] = 2),
                (d[5 + m] = A.length),
                d.set(A, 6 + m),
                0)
          )
        },
        signatureImport(c, f) {
          if (f.length < 8 || f.length > 72 || f[0] !== 48 || f[1] !== f.length - 2 || f[2] !== 2) return 1
          let p = f[3]
          if (p === 0 || 5 + p >= f.length || f[4 + p] !== 2) return 1
          let y = f[5 + p]
          if (
            y === 0 ||
            6 + p + y !== f.length ||
            f[4] & 128 ||
            (p > 1 && f[4] === 0 && !(f[5] & 128)) ||
            f[p + 6] & 128 ||
            (y > 1 && f[p + 6] === 0 && !(f[p + 7] & 128))
          )
            return 1
          let d = f.subarray(4, 4 + p)
          if ((d.length === 33 && d[0] === 0 && (d = d.subarray(1)), d.length > 32)) return 1
          let h = f.subarray(6 + p)
          if ((h.length === 33 && h[0] === 0 && (h = h.slice(1)), h.length > 32))
            throw new Error('S length is too long')
          let m = new s(d)
          m.cmp(i.n) >= 0 && (m = new s(0))
          let _ = new s(f.subarray(6 + p))
          return (
            _.cmp(i.n) >= 0 && (_ = new s(0)),
            c.set(m.toArrayLike(Uint8Array, 'be', 32), 0),
            c.set(_.toArrayLike(Uint8Array, 'be', 32), 32),
            0
          )
        },
        ecdsaSign(c, f, p, y, d) {
          if (d) {
            let _ = d
            d = (A) => {
              let T = _(f, p, null, y, A)
              if (!(T instanceof Uint8Array && T.length === 32)) throw new Error('This is the way')
              return new s(T)
            }
          }
          let h = new s(p)
          if (h.cmp(i.n) >= 0 || h.isZero()) return 1
          let m
          try {
            m = n.sign(f, p, { canonical: !0, k: d, pers: y })
          } catch (_) {
            return 1
          }
          return (
            c.signature.set(m.r.toArrayLike(Uint8Array, 'be', 32), 0),
            c.signature.set(m.s.toArrayLike(Uint8Array, 'be', 32), 32),
            (c.recid = m.recoveryParam),
            0
          )
        },
        ecdsaVerify(c, f, p) {
          let y = { r: c.subarray(0, 32), s: c.subarray(32, 64) },
            d = new s(y.r),
            h = new s(y.s)
          if (d.cmp(i.n) >= 0 || h.cmp(i.n) >= 0) return 1
          if (h.cmp(n.nh) === 1 || d.isZero() || h.isZero()) return 3
          let m = l(p)
          if (m === null) return 2
          let _ = m.getPublic()
          return n.verify(f, y, _) ? 0 : 3
        },
        ecdsaRecover(c, f, p, y) {
          let d = { r: f.slice(0, 32), s: f.slice(32, 64) },
            h = new s(d.r),
            m = new s(d.s)
          if (h.cmp(i.n) >= 0 || m.cmp(i.n) >= 0) return 1
          if (h.isZero() || m.isZero()) return 2
          let _
          try {
            _ = n.recoverPubKey(y, d, p)
          } catch (A) {
            return 2
          }
          return a(c, _), 0
        },
        ecdh(c, f, p, y, d, h, m) {
          let _ = l(f)
          if (_ === null) return 1
          let A = new s(p)
          if (A.cmp(i.n) >= 0 || A.isZero()) return 2
          let T = _.getPublic().mul(A)
          if (d === void 0) {
            let E = T.encode(null, !0),
              k = n.hash().update(E).digest()
            for (let w = 0; w < 32; ++w) c[w] = k[w]
          } else {
            h || (h = new Uint8Array(32))
            let E = T.getX().toArray('be', 32)
            for (let I = 0; I < 32; ++I) h[I] = E[I]
            m || (m = new Uint8Array(32))
            let k = T.getY().toArray('be', 32)
            for (let I = 0; I < 32; ++I) m[I] = k[I]
            let w = d(h, m, y)
            if (!(w instanceof Uint8Array && w.length === c.length)) return 2
            c.set(w)
          }
          return 0
        }
      }
    }
  }),
  zO = te({
    'node_modules/secp256k1/elliptic.js'(e, r) {
      V(), F(), (r.exports = gO()(jO()))
    }
  }),
  KO = te({
    'node_modules/libp2p-crypto/src/keys/secp256k1.js'(e, r) {
      V(), F()
      var t = zO(),
        { sha256: n } = (af(), zc)
      r.exports = (i) => {
        let s = 32
        function u() {
          let d
          do d = i(32)
          while (!t.privateKeyVerify(d))
          return d
        }
        async function o(d, h) {
          let { digest: m } = await n.digest(h),
            _ = t.ecdsaSign(m, d)
          return t.signatureExport(_.signature)
        }
        async function l(d, h, m) {
          let { digest: _ } = await n.digest(m)
          return (h = t.signatureImport(h)), t.ecdsaVerify(h, _, d)
        }
        function a(d) {
          if (!t.publicKeyVerify(d)) throw new Error('Invalid public key')
          return t.publicKeyConvert(d, !0)
        }
        function c(d) {
          return t.publicKeyConvert(d, !1)
        }
        function f(d) {
          if (!t.privateKeyVerify(d)) throw new Error('Invalid private key')
        }
        function p(d) {
          if (!t.publicKeyVerify(d)) throw new Error('Invalid public key')
        }
        function y(d) {
          return f(d), t.publicKeyCreate(d)
        }
        return {
          generateKey: u,
          privateKeyLength: s,
          hashAndSign: o,
          hashAndVerify: l,
          compressPublicKey: a,
          decompressPublicKey: c,
          validatePrivateKey: f,
          validatePublicKey: p,
          computePublicKey: y
        }
      }
    }
  }),
  FO = te({
    'node_modules/libp2p-crypto/src/keys/secp256k1-class.js'(e, r) {
      V(), F()
      var { sha256: t } = (af(), zc),
        n = pt(),
        { equals: i } = (To(), ps),
        { toString: s } = (On(), vn),
        u = b1()
      r.exports = (o, l, a) => {
        a = a || KO()(l)
        class c {
          constructor(m) {
            a.validatePublicKey(m), (this._key = m)
          }
          verify(m, _) {
            return a.hashAndVerify(this._key, _, m)
          }
          marshal() {
            return a.compressPublicKey(this._key)
          }
          get bytes() {
            return o.PublicKey.encode({ Type: o.KeyType.Secp256k1, Data: this.marshal() }).finish()
          }
          equals(m) {
            return i(this.bytes, m.bytes)
          }
          async hash() {
            let { bytes: m } = await t.digest(this.bytes)
            return m
          }
        }
        class f {
          constructor(m, _) {
            ;(this._key = m),
              (this._publicKey = _ || a.computePublicKey(m)),
              a.validatePrivateKey(this._key),
              a.validatePublicKey(this._publicKey)
          }
          sign(m) {
            return a.hashAndSign(this._key, m)
          }
          get public() {
            return new c(this._publicKey)
          }
          marshal() {
            return this._key
          }
          get bytes() {
            return o.PrivateKey.encode({ Type: o.KeyType.Secp256k1, Data: this.marshal() }).finish()
          }
          equals(m) {
            return i(this.bytes, m.bytes)
          }
          async hash() {
            let { bytes: m } = await t.digest(this.bytes)
            return m
          }
          async id() {
            let m = await this.public.hash()
            return s(m, 'base58btc')
          }
          async export(m, _ = 'libp2p-key') {
            if (_ === 'libp2p-key') return u.export(this.bytes, m)
            throw n(new Error(`export format '${_}' is not supported`), 'ERR_INVALID_EXPORT_FORMAT')
          }
        }
        function p(h) {
          return new f(h)
        }
        function y(h) {
          return new c(h)
        }
        async function d() {
          let h = await a.generateKey()
          return new f(h)
        }
        return {
          Secp256k1PublicKey: c,
          Secp256k1PrivateKey: f,
          unmarshalSecp256k1PrivateKey: p,
          unmarshalSecp256k1PublicKey: y,
          generateKeyPair: d
        }
      }
    }
  }),
  VO = te({
    'node_modules/libp2p-crypto/src/hmac/lengths.js'(e, r) {
      V(), F(), (r.exports = { SHA1: 20, SHA256: 32, SHA512: 64 })
    }
  }),
  eE = te({
    'node_modules/libp2p-crypto/src/hmac/index-browser.js'(e) {
      V(), F()
      var r = sf(),
        t = VO(),
        n = { SHA1: 'SHA-1', SHA256: 'SHA-256', SHA512: 'SHA-512' },
        i = async (s, u) => {
          let o = await r.get().subtle.sign({ name: 'HMAC' }, s, u)
          return new Uint8Array(o, o.byteOffset, o.byteLength)
        }
      e.create = async function (s, u) {
        let o = n[s],
          l = await r.get().subtle.importKey('raw', u, { name: 'HMAC', hash: { name: o } }, !1, ['sign'])
        return {
          async digest(a) {
            return i(l, a)
          },
          length: t[s]
        }
      }
    }
  }),
  HO = te({
    'node_modules/libp2p-crypto/src/keys/key-stretcher.js'(e, r) {
      V(), F()
      var t = pt(),
        { concat: n } = (hs(), Li),
        { fromString: i } = (gn(), un),
        s = eE(),
        u = {
          'AES-128': { ivSize: 16, keySize: 16 },
          'AES-256': { ivSize: 16, keySize: 32 },
          Blowfish: { ivSize: 8, cipherKeySize: 32 }
        }
      r.exports = async (o, l, a) => {
        let c = u[o]
        if (!c) {
          let M = Object.keys(u).join(' / ')
          throw t(new Error(`unknown cipher type '${o}'. Must be ${M}`), 'ERR_INVALID_CIPHER_TYPE')
        }
        if (!l) throw t(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE')
        let f = c.keySize,
          p = c.ivSize,
          y = 20,
          d = i('key expansion'),
          h = 2 * (p + f + y),
          m = await s.create(l, a),
          _ = await m.digest(d),
          A = [],
          T = 0
        for (; T < h; ) {
          let M = await m.digest(n([_, d])),
            q = M.length
          T + q > h && (q = h - T), A.push(M), (T += q), (_ = await m.digest(_))
        }
        let E = h / 2,
          k = n(A),
          w = k.slice(0, E),
          v = k.slice(E, h),
          I = (M) => ({ iv: M.slice(0, p), cipherKey: M.slice(p, p + f), macKey: M.slice(p + f) })
        return { k1: I(w), k2: I(v) }
      }
    }
  }),
  $O = te({
    'node_modules/libp2p-crypto/src/keys/validate-curve-type.js'(e, r) {
      V(), F()
      var t = pt()
      r.exports = function (n, i) {
        if (!n.includes(i)) {
          let s = n.join(' / ')
          throw t(new Error(`Unknown curve: ${i}. Must be ${s}`), 'ERR_INVALID_CURVE')
        }
      }
    }
  }),
  GO = te({
    'node_modules/libp2p-crypto/src/keys/ecdh-browser.js'(e) {
      V(), F()
      var r = pt(),
        t = sf(),
        { base64urlToBuffer: n } = m1(),
        i = $O(),
        { toString: s } = (On(), vn),
        { concat: u } = (hs(), Li),
        { equals: o } = (To(), ps),
        l = { 'P-256': 256, 'P-384': 384, 'P-521': 521 }
      e.generateEphmeralKeyPair = async function (y) {
        i(Object.keys(l), y)
        let d = await t.get().subtle.generateKey({ name: 'ECDH', namedCurve: y }, !0, ['deriveBits']),
          h = async (_, A) => {
            let T
            A
              ? (T = await t
                  .get()
                  .subtle.importKey('jwk', p(y, A), { name: 'ECDH', namedCurve: y }, !1, ['deriveBits']))
              : (T = d.privateKey)
            let E = [await t.get().subtle.importKey('jwk', f(y, _), { name: 'ECDH', namedCurve: y }, !1, []), T],
              k = await t.get().subtle.deriveBits({ name: 'ECDH', namedCurve: y, public: E[0] }, E[1], l[y])
            return new Uint8Array(k, k.byteOffset, k.byteLength)
          },
          m = await t.get().subtle.exportKey('jwk', d.publicKey)
        return { key: c(m), genSharedKey: h }
      }
      var a = { 'P-256': 32, 'P-384': 48, 'P-521': 66 }
      function c(y) {
        let d = a[y.crv]
        return u([Uint8Array.from([4]), n(y.x, d), n(y.y, d)], 1 + d * 2)
      }
      function f(y, d) {
        let h = a[y]
        if (o(!d.slice(0, 1), Uint8Array.from([4])))
          throw r(new Error('Cannot unmarshal public key - invalid key format'), 'ERR_INVALID_KEY_FORMAT')
        return { kty: 'EC', crv: y, x: s(d.slice(1, h + 1), 'base64url'), y: s(d.slice(1 + h), 'base64url'), ext: !0 }
      }
      var p = (y, d) => ({ ...f(y, d.public), d: s(d.private, 'base64url') })
    }
  }),
  WO = te({
    'node_modules/libp2p-crypto/src/keys/ephemeral-keys.js'(e, r) {
      V(), F()
      var t = GO()
      r.exports = async (n) => t.generateEphmeralKeyPair(n)
    }
  }),
  g1 = te({
    'node_modules/libp2p-crypto/src/keys/index.js'(e, r) {
      V(), F()
      var t = Yp()
      qi(), t9()
      var n = yt(),
        i = pt(),
        { fromString: s } = (gn(), un),
        u = sO(),
        o = { rsa: pO(), ed25519: vO(), secp256k1: FO()(t, p1()) },
        l = { message: 'secp256k1 support requires libp2p-crypto-secp256k1 package', code: 'ERR_MISSING_PACKAGE' }
      function a(_) {
        let A = o[_.toLowerCase()]
        if (!A) {
          let T = Object.keys(o).join(' / ')
          throw i(new Error(`invalid or unsupported key type ${_}. Must be ${T}`), 'ERR_UNSUPPORTED_KEY_TYPE')
        }
        return A
      }
      var c = async (_, A) => a(_).generateKeyPair(A),
        f = async (_, A, T) => {
          let E = a(_)
          if (_.toLowerCase() !== 'ed25519')
            throw i(
              new Error('Seed key derivation is unimplemented for RSA or secp256k1'),
              'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE'
            )
          return E.generateKeyPairFromSeed(A, T)
        },
        p = (_) => {
          let A = t.PublicKey.decode(_),
            T = A.Data
          switch (A.Type) {
            case t.KeyType.RSA:
              return o.rsa.unmarshalRsaPublicKey(T)
            case t.KeyType.Ed25519:
              return o.ed25519.unmarshalEd25519PublicKey(T)
            case t.KeyType.Secp256k1:
              if (o.secp256k1) return o.secp256k1.unmarshalSecp256k1PublicKey(T)
              throw i(new Error(l.message), l.code)
            default:
              a(A.Type)
          }
        },
        y = (_, A) => ((A = (A || 'rsa').toLowerCase()), a(A), _.bytes),
        d = async (_) => {
          let A = t.PrivateKey.decode(_),
            T = A.Data
          switch (A.Type) {
            case t.KeyType.RSA:
              return o.rsa.unmarshalRsaPrivateKey(T)
            case t.KeyType.Ed25519:
              return o.ed25519.unmarshalEd25519PrivateKey(T)
            case t.KeyType.Secp256k1:
              if (o.secp256k1) return o.secp256k1.unmarshalSecp256k1PrivateKey(T)
              throw i(new Error(l.message), l.code)
            default:
              a(A.Type)
          }
        },
        h = (_, A) => ((A = (A || 'rsa').toLowerCase()), a(A), _.bytes),
        m = async (_, A) => {
          try {
            let k = await u.import(_, A)
            return d(k)
          } catch (k) {}
          let T = n.pki.decryptRsaPrivateKey(_, A)
          if (T === null)
            throw i(
              new Error('Cannot read the key, most likely the password is wrong or not a RSA key'),
              'ERR_CANNOT_DECRYPT_PEM'
            )
          let E = n.asn1.toDer(n.pki.privateKeyToAsn1(T))
          return (E = s(E.getBytes(), 'ascii')), o.rsa.unmarshalRsaPrivateKey(E)
        }
      r.exports = {
        supportedKeys: o,
        keysPBM: t,
        keyStretcher: HO(),
        generateEphemeralKeyPair: WO(),
        generateKeyPair: c,
        generateKeyPairFromSeed: f,
        unmarshalPublicKey: p,
        marshalPublicKey: y,
        unmarshalPrivateKey: d,
        marshalPrivateKey: h,
        import: m
      }
    }
  }),
  JO = te({
    'node_modules/peer-id/src/proto.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-peer-id'] || (t.roots['libp2p-peer-id'] = {})
      ;(u.PeerIdProto = (function () {
        function o(l) {
          if (l) for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
        }
        return (
          (o.prototype.id = s.newBuffer([])),
          (o.prototype.pubKey = s.newBuffer([])),
          (o.prototype.privKey = s.newBuffer([])),
          (o.encode = function (a, c) {
            return (
              c || (c = i.create()),
              c.uint32(10).bytes(a.id),
              a.pubKey != null && Object.hasOwnProperty.call(a, 'pubKey') && c.uint32(18).bytes(a.pubKey),
              a.privKey != null && Object.hasOwnProperty.call(a, 'privKey') && c.uint32(26).bytes(a.privKey),
              c
            )
          }),
          (o.decode = function (a, c) {
            a instanceof n || (a = n.create(a))
            for (var f = c === void 0 ? a.len : a.pos + c, p = new u.PeerIdProto(); a.pos < f; ) {
              var y = a.uint32()
              switch (y >>> 3) {
                case 1:
                  p.id = a.bytes()
                  break
                case 2:
                  p.pubKey = a.bytes()
                  break
                case 3:
                  p.privKey = a.bytes()
                  break
                default:
                  a.skipType(y & 7)
                  break
              }
            }
            if (!p.hasOwnProperty('id')) throw s.ProtocolError("missing required 'id'", { instance: p })
            return p
          }),
          (o.fromObject = function (a) {
            if (a instanceof u.PeerIdProto) return a
            var c = new u.PeerIdProto()
            return (
              a.id != null &&
                (typeof a.id == 'string'
                  ? s.base64.decode(a.id, (c.id = s.newBuffer(s.base64.length(a.id))), 0)
                  : a.id.length && (c.id = a.id)),
              a.pubKey != null &&
                (typeof a.pubKey == 'string'
                  ? s.base64.decode(a.pubKey, (c.pubKey = s.newBuffer(s.base64.length(a.pubKey))), 0)
                  : a.pubKey.length && (c.pubKey = a.pubKey)),
              a.privKey != null &&
                (typeof a.privKey == 'string'
                  ? s.base64.decode(a.privKey, (c.privKey = s.newBuffer(s.base64.length(a.privKey))), 0)
                  : a.privKey.length && (c.privKey = a.privKey)),
              c
            )
          }),
          (o.toObject = function (a, c) {
            c || (c = {})
            var f = {}
            return (
              c.defaults &&
                (c.bytes === String ? (f.id = '') : ((f.id = []), c.bytes !== Array && (f.id = s.newBuffer(f.id))),
                c.bytes === String
                  ? (f.pubKey = '')
                  : ((f.pubKey = []), c.bytes !== Array && (f.pubKey = s.newBuffer(f.pubKey))),
                c.bytes === String
                  ? (f.privKey = '')
                  : ((f.privKey = []), c.bytes !== Array && (f.privKey = s.newBuffer(f.privKey)))),
              a.id != null &&
                a.hasOwnProperty('id') &&
                (f.id =
                  c.bytes === String
                    ? s.base64.encode(a.id, 0, a.id.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.id)
                    : a.id),
              a.pubKey != null &&
                a.hasOwnProperty('pubKey') &&
                (f.pubKey =
                  c.bytes === String
                    ? s.base64.encode(a.pubKey, 0, a.pubKey.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.pubKey)
                    : a.pubKey),
              a.privKey != null &&
                a.hasOwnProperty('privKey') &&
                (f.privKey =
                  c.bytes === String
                    ? s.base64.encode(a.privKey, 0, a.privKey.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.privKey)
                    : a.privKey),
              f
            )
          }),
          (o.prototype.toJSON = function () {
            return this.constructor.toObject(this, t.util.toJSONOptions)
          }),
          o
        )
      })()),
        (r.exports = u)
    }
  }),
  XO = te({
    'node_modules/peer-id/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  })
function YO(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var tE,
  rE,
  nE,
  ZO = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (tE = YO), (rE = tE), (nE = rE)
    }
  }),
  iE = {}
Re(iE, {
  coerce: () => Is,
  empty: () => w1,
  equals: () => _1,
  fromHex: () => oE,
  fromString: () => E1,
  isBinary: () => aE,
  toHex: () => sE,
  toString: () => S1
})
var w1,
  sE,
  oE,
  _1,
  Is,
  aE,
  E1,
  S1,
  Ts = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (w1 = new Uint8Array(0)),
        (sE = (e) => e.reduce((r, t) => r + t.toString(16).padStart(2, '0'), '')),
        (oE = (e) => {
          let r = e.match(/../g)
          return r ? new Uint8Array(r.map((t) => parseInt(t, 16))) : w1
        }),
        (_1 = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (Is = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (aE = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e)),
        (E1 = (e) => new TextEncoder().encode(e)),
        (S1 = (e) => new TextDecoder().decode(e))
    }
  }),
  cE,
  uE,
  A1,
  lE,
  uf,
  Vo,
  fE,
  dE,
  pr,
  ci = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        ZO(),
        Ts(),
        (cE = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (uE = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new A1(r)
          }
        }),
        (A1 = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new A1({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (lE = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new cE(e, r, t)),
              (this.decoder = new uE(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (uf = ({ name: e, prefix: r, encode: t, decode: n }) => new lE(e, r, t, n)),
        (Vo = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = nE(t, r)
          return uf({ prefix: e, name: r, encode: n, decode: (s) => Is(i(s)) })
        }),
        (fE = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (dE = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (pr = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          uf({
            prefix: r,
            name: e,
            encode(i) {
              return dE(i, n, t)
            },
            decode(i) {
              return fE(i, n, t, e)
            }
          }))
    }
  }),
  hE = {}
Re(hE, { identity: () => pE })
var pE,
  QO = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), ci(), Ts(), (pE = uf({ prefix: '\0', name: 'identity', encode: (e) => S1(e), decode: (e) => E1(e) }))
    }
  }),
  mE = {}
Re(mE, { base2: () => bE })
var bE,
  eD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), ci(), (bE = pr({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  yE = {}
Re(yE, { base8: () => vE })
var vE,
  tD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), ci(), (vE = pr({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  gE = {}
Re(gE, { base10: () => wE })
var wE,
  rD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), ci(), (wE = Vo({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  _E = {}
Re(_E, { base16: () => EE, base16upper: () => SE })
var EE,
  SE,
  nD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        ci(),
        (EE = pr({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (SE = pr({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  AE = {}
Re(AE, {
  base32: () => Ho,
  base32hex: () => kE,
  base32hexpad: () => xE,
  base32hexpadupper: () => RE,
  base32hexupper: () => ME,
  base32pad: () => TE,
  base32padupper: () => CE,
  base32upper: () => IE,
  base32z: () => BE
})
var Ho,
  IE,
  TE,
  CE,
  kE,
  ME,
  xE,
  RE,
  BE,
  NE = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        ci(),
        (Ho = pr({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (IE = pr({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (TE = pr({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (CE = pr({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (kE = pr({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        (ME = pr({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (xE = pr({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (RE = pr({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (BE = pr({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  PE = {}
Re(PE, { base36: () => OE, base36upper: () => DE })
var OE,
  DE,
  iD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        ci(),
        (OE = Vo({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (DE = Vo({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  LE = {}
Re(LE, { base58btc: () => jn, base58flickr: () => UE })
var jn,
  UE,
  qE = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        ci(),
        (jn = Vo({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (UE = Vo({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  jE = {}
Re(jE, { base64: () => zE, base64pad: () => KE, base64url: () => FE, base64urlpad: () => VE })
var zE,
  KE,
  FE,
  VE,
  sD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        ci(),
        (zE = pr({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (KE = pr({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (FE = pr({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (VE = pr({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function HE(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= JE; ) (r[t++] = (e & 255) | T1), (e /= 128)
  for (; e & WE; ) (r[t++] = (e & 255) | T1), (e >>>= 7)
  return (r[t] = e | 0), (HE.bytes = t - n + 1), r
}
function I1(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((I1.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & C1) << n : (s & C1) * Math.pow(2, n)), (n += 7)
  } while (s >= YE)
  return (I1.bytes = i - r), t
}
var $E,
  T1,
  GE,
  WE,
  JE,
  XE,
  YE,
  C1,
  ZE,
  QE,
  eS,
  tS,
  rS,
  nS,
  iS,
  sS,
  oS,
  aS,
  cS,
  uS,
  Fc,
  oD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        ($E = HE),
        (T1 = 128),
        (GE = 127),
        (WE = ~GE),
        (JE = Math.pow(2, 31)),
        (XE = I1),
        (YE = 128),
        (C1 = 127),
        (ZE = Math.pow(2, 7)),
        (QE = Math.pow(2, 14)),
        (eS = Math.pow(2, 21)),
        (tS = Math.pow(2, 28)),
        (rS = Math.pow(2, 35)),
        (nS = Math.pow(2, 42)),
        (iS = Math.pow(2, 49)),
        (sS = Math.pow(2, 56)),
        (oS = Math.pow(2, 63)),
        (aS = function (e) {
          return e < ZE
            ? 1
            : e < QE
            ? 2
            : e < eS
            ? 3
            : e < tS
            ? 4
            : e < rS
            ? 5
            : e < nS
            ? 6
            : e < iS
            ? 7
            : e < sS
            ? 8
            : e < oS
            ? 9
            : 10
        }),
        (cS = { encode: $E, decode: XE, encodingLength: aS }),
        (uS = cS),
        (Fc = uS)
    }
  }),
  lS = {}
Re(lS, { decode: () => Vc, encodeTo: () => $o, encodingLength: () => Go })
var Vc,
  $o,
  Go,
  k1 = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        oD(),
        (Vc = (e) => [Fc.decode(e), Fc.decode.bytes]),
        ($o = (e, r, t = 0) => (Fc.encode(e, r, t), r)),
        (Go = (e) => Fc.encodingLength(e))
    }
  }),
  fS = {}
Re(fS, { Digest: () => Hc, create: () => lf, decode: () => M1, equals: () => x1 })
var lf,
  M1,
  x1,
  Hc,
  R1 = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        Ts(),
        k1(),
        (lf = (e, r) => {
          let t = r.byteLength,
            n = Go(e),
            i = n + Go(t),
            s = new Uint8Array(i + t)
          return $o(e, s, 0), $o(t, s, n), s.set(r, i), new Hc(e, t, r, s)
        }),
        (M1 = (e) => {
          let r = Is(e),
            [t, n] = Vc(r),
            [i, s] = Vc(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new Hc(t, i, u, r)
        }),
        (x1 = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && _1(e.bytes, r.bytes))),
        (Hc = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  dS = {}
Re(dS, { Hasher: () => B1, from: () => $c })
var $c,
  B1,
  N1 = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        R1(),
        ($c = ({ name: e, code: r, encode: t }) => new B1(e, r, t)),
        (B1 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return lf(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  hS = {}
Re(hS, { sha256: () => pS, sha512: () => mS })
var P1,
  pS,
  mS,
  aD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        N1(),
        (P1 = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (pS = $c({ name: 'sha2-256', code: 18, encode: P1('SHA-256') })),
        (mS = $c({ name: 'sha2-512', code: 19, encode: P1('SHA-512') }))
    }
  }),
  bS = {}
Re(bS, { identity: () => yS })
var yS,
  cD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), N1(), Ts(), (yS = $c({ name: 'identity', code: 0, encode: (e) => Is(e) }))
    }
  }),
  vS = {}
Re(vS, { code: () => wS, decode: () => ES, encode: () => _S, name: () => gS })
var O1,
  gS,
  wS,
  _S,
  ES,
  uD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(),
        F(),
        Ts(),
        (O1 = (e) => Is(e)),
        ({ name: gS, code: wS, encode: _S, decode: ES } = { name: 'raw', code: 85, decode: O1, encode: O1 })
    }
  }),
  SS = {}
Re(SS, { code: () => IS, decode: () => CS, encode: () => TS, name: () => AS })
var AS,
  IS,
  TS,
  CS,
  lD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(),
        F(),
        ({
          name: AS,
          code: IS,
          encode: TS,
          decode: CS
        } = {
          name: 'json',
          code: 512,
          encode: (e) => new TextEncoder().encode(JSON.stringify(e)),
          decode: (e) => JSON.parse(new TextDecoder().decode(e))
        })
    }
  }),
  Br,
  kS,
  MS,
  xS,
  Wo,
  RS,
  D1,
  L1,
  Gc,
  Wc,
  BS,
  NS,
  PS,
  fD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        k1(),
        R1(),
        qE(),
        NE(),
        Ts(),
        (Br = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: Wc,
                byteLength: Wc,
                code: Gc,
                version: Gc,
                multihash: Gc,
                bytes: Gc,
                _baseCache: Wc,
                asCID: Wc
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== Wo) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== RS) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return Br.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = lf(e, r)
                return Br.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && x1(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return MS(r, n, e || jn.encoder)
              default:
                return xS(r, n, e || Ho.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return NS(/^0\.0/, PS), !!(e && (e[L1] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof Br) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new Br(r, t, n, i || D1(r, t, n.bytes))
            } else if (e != null && e[L1] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = M1(t)
              return Br.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== Wo) throw new Error(`Version 0 CID must use dag-pb (code: ${Wo}) block encoding`)
                return new Br(e, r, t, t.bytes)
              }
              case 1: {
                let n = D1(e, r, t.bytes)
                return new Br(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return Br.create(0, Wo, e)
          }
          static createV1(e, r) {
            return Br.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = Br.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = Br.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = Is(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new Hc(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? Br.createV0(s) : Br.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = Vc(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = Wo
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = kS(e, r),
              i = Br.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (kS = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || jn
              return [jn.prefix, t.decode(`${jn.prefix}${e}`)]
            }
            case jn.prefix: {
              let t = r || jn
              return [jn.prefix, t.decode(e)]
            }
            case Ho.prefix: {
              let t = r || Ho
              return [Ho.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        (MS = (e, r, t) => {
          let { prefix: n } = t
          if (n !== jn.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (xS = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (Wo = 112),
        (RS = 18),
        (D1 = (e, r, t) => {
          let n = Go(e),
            i = n + Go(r),
            s = new Uint8Array(i + t.byteLength)
          return $o(e, s, 0), $o(r, s, n), s.set(t, i), s
        }),
        (L1 = Symbol.for('@ipld/js-cid/CID')),
        (Gc = { writable: !1, configurable: !1, enumerable: !0 }),
        (Wc = { writable: !1, enumerable: !1, configurable: !1 }),
        (BS = '0.0.0-dev'),
        (NS = (e, r) => {
          if (e.test(BS)) console.warn(r)
          else throw new Error(r)
        }),
        (PS = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  dD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), fD(), k1(), Ts(), N1(), R1()
    }
  }),
  OS = {}
Re(OS, {
  CID: () => Br,
  bases: () => DS,
  bytes: () => iE,
  codecs: () => US,
  digest: () => fS,
  hasher: () => dS,
  hashes: () => LS,
  varint: () => lS
})
var DS,
  LS,
  US,
  hD = Ie({
    'node_modules/peer-id/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        QO(),
        eD(),
        tD(),
        rD(),
        nD(),
        NE(),
        iD(),
        qE(),
        sD(),
        aD(),
        cD(),
        uD(),
        lD(),
        dD(),
        (DS = { ...hE, ...mE, ...yE, ...gE, ..._E, ...AE, ...PE, ...LE, ...jE }),
        (LS = { ...hS, ...bS }),
        (US = { raw: vS, json: SS })
    }
  }),
  qS = te({
    'node_modules/peer-id/node_modules/uint8arrays/util/bases.js'(e, r) {
      V(), F()
      var { bases: t } = (hD(), OS)
      function n(o, l, a, c) {
        return { name: o, prefix: l, encoder: { name: o, prefix: l, encode: a }, decoder: { decode: c } }
      }
      var i = n(
          'utf8',
          'u',
          (o) => {
            let l = new TextDecoder('utf8')
            return 'u' + l.decode(o)
          },
          (o) => new TextEncoder().encode(o.substring(1))
        ),
        s = n(
          'ascii',
          'a',
          (o) => {
            let l = 'a'
            for (let a = 0; a < o.length; a++) l += String.fromCharCode(o[a])
            return l
          },
          (o) => {
            o = o.substring(1)
            let l = new Uint8Array(o.length)
            for (let a = 0; a < o.length; a++) l[a] = o.charCodeAt(a)
            return l
          }
        ),
        u = { utf8: i, 'utf-8': i, hex: t.base16, latin1: s, ascii: s, binary: s, ...t }
      r.exports = u
    }
  }),
  pD = te({
    'node_modules/peer-id/node_modules/uint8arrays/from-string.js'(e, r) {
      V(), F()
      var t = qS()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.decoder.decode(`${u.prefix}${i}`)
      }
      r.exports = n
    }
  }),
  mD = te({
    'node_modules/peer-id/node_modules/uint8arrays/to-string.js'(e, r) {
      V(), F()
      var t = qS()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.encoder.encode(i).substring(1)
      }
      r.exports = n
    }
  }),
  er = te({
    'node_modules/peer-id/src/index.js'(e, r) {
      V(), F()
      var t = gc(),
        n = Gr(),
        i = g1(),
        s = l0(),
        { PeerIdProto: u } = JO(),
        o = XO(),
        l = pD(),
        a = mD(),
        c = class {
          constructor(m, _, A) {
            if (!(m instanceof Uint8Array)) throw new Error('invalid id provided')
            if (_ && A && !o(_.public.bytes, A.bytes)) throw new Error('inconsistent arguments')
            ;(this._id = m), (this._idB58String = t.toB58String(this.id)), (this._privKey = _), (this._pubKey = A)
          }
          get id() {
            return this._id
          }
          set id(m) {
            throw new Error('Id is immutable')
          }
          get privKey() {
            return this._privKey
          }
          set privKey(m) {
            this._privKey = m
          }
          get pubKey() {
            if (this._pubKey) return this._pubKey
            if (this._privKey) return this._privKey.public
            try {
              let m = t.decode(this.id)
              m.name === 'identity' && (this._pubKey = i.unmarshalPublicKey(m.digest))
            } catch (m) {}
            return this._pubKey
          }
          set pubKey(m) {
            this._pubKey = m
          }
          marshalPubKey() {
            if (this.pubKey) return i.marshalPublicKey(this.pubKey)
          }
          marshalPrivKey() {
            if (this.privKey) return i.marshalPrivateKey(this.privKey)
          }
          marshal(m) {
            return u
              .encode({ id: this.toBytes(), pubKey: this.marshalPubKey(), privKey: m ? null : this.marshalPrivKey() })
              .finish()
          }
          toPrint() {
            let m = this.toB58String()
            m.startsWith('Qm') && (m = m.slice(2))
            let _ = 6
            return m.length < _ && (_ = m.length), '<peer.ID ' + m.substr(0, _) + '>'
          }
          toJSON() {
            return { id: this.toB58String(), privKey: h(this.marshalPrivKey()), pubKey: h(this.marshalPubKey()) }
          }
          toHexString() {
            return t.toHexString(this.id)
          }
          toBytes() {
            return this.id
          }
          toB58String() {
            return this._idB58String
          }
          toString() {
            if (!this._idCIDString) {
              let m = new n(1, 'libp2p-key', this.id, 'base32')
              Object.defineProperty(this, '_idCIDString', { value: m.toBaseEncodedString('base32'), enumerable: !1 })
            }
            return this._idCIDString
          }
          equals(m) {
            if (m instanceof Uint8Array) return o(this.id, m)
            if (m.id) return o(this.id, m.id)
            throw new Error('not valid Id')
          }
          isEqual(m) {
            return this.equals(m)
          }
          isValid() {
            return Boolean(
              this.privKey &&
                this.privKey.public &&
                this.privKey.public.bytes &&
                this.pubKey.bytes instanceof Uint8Array &&
                o(this.privKey.public.bytes, this.pubKey.bytes)
            )
          }
          hasInlinePublicKey() {
            try {
              if (t.decode(this.id).name === 'identity') return !0
            } catch (m) {}
            return !1
          }
        },
        f = s(c, { className: 'PeerId', symbolName: '@libp2p/js-peer-id/PeerId' })
      e = r.exports = f
      var p = (m) => (m.bytes.length <= 42 ? t.encode(m.bytes, 'identity') : m.hash()),
        y = async (m, _) => {
          let A = await p(_)
          return new f(A, m, _)
        }
      ;(e.create = async (m) => {
        ;(m = m || {}), (m.bits = m.bits || 2048), (m.keyType = m.keyType || 'RSA')
        let _ = await i.generateKeyPair(m.keyType, m.bits)
        return y(_, _.public)
      }),
        (e.createFromHexString = (m) => new f(t.fromHexString(m))),
        (e.createFromBytes = (m) => new f(m)),
        (e.createFromB58String = (m) => e.createFromCID(m))
      var d = (m) => m.codec === 'libp2p-key' || m.codec === 'dag-pb'
      ;(e.createFromCID = (m) => {
        if (((m = n.isCID(m) ? m : new n(m)), !d(m)))
          throw new Error('Supplied PeerID CID has invalid multicodec: ' + m.codec)
        return new f(m.multihash)
      }),
        (e.createFromPubKey = async (m) => {
          let _ = m
          if ((typeof _ == 'string' && (_ = l(m, 'base64pad')), !(_ instanceof Uint8Array)))
            throw new Error('Supplied key is neither a base64 string nor a Uint8Array')
          let A = await i.unmarshalPublicKey(_)
          return y(null, A)
        }),
        (e.createFromPrivKey = async (m) => {
          if ((typeof m == 'string' && (m = l(m, 'base64pad')), !(m instanceof Uint8Array)))
            throw new Error('Supplied key is neither a base64 string nor a Uint8Array')
          let _ = await i.unmarshalPrivateKey(m)
          return y(_, _.public)
        }),
        (e.createFromJSON = async (m) => {
          let _ = t.fromB58String(m.id),
            A = m.privKey && l(m.privKey, 'base64pad'),
            T = m.pubKey && l(m.pubKey, 'base64pad'),
            E = T && (await i.unmarshalPublicKey(T))
          if (!A) return new f(_, null, E)
          let k = await i.unmarshalPrivateKey(A),
            w = await p(k.public),
            v
          if ((E && (v = await p(E)), E && !o(w, v))) throw new Error('Public and private key do not match')
          if (_ && !o(w, _)) throw new Error('Id and private key do not match')
          return new f(_, k, E)
        }),
        (e.createFromProtobuf = async (m) => {
          typeof m == 'string' && (m = l(m, 'base16'))
          let { id: _, privKey: A, pubKey: T } = u.decode(m)
          ;(A = A ? await i.unmarshalPrivateKey(A) : !1), (T = T ? await i.unmarshalPublicKey(T) : !1)
          let E, k
          if ((A && (k = await p(A.public)), T && (E = await p(T)), A)) {
            if (T && !o(k, E)) throw new Error('Public and private key do not match')
            return new f(k, A, A.public)
          }
          if (T) return new f(E, null, T)
          if (_) return new f(_)
          throw new Error('Protobuf did not contain any usable key material')
        }),
        (e.isPeerId = (m) => Boolean(typeof m == 'object' && m._id && m._idB58String))
      function h(m) {
        if (m) return a(m, 'base64pad')
      }
    }
  }),
  U1 = te({
    'node_modules/libp2p-webrtc-star/src/constants.js'(e) {
      V(), F(), (e.CODE_P2P = 421), (e.CODE_CIRCUIT = 290), (e.CLOSE_TIMEOUT = 2e3)
    }
  }),
  jS = te({
    'node_modules/parseuri/index.js'(e, r) {
      V(), F()
      var t =
          /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
        n = [
          'source',
          'protocol',
          'authority',
          'userInfo',
          'user',
          'password',
          'host',
          'port',
          'relative',
          'path',
          'directory',
          'file',
          'query',
          'anchor'
        ]
      r.exports = function (o) {
        var l = o,
          a = o.indexOf('['),
          c = o.indexOf(']')
        a != -1 && c != -1 && (o = o.substring(0, a) + o.substring(a, c).replace(/:/g, ';') + o.substring(c, o.length))
        for (var f = t.exec(o || ''), p = {}, y = 14; y--; ) p[n[y]] = f[y] || ''
        return (
          a != -1 &&
            c != -1 &&
            ((p.source = l),
            (p.host = p.host.substring(1, p.host.length - 1).replace(/;/g, ':')),
            (p.authority = p.authority.replace('[', '').replace(']', '').replace(/;/g, ':')),
            (p.ipv6uri = !0)),
          (p.pathNames = i(p, p.path)),
          (p.queryKey = s(p, p.query)),
          p
        )
      }
      function i(u, o) {
        var l = /\/{2,9}/g,
          a = o.replace(l, '/').split('/')
        return (
          (o.substr(0, 1) == '/' || o.length === 0) && a.splice(0, 1),
          o.substr(o.length - 1, 1) == '/' && a.splice(a.length - 1, 1),
          a
        )
      }
      function s(u, o) {
        var l = {}
        return (
          o.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (a, c, f) {
            c && (l[c] = f)
          }),
          l
        )
      }
    }
  }),
  bD = te({
    'node_modules/socket.io-client/build/url.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.url = void 0)
      var r = jS(),
        t = mt()('socket.io-client:url')
      function n(i, s = '', u) {
        let o = i
        ;(u = u || (typeof location != 'undefined' && location)),
          i == null && (i = u.protocol + '//' + u.host),
          typeof i == 'string' &&
            (i.charAt(0) === '/' && (i.charAt(1) === '/' ? (i = u.protocol + i) : (i = u.host + i)),
            /^(https?|wss?):\/\//.test(i) ||
              (t('protocol-less url %s', i),
              typeof u != 'undefined' ? (i = u.protocol + '//' + i) : (i = 'https://' + i)),
            t('parse %s', i),
            (o = r(i))),
          o.port ||
            (/^(http|ws)$/.test(o.protocol) ? (o.port = '80') : /^(http|ws)s$/.test(o.protocol) && (o.port = '443')),
          (o.path = o.path || '/')
        let a = o.host.indexOf(':') !== -1 ? '[' + o.host + ']' : o.host
        return (
          (o.id = o.protocol + '://' + a + ':' + o.port + s),
          (o.href = o.protocol + '://' + a + (u && u.port === o.port ? '' : ':' + o.port)),
          o
        )
      }
      e.url = n
    }
  }),
  yD = te({
    'node_modules/has-cors/index.js'(e, r) {
      V(), F()
      try {
        r.exports = typeof XMLHttpRequest != 'undefined' && 'withCredentials' in new XMLHttpRequest()
      } catch (t) {
        r.exports = !1
      }
    }
  }),
  ff = te({
    'node_modules/engine.io-client/lib/globalThis.browser.js'(e, r) {
      V(),
        F(),
        (r.exports = (() =>
          typeof self != 'undefined' ? self : typeof window != 'undefined' ? window : Function('return this')())())
    }
  }),
  zS = te({
    'node_modules/engine.io-client/lib/xmlhttprequest.js'(e, r) {
      V(), F()
      var t = yD(),
        n = ff()
      r.exports = function (i) {
        let s = i.xdomain,
          u = i.xscheme,
          o = i.enablesXDR
        try {
          if (typeof XMLHttpRequest != 'undefined' && (!s || t)) return new XMLHttpRequest()
        } catch (l) {}
        try {
          if (typeof XDomainRequest != 'undefined' && !u && o) return new XDomainRequest()
        } catch (l) {}
        if (!s)
          try {
            return new n[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP')
          } catch (l) {}
      }
    }
  }),
  KS = te({
    'node_modules/engine.io-parser/lib/commons.js'(e, r) {
      V(), F()
      var t = Object.create(null)
      ;(t.open = '0'),
        (t.close = '1'),
        (t.ping = '2'),
        (t.pong = '3'),
        (t.message = '4'),
        (t.upgrade = '5'),
        (t.noop = '6')
      var n = Object.create(null)
      Object.keys(t).forEach((s) => {
        n[t[s]] = s
      })
      var i = { type: 'error', data: 'parser error' }
      r.exports = { PACKET_TYPES: t, PACKET_TYPES_REVERSE: n, ERROR_PACKET: i }
    }
  }),
  vD = te({
    'node_modules/engine.io-parser/lib/encodePacket.browser.js'(e, r) {
      V(), F()
      var { PACKET_TYPES: t } = KS(),
        n =
          typeof Blob == 'function' ||
          (typeof Blob != 'undefined' && Object.prototype.toString.call(Blob) === '[object BlobConstructor]'),
        i = typeof ArrayBuffer == 'function',
        s = (l) =>
          typeof ArrayBuffer.isView == 'function' ? ArrayBuffer.isView(l) : l && l.buffer instanceof ArrayBuffer,
        u = ({ type: l, data: a }, c, f) =>
          n && a instanceof Blob
            ? c
              ? f(a)
              : o(a, f)
            : i && (a instanceof ArrayBuffer || s(a))
            ? c
              ? f(a instanceof ArrayBuffer ? a : a.buffer)
              : o(new Blob([a]), f)
            : f(t[l] + (a || '')),
        o = (l, a) => {
          let c = new FileReader()
          return (
            (c.onload = function () {
              let f = c.result.split(',')[1]
              a('b' + f)
            }),
            c.readAsDataURL(l)
          )
        }
      r.exports = u
    }
  }),
  gD = te({
    'node_modules/base64-arraybuffer/lib/base64-arraybuffer.js'(e) {
      V(),
        F(),
        (function (r) {
          'use strict'
          ;(e.encode = function (t) {
            var n = new Uint8Array(t),
              i,
              s = n.length,
              u = ''
            for (i = 0; i < s; i += 3)
              (u += r[n[i] >> 2]),
                (u += r[((n[i] & 3) << 4) | (n[i + 1] >> 4)]),
                (u += r[((n[i + 1] & 15) << 2) | (n[i + 2] >> 6)]),
                (u += r[n[i + 2] & 63])
            return (
              s % 3 == 2
                ? (u = u.substring(0, u.length - 1) + '=')
                : s % 3 == 1 && (u = u.substring(0, u.length - 2) + '=='),
              u
            )
          }),
            (e.decode = function (t) {
              var n = t.length * 0.75,
                i = t.length,
                s,
                u = 0,
                o,
                l,
                a,
                c
              t[t.length - 1] === '=' && (n--, t[t.length - 2] === '=' && n--)
              var f = new ArrayBuffer(n),
                p = new Uint8Array(f)
              for (s = 0; s < i; s += 4)
                (o = r.indexOf(t[s])),
                  (l = r.indexOf(t[s + 1])),
                  (a = r.indexOf(t[s + 2])),
                  (c = r.indexOf(t[s + 3])),
                  (p[u++] = (o << 2) | (l >> 4)),
                  (p[u++] = ((l & 15) << 4) | (a >> 2)),
                  (p[u++] = ((a & 3) << 6) | (c & 63))
              return f
            })
        })('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/')
    }
  }),
  wD = te({
    'node_modules/engine.io-parser/lib/decodePacket.browser.js'(e, r) {
      V(), F()
      var { PACKET_TYPES_REVERSE: t, ERROR_PACKET: n } = KS(),
        i = typeof ArrayBuffer == 'function',
        s
      i && (s = gD())
      var u = (a, c) => {
          if (typeof a != 'string') return { type: 'message', data: l(a, c) }
          let f = a.charAt(0)
          return f === 'b'
            ? { type: 'message', data: o(a.substring(1), c) }
            : t[f]
            ? a.length > 1
              ? { type: t[f], data: a.substring(1) }
              : { type: t[f] }
            : n
        },
        o = (a, c) => {
          if (s) {
            let f = s.decode(a)
            return l(f, c)
          } else return { base64: !0, data: a }
        },
        l = (a, c) => {
          switch (c) {
            case 'blob':
              return a instanceof ArrayBuffer ? new Blob([a]) : a
            case 'arraybuffer':
            default:
              return a
          }
        }
      r.exports = u
    }
  }),
  Jc = te({
    'node_modules/engine.io-parser/lib/index.js'(e, r) {
      V(), F()
      var t = vD(),
        n = wD(),
        i = String.fromCharCode(30),
        s = (o, l) => {
          let a = o.length,
            c = new Array(a),
            f = 0
          o.forEach((p, y) => {
            t(p, !1, (d) => {
              ;(c[y] = d), ++f === a && l(c.join(i))
            })
          })
        },
        u = (o, l) => {
          let a = o.split(i),
            c = []
          for (let f = 0; f < a.length; f++) {
            let p = n(a[f], l)
            if ((c.push(p), p.type === 'error')) break
          }
          return c
        }
      r.exports = { protocol: 4, encodePacket: t, encodePayload: s, decodePacket: n, decodePayload: u }
    }
  }),
  Xc = te({
    'node_modules/component-emitter/index.js'(e, r) {
      V(), F(), typeof r != 'undefined' && (r.exports = t)
      function t(i) {
        if (i) return n(i)
      }
      function n(i) {
        for (var s in t.prototype) i[s] = t.prototype[s]
        return i
      }
      ;(t.prototype.on = t.prototype.addEventListener =
        function (i, s) {
          return (
            (this._callbacks = this._callbacks || {}),
            (this._callbacks['$' + i] = this._callbacks['$' + i] || []).push(s),
            this
          )
        }),
        (t.prototype.once = function (i, s) {
          function u() {
            this.off(i, u), s.apply(this, arguments)
          }
          return (u.fn = s), this.on(i, u), this
        }),
        (t.prototype.off =
          t.prototype.removeListener =
          t.prototype.removeAllListeners =
          t.prototype.removeEventListener =
            function (i, s) {
              if (((this._callbacks = this._callbacks || {}), arguments.length == 0))
                return (this._callbacks = {}), this
              var u = this._callbacks['$' + i]
              if (!u) return this
              if (arguments.length == 1) return delete this._callbacks['$' + i], this
              for (var o, l = 0; l < u.length; l++)
                if (((o = u[l]), o === s || o.fn === s)) {
                  u.splice(l, 1)
                  break
                }
              return u.length === 0 && delete this._callbacks['$' + i], this
            }),
        (t.prototype.emit = function (i) {
          this._callbacks = this._callbacks || {}
          for (var s = new Array(arguments.length - 1), u = this._callbacks['$' + i], o = 1; o < arguments.length; o++)
            s[o - 1] = arguments[o]
          if (u) {
            u = u.slice(0)
            for (var o = 0, l = u.length; o < l; ++o) u[o].apply(this, s)
          }
          return this
        }),
        (t.prototype.listeners = function (i) {
          return (this._callbacks = this._callbacks || {}), this._callbacks['$' + i] || []
        }),
        (t.prototype.hasListeners = function (i) {
          return !!this.listeners(i).length
        })
    }
  }),
  q1 = te({
    'node_modules/engine.io-client/lib/transport.js'(e, r) {
      V(), F()
      var t = Jc(),
        n = Xc(),
        i = mt()('engine.io-client:transport'),
        s = class extends n {
          constructor(u) {
            super()
            ;(this.opts = u), (this.query = u.query), (this.readyState = ''), (this.socket = u.socket)
          }
          onError(u, o) {
            let l = new Error(u)
            return (l.type = 'TransportError'), (l.description = o), this.emit('error', l), this
          }
          open() {
            return (
              (this.readyState === 'closed' || this.readyState === '') &&
                ((this.readyState = 'opening'), this.doOpen()),
              this
            )
          }
          close() {
            return (
              (this.readyState === 'opening' || this.readyState === 'open') && (this.doClose(), this.onClose()), this
            )
          }
          send(u) {
            this.readyState === 'open' ? this.write(u) : i('transport is not open, discarding packets')
          }
          onOpen() {
            ;(this.readyState = 'open'), (this.writable = !0), this.emit('open')
          }
          onData(u) {
            let o = t.decodePacket(u, this.socket.binaryType)
            this.onPacket(o)
          }
          onPacket(u) {
            this.emit('packet', u)
          }
          onClose() {
            ;(this.readyState = 'closed'), this.emit('close')
          }
        }
      r.exports = s
    }
  }),
  j1 = te({
    'node_modules/parseqs/index.js'(e) {
      V(),
        F(),
        (e.encode = function (r) {
          var t = ''
          for (var n in r)
            r.hasOwnProperty(n) &&
              (t.length && (t += '&'), (t += encodeURIComponent(n) + '=' + encodeURIComponent(r[n])))
          return t
        }),
        (e.decode = function (r) {
          for (var t = {}, n = r.split('&'), i = 0, s = n.length; i < s; i++) {
            var u = n[i].split('=')
            t[decodeURIComponent(u[0])] = decodeURIComponent(u[1])
          }
          return t
        })
    }
  }),
  FS = te({
    'node_modules/yeast/index.js'(e, r) {
      V(), F()
      var t = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
        n = 64,
        i = {},
        s = 0,
        u = 0,
        o
      function l(f) {
        var p = ''
        do (p = t[f % n] + p), (f = Math.floor(f / n))
        while (f > 0)
        return p
      }
      function a(f) {
        var p = 0
        for (u = 0; u < f.length; u++) p = p * n + i[f.charAt(u)]
        return p
      }
      function c() {
        var f = l(+new Date())
        return f !== o ? ((s = 0), (o = f)) : f + '.' + l(s++)
      }
      for (; u < n; u++) i[t[u]] = u
      ;(c.encode = l), (c.decode = a), (r.exports = c)
    }
  }),
  VS = te({
    'node_modules/engine.io-client/lib/transports/polling.js'(e, r) {
      V(), F()
      var t = q1(),
        n = j1(),
        i = Jc(),
        s = FS(),
        u = mt()('engine.io-client:polling'),
        o = class extends t {
          get name() {
            return 'polling'
          }
          doOpen() {
            this.poll()
          }
          pause(l) {
            this.readyState = 'pausing'
            let a = () => {
              u('paused'), (this.readyState = 'paused'), l()
            }
            if (this.polling || !this.writable) {
              let c = 0
              this.polling &&
                (u('we are currently polling - waiting to pause'),
                c++,
                this.once('pollComplete', function () {
                  u('pre-pause polling complete'), --c || a()
                })),
                this.writable ||
                  (u('we are currently writing - waiting to pause'),
                  c++,
                  this.once('drain', function () {
                    u('pre-pause writing complete'), --c || a()
                  }))
            } else a()
          }
          poll() {
            u('polling'), (this.polling = !0), this.doPoll(), this.emit('poll')
          }
          onData(l) {
            u('polling got data %s', l)
            let a = (c) => {
              if ((this.readyState === 'opening' && c.type === 'open' && this.onOpen(), c.type === 'close'))
                return this.onClose(), !1
              this.onPacket(c)
            }
            i.decodePayload(l, this.socket.binaryType).forEach(a),
              this.readyState !== 'closed' &&
                ((this.polling = !1),
                this.emit('pollComplete'),
                this.readyState === 'open' ? this.poll() : u('ignoring poll - transport state "%s"', this.readyState))
          }
          doClose() {
            let l = () => {
              u('writing close packet'), this.write([{ type: 'close' }])
            }
            this.readyState === 'open'
              ? (u('transport open - closing'), l())
              : (u('transport not open - deferring close'), this.once('open', l))
          }
          write(l) {
            ;(this.writable = !1),
              i.encodePayload(l, (a) => {
                this.doWrite(a, () => {
                  ;(this.writable = !0), this.emit('drain')
                })
              })
          }
          uri() {
            let l = this.query || {},
              a = this.opts.secure ? 'https' : 'http',
              c = ''
            this.opts.timestampRequests !== !1 && (l[this.opts.timestampParam] = s()),
              !this.supportsBinary && !l.sid && (l.b64 = 1),
              (l = n.encode(l)),
              this.opts.port &&
                ((a === 'https' && Number(this.opts.port) !== 443) ||
                  (a === 'http' && Number(this.opts.port) !== 80)) &&
                (c = ':' + this.opts.port),
              l.length && (l = '?' + l)
            let f = this.opts.hostname.indexOf(':') !== -1
            return a + '://' + (f ? '[' + this.opts.hostname + ']' : this.opts.hostname) + c + this.opts.path + l
          }
        }
      r.exports = o
    }
  }),
  HS = te({
    'node_modules/engine.io-client/lib/util.js'(e, r) {
      V(), F(), (r.exports.pick = (t, ...n) => n.reduce((i, s) => (t.hasOwnProperty(s) && (i[s] = t[s]), i), {}))
    }
  }),
  _D = te({
    'node_modules/engine.io-client/lib/transports/polling-xhr.js'(e, r) {
      V(), F()
      var t = zS(),
        n = VS(),
        i = Xc(),
        { pick: s } = HS(),
        u = ff(),
        o = mt()('engine.io-client:polling-xhr')
      function l() {}
      var a = (function () {
          return new t({ xdomain: !1 }).responseType != null
        })(),
        c = class extends n {
          constructor(y) {
            super(y)
            if (typeof location != 'undefined') {
              let h = location.protocol === 'https:',
                m = location.port
              m || (m = h ? 443 : 80),
                (this.xd = (typeof location != 'undefined' && y.hostname !== location.hostname) || m !== y.port),
                (this.xs = y.secure !== h)
            }
            let d = y && y.forceBase64
            this.supportsBinary = a && !d
          }
          request(y = {}) {
            return Object.assign(y, { xd: this.xd, xs: this.xs }, this.opts), new f(this.uri(), y)
          }
          doWrite(y, d) {
            let h = this.request({ method: 'POST', data: y })
            h.on('success', d),
              h.on('error', (m) => {
                this.onError('xhr post error', m)
              })
          }
          doPoll() {
            o('xhr poll')
            let y = this.request()
            y.on('data', this.onData.bind(this)),
              y.on('error', (d) => {
                this.onError('xhr poll error', d)
              }),
              (this.pollXhr = y)
          }
        },
        f = class extends i {
          constructor(y, d) {
            super()
            ;(this.opts = d),
              (this.method = d.method || 'GET'),
              (this.uri = y),
              (this.async = d.async !== !1),
              (this.data = d.data !== void 0 ? d.data : null),
              this.create()
          }
          create() {
            let y = s(
              this.opts,
              'agent',
              'enablesXDR',
              'pfx',
              'key',
              'passphrase',
              'cert',
              'ca',
              'ciphers',
              'rejectUnauthorized',
              'autoUnref'
            )
            ;(y.xdomain = !!this.opts.xd), (y.xscheme = !!this.opts.xs)
            let d = (this.xhr = new t(y))
            try {
              o('xhr open %s: %s', this.method, this.uri), d.open(this.method, this.uri, this.async)
              try {
                if (this.opts.extraHeaders) {
                  d.setDisableHeaderCheck && d.setDisableHeaderCheck(!0)
                  for (let h in this.opts.extraHeaders)
                    this.opts.extraHeaders.hasOwnProperty(h) && d.setRequestHeader(h, this.opts.extraHeaders[h])
                }
              } catch (h) {}
              if (this.method === 'POST')
                try {
                  d.setRequestHeader('Content-type', 'text/plain;charset=UTF-8')
                } catch (h) {}
              try {
                d.setRequestHeader('Accept', '*/*')
              } catch (h) {}
              'withCredentials' in d && (d.withCredentials = this.opts.withCredentials),
                this.opts.requestTimeout && (d.timeout = this.opts.requestTimeout),
                this.hasXDR()
                  ? ((d.onload = () => {
                      this.onLoad()
                    }),
                    (d.onerror = () => {
                      this.onError(d.responseText)
                    }))
                  : (d.onreadystatechange = () => {
                      d.readyState === 4 &&
                        (d.status === 200 || d.status === 1223
                          ? this.onLoad()
                          : setTimeout(() => {
                              this.onError(typeof d.status == 'number' ? d.status : 0)
                            }, 0))
                    }),
                o('xhr data %s', this.data),
                d.send(this.data)
            } catch (h) {
              setTimeout(() => {
                this.onError(h)
              }, 0)
              return
            }
            typeof document != 'undefined' && ((this.index = f.requestsCount++), (f.requests[this.index] = this))
          }
          onSuccess() {
            this.emit('success'), this.cleanup()
          }
          onData(y) {
            this.emit('data', y), this.onSuccess()
          }
          onError(y) {
            this.emit('error', y), this.cleanup(!0)
          }
          cleanup(y) {
            if (!(typeof this.xhr == 'undefined' || this.xhr === null)) {
              if ((this.hasXDR() ? (this.xhr.onload = this.xhr.onerror = l) : (this.xhr.onreadystatechange = l), y))
                try {
                  this.xhr.abort()
                } catch (d) {}
              typeof document != 'undefined' && delete f.requests[this.index], (this.xhr = null)
            }
          }
          onLoad() {
            let y = this.xhr.responseText
            y !== null && this.onData(y)
          }
          hasXDR() {
            return typeof XDomainRequest != 'undefined' && !this.xs && this.enablesXDR
          }
          abort() {
            this.cleanup()
          }
        }
      if (((f.requestsCount = 0), (f.requests = {}), typeof document != 'undefined')) {
        if (typeof attachEvent == 'function') attachEvent('onunload', p)
        else if (typeof addEventListener == 'function') {
          let y = 'onpagehide' in u ? 'pagehide' : 'unload'
          addEventListener(y, p, !1)
        }
      }
      function p() {
        for (let y in f.requests) f.requests.hasOwnProperty(y) && f.requests[y].abort()
      }
      ;(r.exports = c), (r.exports.Request = f)
    }
  }),
  ED = te({
    'node_modules/engine.io-client/lib/transports/polling-jsonp.js'(e, r) {
      V(), F()
      var t = VS(),
        n = ff(),
        i = /\n/g,
        s = /\\n/g,
        u,
        o = class extends t {
          constructor(l) {
            super(l)
            ;(this.query = this.query || {}),
              u || (u = n.___eio = n.___eio || []),
              (this.index = u.length),
              u.push(this.onData.bind(this)),
              (this.query.j = this.index)
          }
          get supportsBinary() {
            return !1
          }
          doClose() {
            this.script &&
              ((this.script.onerror = () => {}), this.script.parentNode.removeChild(this.script), (this.script = null)),
              this.form && (this.form.parentNode.removeChild(this.form), (this.form = null), (this.iframe = null)),
              super.doClose()
          }
          doPoll() {
            let l = document.createElement('script')
            this.script && (this.script.parentNode.removeChild(this.script), (this.script = null)),
              (l.async = !0),
              (l.src = this.uri()),
              (l.onerror = (f) => {
                this.onError('jsonp poll error', f)
              })
            let a = document.getElementsByTagName('script')[0]
            a ? a.parentNode.insertBefore(l, a) : (document.head || document.body).appendChild(l),
              (this.script = l),
              typeof navigator != 'undefined' &&
                /gecko/i.test(navigator.userAgent) &&
                setTimeout(function () {
                  let f = document.createElement('iframe')
                  document.body.appendChild(f), document.body.removeChild(f)
                }, 100)
          }
          doWrite(l, a) {
            let c
            if (!this.form) {
              let y = document.createElement('form'),
                d = document.createElement('textarea'),
                h = (this.iframeId = 'eio_iframe_' + this.index)
              ;(y.className = 'socketio'),
                (y.style.position = 'absolute'),
                (y.style.top = '-1000px'),
                (y.style.left = '-1000px'),
                (y.target = h),
                (y.method = 'POST'),
                y.setAttribute('accept-charset', 'utf-8'),
                (d.name = 'd'),
                y.appendChild(d),
                document.body.appendChild(y),
                (this.form = y),
                (this.area = d)
            }
            this.form.action = this.uri()
            function f() {
              p(), a()
            }
            let p = () => {
              if (this.iframe)
                try {
                  this.form.removeChild(this.iframe)
                } catch (y) {
                  this.onError('jsonp polling iframe removal error', y)
                }
              try {
                let y = '<iframe src="javascript:0" name="' + this.iframeId + '">'
                c = document.createElement(y)
              } catch (y) {
                ;(c = document.createElement('iframe')), (c.name = this.iframeId), (c.src = 'javascript:0')
              }
              ;(c.id = this.iframeId), this.form.appendChild(c), (this.iframe = c)
            }
            p(),
              (l = l.replace(
                s,
                `\\
`
              )),
              (this.area.value = l.replace(i, '\\n'))
            try {
              this.form.submit()
            } catch (y) {}
            this.iframe.attachEvent
              ? (this.iframe.onreadystatechange = () => {
                  this.iframe.readyState === 'complete' && f()
                })
              : (this.iframe.onload = f)
          }
        }
      r.exports = o
    }
  }),
  SD = te({
    'node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js'(e, r) {
      V(), F()
      var t = ff(),
        n = (() =>
          typeof Promise == 'function' && typeof Promise.resolve == 'function'
            ? (s) => Promise.resolve().then(s)
            : (s) => setTimeout(s, 0))()
      r.exports = {
        WebSocket: t.WebSocket || t.MozWebSocket,
        usingBrowserWebSocket: !0,
        defaultBinaryType: 'arraybuffer',
        nextTick: n
      }
    }
  }),
  AD = te({
    'node_modules/engine.io-client/lib/transports/websocket.js'(e, r) {
      V(), F()
      var t = q1(),
        n = Jc(),
        i = j1(),
        s = FS(),
        { pick: u } = HS(),
        { WebSocket: o, usingBrowserWebSocket: l, defaultBinaryType: a, nextTick: c } = SD(),
        f = mt()('engine.io-client:websocket'),
        p =
          typeof navigator != 'undefined' &&
          typeof navigator.product == 'string' &&
          navigator.product.toLowerCase() === 'reactnative',
        y = class extends t {
          constructor(d) {
            super(d)
            this.supportsBinary = !d.forceBase64
          }
          get name() {
            return 'websocket'
          }
          doOpen() {
            if (!this.check()) return
            let d = this.uri(),
              h = this.opts.protocols,
              m = p
                ? {}
                : u(
                    this.opts,
                    'agent',
                    'perMessageDeflate',
                    'pfx',
                    'key',
                    'passphrase',
                    'cert',
                    'ca',
                    'ciphers',
                    'rejectUnauthorized',
                    'localAddress',
                    'protocolVersion',
                    'origin',
                    'maxPayload',
                    'family',
                    'checkServerIdentity'
                  )
            this.opts.extraHeaders && (m.headers = this.opts.extraHeaders)
            try {
              this.ws = l && !p ? (h ? new o(d, h) : new o(d)) : new o(d, h, m)
            } catch (_) {
              return this.emit('error', _)
            }
            ;(this.ws.binaryType = this.socket.binaryType || a), this.addEventListeners()
          }
          addEventListeners() {
            ;(this.ws.onopen = () => {
              this.opts.autoUnref && this.ws._socket.unref(), this.onOpen()
            }),
              (this.ws.onclose = this.onClose.bind(this)),
              (this.ws.onmessage = (d) => this.onData(d.data)),
              (this.ws.onerror = (d) => this.onError('websocket error', d))
          }
          write(d) {
            this.writable = !1
            for (let h = 0; h < d.length; h++) {
              let m = d[h],
                _ = h === d.length - 1
              n.encodePacket(m, this.supportsBinary, (A) => {
                let T = {}
                l ||
                  (m.options && (T.compress = m.options.compress),
                  this.opts.perMessageDeflate &&
                    (typeof A == 'string' ? Ve.Buffer.byteLength(A) : A.length) <
                      this.opts.perMessageDeflate.threshold &&
                    (T.compress = !1))
                try {
                  l ? this.ws.send(A) : this.ws.send(A, T)
                } catch (E) {
                  f('websocket closed before onclose event')
                }
                _ &&
                  c(() => {
                    ;(this.writable = !0), this.emit('drain')
                  })
              })
            }
          }
          onClose() {
            t.prototype.onClose.call(this)
          }
          doClose() {
            typeof this.ws != 'undefined' && (this.ws.close(), (this.ws = null))
          }
          uri() {
            let d = this.query || {},
              h = this.opts.secure ? 'wss' : 'ws',
              m = ''
            this.opts.port &&
              ((h === 'wss' && Number(this.opts.port) !== 443) || (h === 'ws' && Number(this.opts.port) !== 80)) &&
              (m = ':' + this.opts.port),
              this.opts.timestampRequests && (d[this.opts.timestampParam] = s()),
              this.supportsBinary || (d.b64 = 1),
              (d = i.encode(d)),
              d.length && (d = '?' + d)
            let _ = this.opts.hostname.indexOf(':') !== -1
            return h + '://' + (_ ? '[' + this.opts.hostname + ']' : this.opts.hostname) + m + this.opts.path + d
          }
          check() {
            return !!o && !('__initialize' in o && this.name === y.prototype.name)
          }
        }
      r.exports = y
    }
  }),
  $S = te({
    'node_modules/engine.io-client/lib/transports/index.js'(e) {
      V(), F()
      var r = zS(),
        t = _D(),
        n = ED(),
        i = AD()
      ;(e.polling = s), (e.websocket = i)
      function s(u) {
        let o,
          l = !1,
          a = !1,
          c = u.jsonp !== !1
        if (typeof location != 'undefined') {
          let f = location.protocol === 'https:',
            p = location.port
          p || (p = f ? 443 : 80), (l = u.hostname !== location.hostname || p !== u.port), (a = u.secure !== f)
        }
        if (((u.xdomain = l), (u.xscheme = a), (o = new r(u)), 'open' in o && !u.forceJSONP)) return new t(u)
        if (!c) throw new Error('JSONP disabled')
        return new n(u)
      }
    }
  }),
  ID = te({
    'node_modules/engine.io-client/lib/socket.js'(e, r) {
      V(), F()
      var t = $S(),
        n = Xc(),
        i = mt()('engine.io-client:socket'),
        s = Jc(),
        u = jS(),
        o = j1(),
        l = class extends n {
          constructor(c, f = {}) {
            super()
            c && typeof c == 'object' && ((f = c), (c = null)),
              c
                ? ((c = u(c)),
                  (f.hostname = c.host),
                  (f.secure = c.protocol === 'https' || c.protocol === 'wss'),
                  (f.port = c.port),
                  c.query && (f.query = c.query))
                : f.host && (f.hostname = u(f.host).host),
              (this.secure =
                f.secure != null ? f.secure : typeof location != 'undefined' && location.protocol === 'https:'),
              f.hostname && !f.port && (f.port = this.secure ? '443' : '80'),
              (this.hostname = f.hostname || (typeof location != 'undefined' ? location.hostname : 'localhost')),
              (this.port =
                f.port || (typeof location != 'undefined' && location.port ? location.port : this.secure ? 443 : 80)),
              (this.transports = f.transports || ['polling', 'websocket']),
              (this.readyState = ''),
              (this.writeBuffer = []),
              (this.prevBufferLen = 0),
              (this.opts = Object.assign(
                {
                  path: '/engine.io',
                  agent: !1,
                  withCredentials: !1,
                  upgrade: !0,
                  jsonp: !0,
                  timestampParam: 't',
                  rememberUpgrade: !1,
                  rejectUnauthorized: !0,
                  perMessageDeflate: { threshold: 1024 },
                  transportOptions: {},
                  closeOnBeforeunload: !0
                },
                f
              )),
              (this.opts.path = this.opts.path.replace(/\/$/, '') + '/'),
              typeof this.opts.query == 'string' && (this.opts.query = o.decode(this.opts.query)),
              (this.id = null),
              (this.upgrades = null),
              (this.pingInterval = null),
              (this.pingTimeout = null),
              (this.pingTimeoutTimer = null),
              typeof addEventListener == 'function' &&
                (this.opts.closeOnBeforeunload &&
                  addEventListener(
                    'beforeunload',
                    () => {
                      this.transport && (this.transport.removeAllListeners(), this.transport.close())
                    },
                    !1
                  ),
                this.hostname !== 'localhost' &&
                  ((this.offlineEventListener = () => {
                    this.onClose('transport close')
                  }),
                  addEventListener('offline', this.offlineEventListener, !1))),
              this.open()
          }
          createTransport(c) {
            i('creating transport "%s"', c)
            let f = a(this.opts.query)
            ;(f.EIO = s.protocol), (f.transport = c), this.id && (f.sid = this.id)
            let p = Object.assign({}, this.opts.transportOptions[c], this.opts, {
              query: f,
              socket: this,
              hostname: this.hostname,
              secure: this.secure,
              port: this.port
            })
            return i('options: %j', p), new t[c](p)
          }
          open() {
            let c
            if (this.opts.rememberUpgrade && l.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1)
              c = 'websocket'
            else if (this.transports.length === 0) {
              setTimeout(() => {
                this.emit('error', 'No transports available')
              }, 0)
              return
            } else c = this.transports[0]
            this.readyState = 'opening'
            try {
              c = this.createTransport(c)
            } catch (f) {
              i('error while creating transport: %s', f), this.transports.shift(), this.open()
              return
            }
            c.open(), this.setTransport(c)
          }
          setTransport(c) {
            i('setting transport %s', c.name),
              this.transport &&
                (i('clearing existing transport %s', this.transport.name), this.transport.removeAllListeners()),
              (this.transport = c),
              c
                .on('drain', this.onDrain.bind(this))
                .on('packet', this.onPacket.bind(this))
                .on('error', this.onError.bind(this))
                .on('close', () => {
                  this.onClose('transport close')
                })
          }
          probe(c) {
            i('probing transport "%s"', c)
            let f = this.createTransport(c, { probe: 1 }),
              p = !1
            l.priorWebsocketSuccess = !1
            let y = () => {
              p ||
                (i('probe transport "%s" opened', c),
                f.send([{ type: 'ping', data: 'probe' }]),
                f.once('packet', (E) => {
                  if (!p)
                    if (E.type === 'pong' && E.data === 'probe') {
                      if ((i('probe transport "%s" pong', c), (this.upgrading = !0), this.emit('upgrading', f), !f))
                        return
                      ;(l.priorWebsocketSuccess = f.name === 'websocket'),
                        i('pausing current transport "%s"', this.transport.name),
                        this.transport.pause(() => {
                          p ||
                            (this.readyState !== 'closed' &&
                              (i('changing transport and sending upgrade packet'),
                              T(),
                              this.setTransport(f),
                              f.send([{ type: 'upgrade' }]),
                              this.emit('upgrade', f),
                              (f = null),
                              (this.upgrading = !1),
                              this.flush()))
                        })
                    } else {
                      i('probe transport "%s" failed', c)
                      let k = new Error('probe error')
                      ;(k.transport = f.name), this.emit('upgradeError', k)
                    }
                }))
            }
            function d() {
              p || ((p = !0), T(), f.close(), (f = null))
            }
            let h = (E) => {
              let k = new Error('probe error: ' + E)
              ;(k.transport = f.name),
                d(),
                i('probe transport "%s" failed because of error: %s', c, E),
                this.emit('upgradeError', k)
            }
            function m() {
              h('transport closed')
            }
            function _() {
              h('socket closed')
            }
            function A(E) {
              f && E.name !== f.name && (i('"%s" works - aborting "%s"', E.name, f.name), d())
            }
            let T = () => {
              f.removeListener('open', y),
                f.removeListener('error', h),
                f.removeListener('close', m),
                this.removeListener('close', _),
                this.removeListener('upgrading', A)
            }
            f.once('open', y),
              f.once('error', h),
              f.once('close', m),
              this.once('close', _),
              this.once('upgrading', A),
              f.open()
          }
          onOpen() {
            if (
              (i('socket open'),
              (this.readyState = 'open'),
              (l.priorWebsocketSuccess = this.transport.name === 'websocket'),
              this.emit('open'),
              this.flush(),
              this.readyState === 'open' && this.opts.upgrade && this.transport.pause)
            ) {
              i('starting upgrade probes')
              let c = 0,
                f = this.upgrades.length
              for (; c < f; c++) this.probe(this.upgrades[c])
            }
          }
          onPacket(c) {
            if (this.readyState === 'opening' || this.readyState === 'open' || this.readyState === 'closing')
              switch (
                (i('socket receive: type "%s", data "%s"', c.type, c.data),
                this.emit('packet', c),
                this.emit('heartbeat'),
                c.type)
              ) {
                case 'open':
                  this.onHandshake(JSON.parse(c.data))
                  break
                case 'ping':
                  this.resetPingTimeout(), this.sendPacket('pong'), this.emit('ping'), this.emit('pong')
                  break
                case 'error':
                  let f = new Error('server error')
                  ;(f.code = c.data), this.onError(f)
                  break
                case 'message':
                  this.emit('data', c.data), this.emit('message', c.data)
                  break
              }
            else i('packet received with socket readyState "%s"', this.readyState)
          }
          onHandshake(c) {
            this.emit('handshake', c),
              (this.id = c.sid),
              (this.transport.query.sid = c.sid),
              (this.upgrades = this.filterUpgrades(c.upgrades)),
              (this.pingInterval = c.pingInterval),
              (this.pingTimeout = c.pingTimeout),
              this.onOpen(),
              this.readyState !== 'closed' && this.resetPingTimeout()
          }
          resetPingTimeout() {
            clearTimeout(this.pingTimeoutTimer),
              (this.pingTimeoutTimer = setTimeout(() => {
                this.onClose('ping timeout')
              }, this.pingInterval + this.pingTimeout)),
              this.opts.autoUnref && this.pingTimeoutTimer.unref()
          }
          onDrain() {
            this.writeBuffer.splice(0, this.prevBufferLen),
              (this.prevBufferLen = 0),
              this.writeBuffer.length === 0 ? this.emit('drain') : this.flush()
          }
          flush() {
            this.readyState !== 'closed' &&
              this.transport.writable &&
              !this.upgrading &&
              this.writeBuffer.length &&
              (i('flushing %d packets in socket', this.writeBuffer.length),
              this.transport.send(this.writeBuffer),
              (this.prevBufferLen = this.writeBuffer.length),
              this.emit('flush'))
          }
          write(c, f, p) {
            return this.sendPacket('message', c, f, p), this
          }
          send(c, f, p) {
            return this.sendPacket('message', c, f, p), this
          }
          sendPacket(c, f, p, y) {
            if (
              (typeof f == 'function' && ((y = f), (f = void 0)),
              typeof p == 'function' && ((y = p), (p = null)),
              this.readyState === 'closing' || this.readyState === 'closed')
            )
              return
            ;(p = p || {}), (p.compress = p.compress !== !1)
            let d = { type: c, data: f, options: p }
            this.emit('packetCreate', d), this.writeBuffer.push(d), y && this.once('flush', y), this.flush()
          }
          close() {
            let c = () => {
                this.onClose('forced close'), i('socket closing - telling transport to close'), this.transport.close()
              },
              f = () => {
                this.removeListener('upgrade', f), this.removeListener('upgradeError', f), c()
              },
              p = () => {
                this.once('upgrade', f), this.once('upgradeError', f)
              }
            return (
              (this.readyState === 'opening' || this.readyState === 'open') &&
                ((this.readyState = 'closing'),
                this.writeBuffer.length
                  ? this.once('drain', () => {
                      this.upgrading ? p() : c()
                    })
                  : this.upgrading
                  ? p()
                  : c()),
              this
            )
          }
          onError(c) {
            i('socket error %j', c),
              (l.priorWebsocketSuccess = !1),
              this.emit('error', c),
              this.onClose('transport error', c)
          }
          onClose(c, f) {
            ;(this.readyState === 'opening' || this.readyState === 'open' || this.readyState === 'closing') &&
              (i('socket close with reason: "%s"', c),
              clearTimeout(this.pingIntervalTimer),
              clearTimeout(this.pingTimeoutTimer),
              this.transport.removeAllListeners('close'),
              this.transport.close(),
              this.transport.removeAllListeners(),
              typeof removeEventListener == 'function' && removeEventListener('offline', this.offlineEventListener, !1),
              (this.readyState = 'closed'),
              (this.id = null),
              this.emit('close', c, f),
              (this.writeBuffer = []),
              (this.prevBufferLen = 0))
          }
          filterUpgrades(c) {
            let f = [],
              p = 0,
              y = c.length
            for (; p < y; p++) ~this.transports.indexOf(c[p]) && f.push(c[p])
            return f
          }
        }
      ;(l.priorWebsocketSuccess = !1), (l.protocol = s.protocol)
      function a(c) {
        let f = {}
        for (let p in c) c.hasOwnProperty(p) && (f[p] = c[p])
        return f
      }
      r.exports = l
    }
  }),
  TD = te({
    'node_modules/engine.io-client/lib/index.js'(e, r) {
      V(), F()
      var t = ID()
      ;(r.exports = (n, i) => new t(n, i)),
        (r.exports.Socket = t),
        (r.exports.protocol = t.protocol),
        (r.exports.Transport = q1()),
        (r.exports.transports = $S()),
        (r.exports.parser = Jc())
    }
  }),
  GS = te({
    'node_modules/socket.io-parser/dist/is-binary.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.hasBinary = e.isBinary = void 0)
      var r = typeof ArrayBuffer == 'function',
        t = (l) => (typeof ArrayBuffer.isView == 'function' ? ArrayBuffer.isView(l) : l.buffer instanceof ArrayBuffer),
        n = Object.prototype.toString,
        i = typeof Blob == 'function' || (typeof Blob != 'undefined' && n.call(Blob) === '[object BlobConstructor]'),
        s = typeof File == 'function' || (typeof File != 'undefined' && n.call(File) === '[object FileConstructor]')
      function u(l) {
        return (r && (l instanceof ArrayBuffer || t(l))) || (i && l instanceof Blob) || (s && l instanceof File)
      }
      e.isBinary = u
      function o(l, a) {
        if (!l || typeof l != 'object') return !1
        if (Array.isArray(l)) {
          for (let c = 0, f = l.length; c < f; c++) if (o(l[c])) return !0
          return !1
        }
        if (u(l)) return !0
        if (l.toJSON && typeof l.toJSON == 'function' && arguments.length === 1) return o(l.toJSON(), !0)
        for (let c in l) if (Object.prototype.hasOwnProperty.call(l, c) && o(l[c])) return !0
        return !1
      }
      e.hasBinary = o
    }
  }),
  CD = te({
    'node_modules/socket.io-parser/dist/binary.js'(e) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.reconstructPacket = e.deconstructPacket = void 0)
      var r = GS()
      function t(u) {
        let o = [],
          l = u.data,
          a = u
        return (a.data = n(l, o)), (a.attachments = o.length), { packet: a, buffers: o }
      }
      e.deconstructPacket = t
      function n(u, o) {
        if (!u) return u
        if (r.isBinary(u)) {
          let l = { _placeholder: !0, num: o.length }
          return o.push(u), l
        } else if (Array.isArray(u)) {
          let l = new Array(u.length)
          for (let a = 0; a < u.length; a++) l[a] = n(u[a], o)
          return l
        } else if (typeof u == 'object' && !(u instanceof Date)) {
          let l = {}
          for (let a in u) u.hasOwnProperty(a) && (l[a] = n(u[a], o))
          return l
        }
        return u
      }
      function i(u, o) {
        return (u.data = s(u.data, o)), (u.attachments = void 0), u
      }
      e.reconstructPacket = i
      function s(u, o) {
        if (!u) return u
        if (u && u._placeholder) return o[u.num]
        if (Array.isArray(u)) for (let l = 0; l < u.length; l++) u[l] = s(u[l], o)
        else if (typeof u == 'object') for (let l in u) u.hasOwnProperty(l) && (u[l] = s(u[l], o))
        return u
      }
    }
  }),
  z1 = te({
    'node_modules/socket.io-parser/dist/index.js'(e) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.Decoder = e.Encoder = e.PacketType = e.protocol = void 0)
      var r = Xc(),
        t = CD(),
        n = GS(),
        i = mt()('socket.io-parser')
      e.protocol = 5
      var s
      ;(function (c) {
        ;(c[(c.CONNECT = 0)] = 'CONNECT'),
          (c[(c.DISCONNECT = 1)] = 'DISCONNECT'),
          (c[(c.EVENT = 2)] = 'EVENT'),
          (c[(c.ACK = 3)] = 'ACK'),
          (c[(c.CONNECT_ERROR = 4)] = 'CONNECT_ERROR'),
          (c[(c.BINARY_EVENT = 5)] = 'BINARY_EVENT'),
          (c[(c.BINARY_ACK = 6)] = 'BINARY_ACK')
      })((s = e.PacketType || (e.PacketType = {})))
      var u = class {
        encode(c) {
          return (
            i('encoding packet %j', c),
            (c.type === s.EVENT || c.type === s.ACK) && n.hasBinary(c)
              ? ((c.type = c.type === s.EVENT ? s.BINARY_EVENT : s.BINARY_ACK), this.encodeAsBinary(c))
              : [this.encodeAsString(c)]
          )
        }
        encodeAsString(c) {
          let f = '' + c.type
          return (
            (c.type === s.BINARY_EVENT || c.type === s.BINARY_ACK) && (f += c.attachments + '-'),
            c.nsp && c.nsp !== '/' && (f += c.nsp + ','),
            c.id != null && (f += c.id),
            c.data != null && (f += JSON.stringify(c.data)),
            i('encoded %j as %s', c, f),
            f
          )
        }
        encodeAsBinary(c) {
          let f = t.deconstructPacket(c),
            p = this.encodeAsString(f.packet),
            y = f.buffers
          return y.unshift(p), y
        }
      }
      e.Encoder = u
      var o = class extends r {
        constructor() {
          super()
        }
        add(c) {
          let f
          if (typeof c == 'string')
            (f = this.decodeString(c)),
              f.type === s.BINARY_EVENT || f.type === s.BINARY_ACK
                ? ((this.reconstructor = new a(f)), f.attachments === 0 && super.emit('decoded', f))
                : super.emit('decoded', f)
          else if (n.isBinary(c) || c.base64)
            if (this.reconstructor)
              (f = this.reconstructor.takeBinaryData(c)), f && ((this.reconstructor = null), super.emit('decoded', f))
            else throw new Error('got binary data when not reconstructing a packet')
          else throw new Error('Unknown type: ' + c)
        }
        decodeString(c) {
          let f = 0,
            p = { type: Number(c.charAt(0)) }
          if (s[p.type] === void 0) throw new Error('unknown packet type ' + p.type)
          if (p.type === s.BINARY_EVENT || p.type === s.BINARY_ACK) {
            let d = f + 1
            for (; c.charAt(++f) !== '-' && f != c.length; );
            let h = c.substring(d, f)
            if (h != Number(h) || c.charAt(f) !== '-') throw new Error('Illegal attachments')
            p.attachments = Number(h)
          }
          if (c.charAt(f + 1) === '/') {
            let d = f + 1
            for (; ++f && !(c.charAt(f) === ',' || f === c.length); );
            p.nsp = c.substring(d, f)
          } else p.nsp = '/'
          let y = c.charAt(f + 1)
          if (y !== '' && Number(y) == y) {
            let d = f + 1
            for (; ++f; ) {
              let h = c.charAt(f)
              if (h == null || Number(h) != h) {
                --f
                break
              }
              if (f === c.length) break
            }
            p.id = Number(c.substring(d, f + 1))
          }
          if (c.charAt(++f)) {
            let d = l(c.substr(f))
            if (o.isPayloadValid(p.type, d)) p.data = d
            else throw new Error('invalid payload')
          }
          return i('decoded %s as %j', c, p), p
        }
        static isPayloadValid(c, f) {
          switch (c) {
            case s.CONNECT:
              return typeof f == 'object'
            case s.DISCONNECT:
              return f === void 0
            case s.CONNECT_ERROR:
              return typeof f == 'string' || typeof f == 'object'
            case s.EVENT:
            case s.BINARY_EVENT:
              return Array.isArray(f) && f.length > 0
            case s.ACK:
            case s.BINARY_ACK:
              return Array.isArray(f)
          }
        }
        destroy() {
          this.reconstructor && this.reconstructor.finishedReconstruction()
        }
      }
      e.Decoder = o
      function l(c) {
        try {
          return JSON.parse(c)
        } catch (f) {
          return !1
        }
      }
      var a = class {
        constructor(c) {
          ;(this.packet = c), (this.buffers = []), (this.reconPack = c)
        }
        takeBinaryData(c) {
          if ((this.buffers.push(c), this.buffers.length === this.reconPack.attachments)) {
            let f = t.reconstructPacket(this.reconPack, this.buffers)
            return this.finishedReconstruction(), f
          }
          return null
        }
        finishedReconstruction() {
          ;(this.reconPack = null), (this.buffers = [])
        }
      }
    }
  }),
  WS = te({
    'node_modules/socket.io-client/build/on.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.on = void 0)
      function r(t, n, i) {
        return (
          t.on(n, i),
          function () {
            t.off(n, i)
          }
        )
      }
      e.on = r
    }
  }),
  JS = te({
    'node_modules/socket.io-client/build/typed-events.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.StrictEventEmitter = void 0)
      var r = Xc(),
        t = class extends r {
          on(n, i) {
            return super.on(n, i), this
          }
          once(n, i) {
            return super.once(n, i), this
          }
          emit(n, ...i) {
            return super.emit(n, ...i), this
          }
          emitReserved(n, ...i) {
            return super.emit(n, ...i), this
          }
          listeners(n) {
            return super.listeners(n)
          }
        }
      e.StrictEventEmitter = t
    }
  }),
  XS = te({
    'node_modules/socket.io-client/build/socket.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.Socket = void 0)
      var r = z1(),
        t = WS(),
        n = JS(),
        i = mt()('socket.io-client:socket'),
        s = Object.freeze({
          connect: 1,
          connect_error: 1,
          disconnect: 1,
          disconnecting: 1,
          newListener: 1,
          removeListener: 1
        }),
        u = class extends n.StrictEventEmitter {
          constructor(o, l, a) {
            super()
            ;(this.receiveBuffer = []),
              (this.sendBuffer = []),
              (this.ids = 0),
              (this.acks = {}),
              (this.flags = {}),
              (this.io = o),
              (this.nsp = l),
              (this.ids = 0),
              (this.acks = {}),
              (this.receiveBuffer = []),
              (this.sendBuffer = []),
              (this.connected = !1),
              (this.disconnected = !0),
              (this.flags = {}),
              a && a.auth && (this.auth = a.auth),
              this.io._autoConnect && this.open()
          }
          subEvents() {
            if (this.subs) return
            let o = this.io
            this.subs = [
              t.on(o, 'open', this.onopen.bind(this)),
              t.on(o, 'packet', this.onpacket.bind(this)),
              t.on(o, 'error', this.onerror.bind(this)),
              t.on(o, 'close', this.onclose.bind(this))
            ]
          }
          get active() {
            return !!this.subs
          }
          connect() {
            return this.connected
              ? this
              : (this.subEvents(),
                this.io._reconnecting || this.io.open(),
                this.io._readyState === 'open' && this.onopen(),
                this)
          }
          open() {
            return this.connect()
          }
          send(...o) {
            return o.unshift('message'), this.emit.apply(this, o), this
          }
          emit(o, ...l) {
            if (s.hasOwnProperty(o)) throw new Error('"' + o + '" is a reserved event name')
            l.unshift(o)
            let a = { type: r.PacketType.EVENT, data: l }
            ;(a.options = {}),
              (a.options.compress = this.flags.compress !== !1),
              typeof l[l.length - 1] == 'function' &&
                (i('emitting packet with ack id %d', this.ids), (this.acks[this.ids] = l.pop()), (a.id = this.ids++))
            let c = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable
            return (
              this.flags.volatile && (!c || !this.connected)
                ? i('discard packet as the transport is not currently writable')
                : this.connected
                ? this.packet(a)
                : this.sendBuffer.push(a),
              (this.flags = {}),
              this
            )
          }
          packet(o) {
            ;(o.nsp = this.nsp), this.io._packet(o)
          }
          onopen() {
            i('transport is open - connecting'),
              typeof this.auth == 'function'
                ? this.auth((o) => {
                    this.packet({ type: r.PacketType.CONNECT, data: o })
                  })
                : this.packet({ type: r.PacketType.CONNECT, data: this.auth })
          }
          onerror(o) {
            this.connected || this.emitReserved('connect_error', o)
          }
          onclose(o) {
            i('close (%s)', o),
              (this.connected = !1),
              (this.disconnected = !0),
              delete this.id,
              this.emitReserved('disconnect', o)
          }
          onpacket(o) {
            if (o.nsp === this.nsp)
              switch (o.type) {
                case r.PacketType.CONNECT:
                  if (o.data && o.data.sid) {
                    let c = o.data.sid
                    this.onconnect(c)
                  } else
                    this.emitReserved(
                      'connect_error',
                      new Error(
                        'It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)'
                      )
                    )
                  break
                case r.PacketType.EVENT:
                  this.onevent(o)
                  break
                case r.PacketType.BINARY_EVENT:
                  this.onevent(o)
                  break
                case r.PacketType.ACK:
                  this.onack(o)
                  break
                case r.PacketType.BINARY_ACK:
                  this.onack(o)
                  break
                case r.PacketType.DISCONNECT:
                  this.ondisconnect()
                  break
                case r.PacketType.CONNECT_ERROR:
                  let a = new Error(o.data.message)
                  ;(a.data = o.data.data), this.emitReserved('connect_error', a)
                  break
              }
          }
          onevent(o) {
            let l = o.data || []
            i('emitting event %j', l),
              o.id != null && (i('attaching ack callback to event'), l.push(this.ack(o.id))),
              this.connected ? this.emitEvent(l) : this.receiveBuffer.push(Object.freeze(l))
          }
          emitEvent(o) {
            if (this._anyListeners && this._anyListeners.length) {
              let l = this._anyListeners.slice()
              for (let a of l) a.apply(this, o)
            }
            super.emit.apply(this, o)
          }
          ack(o) {
            let l = this,
              a = !1
            return function (...c) {
              a || ((a = !0), i('sending ack %j', c), l.packet({ type: r.PacketType.ACK, id: o, data: c }))
            }
          }
          onack(o) {
            let l = this.acks[o.id]
            typeof l == 'function'
              ? (i('calling ack %s with %j', o.id, o.data), l.apply(this, o.data), delete this.acks[o.id])
              : i('bad ack %s', o.id)
          }
          onconnect(o) {
            i('socket connected with id %s', o),
              (this.id = o),
              (this.connected = !0),
              (this.disconnected = !1),
              this.emitBuffered(),
              this.emitReserved('connect')
          }
          emitBuffered() {
            this.receiveBuffer.forEach((o) => this.emitEvent(o)),
              (this.receiveBuffer = []),
              this.sendBuffer.forEach((o) => this.packet(o)),
              (this.sendBuffer = [])
          }
          ondisconnect() {
            i('server disconnect (%s)', this.nsp), this.destroy(), this.onclose('io server disconnect')
          }
          destroy() {
            this.subs && (this.subs.forEach((o) => o()), (this.subs = void 0)), this.io._destroy(this)
          }
          disconnect() {
            return (
              this.connected &&
                (i('performing disconnect (%s)', this.nsp), this.packet({ type: r.PacketType.DISCONNECT })),
              this.destroy(),
              this.connected && this.onclose('io client disconnect'),
              this
            )
          }
          close() {
            return this.disconnect()
          }
          compress(o) {
            return (this.flags.compress = o), this
          }
          get volatile() {
            return (this.flags.volatile = !0), this
          }
          onAny(o) {
            return (this._anyListeners = this._anyListeners || []), this._anyListeners.push(o), this
          }
          prependAny(o) {
            return (this._anyListeners = this._anyListeners || []), this._anyListeners.unshift(o), this
          }
          offAny(o) {
            if (!this._anyListeners) return this
            if (o) {
              let l = this._anyListeners
              for (let a = 0; a < l.length; a++) if (o === l[a]) return l.splice(a, 1), this
            } else this._anyListeners = []
            return this
          }
          listenersAny() {
            return this._anyListeners || []
          }
        }
      e.Socket = u
    }
  }),
  kD = te({
    'node_modules/backo2/index.js'(e, r) {
      V(), F(), (r.exports = t)
      function t(n) {
        ;(n = n || {}),
          (this.ms = n.min || 100),
          (this.max = n.max || 1e4),
          (this.factor = n.factor || 2),
          (this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0),
          (this.attempts = 0)
      }
      ;(t.prototype.duration = function () {
        var n = this.ms * Math.pow(this.factor, this.attempts++)
        if (this.jitter) {
          var i = Math.random(),
            s = Math.floor(i * this.jitter * n)
          n = (Math.floor(i * 10) & 1) == 0 ? n - s : n + s
        }
        return Math.min(n, this.max) | 0
      }),
        (t.prototype.reset = function () {
          this.attempts = 0
        }),
        (t.prototype.setMin = function (n) {
          this.ms = n
        }),
        (t.prototype.setMax = function (n) {
          this.max = n
        }),
        (t.prototype.setJitter = function (n) {
          this.jitter = n
        })
    }
  }),
  YS = te({
    'node_modules/socket.io-client/build/manager.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.Manager = void 0)
      var r = TD(),
        t = XS(),
        n = z1(),
        i = WS(),
        s = kD(),
        u = JS(),
        o = mt()('socket.io-client:manager'),
        l = class extends u.StrictEventEmitter {
          constructor(a, c) {
            super()
            ;(this.nsps = {}),
              (this.subs = []),
              a && typeof a == 'object' && ((c = a), (a = void 0)),
              (c = c || {}),
              (c.path = c.path || '/socket.io'),
              (this.opts = c),
              this.reconnection(c.reconnection !== !1),
              this.reconnectionAttempts(c.reconnectionAttempts || 1 / 0),
              this.reconnectionDelay(c.reconnectionDelay || 1e3),
              this.reconnectionDelayMax(c.reconnectionDelayMax || 5e3),
              this.randomizationFactor(c.randomizationFactor || 0.5),
              (this.backoff = new s({
                min: this.reconnectionDelay(),
                max: this.reconnectionDelayMax(),
                jitter: this.randomizationFactor()
              })),
              this.timeout(c.timeout == null ? 2e4 : c.timeout),
              (this._readyState = 'closed'),
              (this.uri = a)
            let f = c.parser || n
            ;(this.encoder = new f.Encoder()),
              (this.decoder = new f.Decoder()),
              (this._autoConnect = c.autoConnect !== !1),
              this._autoConnect && this.open()
          }
          reconnection(a) {
            return arguments.length ? ((this._reconnection = !!a), this) : this._reconnection
          }
          reconnectionAttempts(a) {
            return a === void 0 ? this._reconnectionAttempts : ((this._reconnectionAttempts = a), this)
          }
          reconnectionDelay(a) {
            var c
            return a === void 0
              ? this._reconnectionDelay
              : ((this._reconnectionDelay = a), (c = this.backoff) === null || c === void 0 || c.setMin(a), this)
          }
          randomizationFactor(a) {
            var c
            return a === void 0
              ? this._randomizationFactor
              : ((this._randomizationFactor = a), (c = this.backoff) === null || c === void 0 || c.setJitter(a), this)
          }
          reconnectionDelayMax(a) {
            var c
            return a === void 0
              ? this._reconnectionDelayMax
              : ((this._reconnectionDelayMax = a), (c = this.backoff) === null || c === void 0 || c.setMax(a), this)
          }
          timeout(a) {
            return arguments.length ? ((this._timeout = a), this) : this._timeout
          }
          maybeReconnectOnOpen() {
            !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect()
          }
          open(a) {
            if ((o('readyState %s', this._readyState), ~this._readyState.indexOf('open'))) return this
            o('opening %s', this.uri), (this.engine = r(this.uri, this.opts))
            let c = this.engine,
              f = this
            ;(this._readyState = 'opening'), (this.skipReconnect = !1)
            let p = i.on(c, 'open', function () {
                f.onopen(), a && a()
              }),
              y = i.on(c, 'error', (d) => {
                o('error'),
                  f.cleanup(),
                  (f._readyState = 'closed'),
                  this.emitReserved('error', d),
                  a ? a(d) : f.maybeReconnectOnOpen()
              })
            if (this._timeout !== !1) {
              let d = this._timeout
              o('connect attempt will timeout after %d', d), d === 0 && p()
              let h = setTimeout(() => {
                o('connect attempt timed out after %d', d), p(), c.close(), c.emit('error', new Error('timeout'))
              }, d)
              this.opts.autoUnref && h.unref(),
                this.subs.push(function () {
                  clearTimeout(h)
                })
            }
            return this.subs.push(p), this.subs.push(y), this
          }
          connect(a) {
            return this.open(a)
          }
          onopen() {
            o('open'), this.cleanup(), (this._readyState = 'open'), this.emitReserved('open')
            let a = this.engine
            this.subs.push(
              i.on(a, 'ping', this.onping.bind(this)),
              i.on(a, 'data', this.ondata.bind(this)),
              i.on(a, 'error', this.onerror.bind(this)),
              i.on(a, 'close', this.onclose.bind(this)),
              i.on(this.decoder, 'decoded', this.ondecoded.bind(this))
            )
          }
          onping() {
            this.emitReserved('ping')
          }
          ondata(a) {
            this.decoder.add(a)
          }
          ondecoded(a) {
            this.emitReserved('packet', a)
          }
          onerror(a) {
            o('error', a), this.emitReserved('error', a)
          }
          socket(a, c) {
            let f = this.nsps[a]
            return f || ((f = new t.Socket(this, a, c)), (this.nsps[a] = f)), f
          }
          _destroy(a) {
            let c = Object.keys(this.nsps)
            for (let f of c)
              if (this.nsps[f].active) {
                o('socket %s is still active, skipping close', f)
                return
              }
            this._close()
          }
          _packet(a) {
            o('writing packet %j', a)
            let c = this.encoder.encode(a)
            for (let f = 0; f < c.length; f++) this.engine.write(c[f], a.options)
          }
          cleanup() {
            o('cleanup'), this.subs.forEach((a) => a()), (this.subs.length = 0), this.decoder.destroy()
          }
          _close() {
            o('disconnect'),
              (this.skipReconnect = !0),
              (this._reconnecting = !1),
              this._readyState === 'opening' && this.cleanup(),
              this.backoff.reset(),
              (this._readyState = 'closed'),
              this.engine && this.engine.close()
          }
          disconnect() {
            return this._close()
          }
          onclose(a) {
            o('onclose'),
              this.cleanup(),
              this.backoff.reset(),
              (this._readyState = 'closed'),
              this.emitReserved('close', a),
              this._reconnection && !this.skipReconnect && this.reconnect()
          }
          reconnect() {
            if (this._reconnecting || this.skipReconnect) return this
            let a = this
            if (this.backoff.attempts >= this._reconnectionAttempts)
              o('reconnect failed'),
                this.backoff.reset(),
                this.emitReserved('reconnect_failed'),
                (this._reconnecting = !1)
            else {
              let c = this.backoff.duration()
              o('will wait %dms before reconnect attempt', c), (this._reconnecting = !0)
              let f = setTimeout(() => {
                a.skipReconnect ||
                  (o('attempting reconnect'),
                  this.emitReserved('reconnect_attempt', a.backoff.attempts),
                  !a.skipReconnect &&
                    a.open((p) => {
                      p
                        ? (o('reconnect attempt error'),
                          (a._reconnecting = !1),
                          a.reconnect(),
                          this.emitReserved('reconnect_error', p))
                        : (o('reconnect success'), a.onreconnect())
                    }))
              }, c)
              this.opts.autoUnref && f.unref(),
                this.subs.push(function () {
                  clearTimeout(f)
                })
            }
          }
          onreconnect() {
            let a = this.backoff.attempts
            ;(this._reconnecting = !1), this.backoff.reset(), this.emitReserved('reconnect', a)
          }
        }
      e.Manager = l
    }
  }),
  MD = te({
    'node_modules/socket.io-client/build/index.js'(e, r) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.io = e.Socket = e.Manager = e.protocol = void 0)
      var t = bD(),
        n = YS(),
        i = mt()('socket.io-client')
      r.exports = e = u
      var s = (e.managers = {})
      function u(c, f) {
        typeof c == 'object' && ((f = c), (c = void 0)), (f = f || {})
        let p = t.url(c, f.path || '/socket.io'),
          y = p.source,
          d = p.id,
          h = p.path,
          m = s[d] && h in s[d].nsps,
          _ = f.forceNew || f['force new connection'] || f.multiplex === !1 || m,
          A
        return (
          _
            ? (i('ignoring socket cache for %s', y), (A = new n.Manager(y, f)))
            : (s[d] || (i('new io instance for %s', y), (s[d] = new n.Manager(y, f))), (A = s[d])),
          p.query && !f.query && (f.query = p.queryKey),
          A.socket(p.path, f)
        )
      }
      e.io = u
      var o = z1()
      Object.defineProperty(e, 'protocol', {
        enumerable: !0,
        get: function () {
          return o.protocol
        }
      }),
        (e.connect = u)
      var l = YS()
      Object.defineProperty(e, 'Manager', {
        enumerable: !0,
        get: function () {
          return l.Manager
        }
      })
      var a = XS()
      Object.defineProperty(e, 'Socket', {
        enumerable: !0,
        get: function () {
          return a.Socket
        }
      }),
        (e.default = u)
    }
  }),
  K1 = te({
    'node_modules/stream-to-it/source.js'(e, r) {
      V(),
        F(),
        (r.exports = (t) => {
          if (t[Symbol.asyncIterator]) return t
          if (t.getReader)
            return (async function* () {
              let n = t.getReader()
              try {
                for (;;) {
                  let { done: i, value: s } = await n.read()
                  if (i) return
                  yield s
                }
              } finally {
                n.releaseLock()
              }
            })()
          throw new Error('unknown stream')
        })
    }
  }),
  ZS = te({
    'node_modules/stream-to-it/sink.js'(e, r) {
      V(), F()
      var t = H0()
      r.exports = (n) => async (i) => {
        i = t(i)
        let s = (E) => {
            typeof E.return == 'function' && E.return()
          },
          u = null,
          o = null,
          l = (E) => {
            ;(u = E), o && o(E), s(i)
          },
          a = null,
          c = !1,
          f = () => {
            ;(c = !0), a && a()
          },
          p = null,
          y = !1,
          d = () => {
            ;(y = !0), p && p()
          },
          h = null,
          m = () => {
            h && h()
          },
          _ = () =>
            new Promise((E, k) => {
              ;(a = h = E), (o = k), n.once('drain', m)
            }),
          A = () => (
            s(i),
            new Promise((E, k) => {
              if (c || y || u) return E()
              ;(p = a = E), (o = k)
            })
          ),
          T = () => {
            n.removeListener('error', l),
              n.removeListener('close', f),
              n.removeListener('finish', d),
              n.removeListener('drain', m)
          }
        n.once('error', l), n.once('close', f), n.once('finish', d)
        try {
          for await (let E of i) {
            if (!n.writable || n.destroyed || u) break
            n.write(E) === !1 && (await _())
          }
        } catch (E) {
          u || n.destroy(), (u = E)
        }
        try {
          if ((n.writable && n.end(), await A(), u)) throw u
        } finally {
          T()
        }
      }
    }
  }),
  QS = te({
    'node_modules/stream-to-it/duplex.js'(e, r) {
      V(), F()
      var t = ZS(),
        n = K1()
      r.exports = (i) => ({ sink: t(i), source: n(i) })
    }
  }),
  xD = te({
    'node_modules/stream-to-it/transform.js'(e, r) {
      V(), F()
      var t = QS()
      r.exports = (n) =>
        async function* (i) {
          let s = t(n),
            u
          if (
            (s.sink(i).catch((o) => {
              u = o
            }),
            yield* s.source,
            u)
          )
            throw u
        }
    }
  }),
  RD = te({
    'node_modules/stream-to-it/index.js'(e, r) {
      V(),
        F(),
        (r.exports = K1()),
        (r.exports.source = K1()),
        (r.exports.sink = ZS()),
        (r.exports.transform = xD()),
        (r.exports.duplex = QS())
    }
  }),
  eA = te({
    'node_modules/libp2p-webrtc-star/src/socket-to-conn.js'(e, r) {
      V(), F()
      var t = Ui(),
        n = RD(),
        { CLOSE_TIMEOUT: i } = U1(),
        s = fw(),
        u = mt(),
        o = u('libp2p:webrtc-star:socket')
      o.error = u('libp2p:webrtc-star:socket:error')
      var l = (a, c) => {
        if (!(!a || !c))
          try {
            return s(a, c)
          } catch (f) {
            return o.error(f), s('0.0.0.0', c)
          }
      }
      r.exports = (a, c = {}) => {
        let { sink: f, source: p } = n.duplex(a),
          y = c.remoteAddr || l(a.remoteAddress, a.remotePort),
          d = l(a.localAddress, a.localPort),
          h = {
            async sink(m) {
              c.signal && (m = t(m, c.signal))
              try {
                await f(
                  (async function* () {
                    for await (let _ of m) yield _ instanceof Uint8Array ? _ : _.slice()
                  })()
                )
              } catch (_) {
                _.type !== 'aborted' && o.error(_)
              }
            },
            source: c.signal ? t(p, c.signal) : p,
            conn: a,
            localAddr: d,
            remoteAddr: y,
            timeline: { open: Date.now() },
            close() {
              if (!a.destroyed)
                return new Promise((m, _) => {
                  let A = Date.now(),
                    T = setTimeout(() => {
                      if (h.remoteAddr) {
                        let { host: E, port: k } = h.remoteAddr.toOptions()
                        o('timeout closing socket to %s:%s after %dms, destroying it manually', E, k, Date.now() - A)
                      }
                      a.destroyed || a.destroy()
                    }, i)
                  a.once('close', () => {
                    m()
                  }),
                    a.end((E) => {
                      if ((clearTimeout(T), (h.timeline.close = Date.now()), E)) return _(E)
                    })
                })
            }
          }
        return (
          a.once('close', () => {
            h.timeline.close || (h.timeline.close = Date.now())
          }),
          h
        )
      }
    }
  }),
  tA = te({
    'node_modules/libp2p-webrtc-star/src/utils.js'(e, r) {
      V(), F()
      var { Multiaddr: t } = J7()
      function n(s) {
        let u = s.toString().split('/'),
          o = s.protos()[1].name,
          l = s.protos()[2].name,
          a = s.stringTuples()[1][1]
        if (o !== 'tcp' || (l !== 'ws' && l !== 'wss')) throw new Error('invalid multiaddr: ' + s.toString())
        if (!t.isName(s)) return 'http://' + u[2] + ':' + u[4]
        if (l === 'ws') return 'http://' + u[2] + (a === '80' ? '' : ':' + a)
        if (l === 'wss') return 'https://' + u[2] + (a === '443' ? '' : ':' + a)
      }
      function i(s) {
        let u = '/libp2p-webrtc-star'
        if (s.indexOf(u) !== -1) {
          s = s.substring(u.length, s.length)
          let o = new t(s),
            l = o.stringTuples().filter((a) => a[0] === 421)[0]
          ;(o = o.decapsulate('p2p')),
            (o = o.encapsulate('/p2p-webrtc-star')),
            (o = o.encapsulate(`/p2p/${l[1]}`)),
            (s = o.toString())
        }
        return s
      }
      r.exports = { cleanUrlSIO: n, cleanMultiaddr: i }
    }
  }),
  BD = te({
    'node_modules/libp2p-webrtc-star/src/listener.js'(e, r) {
      V(), F()
      var t = ln(),
        n = mt(),
        i = n('libp2p:webrtc-star:listener')
      i.error = n('libp2p:webrtc-star:listener:error')
      var s = pt(),
        u = MD(),
        o = c_(),
        l = Vl(),
        a = eA(),
        { cleanUrlSIO: c } = tA(),
        { CODE_P2P: f } = U1(),
        p = { transports: ['websocket'], 'force new connection': !0, path: '/socket.io-next/' }
      r.exports = ({ handler: d, upgrader: h }, m, _ = {}) => {
        let A = new t(),
          T,
          E
        return (
          (A.__connections = []),
          (A.__spChannels = new Map()),
          (A.__pendingIntents = new Map()),
          (A.listen = (k) => {
            if (T) throw s(new Error('listener already in use'), 'ERR_ALREADY_LISTENING')
            let w = l()
            T = k
            let v
            !k.protoCodes().includes(f) && h.localPeer
              ? (v = k.encapsulate(`/p2p/${h.localPeer.toB58String()}`))
              : (v = k),
              A.on('error', () => w.reject()),
              (E = c(k)),
              i('Dialing to Signalling Server on: ' + E),
              (A.io = u.connect(E, p))
            let I = (M) => {
              if (M.answer || M.err || !M.intentId) return
              let q = M.intentId,
                G = A.__pendingIntents.get(q)
              G || ((G = []), A.__pendingIntents.set(q, G))
              let O = A.__spChannels.get(q)
              if (O) {
                O.signal(M.signal)
                return
              } else if (M.signal.type !== 'offer') {
                G.push(M)
                return
              }
              let x = { trickle: !1, ..._ }
              m.wrtc && (x.wrtc = m.wrtc), (O = new o(x))
              let L = (K) => {
                i.error('incoming connection errored', K)
              }
              O.on('error', L),
                O.once('close', (...K) => {
                  O.removeListener('error', L)
                }),
                O.on('signal', (K) => {
                  ;(M.signal = K), (M.answer = !0), A.io.emit('ss-handshake', M)
                }),
                O.signal(M.signal)
              for (let K of G) O.signal(K.signal)
              A.__pendingIntents.set(q, []),
                O.once('connect', async () => {
                  let K = a(O)
                  i('new inbound connection %s', K.remoteAddr)
                  let J
                  try {
                    J = await h.upgradeInbound(K)
                  } catch (Z) {
                    return i.error('inbound connection failed to upgrade', Z), K.close()
                  }
                  if (!J.remoteAddr)
                    try {
                      J.remoteAddr = k.decapsulateCode(f).encapsulate(`/p2p/${J.remotePeer.toB58String()}`)
                    } catch (Z) {
                      i.error('could not determine remote address', Z)
                    }
                  i('inbound connection %s upgraded', K.remoteAddr), y(A, K, q), A.emit('connection', J), d(J)
                }),
                A.__spChannels.set(q, O)
            }
            return (
              A.io.once('connect_error', (M) => w.reject(M)),
              A.io.once('error', (M) => {
                A.emit('error', M), A.emit('close')
              }),
              A.io.on('ws-handshake', I),
              A.io.on('ws-peer', m._peerDiscovered),
              A.io.on('connect', () => {
                A.io.emit('ss-join', v.toString())
              }),
              A.io.once('connect', () => {
                A.emit('listening'), w.resolve()
              }),
              m.sigReferences.set(E, { listener: A, signallingAddr: v }),
              w.promise
            )
          }),
          (A.close = async () => {
            let k = m.sigReferences.get(E)
            k && k.listener.io && (k.listener.io.emit('ss-leave'), k.listener.io.close()),
              await Promise.all(A.__connections.map((w) => w.close())),
              A.emit('close'),
              A.removeAllListeners(),
              (T = void 0),
              m.sigReferences.delete(E)
          }),
          (A.getAddrs = () => [T]),
          A
        )
      }
      function y(d, h, m) {
        d.__connections.push(h)
        let _ = () => {
          ;(d.__connections = d.__connections.filter((A) => A !== h)),
            d.__spChannels.delete(m),
            d.__pendingIntents.delete(m)
        }
        h.conn.once('close', _)
      }
    }
  }),
  ND = te({
    'node_modules/libp2p-webrtc-star/src/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = t('libp2p:webrtc-star')
      n.error = t('libp2p:webrtc-star:error')
      var { EventEmitter: i } = ln(),
        s = pt(),
        u = l0(),
        { AbortError: o } = Ui(),
        l = c_(),
        { supportsWebRTCDataChannels: a } = fP(),
        { Multiaddr: c } = J7(),
        f = xp(),
        p = er(),
        { CODE_CIRCUIT: y } = U1(),
        d = BD(),
        h = eA(),
        { cleanMultiaddr: m, cleanUrlSIO: _ } = tA()
      function A() {}
      var T = class {
        constructor(E = {}) {
          if (!E.upgrader)
            throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.')
          ;(this._upgrader = E.upgrader),
            (this.sioOptions = { transports: ['websocket'], 'force new connection': !0 }),
            E.wrtc && (this.wrtc = E.wrtc),
            (this.sigReferences = new Map()),
            (this.discovery = new i()),
            (this.discovery.tag = 'webRTCStar'),
            (this.discovery._isStarted = !1),
            (this.discovery.start = () => {
              this.discovery._isStarted = !0
            }),
            (this.discovery.stop = () => {
              this.discovery._isStarted = !1
            }),
            (this._peerDiscovered = this._peerDiscovered.bind(this))
        }
        async dial(E, k = {}) {
          let w = await this._connect(E, k),
            v = h(w, { remoteAddr: E, signal: k.signal })
          n('new outbound connection %s', v.remoteAddr)
          let I = await this._upgrader.upgradeOutbound(v)
          return n('outbound connection %s upgraded', v.remoteAddr), I
        }
        _connect(E, k = {}) {
          if (k.signal && k.signal.aborted) throw new o()
          let w = { initiator: !0, trickle: !1, ...(k.spOptions || {}) }
          this.wrtc && (w.wrtc = this.wrtc)
          let v = E.toOptions(),
            I = (~~(Math.random() * 1e9)).toString(36) + Date.now()
          return new Promise((M, q) => {
            let G = this.sigReferences.get(_(E))
            if (!G || !G.listener) return q(s(new Error('unknown signal server to use'), 'ERR_UNKNOWN_SIGNAL_SERVER'))
            let O = G.listener.io,
              x = Date.now(),
              L
            n('dialing %s:%s', v.host, v.port)
            let K = new l(w),
              J = (W) => {
                if (!L) {
                  let le = `connection error ${v.host}:${v.port}: ${W.message}`
                  n.error(le), ie(W)
                }
              },
              Z = () => {
                n('connnection timeout %s:%s', v.host, v.port)
                let W = s(new Error(`connection timeout after ${Date.now() - x}ms`), 'ERR_CONNECT_TIMEOUT')
                K.emit('error', W)
              },
              Q = () => {
                ;(L = !0), n('connection opened %s:%s', v.host, v.port), ie(null)
              },
              fe = () => {
                n.error('connection aborted %s:%s', v.host, v.port), K.destroy(), ie(new o())
              },
              ie = (W) => {
                K.removeListener('timeout', Z),
                  K.removeListener('connect', Q),
                  k.signal && k.signal.removeEventListener('abort', fe),
                  W ? q(W) : M(K)
              }
            K.on('error', J),
              K.once('timeout', Z),
              K.once('connect', Q),
              K.on('close', () => {
                K.removeListener('error', J)
              }),
              k.signal && k.signal.addEventListener('abort', fe),
              K.on('signal', (W) => {
                O.emit('ss-handshake', {
                  intentId: I,
                  srcMultiaddr: G.signallingAddr.toString(),
                  dstMultiaddr: E.toString(),
                  signal: W
                })
              }),
              O.on('ws-handshake', (W) => {
                W.intentId === I &&
                  W.err &&
                  (K.destroy(), q(s(W.err instanceof Error ? W.err : new Error(W.err), 'ERR_SIGNALLING_FAILED'))),
                  !(W.intentId !== I || !W.answer || K.destroyed) && K.signal(W.signal)
              })
          })
        }
        createListener(E = {}, k) {
          if (!a && !this.wrtc) throw s(new Error('no WebRTC support'), 'ERR_NO_WEBRTC_SUPPORT')
          return (
            typeof E == 'function' && ((k = E), (E = {})),
            (k = k || A),
            d({ handler: k, upgrader: this._upgrader }, this, E)
          )
        }
        filter(E) {
          return (
            (E = Array.isArray(E) ? E : [E]),
            E.filter((k) => (k.protoCodes().includes(y) ? !1 : f.WebRTCStar.matches(k)))
          )
        }
        _peerDiscovered(E) {
          if (!this.discovery._isStarted) return
          n('Peer Discovered:', E), (E = m(E))
          let k = new c(E),
            w = p.createFromB58String(k.getPeerId())
          this.discovery.emit('peer', { id: w, multiaddrs: [k] })
        }
      }
      r.exports = u(T, { className: 'WebRTCStar', symbolName: '@libp2p/js-libp2p-webrtc-star/webrtcstar' })
    }
  }),
  ji = te({
    'node_modules/bcrypto/lib/internal/assert.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (!n) {
          let s = new Error(i || 'Assertion failed')
          throw (Error.captureStackTrace && Error.captureStackTrace(s, t), s)
        }
      }
      r.exports = t
    }
  }),
  rA = te({
    'node_modules/bcrypto/lib/internal/custom-browser.js'(e) {
      V(), F(), (e.custom = 'inspect')
    }
  }),
  PD = te({
    'node_modules/bcrypto/lib/js/bn.js'(e, r) {
      V(), F()
      var { custom: t } = rA(),
        n = [
          '',
          '0',
          '00',
          '000',
          '0000',
          '00000',
          '000000',
          '0000000',
          '00000000',
          '000000000',
          '0000000000',
          '00000000000',
          '000000000000',
          '0000000000000',
          '00000000000000',
          '000000000000000',
          '0000000000000000',
          '00000000000000000',
          '000000000000000000',
          '0000000000000000000',
          '00000000000000000000',
          '000000000000000000000',
          '0000000000000000000000',
          '00000000000000000000000',
          '000000000000000000000000',
          '0000000000000000000000000'
        ],
        i = [
          0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
          5
        ],
        s = [
          0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808,
          62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624,
          9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875,
          60466176
        ],
        u = { p192: null, p224: null, p521: null, k256: null, p251: null, p25519: null, p448: null },
        o = { NONE: 0, QUO: 1, REM: 2, BOTH: 3, EUCLID: 4, ALL: 7 },
        l = 4,
        a = 1 << (l - 1),
        c = typeof BigInt == 'function',
        f = class {
          constructor(b, C, S) {
            ;(this.words = [0]), (this.length = 1), (this.negative = 0), (this.red = null), this.from(b, C, S)
          }
          _iadd(b, C) {
            let S = 0,
              R = 0
            for (b.length < C.length && ([b, C] = [C, b]), b !== this && this._alloc(b.length); R < C.length; R++) {
              let P = (b.words[R] | 0) + (C.words[R] | 0) + S
              ;(this.words[R] = P & 67108863), (S = P >>> 26)
            }
            for (; S !== 0 && R < b.length; R++) {
              let P = (b.words[R] | 0) + S
              ;(this.words[R] = P & 67108863), (S = P >>> 26)
            }
            if (((this.length = b.length), S !== 0)) this._alloc(this.length + 1), (this.words[this.length++] = S)
            else if (b !== this) for (; R < b.length; R++) this.words[R] = b.words[R]
            return this
          }
          _iaddn(b) {
            if (((this.words[0] += b), this.words[0] < 67108864)) return this
            let C = 0
            for (
              this._alloc(this.length + 1), this.words[this.length] = 0;
              C < this.length && this.words[C] >= 67108864;
              C++
            )
              (this.words[C] -= 67108864), (this.words[C + 1] += 1)
            return (this.length = Math.max(this.length, C + 1)), this
          }
          iadd(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), this.negative === b.negative)) this._iadd(this, b)
            else {
              let C = this.ucmp(b)
              if (C === 0) return (this.words[0] = 0), (this.length = 1), (this.negative = 0), this
              C < 0 ? (this._isub(b, this), (this.negative ^= 1)) : this._isub(this, b)
            }
            return this
          }
          iaddn(b) {
            O(fe(b), 'num', 'smi')
            let C = (b < 0) | 0
            return (
              C && (b = -b),
              this.negative === C
                ? this._iaddn(b)
                : this.length === 1 && this.words[0] < b
                ? ((this.words[0] = b - this.words[0]), (this.negative ^= 1))
                : this._isubn(b),
              this
            )
          }
          add(b) {
            return O(f.isBN(b), 'num', 'bignum'), b.length > this.length ? b.clone().iadd(this) : this.clone().iadd(b)
          }
          addn(b) {
            return this.clone().iaddn(b)
          }
          _isub(b, C) {
            let S = 0,
              R = 0
            for (G(b.length >= C.length), b !== this && this._alloc(b.length); R < C.length; R++) {
              let P = (b.words[R] | 0) - (C.words[R] | 0) + S
              ;(S = P >> 26), (this.words[R] = P & 67108863)
            }
            for (; S !== 0 && R < b.length; R++) {
              let P = (b.words[R] | 0) + S
              ;(S = P >> 26), (this.words[R] = P & 67108863)
            }
            if ((G(S === 0), b !== this)) for (; R < b.length; R++) this.words[R] = b.words[R]
            return (this.length = Math.max(this.length, R)), this._strip()
          }
          _isubn(b) {
            if (((this.words[0] -= b), this.words[0] >= 0)) return this._normalize()
            G(this.length !== 1), this._alloc(this.length + 1)
            for (let C = 0; C < this.length && this.words[C] < 0; C++)
              (this.words[C] += 67108864), (this.words[C + 1] -= 1)
            return (this.words[this.length] = 0), this._strip()
          }
          isub(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), this.negative !== b.negative)) this._iadd(this, b)
            else {
              let C = this.ucmp(b)
              if (C === 0) return (this.words[0] = 0), (this.length = 1), (this.negative = 0), this
              C < 0 ? (this._isub(b, this), (this.negative ^= 1)) : this._isub(this, b)
            }
            return this
          }
          isubn(b) {
            O(fe(b), 'num', 'smi')
            let C = (b < 0) | 0
            return (
              C && (b = -b),
              this.negative !== C
                ? this._iaddn(b)
                : this.length === 1 && this.words[0] < b
                ? ((this.words[0] = b - this.words[0]), (this.negative ^= 1))
                : this._isubn(b),
              this
            )
          }
          sub(b) {
            return this.clone().isub(b)
          }
          subn(b) {
            return this.clone().isubn(b)
          }
          _mul(b, C) {
            if ((O(f.isBN(b), 'num', 'bignum'), O(f.isBN(C), 'out', 'bignum'), this.length === 10 && b.length === 10))
              return j(this, b, C)
            let S = this.length + b.length
            return S < 63 ? be(this, b, C) : S < 1024 ? ge(this, b, C) : re(this, b, C)
          }
          imul(b) {
            return this.mul(b)._move(this)
          }
          imuln(b) {
            O(fe(b), 'num', 'smi')
            let C = (b < 0) | 0
            C && (b = -b)
            let S = 0
            for (let R = 0; R < this.length; R++) {
              let P = this.words[R] * b,
                B = (P & 67108863) + (S & 67108863)
              ;(S >>= 26), (S += (P / 67108864) | 0), (S += B >>> 26), (this.words[R] = B & 67108863)
            }
            return (
              (this.negative ^= C),
              S !== 0 ? (this._alloc(this.length + 1), (this.words[this.length++] = S)) : this._strip(),
              this
            )
          }
          mul(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = this.length + b.length,
              S = new f()
            S.words = new Array(C)
            for (let R = 0; R < C; R++) S.words[R] = 0
            return this._mul(b, S)
          }
          muln(b) {
            return this.clone().imuln(b)
          }
          mulShift(b, C) {
            O(f.isBN(b), 'num', 'bignum'), O(C >>> 0 === C, 'bits', 'uint32')
            let S = this.mul(b),
              R = S.utestn(C - 1)
            return S.iushrn(C), this.negative ^ b.negative ? S.isubn(R) : S.iaddn(R)
          }
          _div(b, C) {
            O(f.isBN(b), 'num', 'bignum'), G((C & o.ALL) === C), G(C !== o.NONE)
            let S = this,
              R = b
            if ((J(!R.isZero()), S.isZero())) return [new f(0), new f(0)]
            let P = S.negative,
              B = R.negative
            ;(S.negative = 0), (R.negative = 0)
            let D = null,
              $ = null
            return (
              S.ucmp(R) < 0
                ? (C & o.QUO && (D = new f(0)), C & o.REM && ($ = S.clone()))
                : R.length === 1
                ? (C & o.QUO && (D = S.quon(R.words[0])), C & o.REM && ($ = S.remn(R.words[0])))
                : ([D, $] = S._wordDiv(R, C)),
              (S.negative = P),
              (R.negative = B),
              C & o.QUO && ((D.negative = S.negative ^ R.negative), D._normalize()),
              C & o.REM && (($.negative = S.negative), $._normalize()),
              C & o.EUCLID &&
                (C & o.QUO && (G((C & o.REM) != 0), $.negative !== 0 && (R.negative !== 0 ? D.iaddn(1) : D.isubn(1))),
                C & o.REM && $.negative !== 0 && (R.negative !== 0 ? $.isub(R) : $.iadd(R))),
              [D, $]
            )
          }
          _wordDiv(b, C) {
            let S = this.clone(),
              R = b,
              P = null,
              B,
              D = R.words[R.length - 1] | 0,
              $ = 26 - le(D)
            $ !== 0 ? ((R = R.clone()), S.iushln($), R.iushln($), (B = R.words[R.length - 1] | 0)) : (B = D)
            let g = S.length - R.length
            if ((G(g >= 0), C & o.QUO)) {
              ;(P = new f(0)), (P.length = g + 1), (P.words = new Array(P.length))
              for (let U = 0; U < P.length; U++) P.words[U] = 0
            }
            let N = S.clone()
            N._ishlnsubmul(R, 1, g), N.negative === 0 && (P && (P.words[g] = 1), (S = N))
            for (let U = g - 1; U >= 0; U--) {
              let X = S.words[R.length + U],
                ne = S.words[R.length + U - 1],
                ee = ((X * 67108864 + ne) / B) | 0,
                ae = Math.min(ee, 67108863)
              for (S._ishlnsubmul(R, ae, U); S.negative !== 0; )
                (ae -= 1), (S.negative = 0), S._ishlnsubmul(R, 1, U), S.ineg()
              P && (P.words[U] = ae)
            }
            return P && P._strip(), C & o.REM && $ !== 0 && S.iushrn($), [P, S]
          }
          _ishlnsubmul(b, C, S) {
            let R = 0,
              P = 0
            for (this._expand(b.length + S); P < b.length; P++) {
              let B = (this.words[P + S] | 0) + R,
                D = b.words[P] * C,
                $ = B - (D & 67108863)
              ;(R = ($ >> 26) - ((D / 67108864) | 0)), (this.words[P + S] = $ & 67108863)
            }
            for (; P < this.length - S; P++) {
              let B = (this.words[P + S] | 0) + R
              ;(R = B >> 26), (this.words[P + S] = B & 67108863)
            }
            if (R === 0) return this._strip()
            G(R === -1), (R = 0)
            for (let B = 0; B < this.length; B++) {
              let D = -(this.words[B] | 0) + R
              ;(R = D >> 26), (this.words[B] = D & 67108863)
            }
            return (this.negative = 1), this._strip()
          }
          quorem(b) {
            return this._div(b, o.BOTH)
          }
          iquo(b) {
            return this.quo(b)._move(this)
          }
          iquon(b) {
            O(fe(b), 'num', 'smi'), J(b !== 0)
            let C = (b < 0) | 0
            C && (b = -b)
            let S = 0
            for (let R = this.length - 1; R >= 0; R--) {
              let P = (this.words[R] | 0) + S * 67108864
              ;(this.words[R] = (P / b) | 0), (S = P % b)
            }
            return (this.negative ^= C), this._strip()
          }
          quo(b) {
            return this._div(b, o.QUO)[0]
          }
          quon(b) {
            return this.clone().iquon(b)
          }
          irem(b) {
            return this.rem(b)._move(this)
          }
          iremn(b) {
            let C = this.remrn(b)
            return C < 0 && (C = -C), (this.words[0] = C), (this.length = 1), this._normalize()
          }
          rem(b) {
            return this._div(b, o.REM)[1]
          }
          remn(b) {
            return this.clone().iremn(b)
          }
          remrn(b) {
            O(fe(b), 'num', 'smi'), J(b !== 0), b < 0 && (b = -b)
            let C = (1 << 26) % b,
              S = 0
            for (let R = this.length - 1; R >= 0; R--) S = (C * S + (this.words[R] | 0)) % b
            return this.negative !== 0 ? -S | 0 : S
          }
          divmod(b) {
            return this._div(b, o.BOTH | o.EUCLID)
          }
          idiv(b) {
            return this.div(b)._move(this)
          }
          idivn(b) {
            if (this.negative === 0) return this.iquon(b)
            let C = this.remrn(b)
            return this.iquon(b), C < 0 && (b < 0 ? this.iaddn(1) : this.isubn(1)), this
          }
          div(b) {
            return this._div(b, o.BOTH | o.EUCLID)[0]
          }
          divn(b) {
            return this.clone().idivn(b)
          }
          imod(b) {
            return this.ucmp(b) < 0
              ? (this.negative !== 0 && (this._isub(b, this), (this.negative = 0)), this)
              : this.mod(b)._move(this)
          }
          imodn(b) {
            return (this.words[0] = this.modrn(b)), (this.length = 1), (this.negative = 0), this
          }
          mod(b) {
            return this._div(b, o.REM | o.EUCLID)[1]
          }
          modn(b) {
            return this.clone().imodn(b)
          }
          modrn(b) {
            O(fe(b), 'num', 'smi')
            let C = this.remrn(b)
            return C < 0 && (b < 0 ? (C -= b) : (C += b)), C
          }
          divRound(b) {
            let [C, S] = this.quorem(b)
            if (S.isZero()) return C
            let R = b.words[0] & 1
            b.iushrn(1)
            let P = S.ucmp(b)
            return (
              b.iushln(1),
              (b.words[0] |= R),
              P < 0 || (b.isOdd() && P === 0) ? C : this.negative ^ b.negative ? C.isubn(1) : C.iaddn(1)
            )
          }
          ipow(b) {
            return this.pow(b)._move(this)
          }
          ipown(b) {
            return this.pown(b)._move(this)
          }
          pow(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = le(b.words[b.length - 1]),
              S = new f(1)
            for (let R = b.length - 1; R >= 0; R--) {
              let P = b.words[R]
              for (let B = C - 1; B >= 0; B--) (S = S.sqr()), (P >> B) & 1 && (S = S.mul(this))
              C = 26
            }
            return S
          }
          pown(b) {
            if ((O(fe(b), 'num', 'smi'), b < 0 && (b = -b), b === 0)) return new f(1)
            if (b === 1) return this.clone()
            let C = le(b),
              S = this
            for (let R = C - 2; R >= 0; R--) (S = S.sqr()), (b >> R) & 1 && (S = S.mul(this))
            return S
          }
          isqr() {
            return this.imul(this)
          }
          sqr() {
            return this.mul(this)
          }
          _rootrem(b, C) {
            if ((O(b >>> 0 === b, 'num', 'uint32'), b === 0)) throw new RangeError('Zeroth root.')
            if (~b & this.negative) throw new RangeError('Negative with even root.')
            if (this.ucmpn(1) <= 0) return [this.clone(), new f(0)]
            let S = new f(0),
              R = f.shift(1, (this.bitLength() / b + 1) | 0),
              P,
              B
            if ((this.negative !== 0 && R.ineg(), b === 2))
              do (S = R), (R = this.quo(S)), R.iadd(S), R.iushrn(1)
              while (R.ucmp(S) < 0)
            else
              do (S = R), (R = S.pown(b - 1)), (R = this.quo(R)), (P = S.muln(b - 1)), R.iadd(P), (R = R.quon(b))
              while (R.ucmp(S) < 0)
            return C && ((R = S.pown(b)), (B = this.sub(R))), [S, B]
          }
          rootrem(b) {
            return this._rootrem(b, 1)
          }
          iroot(b) {
            return this.root(b)._move(this)
          }
          root(b) {
            return this._rootrem(b, 0)[0]
          }
          isPower(b) {
            if ((O(b >>> 0 === b, 'num', 'uint32'), b === 0 || ~b & this.negative)) return !1
            let [, C] = this.rootrem(b)
            return C.sign() === 0
          }
          sqrtrem() {
            return this.rootrem(2)
          }
          isqrt() {
            return this.sqrt()._move(this)
          }
          sqrt() {
            return this.root(2)
          }
          isSquare() {
            return this.isPower(2)
          }
          iand(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = this,
              S = b
            if (C === S) return C
            if ((C.negative | S.negative) == 0) return C.iuand(S)
            if ((C.negative & S.negative) == 1) return C.iaddn(1), S.iaddn(1), C.iuor(S), C.isubn(1), S.isubn(1), C
            C.negative !== 0 && ([C, S] = [S.clone(), C])
            let R = C.bitLength()
            return S.iaddn(1), S.inotn(R), C.iuand(S), S.inotn(R), S.isubn(1), C._move(this)
          }
          iandn(b) {
            return (
              O(fe(b), 'num', 'smi'),
              (this.negative | (b < 0)) != 0 ? this.iand(new f(b)) : ((this.words[0] &= b), (this.length = 1), this)
            )
          }
          and(b) {
            return this.clone().iand(b)
          }
          andn(b) {
            return this.clone().iandn(b)
          }
          andrn(b) {
            if ((O(fe(b), 'num', 'smi'), (this.negative | (b < 0)) != 0)) {
              let C = this.iand(new f(b))
              if (C.length > 1) throw new RangeError('Number exceeds 26 bits.')
              return C.negative !== 0 ? -C.words[0] : C.words[0]
            }
            return this.words[0] & b
          }
          iuand(b) {
            O(f.isBN(b), 'num', 'bignum'), (this.length = Math.min(this.length, b.length))
            for (let C = 0; C < this.length; C++) this.words[C] &= b.words[C]
            return this._strip()
          }
          iuandn(b) {
            return O(fe(b), 'num', 'smi'), (this.words[0] &= Math.abs(b)), (this.length = 1), this._normalize()
          }
          uand(b) {
            return this.clone().iuand(b)
          }
          uandn(b) {
            return this.clone().iuandn(b)
          }
          uandrn(b) {
            O(fe(b), 'num', 'smi')
            let C = this.words[0] & Math.abs(b)
            return this.negative !== 0 ? -C | 0 : C
          }
          ior(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = this,
              S = b
            return C === S
              ? C
              : (C.negative | S.negative) == 0
              ? C.iuor(S)
              : (C.negative & S.negative) == 1
              ? (C.iaddn(1), S.iaddn(1), C.iuand(S), C.isubn(1), S.isubn(1), C)
              : ((S = S.clone()),
                C.negative !== 0 && ([C, S] = [S, C]),
                S.iaddn(1),
                C.inotn(S.bitLength()),
                S.iuand(C),
                S.isubn(1),
                S._move(this))
          }
          iorn(b) {
            return (
              O(fe(b), 'num', 'smi'), (this.negative | (b < 0)) != 0 ? this.ior(new f(b)) : ((this.words[0] |= b), this)
            )
          }
          or(b) {
            return this.clone().ior(b)
          }
          orn(b) {
            return this.clone().iorn(b)
          }
          iuor(b) {
            O(f.isBN(b), 'num', 'bignum'), this._expand(b.length)
            for (let C = 0; C < b.length; C++) this.words[C] |= b.words[C]
            return this
          }
          iuorn(b) {
            return O(fe(b), 'num', 'smi'), (this.words[0] |= Math.abs(b)), this
          }
          uor(b) {
            return this.clone().iuor(b)
          }
          uorn(b) {
            return this.clone().iuorn(b)
          }
          ixor(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = this,
              S = b
            return C === S
              ? ((C.words[0] = 0), (C.length = 1), (C.negative = 0), C)
              : (C.negative | S.negative) == 0
              ? C.iuxor(S)
              : (C.negative & S.negative) == 1
              ? (C.iaddn(1), S.iaddn(1), C.iuxor(S), C.ineg(), S.isubn(1), C)
              : (C.negative !== 0 && ([C, S] = [S.clone(), C]),
                S.iaddn(1),
                C.iuxor(S),
                C.iaddn(1),
                C.ineg(),
                S.isubn(1),
                C._move(this))
          }
          ixorn(b) {
            return (
              O(fe(b), 'num', 'smi'),
              (this.negative | (b < 0)) != 0 ? this.ixor(new f(b)) : ((this.words[0] ^= b), this)
            )
          }
          xor(b) {
            return this.clone().ixor(b)
          }
          xorn(b) {
            return this.clone().ixorn(b)
          }
          iuxor(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = this,
              S = b
            C.length < S.length && ([C, S] = [S, C])
            let R = 0
            for (; R < S.length; R++) this.words[R] = C.words[R] ^ S.words[R]
            if (C !== this) for (this._alloc(C.length); R < C.length; R++) this.words[R] = C.words[R]
            return (this.length = C.length), this._strip()
          }
          iuxorn(b) {
            return O(fe(b), 'num', 'smi'), (this.words[0] ^= Math.abs(b)), this._normalize()
          }
          uxor(b) {
            return this.clone().iuxor(b)
          }
          uxorn(b) {
            return this.clone().iuxorn(b)
          }
          inot() {
            return this.negative !== 0 ? this.ineg().isubn(1) : this.iaddn(1).ineg(), this
          }
          not() {
            return this.clone().inot()
          }
          inotn(b) {
            O(b >>> 0 === b, 'width', 'uint32')
            let C = b % 26,
              S = Math.ceil(b / 26),
              R = 0
            for (this._expand(S), C > 0 && (S -= 1); R < S; R++) this.words[R] ^= 67108863
            return C > 0 && (this.words[R] ^= (1 << C) - 1), this._strip()
          }
          notn(b) {
            return this.clone().inotn(b)
          }
          ishl(b) {
            return O(f.isBN(b), 'bits', 'bignum'), O(b.bitLength() <= 32, 'bits', 'uint32'), this.ishln(b.toNumber())
          }
          ishln(b) {
            return this.iushln(b)
          }
          shl(b) {
            return this.clone().ishl(b)
          }
          shln(b) {
            return this.clone().ishln(b)
          }
          iushl(b) {
            return O(f.isBN(b), 'bits', 'bignum'), O(b.bitLength() <= 32, 'bits', 'uint32'), this.iushln(b.toNumber())
          }
          iushln(b) {
            O(b >>> 0 === b, 'bits', 'uint32')
            let C = b % 26,
              S = (b - C) / 26,
              R = ((1 << C) - 1) << (26 - C)
            if (C !== 0) {
              let P = 0
              for (let B = 0; B < this.length; B++) {
                let D = this.words[B] & R,
                  $ = ((this.words[B] | 0) - D) << C
                ;(this.words[B] = $ | P), (P = D >>> (26 - C))
              }
              P !== 0 && (this._alloc(this.length + 1), (this.words[this.length++] = P))
            }
            if (S !== 0) {
              this._alloc(this.length + S)
              for (let P = this.length - 1; P >= 0; P--) this.words[P + S] = this.words[P]
              for (let P = 0; P < S; P++) this.words[P] = 0
              this.length += S
            }
            return this._strip()
          }
          ushl(b) {
            return this.clone().iushl(b)
          }
          ushln(b) {
            return this.clone().iushln(b)
          }
          _split(b, C) {
            let S = b % 26,
              R = Math.min((b - S) / 26, this.length),
              P = (1 << S) - 1
            if (C) {
              C._alloc(R)
              for (let D = 0; D < R; D++) C.words[D] = this.words[D]
              C.length = R
            }
            if (R !== 0)
              if (this.length > R) {
                this.length -= R
                for (let D = 0; D < this.length; D++) this.words[D] = this.words[D + R]
              } else (this.words[0] = 0), (this.length = 1)
            let B = 0
            if (S !== 0)
              for (let D = this.length - 1; D >= 0; D--) {
                let $ = this.words[D] | 0
                ;(this.words[D] = (B << (26 - S)) | ($ >>> S)), (B = $ & P)
              }
            return (
              C &&
                (B !== 0
                  ? (C._alloc(C.length + 1), (C.words[C.length++] = B))
                  : (C.length === 0 && (C.words[C.length++] = 0), C._strip())),
              this._strip()
            )
          }
          ishr(b) {
            return O(f.isBN(b), 'bits', 'bignum'), O(b.bitLength() <= 32, 'bits', 'uint32'), this.ishrn(b.toNumber())
          }
          ishrn(b) {
            return (
              O(b >>> 0 === b, 'bits', 'uint32'),
              this.negative !== 0 ? (this.iaddn(1), this.iushrn(b), this.isubn(1), this) : this.iushrn(b)
            )
          }
          shr(b) {
            return this.clone().ishr(b)
          }
          shrn(b) {
            return this.clone().ishrn(b)
          }
          iushr(b) {
            return O(f.isBN(b), 'bits', 'bignum'), O(b.bitLength() <= 32, 'bits', 'uint32'), this.iushrn(b.toNumber())
          }
          iushrn(b) {
            return O(b >>> 0 === b, 'bits', 'uint32'), this._split(b, null)
          }
          ushr(b) {
            return this.clone().iushr(b)
          }
          ushrn(b) {
            return this.clone().iushrn(b)
          }
          setn(b, C) {
            return (
              O(b >>> 0 === b, 'bit', 'uint32'),
              this.negative !== 0 ? (this.iaddn(1), this.usetn(b, !C), this.isubn(1), this) : this.usetn(b, C)
            )
          }
          usetn(b, C) {
            O(b >>> 0 === b, 'bit', 'uint32')
            let S = b % 26,
              R = (b - S) / 26
            return this._expand(R + 1), C ? (this.words[R] |= 1 << S) : (this.words[R] &= ~(1 << S)), this._strip()
          }
          testn(b) {
            O(b >>> 0 === b, 'bit', 'uint32')
            let C = b % 26,
              S = (b - C) / 26
            if (this.length <= S) return this.negative
            let R = this.words[S],
              P = (R >> C) & 1
            if (this.negative !== 0) {
              if (C > 0 && R & ((1 << C) - 1)) return P ^ 1
              let B = S
              for (; B--; ) if (this.words[B] > 0) return P ^ 1
            }
            return P
          }
          utestn(b) {
            O(b >>> 0 === b, 'bit', 'uint32')
            let C = b % 26,
              S = (b - C) / 26
            return this.length <= S ? 0 : (this.words[S] >> C) & 1
          }
          imaskn(b) {
            return (
              O(b >>> 0 === b, 'bits', 'uint32'),
              this.negative !== 0 && (this.iaddn(1), this.inotn(b + 1), this.ineg()),
              this.iumaskn(b)
            )
          }
          maskn(b) {
            return this.clone().imaskn(b)
          }
          iumaskn(b) {
            O(b >>> 0 === b, 'bits', 'uint32')
            let C = b % 26,
              S = (b - C) / 26
            return this.length <= S
              ? this
              : (C !== 0 && (S += 1),
                (this.length = Math.min(S, this.length)),
                C !== 0 && (this.words[this.length - 1] &= (1 << C) - 1),
                this.length === 0 && (this.words[this.length++] = 0),
                this._strip())
          }
          umaskn(b) {
            return this.clone().iumaskn(b)
          }
          andln(b) {
            return this.words[0] & b
          }
          bit(b) {
            return this.utestn(b)
          }
          bits(b, C) {
            O(b >>> 0 === b, 'pos', 'uint32'), O(C >>> 0 === C, 'width', 'uint32'), O(C <= 26, 'width', 'width')
            let S = b % 26,
              R = (b - S) / 26
            if (R >= this.length) return 0
            let P = (this.words[R] >> S) & ((1 << C) - 1)
            if (S + C > 26 && R + 1 < this.length) {
              let B = S + C - 26
              P |= (this.words[R + 1] & ((1 << B) - 1)) << (26 - S)
            }
            return P
          }
          ineg() {
            return this.isZero() || (this.negative ^= 1), this
          }
          neg() {
            return this.clone().ineg()
          }
          iabs() {
            return (this.negative = 0), this
          }
          abs() {
            return this.clone().iabs()
          }
          cmp(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), this.negative !== b.negative)) return b.negative - this.negative
            let C = this.ucmp(b)
            return this.negative !== 0 ? -C | 0 : C
          }
          cmpn(b) {
            O(fe(b), 'num', 'smi')
            let C = (b < 0) | 0
            if (this.negative !== C) return C - this.negative
            let S = this.ucmpn(b)
            return this.negative !== 0 ? -S | 0 : S
          }
          eq(b) {
            return this.cmp(b) === 0
          }
          eqn(b) {
            return this.cmpn(b) === 0
          }
          gt(b) {
            return this.cmp(b) > 0
          }
          gtn(b) {
            return this.cmpn(b) > 0
          }
          gte(b) {
            return this.cmp(b) >= 0
          }
          gten(b) {
            return this.cmpn(b) >= 0
          }
          lt(b) {
            return this.cmp(b) < 0
          }
          ltn(b) {
            return this.cmpn(b) < 0
          }
          lte(b) {
            return this.cmp(b) <= 0
          }
          lten(b) {
            return this.cmpn(b) <= 0
          }
          sign() {
            return this.negative !== 0 ? -1 : this.length === 1 && this.words[0] === 0 ? 0 : 1
          }
          isZero() {
            return this.length === 1 && this.words[0] === 0
          }
          isNeg() {
            return this.negative !== 0
          }
          isPos() {
            return this.negative === 0
          }
          isOdd() {
            return (this.words[0] & 1) == 1
          }
          isEven() {
            return (this.words[0] & 1) == 0
          }
          ucmp(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), this.length < b.length)) return -1
            if (this.length > b.length) return 1
            for (let C = this.length - 1; C >= 0; C--) {
              let S = this.words[C] | 0,
                R = b.words[C] | 0
              if (S !== R) return (S > R) - (S < R)
            }
            return 0
          }
          ucmpn(b) {
            if ((O(fe(b), 'num', 'smi'), this.length > 1)) return 1
            let C = this.words[0] | 0
            return b < 0 && (b = -b), (C > b) - (C < b)
          }
          legendre(b) {
            let C = c ? f.red(b) : f.mont(b)
            return this.toRed(C).redLegendre()
          }
          jacobi(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), b.isZero() || b.isEven())) throw new Error('jacobi: `num` must be odd.')
            let C = this._cloneNormal(),
              S = b.clone(),
              R = 1
            for (
              S.isNeg() && (C.isNeg() && (R = -1), S.ineg()), (C.isNeg() || C.ucmp(S) >= 0) && C.imod(S);
              !C.isZero();

            ) {
              if (C._makeOdd() & 1) {
                let D = S.andln(7)
                ;(D === 3 || D === 5) && (R = -R)
              }
              C.ucmp(S) < 0 && (([C, S] = [S, C]), C.andln(3) === 3 && S.andln(3) === 3 && (R = -R)),
                C._isub(C, S).iushrn(1)
              let B = S.andln(7)
              ;(B === 3 || B === 5) && (R = -R)
            }
            return S.cmpn(1) !== 0 ? 0 : R
          }
          kronecker(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = [0, 1, 0, -1, 0, -1, 0, 1],
              S = this._cloneNormal(),
              R = b.clone(),
              P = 1
            if (R.isZero()) return S.ucmpn(1) === 0 ? P : 0
            if (!S.isOdd() && !R.isOdd()) return 0
            for (R._makeOdd() & 1 && (P = C[S.andln(7)]), R.isNeg() && (S.isNeg() && (P = -P), R.ineg()); !S.isZero(); )
              S._makeOdd() & 1 && (P *= C[R.andln(7)]),
                (S.words[0] ^ (S.negative * 67108863)) & R.words[0] & 2 && (P = -P),
                R.imod(S),
                ([S, R] = [R, S]),
                (R.negative = 0)
            return R.cmpn(1) !== 0 ? 0 : P
          }
          igcd(b) {
            return this.gcd(b)._move(this)
          }
          gcd(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), this.isZero())) return b.abs()
            if (b.isZero()) return this.abs()
            let C = this.clone(),
              S = b.clone()
            ;(C.negative = 0), (S.negative = 0)
            let R = C._factor2(S)
            for (R !== 0 && (C.iushrn(R), S.iushrn(R)); ; ) {
              C._makeOdd(), S._makeOdd()
              let P = C.ucmp(S)
              if (P < 0) [C, S] = [S, C]
              else if (P === 0 || S.ucmpn(1) === 0) break
              C._isub(C, S)
            }
            return S.iushln(R)
          }
          ilcm(b) {
            return this.lcm(b)._move(this)
          }
          lcm(b) {
            return (
              O(f.isBN(b), 'num', 'bignum'),
              this.isZero() || b.isZero() ? new f(0) : this.quo(this.gcd(b)).mul(b).iabs()
            )
          }
          egcd(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), this.isZero())) return [new f(0), new f(b.sign()), b.abs()]
            if (b.isZero()) return [new f(this.sign()), new f(0), this.abs()]
            let C = this.clone(),
              S = b.clone()
            ;(C.negative = 0), (S.negative = 0)
            let R = new f(1),
              P = new f(0),
              B = new f(0),
              D = new f(1),
              $ = C._factor2(S)
            $ > 0 && (C.iushrn($), S.iushrn($))
            let g = C.clone(),
              N = S.clone()
            for (; !C.isZero(); ) {
              let U = C._makeOdd(),
                X = S._makeOdd()
              for (; U--; ) (R.isOdd() || P.isOdd()) && (R.iadd(N), P.isub(g)), R.iushrn(1), P.iushrn(1)
              for (; X--; ) (B.isOdd() || D.isOdd()) && (B.iadd(N), D.isub(g)), B.iushrn(1), D.iushrn(1)
              C.cmp(S) >= 0 ? (C.isub(S), R.isub(B), P.isub(D)) : (S.isub(C), B.isub(R), D.isub(P))
            }
            return this.negative !== 0 && B.ineg(), b.negative !== 0 && D.ineg(), [B, D, S.iushln($)]
          }
          iinvert(b) {
            return this.invert(b)._move(this)
          }
          invert(b) {
            if ((O(f.isBN(b), 'num', 'bignum'), x(b.sign() > 0, 'invert'), b.isOdd())) return this._invertp(b)
            if (b.cmpn(1) === 0) throw new RangeError('Not invertible.')
            let [C, , S] = this.egcd(b)
            if (S.cmpn(1) !== 0) throw new RangeError('Not invertible.')
            return C.imod(b)
          }
          ifermat(b) {
            return this.fermat(b)._move(this)
          }
          fermat(b) {
            let C = c ? f.red(b) : f.mont(b)
            return this.toRed(C).redFermat().fromRed()
          }
          ipowm(b, C, S) {
            return this.powm(b, C, S)._move(this)
          }
          powm(b, C, S) {
            let R = !c && S ? f.mont(C) : f.red(C)
            return this.toRed(R).redPow(b).fromRed()
          }
          ipowmn(b, C, S) {
            return this.powmn(b, C, S)._move(this)
          }
          powmn(b, C, S) {
            let R = S ? f.mont(C) : f.red(C)
            return this.toRed(R).redPown(b).fromRed()
          }
          isqrtm(b) {
            return this.sqrtm(b)._move(this)
          }
          sqrtm(b) {
            O(f.isBN(b), 'p', 'bignum')
            let C
            return (
              b.andln(3) === 3 || b.andln(7) === 5 ? (C = f.red(b)) : (C = f.mont(b)), this.toRed(C).redSqrt().fromRed()
            )
          }
          isqrtpq(b, C) {
            return this.sqrtpq(b, C)._move(this)
          }
          sqrtpq(b, C) {
            let S = this.sqrtm(b),
              R = this.sqrtm(C),
              [P, B] = b.egcd(C),
              D = R.mul(P).mul(b),
              $ = S.mul(B).mul(C),
              g = b.mul(C)
            return D.iadd($).imod(g)
          }
          isPrime(b, C, S) {
            return O(C >>> 0 === C, 'reps', 'uint32'), !(!this.isPrimeMR(b, C + 1, !0) || !this.isPrimeLucas(S))
          }
          isPrimeMR(b, C, S = !1) {
            O(C >>> 0 === C, 'reps', 'uint32'),
              O(C > 0, 'reps', 'integer'),
              O(typeof S == 'boolean', 'force2', 'boolean')
            let R = this
            if (R.cmpn(7) < 0) return R.cmpn(2) === 0 || R.cmpn(3) === 0 || R.cmpn(5) === 0
            if (R.isEven()) return !1
            let P = R.subn(1),
              B = P.subn(2),
              D = P.zeroBits(),
              $ = P.ushrn(D),
              g = f.red(R),
              N = P.toRed(g),
              U = new f(1).toRed(g)
            e: for (let X = 0; X < C; X++) {
              let ne
              X === C - 1 && S ? (ne = new f(2)) : ((ne = f.random(b, 0, B)), ne.iaddn(2))
              let ee = ne.toRed(g).redPow($)
              if (!(ee.cmp(U) === 0 || ee.cmp(N) === 0)) {
                for (let ae = 1; ae < D; ae++) {
                  if (((ee = ee.redSqr()), ee.cmp(N) === 0)) continue e
                  if (ee.cmp(U) === 0) return !1
                }
                return !1
              }
            }
            return !0
          }
          isPrimeLucas(b = 0) {
            O(b >>> 0 === b, 'limit', 'uint32')
            let C = this
            if (C.cmpn(1) <= 0) return !1
            if (C.isEven()) return C.cmpn(2) === 0
            let S = 3
            for (;;) {
              if (S > 1e4) throw new Error(`Cannot find (D/n) = -1 for ${C.toString(10)}.`)
              if (b !== 0 && S > b) return !1
              let g = new f(S * S - 4).jacobi(C)
              if (g === -1) break
              if (g === 0) return C.cmpn(S + 2) === 0
              if (S === 40 && C.isSquare()) return !1
              S += 1
            }
            let R = C.addn(1),
              P = R._makeOdd(),
              B = new f(2),
              D = new f(S)
            for (let $ = R.bitLength(); $ >= 0; $--)
              R.utestn($)
                ? ((B = B.mul(D).isubn(S).imod(C)), (D = D.sqr().isubn(2).imod(C)))
                : ((D = D.mul(B).isubn(S).imod(C)), (B = B.sqr().isubn(2).imod(C)))
            if (B.cmpn(2) === 0 || B.cmp(C.subn(2)) === 0) {
              let $ = B.muln(S).imod(C),
                g = D.ushln(1).imod(C)
              if ($.cmp(g) === 0) return !0
            }
            for (let $ = 0; $ < P - 1; $++) {
              if (B.isZero()) return !0
              if (B.cmpn(2) === 0) return !1
              B = B.sqr().isubn(2).imod(C)
            }
            return !1
          }
          toTwos(b) {
            return this.negative !== 0 ? this.abs().inotn(b).iaddn(1) : this.clone()
          }
          fromTwos(b) {
            return (
              O(b >>> 0 === b, 'width', 'uint32'),
              x(b > 0, 'width'),
              this.testn(b - 1) ? this.notn(b).iaddn(1).ineg() : this.clone()
            )
          }
          toRed(b) {
            if ((O(b instanceof v, 'ctx', 'reduction context'), this.red))
              throw new Error('Already in reduction context.')
            return b.convertTo(this)
          }
          fromRed() {
            return L(this.red, 'fromRed'), this.red.convertFrom(this)
          }
          forceRed(b) {
            if ((O(b instanceof v, 'ctx', 'reduction context'), this.red)) {
              if (!b.m.eq(this.red.m) || b.mont !== this.red.mont) throw new Error('Already in reduction context.')
            } else x(this.negative === 0, 'red'), x(this.ucmp(b.m) < 0, 'red')
            return this.clone()._forceRed(b)
          }
          redIAdd(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redIAdd'), this.red.iadd(this, b)
          }
          redAdd(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redAdd'), this.red.add(this, b)
          }
          redIAddn(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redIAddn'), this.red.iaddn(this, b)
          }
          redAddn(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redAddn'), this.red.addn(this, b)
          }
          redISub(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redISub'), this.red.isub(this, b)
          }
          redSub(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redSub'), this.red.sub(this, b)
          }
          redISubn(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redISubn'), this.red.isubn(this, b)
          }
          redSubn(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redSubn'), this.red.subn(this, b)
          }
          redIMul(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redIMul'), this.red.imul(this, b)
          }
          redMul(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redMul'), this.red.mul(this, b)
          }
          redIMuln(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redIMuln'), this.red.imuln(this, b)
          }
          redMuln(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redMuln'), this.red.muln(this, b)
          }
          redIDiv(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redIDiv'), this.red.idiv(this, b)
          }
          redDiv(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redDiv'), this.red.div(this, b)
          }
          redIDivn(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redIDivn'), this.red.idivn(this, b)
          }
          redDivn(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redDivn'), this.red.divn(this, b)
          }
          redIPow(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redIPow'), K(!b.red, 'redIPow'), this.red.ipow(this, b)
          }
          redPow(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redPow'), K(!b.red, 'redPow'), this.red.pow(this, b)
          }
          redIPown(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redIPown'), this.red.ipown(this, b)
          }
          redPown(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redPown'), this.red.pown(this, b)
          }
          redISqr() {
            return L(this.red, 'redISqr'), this.red.isqr(this)
          }
          redSqr() {
            return L(this.red, 'redSqr'), this.red.sqr(this)
          }
          redISqrt() {
            return L(this.red, 'redISqrt'), this.red.isqrt(this)
          }
          redSqrt() {
            return L(this.red, 'redSqrt'), this.red.sqrt(this)
          }
          redIDivSqrt(b) {
            return L(this.red, 'redIDivSqrt'), this.red.idivsqrt(this, b)
          }
          redDivSqrt(b) {
            return L(this.red, 'redDivSqrt'), this.red.divsqrt(this, b)
          }
          redIsSquare() {
            return L(this.red, 'redIsSquare'), this.red.isSquare(this)
          }
          redIShl(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redIShl'), K(!b.red, 'redIShl'), this.red.ishl(this, b)
          }
          redShl(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redShl'), K(!b.red, 'redShl'), this.red.shl(this, b)
          }
          redIShln(b) {
            return O(b >>> 0 === b, 'num', 'uint32'), L(this.red, 'redIShln'), this.red.ishln(this, b)
          }
          redShln(b) {
            return O(b >>> 0 === b, 'num', 'uint32'), L(this.red, 'redShln'), this.red.shln(this, b)
          }
          redINeg() {
            return L(this.red, 'redINeg'), this.red.ineg(this)
          }
          redNeg() {
            return L(this.red, 'redNeg'), this.red.neg(this)
          }
          redEq(b) {
            return O(f.isBN(b), 'num', 'bignum'), L(this.red, 'redEq'), this.red.eq(this, b)
          }
          redEqn(b) {
            return O(fe(b), 'num', 'smi'), L(this.red, 'redEqn'), this.red.eqn(this, b)
          }
          redIsHigh() {
            return L(this.red, 'redIsHigh'), this.red.isHigh(this)
          }
          redIsLow() {
            return L(this.red, 'redIsLow'), this.red.isLow(this)
          }
          redIsOdd() {
            return L(this.red, 'redIsOdd'), this.red.isOdd(this)
          }
          redIsEven() {
            return L(this.red, 'redIsEven'), this.red.isEven(this)
          }
          redLegendre() {
            return L(this.red, 'redLegendre'), this.red.legendre(this)
          }
          redJacobi() {
            return L(this.red, 'redJacobi'), this.red.jacobi(this)
          }
          redKronecker() {
            return L(this.red, 'redKronecker'), this.red.kronecker(this)
          }
          redIInvert() {
            return L(this.red, 'redIInvert'), this.red.iinvert(this)
          }
          redInvert() {
            return L(this.red, 'redInvert'), this.red.invert(this)
          }
          redIFermat() {
            return L(this.red, 'redIFermat'), this.red.ifermat(this)
          }
          redFermat() {
            return L(this.red, 'redFermat'), this.red.fermat(this)
          }
          _move(b) {
            return (b.words = this.words), (b.length = this.length), (b.negative = this.negative), (b.red = this.red), b
          }
          _alloc(b) {
            for (; this.words.length < b; ) this.words.push(0)
            return this
          }
          _expand(b) {
            for (this._alloc(b); this.length < b; ) this.words[this.length++] = 0
            return this
          }
          _strip() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length -= 1
            return this._normalize()
          }
          _normalize() {
            return G(this.length > 0), this.length === 1 && this.words[0] === 0 && (this.negative = 0), this
          }
          _check() {
            return (
              G(this.length > 0),
              G(this.length <= this.words.length),
              this.length === 1
                ? (this.words[0] === 0 && G(this.negative === 0), this)
                : (G(this.words[this.length - 1] !== 0), this)
            )
          }
          _invertp(b) {
            if ((O(f.isBN(b), 'p', 'bignum'), x(b.sign() > 0, 'invert'), G(b.isOdd()), b.cmpn(1) === 0))
              throw new RangeError('Not invertible.')
            let C = this.clone(),
              S = b.clone(),
              R = new f(1),
              P = new f(0)
            for ((C.isNeg() || C.ucmp(S) >= 0) && C.imod(S); !C.isZero(); ) {
              let B = C._makeOdd(),
                D = S._makeOdd()
              for (; B--; ) R.isOdd() && R._iadd(R, b), R.iushrn(1)
              for (; D--; ) P.isOdd() && P._iadd(P, b), P.iushrn(1)
              C.ucmp(S) >= 0
                ? (C._isub(C, S), R.ucmp(P) < 0 ? (R._isub(P, R), R._isub(b, R)) : R._isub(R, P))
                : (S._isub(S, C), P.ucmp(R) < 0 ? (P._isub(R, P), P._isub(b, P)) : P._isub(P, R))
            }
            if (S.cmpn(1) !== 0) throw new RangeError('Not invertible.')
            return G(P.negative === 0), G(P.ucmp(b) < 0), P
          }
          _makeOdd() {
            let b = this.zeroBits()
            return b > 0 && this.iushrn(b), b
          }
          _factor2(b) {
            if ((this.words[0] | b.words[0]) & 1) return 0
            let C = Math.min(this.length, b.length),
              S = 0
            for (let R = 0; R < C; R++) {
              let P = xe(this.words[R] | b.words[R])
              if (((S += P), P !== 26)) break
            }
            return S
          }
          _cloneNormal() {
            return this.red ? this.fromRed() : this.clone()
          }
          _forceRed(b) {
            return (this.red = b), this
          }
          clone() {
            let b = new f()
            b.words = new Array(this.length)
            for (let C = 0; C < this.length; C++) b.words[C] = this.words[C]
            return (b.length = this.length), (b.negative = this.negative), (b.red = this.red), b
          }
          inject(b) {
            O(f.isBN(b), 'num', 'bignum'), this._alloc(b.length)
            for (let C = 0; C < b.length; C++) this.words[C] = b.words[C]
            return (this.length = b.length), (this.negative = b.negative), (this.red = b.red), this
          }
          set(b, C) {
            return this.fromNumber(b, C)
          }
          swap(b) {
            O(f.isBN(b), 'num', 'bignum')
            let C = this,
              S = b
            return (
              ([C.words, S.words] = [S.words, C.words]),
              ([C.length, S.length] = [S.length, C.length]),
              ([C.negative, S.negative] = [S.negative, C.negative]),
              ([C.red, S.red] = [S.red, C.red]),
              C
            )
          }
          reverse() {
            let b = this.negative
            return this.fromBuffer(this.toBuffer('be'), 'le'), (this.negative = b), this
          }
          byteLength() {
            return Math.ceil(this.bitLength() / 8)
          }
          bitLength() {
            let b = this.words[this.length - 1],
              C = le(b)
            return (this.length - 1) * 26 + C
          }
          zeroBits() {
            if (this.isZero() || this.isOdd()) return 0
            let b = 0
            for (let C = 0; C < this.length; C++) {
              let S = xe(this.words[C])
              if (((b += S), S !== 26)) break
            }
            return b
          }
          isSafe() {
            return this.length <= 2 || (this.length === 3 && this.words[2] === 1)
          }
          word(b) {
            return O(b >>> 0 === b, 'pos', 'uint32'), b >= this.length ? 0 : this.words[b]
          }
          [t]() {
            let b = 'BN'
            return this.red && (b = 'BN-R'), `<${b}: ${this.toString(10)}>`
          }
          toNumber() {
            let b = this.words[0]
            if (this.length === 2) b += this.words[1] * 67108864
            else if (this.length === 3 && this.words[2] === 1) b += 4503599627370496 + this.words[1] * 67108864
            else if (this.length > 2) throw new RangeError('Number can only safely store up to 53 bits.')
            return this.negative !== 0 ? -b : b
          }
          toDouble() {
            let b = 0
            for (let C = this.length - 1; C >= 0; C--) b = b * 67108864 + this.words[C]
            return this.negative !== 0 ? -b : b
          }
          valueOf() {
            return this.toDouble()
          }
          toBigInt() {
            if (!c) throw new Error('BigInt is not supported!')
            let b = BigInt(52),
              C = BigInt(26),
              S = this.length - 1,
              R = BigInt(0)
            for (; S >= 1; S -= 2) {
              let P = this.words[S] * 67108864,
                B = this.words[S - 1]
              R = (R << b) | BigInt(P + B)
            }
            return S >= 0 && (R = (R << C) | BigInt(this.words[0])), this.negative !== 0 ? -R : R
          }
          toBool() {
            return !this.isZero()
          }
          toString(b, C) {
            if (
              ((b = W(b)),
              C == null && (C = 0),
              C === 0 && (C = 1),
              O(b >>> 0 === b, 'base', 'uint32'),
              O(C >>> 0 === C, 'padding', 'uint32'),
              b < 2 || b > 36)
            )
              throw new RangeError('Base ranges between 2 and 36.')
            if ((this._check(), b === 16)) {
              let D = '',
                $ = 0,
                g = 0
              for (let N = 0; N < this.length; N++) {
                let U = this.words[N],
                  X = (((U << $) | g) & 16777215).toString(16)
                ;(g = (U >>> (24 - $)) & 16777215),
                  g !== 0 || N !== this.length - 1 ? (D = n[6 - X.length] + X + D) : (D = X + D),
                  ($ += 2),
                  $ >= 26 && (($ -= 26), (N -= 1))
              }
              for (g !== 0 && (D = g.toString(16) + D); D.length % C != 0; ) D = '0' + D
              return this.negative !== 0 && (D = '-' + D), D
            }
            let S = i[b - 1],
              R = s[b - 1],
              P = this.clone(),
              B = ''
            for (P.negative = 0; !P.isZero(); ) {
              let D = P.remrn(R).toString(b)
              P.iquon(R), P.isZero() ? (B = D + B) : (B = n[S - D.length] + D + B)
            }
            for (this.isZero() && (B = '0'); B.length % C != 0; ) B = '0' + B
            return this.negative !== 0 && (B = '-' + B), B
          }
          toJSON() {
            return this.toString(16, 2)
          }
          toArray(b, C) {
            return this.toArrayLike(Array, b, C)
          }
          toBuffer(b, C) {
            return this.toArrayLike(Ve.Buffer, b, C)
          }
          toArrayLike(b, C, S) {
            C == null && (C = 'be'),
              S == null && (S = 0),
              O(typeof b == 'function', 'ArrayType', 'function'),
              O(C === 'be' || C === 'le', 'endian', 'endianness'),
              O(S >>> 0 === S, 'length', 'uint32'),
              this._check()
            let R = this.byteLength(),
              P = S || Math.max(1, R)
            if (R > P) throw new RangeError('Byte array longer than desired length.')
            let B = ie(b, P)
            if (C === 'be') {
              let D = B.length - 1,
                $ = 0
              for (let g = 0; g < this.length; g++) {
                let N = (g & 3) << 1,
                  U = (this.words[g] << N) | $
                ;(B[D--] = U & 255),
                  D >= 0 && (B[D--] = (U >>> 8) & 255),
                  D >= 0 && (B[D--] = (U >>> 16) & 255),
                  N === 6 ? (D >= 0 && (B[D--] = (U >>> 24) & 255), ($ = 0)) : ($ = U >>> 24)
              }
              if (D >= 0) {
                for (B[D--] = $; D >= 0; ) B[D--] = 0
                $ = 0
              }
              G($ === 0)
            } else {
              let D = 0,
                $ = 0
              for (let g = 0; g < this.length; g++) {
                let N = (g & 3) << 1,
                  U = (this.words[g] << N) | $
                ;(B[D++] = U & 255),
                  D < B.length && (B[D++] = (U >>> 8) & 255),
                  D < B.length && (B[D++] = (U >>> 16) & 255),
                  N === 6 ? (D < B.length && (B[D++] = (U >>> 24) & 255), ($ = 0)) : ($ = U >>> 24)
              }
              if (D < B.length) {
                for (B[D++] = $; D < B.length; ) B[D++] = 0
                $ = 0
              }
              G($ === 0)
            }
            return B
          }
          encode(b, C) {
            return this.toBuffer(b, C)
          }
          of(b, C) {
            return this.fromNumber(b, C)
          }
          fromNumber(b, C) {
            C == null && (C = 'be'), O(Q(b), 'num', 'integer'), O(C === 'be' || C === 'le', 'endian', 'endianness')
            let S = (b < 0) | 0
            return (
              S && (b = -b),
              b < 67108864
                ? ((this.words[0] = b & 67108863), (this.length = 1))
                : b < 4503599627370496
                ? ((this.words = [b & 67108863, (b / 67108864) & 67108863]), (this.length = 2))
                : ((this.words = [b & 67108863, (b / 67108864) & 67108863, 1]), (this.length = 3)),
              (this.negative = S),
              C === 'le' && this.reverse(),
              this
            )
          }
          fromDouble(b, C) {
            C == null && (C = 'be'),
              O(typeof b == 'number', 'num', 'double'),
              O(C === 'be' || C === 'le', 'endian', 'endianness'),
              isFinite(b) || (b = 0)
            let S = (b <= -1) | 0
            for (b < 0 && (b = -b), b = Math.floor(b), this.words = []; b > 0; ) {
              let R = b % 67108864,
                P = (b - R) / 67108864
              this.words.push(R), (b = P)
            }
            return (
              this.words.length === 0 && this.words.push(0),
              (this.length = this.words.length),
              (this.negative = S),
              C === 'le' && this.reverse(),
              this
            )
          }
          fromBigInt(b, C) {
            if (
              (C == null && (C = 'be'),
              O(typeof b == 'bigint', 'num', 'bigint'),
              O(C === 'be' || C === 'le', 'endian', 'endianness'),
              !c)
            )
              throw new Error('BigInt is not supported!')
            let S = (b < BigInt(0)) | 0
            return this._fromHex(b.toString(16), S), (this.negative = S), C === 'le' && this.reverse(), this
          }
          fromBool(b) {
            return (
              O(typeof b == 'boolean', 'value', 'boolean'),
              (this.words[0] = b | 0),
              (this.length = 1),
              (this.negative = 0),
              this
            )
          }
          fromString(b, C, S) {
            if (
              ((C === 'le' || C === 'be') && ([C, S] = [S, C]),
              (C = W(C)),
              S == null && (S = 'be'),
              O(typeof b == 'string', 'string', 'string'),
              O(C >>> 0 === C, 'base', 'uint32'),
              O(S === 'be' || S === 'le', 'endian', 'endianness'),
              C < 2 || C > 36)
            )
              throw new Error('Base ranges between 2 and 36.')
            b = b.replace(/\s+/g, '')
            let R = 0
            return (
              b.length > 0 && b.charCodeAt(0) === 45 && (R = 1),
              C === 16 ? this._fromHex(b, R) : this._fromBase(b, C, R),
              (this.negative = R),
              this._normalize(),
              S === 'le' && this.reverse(),
              this
            )
          }
          _fromHex(b, C) {
            ;(this.length = Math.max(2, Math.ceil((b.length - C) / 6))), (this.words = new Array(this.length))
            for (let B = 0; B < this.length; B++) this.words[B] = 0
            let S = 0,
              R = b.length - 6,
              P = 0
            for (; R >= C; R -= 6) {
              let B = _e(b, R, R + 6)
              ;(this.words[P] |= (B << S) & 67108863),
                (this.words[P + 1] |= (B >>> (26 - S)) & 4194303),
                (S += 24),
                S >= 26 && ((S -= 26), (P += 1))
            }
            if (R + 6 !== C) {
              let B = _e(b, C, R + 6)
              ;(this.words[P] |= (B << S) & 67108863), (this.words[P + 1] |= (B >>> (26 - S)) & 4194303)
            }
            return this._strip()
          }
          _fromBase(b, C, S) {
            ;(this.words[0] = 0), (this.length = 1), (this.negative = 0)
            let R = 0,
              P = 1
            for (; P <= 67108863; P *= C) R += 1
            ;(R -= 1), (P = (P / C) | 0)
            let B = b.length - S,
              D = B % R,
              $ = Math.min(B, B - D) + S,
              g = S
            for (; g < $; g += R) {
              let N = Ne(b, g, g + R, C)
              this.imuln(P), this._iaddn(N)
            }
            if (D !== 0) {
              let N = Math.pow(C, D),
                U = Ne(b, g, b.length, C)
              this.imuln(N), this._iaddn(U)
            }
            return this
          }
          fromJSON(b) {
            if (f.isBN(b)) return b.red ? b.fromRed() : b.clone()
            if (Array.isArray(b)) {
              for (let C of b) O(typeof C == 'string', 'chunk', 'string')
              b = b.join('')
            }
            return this.fromString(b, 16)
          }
          fromBN(b) {
            return this.inject(b)
          }
          fromArray(b, C) {
            return O(Array.isArray(b), 'data', 'array'), this.fromArrayLike(b, C)
          }
          fromBuffer(b, C) {
            return O(Ve.Buffer.isBuffer(b), 'data', 'buffer'), this.fromArrayLike(b, C)
          }
          fromArrayLike(b, C) {
            if (
              (C == null && (C = 'be'),
              O(b && b.length >>> 0 === b.length, 'data', 'array-like'),
              O(C === 'be' || C === 'le', 'endian', 'endianness'),
              b.length === 0)
            )
              return (this.words[0] = 0), (this.length = 1), (this.negative = 0), this
            ;(this.length = Math.max(2, Math.ceil(b.length / 3))),
              (this.words = new Array(this.length)),
              (this.negative = 0)
            for (let D = 0; D < this.length; D++) this.words[D] = 0
            let S = b.length % 3,
              R = 0,
              P = 0,
              B = 0
            if (C === 'be') {
              for (let D = b.length - 1; D >= 2; D -= 3) {
                let $ = b[D] | (b[D - 1] << 8) | (b[D - 2] << 16)
                ;(this.words[P] |= ($ << R) & 67108863),
                  (this.words[P + 1] = ($ >>> (26 - R)) & 67108863),
                  (R += 24),
                  R >= 26 && ((R -= 26), (P += 1))
              }
              switch (S) {
                case 2:
                  B = b[1] | (b[0] << 8)
                  break
                case 1:
                  B = b[0]
                  break
              }
            } else {
              let D = b.length - S
              for (let $ = 0; $ < D; $ += 3) {
                let g = b[$] | (b[$ + 1] << 8) | (b[$ + 2] << 16)
                ;(this.words[P] |= (g << R) & 67108863),
                  (this.words[P + 1] = (g >>> (26 - R)) & 67108863),
                  (R += 24),
                  R >= 26 && ((R -= 26), (P += 1))
              }
              switch (S) {
                case 2:
                  B = b[D] | (b[D + 1] << 8)
                  break
                case 1:
                  B = b[D]
                  break
              }
            }
            return (
              S > 0 && ((this.words[P] |= (B << R) & 67108863), (this.words[P + 1] = (B >>> (26 - R)) & 67108863)),
              this._strip()
            )
          }
          decode(b, C) {
            return this.fromBuffer(b, C)
          }
          from(b, C, S) {
            if (b == null) return this
            if (((C === 'le' || C === 'be') && ([C, S] = [S, C]), typeof b == 'number')) return this.fromNumber(b, S)
            if (typeof b == 'bigint') return this.fromBigInt(b, S)
            if (typeof b == 'string') return this.fromString(b, C, S)
            if (typeof b == 'object') {
              if (f.isBN(b)) return this.fromBN(b, S)
              if (b.length >>> 0 === b.length) return this.fromArrayLike(b, S)
            }
            if (typeof b == 'boolean') return this.fromBool(b)
            throw new TypeError('Non-numeric object passed to BN.')
          }
          static min(...b) {
            let C = null
            for (let S of b) O(f.isBN(S), 'num', 'bignum'), (!C || S.cmp(C) < 0) && (C = S)
            return C || new f(0)
          }
          static max(...b) {
            let C = null
            for (let S of b) O(f.isBN(S), 'num', 'bignum'), (!C || S.cmp(C) > 0) && (C = S)
            return C || new f(0)
          }
          static cmp(b, C) {
            return O(f.isBN(b), 'a', 'bignum'), b.cmp(C)
          }
          static ucmp(b, C) {
            return O(f.isBN(b), 'a', 'bignum'), b.ucmp(C)
          }
          static red(b) {
            return new v(b)
          }
          static barrett(b) {
            return new I(b)
          }
          static mont(b) {
            return new M(b)
          }
          static _prime(b) {
            if (u[b]) return u[b]
            let C
            if (b === 'p192') C = new m()
            else if (b === 'p224') C = new _()
            else if (b === 'p521') C = new A()
            else if (b === 'k256') C = new T()
            else if (b === 'p251') C = new E()
            else if (b === 'p25519') C = new k()
            else if (b === 'p448') C = new w()
            else throw new Error(`Unknown prime: "${b}".`)
            return (u[b] = C), C
          }
          static prime(b) {
            return f._prime(b).p.clone()
          }
          static pow(b, C) {
            return b === 2 ? f.shift(1, C) : new f().fromNumber(b).pown(C)
          }
          static shift(b, C) {
            return b === 1 ? new f(0).usetn(C, 1) : new f().fromNumber(b).ishln(C)
          }
          static mask(b) {
            return f.shift(1, b).isubn(1)
          }
          static randomBits(b, C) {
            if ((O(b != null, 'rng', 'rng'), O(C >>> 0 === C, 'bits', 'uint32'), typeof b == 'object')) {
              O(typeof b.randomBytes == 'function', 'rng', 'rng')
              let R = (C + 7) >>> 3,
                P = R * 8,
                B = b.randomBytes(R)
              if ((O(Ve.Buffer.isBuffer(B), 'bytes', 'buffer'), B.length !== R))
                throw new RangeError('Invalid number of bytes returned from RNG.')
              let D = f.fromBuffer(B)
              return P > C && D.iushrn(P - C), D
            }
            O(typeof b == 'function', 'rng', 'rng')
            let S = b(C)
            if ((O(f.isBN(S), 'num', 'bignum'), x(S.negative === 0, 'RNG'), K(!S.red, 'RNG'), S.bitLength() > C))
              throw new RangeError('Invalid number of bits returned from RNG.')
            return S
          }
          static random(b, C, S) {
            if (((C = f.cast(C, 16)), (S = f.cast(S, 16)), C.cmp(S) > 0))
              throw new RangeError('Minimum cannot be greater than maximum.')
            let R = S.sub(C).iabs(),
              P = R.bitLength()
            if (P === 0) return C.clone()
            for (;;) {
              let B = f.randomBits(b, P)
              if (!(B.cmp(R) >= 0)) return B.iadd(C), B
            }
          }
          static of(b, C) {
            return new f().of(b, C)
          }
          static fromNumber(b, C) {
            return new f().fromNumber(b, C)
          }
          static fromDouble(b, C) {
            return new f().fromDouble(b, C)
          }
          static fromBigInt(b, C) {
            return new f().fromBigInt(b, C)
          }
          static fromBool(b) {
            return new f().fromBool(b)
          }
          static fromString(b, C, S) {
            return new f().fromString(b, C, S)
          }
          static fromJSON(b) {
            return new f().fromJSON(b)
          }
          static fromBN(b) {
            return new f().fromBN(b)
          }
          static fromArray(b, C) {
            return new f().fromArray(b, C)
          }
          static fromBuffer(b, C) {
            return new f().fromBuffer(b, C)
          }
          static fromArrayLike(b, C) {
            return new f().fromArrayLike(b, C)
          }
          static decode(b, C) {
            return new f().decode(b, C)
          }
          static from(b, C, S) {
            return new f().from(b, C, S)
          }
          static cast(b, C, S) {
            return f.isBN(b) ? b : new f(b, C, S)
          }
          static isBN(b) {
            return b instanceof f
          }
        }
      ;(f.BN = f), (f.wordSize = 26), (f.native = 0)
      var p = class {
          constructor(b, C) {
            ;(this.name = b),
              (this.p = new f(C, 16)),
              (this.n = this.p.bitLength()),
              (this.k = f.shift(1, this.n).isub(this.p)),
              (this.lo = this.p.clone()),
              (this.one = this.p.clone())
          }
          ireduce(b) {
            let C = b.negative !== 0,
              S = b.bitLength()
            for (G(S <= this.n * 2), b.negative = 0; S > this.n; )
              this.split(b, this.lo), this.imulK(b), b._iadd(b, this.lo), (S = b.bitLength())
            let R = S < this.n ? -1 : b.ucmp(this.p)
            return (
              R === 0 ? ((b.words[0] = 0), (b.length = 1)) : R > 0 && b._isub(b, this.p),
              C && !b.isZero() && b._isub(this.p, b),
              b
            )
          }
          split(b, C) {
            b._split(this.n, C)
          }
          imulK(b) {
            return b.imul(this.k)
          }
          pm2(b) {
            throw new Error('Not implemented.')
          }
          fermat(b) {
            return this.pm2(b)
          }
        },
        y = class extends p {
          constructor(b, C) {
            super(b, C)
          }
          pm3d4(b) {
            throw new Error('Not implemented.')
          }
          pp1d4(b) {
            throw new Error('Not implemented.')
          }
          sqrt(b) {
            let { red: C } = b,
              S = this.pp1d4(b)
            if (!C.sqr(S).eq(b)) throw new Z(S)
            return S
          }
          divsqrt(b, C) {
            let { red: S } = b,
              R = S.sqr(b),
              P = S.mul(R, b),
              B = S.mul(P, R),
              D = S.mul(S.sqr(C), C),
              $ = this.pm3d4(S.mul(B, D)),
              g = S.mul(S.mul(P, C), $)
            if (S.mul(C, S.sqr(g)).eq(b)) return g
            throw new Z(g)
          }
        },
        d = class extends p {
          constructor(b, C, S) {
            super(b, C)
            this.sm1 = new f(S, 16)
          }
          pm5d8(b) {
            throw new Error('Not implemented.')
          }
          pp3d8(b) {
            throw new Error('Not implemented.')
          }
          sqrt(b) {
            let { red: C } = b,
              S = this.sm1._forceRed(C),
              R = this.pp3d8(b)
            if (C.sqr(R).eq(b)) return R
            let P = C.mul(R, S)
            if (C.sqr(P).eq(b)) return P
            throw new Z(R)
          }
          divsqrt(b, C) {
            let { red: S } = b,
              R = this.sm1._forceRed(S),
              P = S.mul(S.sqr(C), C),
              B = S.mul(S.sqr(P), C),
              D = this.pm5d8(S.mul(b, B)),
              $ = S.mul(S.mul(b, P), D),
              g = S.mul(C, S.sqr($))
            if (g.eq(b)) return $
            let N = S.ineg(g)
            if (N.eq(b)) return S.mul($, R)
            throw N.eq(S.mul(b, R)) ? new Z(S.mul($, R)) : new Z($)
          }
        },
        h = class extends p {
          constructor(b, C, S) {
            super(b, C)
            ;(this.g = new f(S, 16)), (this.z = this.p.subn(1).zeroBits())
          }
          powS(b) {
            throw new Error('Not implemented.')
          }
          powE(b) {
            throw new Error('Not implemented.')
          }
          sqrt(b) {
            let { red: C } = b
            switch (C.jacobi(b)) {
              case -1:
                throw new Z(b)
              case 0:
                return b.clone()
              case 1:
                break
            }
            let S = this.g._forceRed(C),
              R = this.powE(b),
              P = this.powS(b),
              B = this.z
            for (;;) {
              let D = P,
                $ = 0
              for (; D.cmpn(1) !== 0 && $ < B; ) (D = C.sqr(D)), ($ += 1)
              if ($ === 0) break
              G($ < B), (D = C.sqrn(S, B - $ - 1)), (S = C.sqr(D)), (R = C.mul(R, D)), (P = C.mul(P, S)), (B = $)
            }
            return R
          }
          divsqrt(b, C) {
            let { red: S } = b
            if (C.isZero()) throw new Z(C)
            return this.sqrt(S.div(b, C))
          }
        },
        m = class extends y {
          constructor() {
            super('p192', 'ffffffff ffffffff ffffffff fffffffeffffffff ffffffff')
          }
          imulK(b) {
            let C = this.one.inject(b)
            return b.iushln(64)._iadd(b, C)
          }
          core(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = C.sqrnmul(S, 1, b),
              P = C.sqrnmul(R, 3, R),
              B = C.sqrnmul(P, 6, P),
              D = C.sqrnmul(B, 12, B),
              $ = C.sqrnmul(D, 6, P),
              g = C.sqrnmul($, 1, b),
              N = C.sqrnmul(g, 31, g),
              U = C.sqrnmul(N, 62, N),
              X = C.sqrnmul(U, 3, R),
              ne = C.sqrn(X, 1)
            return C.sqrnmul(ne, 62, N)
          }
          pm3d4(b) {
            return this.core(b)
          }
          pm2(b) {
            let { red: C } = b,
              S = this.core(b),
              R = C.sqrn(S, 1)
            return C.sqrnmul(R, 1, b)
          }
          pp1d4(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = C.sqrnmul(S, 2, S),
              P = C.sqrnmul(R, 4, R),
              B = C.sqrnmul(P, 8, P),
              D = C.sqrnmul(B, 16, B),
              $ = C.sqrnmul(D, 32, D),
              g = C.sqrnmul($, 64, $)
            return C.sqrn(g, 62)
          }
        },
        _ = class extends h {
          constructor() {
            super(
              'p224',
              'ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001',
              '6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74'
            )
          }
          imulK(b) {
            let C = this.one.inject(b)
            return b.iushln(96)._isub(b, C)
          }
          powS(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = C.sqrnmul(S, 2, S),
              P = C.sqrnmul(R, 4, R),
              B = C.sqrnmul(P, 8, P),
              D = C.sqrnmul(B, 16, B),
              $ = C.sqrnmul(D, 32, D)
            return C.sqrnmul($, 64, $)
          }
          powE(b) {
            let { red: C } = b
            return C.sqrn(b, 127)
          }
          pm2(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = C.sqrnmul(S, 1, b),
              P = C.sqrnmul(R, 3, R),
              B = C.sqrnmul(P, 6, P),
              D = C.sqrnmul(B, 12, B),
              $ = C.sqrnmul(D, 24, D),
              g = C.sqrnmul($, 48, $),
              N = C.sqrnmul(g, 24, D),
              U = C.sqrnmul(N, 6, P),
              X = C.sqrnmul(U, 1, b),
              ne = C.sqrn(X, 1)
            return C.sqrnmul(ne, 96, g)
          }
        },
        A = class extends y {
          constructor() {
            super(
              'p521',
              '000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff'
            )
          }
          imulK(b) {
            return b
          }
          core(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = C.sqrnmul(S, 1, b),
              P = C.sqrnmul(R, 3, R),
              B = C.sqrnmul(P, 1, b),
              D = C.sqrnmul(B, 1, b),
              $ = C.sqrnmul(D, 8, D),
              g = C.sqrnmul($, 16, $),
              N = C.sqrnmul(g, 32, g),
              U = C.sqrnmul(N, 64, N),
              X = C.sqrnmul(U, 128, U),
              ne = C.sqrnmul(X, 256, X)
            return C.sqrnmul(ne, 7, B)
          }
          pm3d4(b) {
            return this.core(b)
          }
          pm2(b) {
            let { red: C } = b,
              S = this.core(b),
              R = C.sqrn(S, 1)
            return C.sqrnmul(R, 1, b)
          }
          pp1d4(b) {
            let { red: C } = b
            return C.sqrn(b, 519)
          }
        },
        T = class extends y {
          constructor() {
            super('k256', 'ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f')
          }
          split(b, C) {
            let S = 4194303,
              R = Math.min(b.length, 9)
            C._alloc(R + 1)
            for (let D = 0; D < R; D++) C.words[D] = b.words[D]
            if (((C.length = R), b.length <= 9)) {
              C._strip(), (b.words[0] = 0), (b.length = 1)
              return
            }
            let P = b.words[9],
              B = 10
            for (C.words[C.length++] = P & S, C._strip(); B < b.length; B++) {
              let D = b.words[B] | 0
              ;(b.words[B - 10] = ((D & S) << 4) | (P >>> 22)), (P = D)
            }
            ;(P >>>= 22),
              (b.words[B - 10] = P),
              P === 0 && b.length > 10 ? (b.length -= 10) : (b.length -= 9),
              b._strip()
          }
          imulK(b) {
            b._expand(b.length + 2)
            let C = 0
            for (let S = 0; S < b.length; S++) {
              let R = b.words[S]
              ;(C += R * 977), (b.words[S] = C & 67108863), (C = R * 64 + Math.floor(C / 67108864))
            }
            return b.words[b.length - 1] === 0 && ((b.length -= 1), b.words[b.length - 1] === 0 && (b.length -= 1)), b
          }
          core(b, C) {
            let { red: S } = b,
              R = S.sqrnmul(C, 1, b),
              P = S.sqrnmul(R, 3, R),
              B = S.sqrnmul(P, 3, R),
              D = S.sqrnmul(B, 2, C),
              $ = S.sqrnmul(D, 11, D),
              g = S.sqrnmul($, 22, $),
              N = S.sqrnmul(g, 44, g),
              U = S.sqrnmul(N, 88, N),
              X = S.sqrnmul(U, 44, g),
              ne = S.sqrnmul(X, 3, R),
              ee = S.sqrn(ne, 1),
              ae = S.sqrnmul(ee, 22, $)
            return S.sqrn(ae, 4)
          }
          pm3d4(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrnmul(R, 1, b),
              B = C.sqrn(P, 1)
            return C.sqrnmul(B, 2, S)
          }
          pm2(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrnmul(R, 1, b),
              B = C.sqrn(P, 1),
              D = C.sqrnmul(B, 2, S),
              $ = C.sqrn(D, 1)
            return C.sqrnmul($, 1, b)
          }
          pp1d4(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrnmul(R, 2, S)
            return C.sqrn(P, 2)
          }
        },
        E = class extends y {
          constructor() {
            super('p251', '07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7')
          }
          imulK(b) {
            if (b.isZero()) return b
            let C = 0
            for (let S = 0; S < b.length; S++) {
              let R = b.words[S] * 9 + C
              ;(C = R >>> 26), (b.words[S] = R & 67108863)
            }
            return C !== 0 && (b._alloc(b.length + 1), (b.words[b.length++] = C)), b
          }
          core(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = C.sqrnmul(S, 1, b),
              P = C.sqrnmul(R, 3, R),
              B = C.sqrnmul(P, 6, P),
              D = C.sqrnmul(B, 12, B),
              $ = C.sqrnmul(D, 24, D),
              g = C.sqrnmul($, 48, $),
              N = C.sqrnmul(g, 96, g),
              U = C.sqrnmul(N, 48, $),
              X = C.sqrnmul(U, 6, P)
            return C.sqrnmul(X, 1, b)
          }
          pm3d4(b) {
            let { red: C } = b,
              S = this.core(b),
              R = C.sqrn(S, 1)
            return C.sqrnmul(R, 1, b)
          }
          pm2(b) {
            let { red: C } = b,
              S = this.core(b),
              R = C.sqrn(S, 1),
              P = C.sqrnmul(R, 1, b),
              B = C.sqrn(P, 1)
            return C.sqrnmul(B, 1, b)
          }
          pp1d4(b) {
            let { red: C } = b,
              S = this.core(b),
              R = C.sqrnmul(S, 1, b)
            return C.sqrn(R, 1)
          }
        },
        k = class extends d {
          constructor() {
            super(
              'p25519',
              '7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed',
              '2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0'
            )
          }
          imulK(b) {
            let C = 0
            for (let S = 0; S < b.length; S++) {
              let R = b.words[S] * 19 + C
              ;(C = R >>> 26), (b.words[S] = R & 67108863)
            }
            return C !== 0 && (b._alloc(b.length + 1), (b.words[b.length++] = C)), b
          }
          core(b, C) {
            let { red: S } = b,
              R = S.sqrnmul(C, 2, C),
              P = S.sqrnmul(R, 1, b),
              B = S.sqrnmul(P, 5, P),
              D = S.sqrnmul(B, 10, B),
              $ = S.sqrnmul(D, 20, D),
              g = S.sqrnmul($, 10, B),
              N = S.sqrnmul(g, 50, g),
              U = S.sqrnmul(N, 100, N)
            return S.sqrnmul(U, 50, g)
          }
          pm5d8(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrn(R, 1)
            return C.sqrnmul(P, 1, b)
          }
          pm2(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrn(R, 1),
              B = C.sqrnmul(P, 1, b),
              D = C.sqrn(B, 1)
            return C.sqrnmul(D, 2, S)
          }
          pp3d8(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrnmul(R, 1, b)
            return C.sqrn(P, 1)
          }
        },
        w = class extends y {
          constructor() {
            super(
              'p448',
              'ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff'
            )
          }
          imulK(b) {
            let C = this.one.inject(b)
            return b.iushln(224)._iadd(b, C)
          }
          core(b, C) {
            let { red: S } = b,
              R = S.sqrnmul(C, 1, b),
              P = S.sqrnmul(R, 3, R),
              B = S.sqrnmul(P, 3, R),
              D = S.sqrnmul(B, 2, C),
              $ = S.sqrnmul(D, 11, D),
              g = S.sqrnmul($, 22, $),
              N = S.sqrnmul(g, 44, g),
              U = S.sqrnmul(N, 88, N),
              X = S.sqrnmul(U, 44, g)
            return S.sqrnmul(X, 2, C)
          }
          pm3d4(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrnmul(R, 1, b),
              B = C.sqrn(P, 1)
            return C.sqrnmul(B, 222, R)
          }
          pm2(b) {
            let { red: C } = b,
              S = this.pm3d4(b),
              R = C.sqrn(S, 1)
            return C.sqrnmul(R, 1, b)
          }
          pp1d4(b) {
            let { red: C } = b,
              S = C.sqrnmul(b, 1, b),
              R = this.core(b, S),
              P = C.sqrnmul(R, 2, S)
            return C.sqrn(P, 222)
          }
        },
        v = class {
          constructor(b) {
            let C = null
            typeof b == 'string' && ((C = f._prime(b)), (b = C.p)),
              O(f.isBN(b), 'm', 'bignum'),
              K(!b.red, 'reduction'),
              x(b.sign() > 0, 'reduction'),
              (this.m = b),
              (this.prime = C),
              (this.mb = null),
              (this.sm1 = null)
          }
          _verify1(b) {
            x(b.negative === 0, 'red'), L(b.red != null, 'red')
          }
          _verify2(b, C) {
            x((b.negative | C.negative) == 0, 'red'), L(b.red != null && b.red === C.red, 'red')
          }
          get mont() {
            return !1
          }
          precompute() {
            if (this.sm1 === null && this.m.andln(7) === 5)
              if (this.prime) this.sm1 = this.prime.sm1.clone()._forceRed(this)
              else {
                let b = new f(2).toRed(this),
                  C = this.m.subn(1).iushrn(2)
                this.sm1 = this.pow(b, C)
              }
            return this
          }
          convertTo(b) {
            let C = b.mod(this.m)
            return (C.red = this), C
          }
          convertFrom(b) {
            let C = b.clone()
            return (C.red = null), C
          }
          intTo(b) {
            return b
          }
          intFrom(b) {
            return b
          }
          imod(b) {
            return this.prime ? this.prime.ireduce(b)._forceRed(this) : b.imod(this.m)._forceRed(this)
          }
          iadd(b, C) {
            return this._verify2(b, C), b._iadd(b, C), b.ucmp(this.m) >= 0 && b._isub(b, this.m), b
          }
          add(b, C) {
            return b.length < C.length ? this.iadd(C.clone(), b) : this.iadd(b.clone(), C)
          }
          iaddn(b, C) {
            return (
              this._verify1(b),
              C < 0
                ? this.isubn(b, -C)
                : (this.m.length === 1 && (C %= this.m.words[0]),
                  b._iaddn(C),
                  b.ucmp(this.m) >= 0 && b._isub(b, this.m),
                  b)
            )
          }
          addn(b, C) {
            return this.iaddn(b.clone(), C)
          }
          isub(b, C) {
            this._verify2(b, C)
            let S = b.ucmp(C)
            return S === 0
              ? ((b.words[0] = 0), (b.length = 1), b)
              : (S < 0 ? (b._isub(C, b), b._isub(this.m, b)) : b._isub(b, C), b)
          }
          sub(b, C) {
            return this.isub(b.clone(), C)
          }
          isubn(b, C) {
            return (
              this._verify1(b),
              C < 0
                ? this.iaddn(b, -C)
                : (this.m.length === 1 && (C %= this.m.words[0]),
                  b.length === 1 && b.words[0] < C ? ((b.words[0] = C - b.words[0]), b._isub(this.m, b)) : b._isubn(C),
                  b)
            )
          }
          subn(b, C) {
            return this.isubn(b.clone(), C)
          }
          imul(b, C) {
            return this._verify2(b, C), this.imod(b.imul(C))
          }
          mul(b, C) {
            return this._verify2(b, C), this.imod(b.mul(C))
          }
          imuln(b, C) {
            if ((this._verify1(b), b.isZero())) return b
            if (C === 0) return (b.words[0] = 0), (b.length = 1), b
            let S = C < 0
            if ((S && (C = -C), this.m.length === 1 && (C %= this.m.words[0]), b.imuln(C), C <= 16))
              for (; b.ucmp(this.m) >= 0; ) b._isub(b, this.m)
            else this.imod(b)
            return S && this.ineg(b), b
          }
          muln(b, C) {
            return this.imuln(b.clone(), C)
          }
          idiv(b, C) {
            return this.div(b, C)._move(b)
          }
          div(b, C) {
            return this.mul(b, this.invert(C))
          }
          idivn(b, C) {
            return this.divn(b, C)._move(b)
          }
          divn(b, C) {
            return this.div(b, this.convertTo(new f(C)))
          }
          ipow(b, C) {
            return this.pow(b, C)._move(b)
          }
          pow(b, C) {
            return (
              this._verify1(b),
              C.isNeg() && (b = this.invert(b)),
              C.length === 1 ? this.pown(b, C.words[0]) : c && !this.prime ? this.powInt(b, C) : this.powNum(b, C)
            )
          }
          powNum(b, C) {
            let S = new f(1).toRed(this),
              R = new Array(a),
              P = this.sqr(b)
            R[0] = b
            for (let $ = 1; $ < a; $++) R[$] = this.mul(R[$ - 1], P)
            let B = C.bitLength(),
              D = S
            for (; B >= l; ) {
              let $ = l,
                g = C.bits(B - $, $)
              if (g < a) {
                ;(D = this.sqr(D)), (B -= 1)
                continue
              }
              for (; (g & 1) == 0; ) ($ -= 1), (g >>= 1)
              D === S ? (D = R[g >> 1].clone()) : ((D = this.sqrn(D, $)), (D = this.mul(D, R[g >> 1]))), (B -= $)
            }
            if (B > 0) {
              let $ = C.bits(0, B)
              for (; B--; ) (D = this.sqr(D)), ($ >> B) & 1 && (D = this.mul(D, b))
            }
            return D
          }
          powInt(b, C) {
            this.mb === null && (this.mb = this.m.toBigInt())
            let S = this.intFrom(b.toBigInt()),
              R = ke(S, C, this.mb),
              P = this.intTo(R)
            return f.fromBigInt(P)._forceRed(this)
          }
          sqrn(b, C) {
            for (; C--; ) b = this.sqr(b)
            return b
          }
          sqrnmul(b, C, S) {
            return this.mul(this.sqrn(b, C), S)
          }
          ipown(b, C) {
            return this.pown(b, C)._move(b)
          }
          pown(b, C) {
            if ((this._verify1(b), C < 0 && ((b = this.invert(b)), (C = -C)), C === 0)) return new f(1).toRed(this)
            if (C === 1) return b.clone()
            let S = le(C),
              R = b
            for (let P = S - 2; P >= 0; P--) (R = this.sqr(R)), (C >> P) & 1 && (R = this.mul(R, b))
            return R
          }
          isqr(b) {
            return this.imul(b, b)
          }
          sqr(b) {
            return this.mul(b, b)
          }
          isqrt(b) {
            return this.sqrt(b)._move(b)
          }
          sqrt(b) {
            return (
              this._verify1(b),
              this.prime
                ? this.prime.sqrt(b)
                : this.m.andln(3) === 3
                ? this.sqrt3mod4(b)
                : this.m.andln(7) === 5
                ? this.sm1 != null
                  ? this.sqrt5mod8sm1(b)
                  : this.sqrt5mod8(b)
                : this.sqrt0(b)
            )
          }
          sqrt3mod4(b) {
            let C = this.m.addn(1).iushrn(2),
              S = this.pow(b, C)
            if (!this.sqr(S).eq(b)) throw new Z(S)
            return S
          }
          sqrt5mod8(b) {
            let C = new f(1).toRed(this),
              S = this.m.ushrn(3),
              R = this.add(b, b),
              P = this.pow(R, S),
              B = this.mul(R, this.sqr(P)),
              D = this.mul(this.mul(P, b), this.isub(B, C))
            if (!this.sqr(D).eq(b)) throw new Z(D)
            return D
          }
          sqrt5mod8sm1(b) {
            let C = this.m.addn(3).iushrn(3),
              S = this.pow(b, C)
            if (this.sqr(S).eq(b)) return S
            let R = this.mul(S, this.sm1)
            if (this.sqr(R).eq(b)) return R
            throw new Z(S)
          }
          sqrt0(b) {
            if (this.m.cmpn(1) === 0 || !this.m.isOdd()) throw new Error('Invalid prime.')
            switch (this.jacobi(b)) {
              case -1:
                throw new Z(b)
              case 0:
                return b.clone()
              case 1:
                break
            }
            let C = new f(1).toRed(this),
              S = this.m.subn(1),
              R = S._makeOdd(),
              P = new f(2).toRed(this)
            for (; this.jacobi(P) !== -1; ) this.iadd(P, C)
            let B = this.pow(P, S),
              D = this.pow(b, S),
              $ = this.pow(b, S.iaddn(1).iushrn(1)),
              g = R
            for (;;) {
              let N = D,
                U = 0
              for (; !N.eq(C) && U < g; ) (N = this.sqr(N)), (U += 1)
              if (U === 0) break
              G(U < g),
                (N = this.sqrn(B, g - U - 1)),
                (B = this.sqr(N)),
                ($ = this.mul($, N)),
                (D = this.mul(D, B)),
                (g = U)
            }
            return $
          }
          idivsqrt(b, C) {
            return this.divsqrt(b, C)._move(b)
          }
          divsqrt(b, C) {
            if ((this._verify2(b, C), b.isZero() && C.isZero())) throw new Z(C)
            if (this.prime) return this.prime.divsqrt(b, C)
            if (this.m.andln(3) === 3) return this.divsqrt3mod4(b, C)
            if (this.sm1 != null && this.m.andln(7) === 5) return this.divsqrt5mod8(b, C)
            if (C.isZero()) throw new Z(C)
            return this.sqrt(this.div(b, C))
          }
          divsqrt3mod4(b, C) {
            let S = this.m.subn(3).iushrn(2),
              R = this.sqr(b),
              P = this.mul(R, b),
              B = this.mul(P, R),
              D = this.mul(this.sqr(C), C),
              $ = this.pow(this.mul(B, D), S),
              g = this.mul(this.mul(P, C), $)
            if (this.mul(C, this.sqr(g)).eq(b)) return g
            throw new Z(g)
          }
          divsqrt5mod8(b, C) {
            let S = this.m.subn(5).iushrn(3),
              R = this.mul(this.sqr(C), C),
              P = this.mul(this.sqr(R), C),
              B = this.pow(this.mul(b, P), S),
              D = this.mul(this.mul(b, R), B),
              $ = this.mul(C, this.sqr(D))
            if ($.eq(b)) return D
            let g = this.ineg($)
            if (g.eq(b)) return this.mul(D, this.sm1)
            throw g.eq(this.mul(b, this.sm1)) ? new Z(this.mul(D, this.sm1)) : new Z(D)
          }
          isSquare(b) {
            return this.m.isOdd() ? this.jacobi(b) >= 0 : this.kronecker(b) >= 0
          }
          ishl(b, C) {
            return this._verify1(b), this.imod(b.iushl(C))
          }
          shl(b, C) {
            return this.ishl(b.clone(), C)
          }
          ishln(b, C) {
            if ((this._verify1(b), b.iushln(C), C <= 4)) for (; b.ucmp(this.m) >= 0; ) b._isub(b, this.m)
            else this.imod(b)
            return b
          }
          shln(b, C) {
            return this.ishln(b.clone(), C)
          }
          ineg(b) {
            return this._verify1(b), b.isZero() || b._isub(this.m, b), b
          }
          neg(b) {
            return this.ineg(b.clone())
          }
          eq(b, C) {
            return this._verify2(b, C), b.ucmp(C) === 0
          }
          eqn(b, C) {
            if ((this._verify1(b), this.m.length === 1))
              return (C %= this.m.words[0]), C < 0 && (C += this.m.words[0]), b.ucmpn(C) === 0
            if (C < 0) {
              this.m._isubn(-C)
              let S = b.ucmp(this.m)
              return this.m._iaddn(-C), S === 0
            }
            return b.ucmpn(C) === 0
          }
          isHigh(b) {
            return !this.isLow(b)
          }
          isLow(b) {
            return this._verify1(b), b.ucmp(this.m.ushrn(1)) <= 0
          }
          isOdd(b) {
            return this._verify1(b), b.isOdd()
          }
          isEven(b) {
            return this._verify1(b), b.isEven()
          }
          legendre(b) {
            if ((this._verify1(b), this.m.isEven())) throw new Error('legendre: `num` must be odd.')
            let C = this.m.subn(1).iushrn(1),
              S = this.pow(b, C)
            if (S.isZero()) return 0
            let R = new f(1).toRed(this)
            if (S.eq(R)) return 1
            if (S.eq(this.ineg(R))) return -1
            throw new Error('Invalid prime.')
          }
          jacobi(b) {
            return this._verify1(b), b.jacobi(this.m)
          }
          kronecker(b) {
            return this._verify1(b), b.kronecker(this.m)
          }
          iinvert(b) {
            return this.invert(b)._move(b)
          }
          invert(b) {
            return this._verify1(b), b.invert(this.m)._forceRed(this)
          }
          ifermat(b) {
            return this.fermat(b)._move(b)
          }
          fermat(b) {
            if ((this._verify1(b), b.isZero() || this.m.cmpn(1) === 0)) throw new RangeError('Not invertible.')
            return this.prime ? this.prime.fermat(b) : this.pow(b, this.m.subn(2))
          }
          invertAll(b) {
            O(Array.isArray(b), 'elems', 'array')
            for (let P of b) O(f.isBN(P), 'elem', 'bignum'), this._verify1(P)
            if (this.m.cmpn(1) === 0 || this.m.isEven()) throw new RangeError('Not invertible.')
            let C = b.length,
              S = new Array(C)
            if (C === 0) return S
            let R = new f(1).toRed(this)
            for (let P = 0; P < C; P++) {
              if (b[P].isZero()) {
                S[P] = b[P].clone()
                continue
              }
              ;(S[P] = R), (R = this.mul(R, b[P]))
            }
            R = this.invert(R)
            for (let P = C - 1; P >= 0; P--) b[P].isZero() || ((S[P] = this.mul(R, S[P])), (R = this.mul(R, b[P])))
            return S
          }
          [t]() {
            return this.prime ? `<Red: ${this.prime.name}>` : `<Red: ${this.m.toString(10)}>`
          }
        },
        I = class extends v {
          constructor(b) {
            super(b)
            ;(this.prime = null),
              (this.n = this.m.bitLength()),
              this.n % 26 != 0 && (this.n += 26 - (this.n % 26)),
              (this.k = this.n * 2),
              (this.w = this.k / 26),
              (this.b = f.shift(1, this.k).div(this.m))
          }
          convertTo(b) {
            return b.length > this.w ? super.convertTo(b) : this.imod(b.clone())
          }
          _shift(b) {
            let C = 0,
              S = this.w
            for (; S < b.length; ) b.words[C++] = b.words[S++]
            C === 0 && (b.words[C++] = 0), (b.length = C)
          }
          imod(b) {
            let C = b.negative
            G(b.length <= this.w), (b.negative = 0)
            let S = b.mul(this.b)
            return (
              this._shift(S),
              b._isub(b, S.mul(this.m)),
              b.ucmp(this.m) >= 0 && b._isub(b, this.m),
              C && !b.isZero() && b._isub(this.m, b),
              (b.red = this),
              b
            )
          }
        },
        M = class extends v {
          constructor(b) {
            super(b)
            ;(this.prime = null),
              (this.n = this.m.length * 26),
              (this.r = f.shift(1, this.n)),
              (this.r2 = f.shift(1, this.n * 2).imod(this.m)),
              (this.ri = this.r.invert(this.m)),
              (this.mi = this.r.mul(this.ri).isubn(1).div(this.m)),
              (this.rib = null)
          }
          get mont() {
            return !0
          }
          convertTo(b) {
            return b.isNeg() || b.ucmp(this.m) >= 0 ? this.imod(b.ushln(this.n)) : this.mul(b, this.r2)
          }
          convertFrom(b) {
            let C = this.mul(b, new f(1))
            return (C.red = null), C
          }
          intTo(b) {
            return (b << BigInt(this.n)) % this.mb
          }
          intFrom(b) {
            return this.rib === null && (this.rib = this.ri.toBigInt()), (b * this.rib) % this.mb
          }
          iaddn(b, C) {
            return this.iadd(b, this.convertTo(new f(C)))
          }
          isubn(b, C) {
            return this.isub(b, this.convertTo(new f(C)))
          }
          imul(b, C) {
            return this.mul(b, C)._move(b)
          }
          mul(b, C) {
            if (b.isZero() || C.isZero()) return new f(0)._forceRed(this)
            let S = b.mul(C),
              R = S.umaskn(this.n).mul(this.mi).iumaskn(this.n),
              P = S.iadd(R.mul(this.m)).iushrn(this.n)
            return P.ucmp(this.m) >= 0 && P._isub(P, this.m), P._forceRed(this)
          }
          imuln(b, C) {
            if ((this._verify1(b), b.isZero())) return b
            if (C === 0) return (b.words[0] = 0), (b.length = 1), b
            let S = C < 0
            S && (C = -C), this.m.length === 1 && (C %= this.m.words[0])
            let R = le(C)
            if (R > 5) this.imul(b, this.convertTo(new f(C)))
            else if ((C & (C - 1)) == 0) for (let P = 0; P < R - 1; P++) this.iadd(b, b)
            else {
              let P = b.clone()
              for (let B = R - 2; B >= 0; B--) this.iadd(b, b), (C >> B) & 1 && this.iadd(b, P)
            }
            return S && this.ineg(b), b
          }
          eqn(b, C) {
            return this._verify1(b), C === 0 ? b.isZero() : b.ucmp(this.convertTo(new f(C))) === 0
          }
          isLow(b) {
            return this._verify1(b), this.convertFrom(b).ucmp(this.m.ushrn(1)) <= 0
          }
          isOdd(b) {
            return this._verify1(b), this.convertFrom(b).isOdd()
          }
          isEven(b) {
            return this._verify1(b), this.convertFrom(b).isEven()
          }
          invert(b) {
            return this._verify1(b), this.imod(b.invert(this.m).mul(this.r2))
          }
        }
      function q(b, C, S) {
        let R = new b(C)
        return b.captureStackTrace && b.captureStackTrace(R, S), R
      }
      function G(b, C) {
        if (!b) throw q(Error, C || 'Assertion failed.', G)
      }
      function O(b, C, S) {
        if (!b) {
          let R = `"${C}" must be a(n) ${S}.`
          throw q(TypeError, R, O)
        }
      }
      function x(b, C) {
        if (!b) {
          let S = `"${C}" only works with positive numbers.`
          throw q(RangeError, S, x)
        }
      }
      function L(b, C) {
        if (!b) {
          let S = `"${C}" only works with red numbers.`
          throw q(TypeError, S, L)
        }
      }
      function K(b, C) {
        if (!b) {
          let S = `"${C}" only works with normal numbers.`
          throw q(TypeError, S, K)
        }
      }
      function J(b) {
        if (!b) throw q(RangeError, 'Cannot divide by zero.', J)
      }
      var Z = class extends Error {
        constructor(b) {
          super()
          ;(this.name = 'SquareRootError'),
            (this.message = 'X is not a square mod P.'),
            (this.result = b.fromRed()),
            Error.captureStackTrace && Error.captureStackTrace(this, Z)
        }
      }
      function Q(b) {
        return Number.isSafeInteger(b)
      }
      function fe(b) {
        return Q(b) && b >= -67108863 && b <= 67108863
      }
      function ie(b, C) {
        return b.allocUnsafeSlow ? b.allocUnsafeSlow(C) : new b(C)
      }
      function W(b) {
        if (b == null) return 10
        if (typeof b == 'number') return b
        switch (b) {
          case 'bin':
            return 2
          case 'oct':
            return 8
          case 'dec':
            return 10
          case 'hex':
            return 16
        }
        return 0
      }
      function le(b) {
        if (Math.clz32) return 32 - Math.clz32(b)
        let C = b,
          S = 0
        return (
          C >= 4096 && ((S += 13), (C >>>= 13)),
          C >= 64 && ((S += 7), (C >>>= 7)),
          C >= 8 && ((S += 4), (C >>>= 4)),
          C >= 2 && ((S += 2), (C >>>= 2)),
          S + C
        )
      }
      function xe(b) {
        if (b === 0) return 26
        let C = b,
          S = 0
        return (
          (C & 8191) == 0 && ((S += 13), (C >>>= 13)),
          (C & 127) == 0 && ((S += 7), (C >>>= 7)),
          (C & 15) == 0 && ((S += 4), (C >>>= 4)),
          (C & 3) == 0 && ((S += 2), (C >>>= 2)),
          (C & 1) == 0 && (S += 1),
          S
        )
      }
      function _e(b, C, S) {
        let R = Math.min(b.length, S),
          P = 0,
          B = 0
        for (let D = C; D < R; D++) {
          let $ = b.charCodeAt(D) - 48
          P <<= 4
          let g
          $ >= 49 && $ <= 54 ? (g = $ - 49 + 10) : $ >= 17 && $ <= 22 ? (g = $ - 17 + 10) : (g = $), (P |= g), (B |= g)
        }
        if (B & ~15) throw new Error('Invalid string.')
        return P
      }
      function Ne(b, C, S, R) {
        let P = Math.min(b.length, S),
          B = 0
        for (let D = C; D < P; D++) {
          let $ = b.charCodeAt(D) - 48
          B *= R
          let g
          if (($ >= 49 ? (g = $ - 49 + 10) : $ >= 17 ? (g = $ - 17 + 10) : (g = $), $ < 0 || $ > 207 || g >= R))
            throw new Error('Invalid string.')
          B += g
        }
        return B
      }
      function ke(b, C, S) {
        let R = BigInt(1),
          P = new Array(a),
          B = (b * b) % S
        P[0] = b
        for (let g = 1; g < a; g++) P[g] = (P[g - 1] * B) % S
        let D = C.bitLength(),
          $ = R
        for (; D >= l; ) {
          let g = l,
            N = C.bits(D - g, g)
          if (N < a) {
            ;($ = ($ * $) % S), (D -= 1)
            continue
          }
          for (; (N & 1) == 0; ) (g -= 1), (N >>= 1)
          $ === R ? ($ = P[N >> 1]) : (($ = oe($, g, S)), ($ = ($ * P[N >> 1]) % S)), (D -= g)
        }
        if (D > 0) {
          let g = C.bits(0, D)
          for (; D--; ) ($ = ($ * $) % S), (g >> D) & 1 && ($ = ($ * b) % S)
        }
        return $
      }
      function oe(b, C, S) {
        for (let R = 0; R < C; R++) b = (b * b) % S
        return b
      }
      function be(b, C, S) {
        let R = b.length + C.length
        ;(S.negative = b.negative ^ C.negative), S._alloc(R), (S.length = R)
        let P = b.words[0],
          B = C.words[0],
          D = P * B,
          $ = D & 67108863,
          g = (D / 67108864) | 0,
          N = 1
        for (S.words[0] = $; N < S.length - 1; N++) {
          let U = g >>> 26,
            X = g & 67108863,
            ne = Math.max(0, N - b.length + 1),
            ee = Math.min(N, C.length - 1)
          for (let ae = ne; ae <= ee; ae++) {
            let Y = N - ae,
              z = b.words[Y],
              H = C.words[ae],
              se = z * H + X
            ;(U += (se / 67108864) | 0), (X = se & 67108863)
          }
          ;(S.words[N] = X | 0), (g = U | 0)
        }
        return g !== 0 ? (S.words[N] = g | 0) : (S.length -= 1), S._strip()
      }
      function ge(b, C, S) {
        let R = b.length + C.length
        ;(S.negative = b.negative ^ C.negative), S._alloc(R), (S.length = R)
        let P = 0,
          B = 0,
          D = 0
        for (; D < S.length - 1; D++) {
          let $ = B
          B = 0
          let g = P & 67108863,
            N = Math.max(0, D - b.length + 1),
            U = Math.min(D, C.length - 1)
          for (let X = N; X <= U; X++) {
            let ne = D - X,
              ee = b.words[ne],
              ae = C.words[X],
              Y = ee * ae,
              z = Y & 67108863
            ;($ = ($ + ((Y / 67108864) | 0)) | 0),
              (z = (z + g) | 0),
              (g = z & 67108863),
              ($ = ($ + (z >>> 26)) | 0),
              (B += $ >>> 26),
              ($ &= 67108863)
          }
          ;(S.words[D] = g), (P = $), ($ = B)
        }
        return P !== 0 ? (S.words[D] = P) : (S.length -= 1), S._strip()
      }
      function re(b, C, S) {
        if (!c || b.length + C.length > 82595519) return ge(b, C, S)
        let R = BigInt(0),
          P = BigInt(67108863),
          B = BigInt(26),
          D = b.toBigInt() * C.toBigInt(),
          $ = (D < R) | 0
        $ && (D = -D)
        let g = 0
        for (; D > R; ) (S.words[g++] = Number(D & P)), (D >>= B)
        return g === 0 && (S.words[g++] = 0), (S.length = g), (S.negative = $), S
      }
      function j(b, C, S) {
        let R = b.words,
          P = C.words,
          B = S.words,
          D = R[0] | 0,
          $ = D & 8191,
          g = D >>> 13,
          N = R[1] | 0,
          U = N & 8191,
          X = N >>> 13,
          ne = R[2] | 0,
          ee = ne & 8191,
          ae = ne >>> 13,
          Y = R[3] | 0,
          z = Y & 8191,
          H = Y >>> 13,
          se = R[4] | 0,
          me = se & 8191,
          we = se >>> 13,
          Ee = R[5] | 0,
          Me = Ee & 8191,
          Be = Ee >>> 13,
          je = R[6] | 0,
          Pe = je & 8191,
          Oe = je >>> 13,
          ht = R[7] | 0,
          Qe = ht & 8191,
          et = ht >>> 13,
          Mt = R[8] | 0,
          ut = Mt & 8191,
          at = Mt >>> 13,
          Pt = R[9] | 0,
          ft = Pt & 8191,
          We = Pt >>> 13,
          gt = P[0] | 0,
          Ge = gt & 8191,
          He = gt >>> 13,
          wt = P[1] | 0,
          tt = wt & 8191,
          Xe = wt >>> 13,
          _t = P[2] | 0,
          nt = _t & 8191,
          it = _t >>> 13,
          xt = P[3] | 0,
          st = xt & 8191,
          ot = xt >>> 13,
          Rt = P[4] | 0,
          Ze = Rt & 8191,
          Ye = Rt >>> 13,
          Er = P[5] | 0,
          Et = Er & 8191,
          St = Er >>> 13,
          Dr = P[6] | 0,
          At = Dr & 8191,
          vt = Dr >>> 13,
          Yt = P[7] | 0,
          It = Yt & 8191,
          Ot = Yt >>> 13,
          En = P[8] | 0,
          Dt = En & 8191,
          Lt = En >>> 13,
          Sn = P[9] | 0,
          Ut = Sn & 8191,
          qt = Sn >>> 13,
          dt = 0,
          Se,
          ue,
          Ae
        ;(S.negative = b.negative ^ C.negative),
          S._alloc(20),
          (S.length = 19),
          (Se = Math.imul($, Ge)),
          (ue = Math.imul($, He)),
          (ue = (ue + Math.imul(g, Ge)) | 0),
          (Ae = Math.imul(g, He))
        let Fi = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Fi >>> 26)) | 0),
          (Fi &= 67108863),
          (Se = Math.imul(U, Ge)),
          (ue = Math.imul(U, He)),
          (ue = (ue + Math.imul(X, Ge)) | 0),
          (Ae = Math.imul(X, He)),
          (Se = (Se + Math.imul($, tt)) | 0),
          (ue = (ue + Math.imul($, Xe)) | 0),
          (ue = (ue + Math.imul(g, tt)) | 0),
          (Ae = (Ae + Math.imul(g, Xe)) | 0)
        let de = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (de >>> 26)) | 0),
          (de &= 67108863),
          (Se = Math.imul(ee, Ge)),
          (ue = Math.imul(ee, He)),
          (ue = (ue + Math.imul(ae, Ge)) | 0),
          (Ae = Math.imul(ae, He)),
          (Se = (Se + Math.imul(U, tt)) | 0),
          (ue = (ue + Math.imul(U, Xe)) | 0),
          (ue = (ue + Math.imul(X, tt)) | 0),
          (Ae = (Ae + Math.imul(X, Xe)) | 0),
          (Se = (Se + Math.imul($, nt)) | 0),
          (ue = (ue + Math.imul($, it)) | 0),
          (ue = (ue + Math.imul(g, nt)) | 0),
          (Ae = (Ae + Math.imul(g, it)) | 0)
        let pe = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (pe >>> 26)) | 0),
          (pe &= 67108863),
          (Se = Math.imul(z, Ge)),
          (ue = Math.imul(z, He)),
          (ue = (ue + Math.imul(H, Ge)) | 0),
          (Ae = Math.imul(H, He)),
          (Se = (Se + Math.imul(ee, tt)) | 0),
          (ue = (ue + Math.imul(ee, Xe)) | 0),
          (ue = (ue + Math.imul(ae, tt)) | 0),
          (Ae = (Ae + Math.imul(ae, Xe)) | 0),
          (Se = (Se + Math.imul(U, nt)) | 0),
          (ue = (ue + Math.imul(U, it)) | 0),
          (ue = (ue + Math.imul(X, nt)) | 0),
          (Ae = (Ae + Math.imul(X, it)) | 0),
          (Se = (Se + Math.imul($, st)) | 0),
          (ue = (ue + Math.imul($, ot)) | 0),
          (ue = (ue + Math.imul(g, st)) | 0),
          (Ae = (Ae + Math.imul(g, ot)) | 0)
        let ye = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (ye >>> 26)) | 0),
          (ye &= 67108863),
          (Se = Math.imul(me, Ge)),
          (ue = Math.imul(me, He)),
          (ue = (ue + Math.imul(we, Ge)) | 0),
          (Ae = Math.imul(we, He)),
          (Se = (Se + Math.imul(z, tt)) | 0),
          (ue = (ue + Math.imul(z, Xe)) | 0),
          (ue = (ue + Math.imul(H, tt)) | 0),
          (Ae = (Ae + Math.imul(H, Xe)) | 0),
          (Se = (Se + Math.imul(ee, nt)) | 0),
          (ue = (ue + Math.imul(ee, it)) | 0),
          (ue = (ue + Math.imul(ae, nt)) | 0),
          (Ae = (Ae + Math.imul(ae, it)) | 0),
          (Se = (Se + Math.imul(U, st)) | 0),
          (ue = (ue + Math.imul(U, ot)) | 0),
          (ue = (ue + Math.imul(X, st)) | 0),
          (Ae = (Ae + Math.imul(X, ot)) | 0),
          (Se = (Se + Math.imul($, Ze)) | 0),
          (ue = (ue + Math.imul($, Ye)) | 0),
          (ue = (ue + Math.imul(g, Ze)) | 0),
          (Ae = (Ae + Math.imul(g, Ye)) | 0)
        let Te = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Te >>> 26)) | 0),
          (Te &= 67108863),
          (Se = Math.imul(Me, Ge)),
          (ue = Math.imul(Me, He)),
          (ue = (ue + Math.imul(Be, Ge)) | 0),
          (Ae = Math.imul(Be, He)),
          (Se = (Se + Math.imul(me, tt)) | 0),
          (ue = (ue + Math.imul(me, Xe)) | 0),
          (ue = (ue + Math.imul(we, tt)) | 0),
          (Ae = (Ae + Math.imul(we, Xe)) | 0),
          (Se = (Se + Math.imul(z, nt)) | 0),
          (ue = (ue + Math.imul(z, it)) | 0),
          (ue = (ue + Math.imul(H, nt)) | 0),
          (Ae = (Ae + Math.imul(H, it)) | 0),
          (Se = (Se + Math.imul(ee, st)) | 0),
          (ue = (ue + Math.imul(ee, ot)) | 0),
          (ue = (ue + Math.imul(ae, st)) | 0),
          (Ae = (Ae + Math.imul(ae, ot)) | 0),
          (Se = (Se + Math.imul(U, Ze)) | 0),
          (ue = (ue + Math.imul(U, Ye)) | 0),
          (ue = (ue + Math.imul(X, Ze)) | 0),
          (Ae = (Ae + Math.imul(X, Ye)) | 0),
          (Se = (Se + Math.imul($, Et)) | 0),
          (ue = (ue + Math.imul($, St)) | 0),
          (ue = (ue + Math.imul(g, Et)) | 0),
          (Ae = (Ae + Math.imul(g, St)) | 0)
        let De = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (De >>> 26)) | 0),
          (De &= 67108863),
          (Se = Math.imul(Pe, Ge)),
          (ue = Math.imul(Pe, He)),
          (ue = (ue + Math.imul(Oe, Ge)) | 0),
          (Ae = Math.imul(Oe, He)),
          (Se = (Se + Math.imul(Me, tt)) | 0),
          (ue = (ue + Math.imul(Me, Xe)) | 0),
          (ue = (ue + Math.imul(Be, tt)) | 0),
          (Ae = (Ae + Math.imul(Be, Xe)) | 0),
          (Se = (Se + Math.imul(me, nt)) | 0),
          (ue = (ue + Math.imul(me, it)) | 0),
          (ue = (ue + Math.imul(we, nt)) | 0),
          (Ae = (Ae + Math.imul(we, it)) | 0),
          (Se = (Se + Math.imul(z, st)) | 0),
          (ue = (ue + Math.imul(z, ot)) | 0),
          (ue = (ue + Math.imul(H, st)) | 0),
          (Ae = (Ae + Math.imul(H, ot)) | 0),
          (Se = (Se + Math.imul(ee, Ze)) | 0),
          (ue = (ue + Math.imul(ee, Ye)) | 0),
          (ue = (ue + Math.imul(ae, Ze)) | 0),
          (Ae = (Ae + Math.imul(ae, Ye)) | 0),
          (Se = (Se + Math.imul(U, Et)) | 0),
          (ue = (ue + Math.imul(U, St)) | 0),
          (ue = (ue + Math.imul(X, Et)) | 0),
          (Ae = (Ae + Math.imul(X, St)) | 0),
          (Se = (Se + Math.imul($, At)) | 0),
          (ue = (ue + Math.imul($, vt)) | 0),
          (ue = (ue + Math.imul(g, At)) | 0),
          (Ae = (Ae + Math.imul(g, vt)) | 0)
        let Le = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Le >>> 26)) | 0),
          (Le &= 67108863),
          (Se = Math.imul(Qe, Ge)),
          (ue = Math.imul(Qe, He)),
          (ue = (ue + Math.imul(et, Ge)) | 0),
          (Ae = Math.imul(et, He)),
          (Se = (Se + Math.imul(Pe, tt)) | 0),
          (ue = (ue + Math.imul(Pe, Xe)) | 0),
          (ue = (ue + Math.imul(Oe, tt)) | 0),
          (Ae = (Ae + Math.imul(Oe, Xe)) | 0),
          (Se = (Se + Math.imul(Me, nt)) | 0),
          (ue = (ue + Math.imul(Me, it)) | 0),
          (ue = (ue + Math.imul(Be, nt)) | 0),
          (Ae = (Ae + Math.imul(Be, it)) | 0),
          (Se = (Se + Math.imul(me, st)) | 0),
          (ue = (ue + Math.imul(me, ot)) | 0),
          (ue = (ue + Math.imul(we, st)) | 0),
          (Ae = (Ae + Math.imul(we, ot)) | 0),
          (Se = (Se + Math.imul(z, Ze)) | 0),
          (ue = (ue + Math.imul(z, Ye)) | 0),
          (ue = (ue + Math.imul(H, Ze)) | 0),
          (Ae = (Ae + Math.imul(H, Ye)) | 0),
          (Se = (Se + Math.imul(ee, Et)) | 0),
          (ue = (ue + Math.imul(ee, St)) | 0),
          (ue = (ue + Math.imul(ae, Et)) | 0),
          (Ae = (Ae + Math.imul(ae, St)) | 0),
          (Se = (Se + Math.imul(U, At)) | 0),
          (ue = (ue + Math.imul(U, vt)) | 0),
          (ue = (ue + Math.imul(X, At)) | 0),
          (Ae = (Ae + Math.imul(X, vt)) | 0),
          (Se = (Se + Math.imul($, It)) | 0),
          (ue = (ue + Math.imul($, Ot)) | 0),
          (ue = (ue + Math.imul(g, It)) | 0),
          (Ae = (Ae + Math.imul(g, Ot)) | 0)
        let $e = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + ($e >>> 26)) | 0),
          ($e &= 67108863),
          (Se = Math.imul(ut, Ge)),
          (ue = Math.imul(ut, He)),
          (ue = (ue + Math.imul(at, Ge)) | 0),
          (Ae = Math.imul(at, He)),
          (Se = (Se + Math.imul(Qe, tt)) | 0),
          (ue = (ue + Math.imul(Qe, Xe)) | 0),
          (ue = (ue + Math.imul(et, tt)) | 0),
          (Ae = (Ae + Math.imul(et, Xe)) | 0),
          (Se = (Se + Math.imul(Pe, nt)) | 0),
          (ue = (ue + Math.imul(Pe, it)) | 0),
          (ue = (ue + Math.imul(Oe, nt)) | 0),
          (Ae = (Ae + Math.imul(Oe, it)) | 0),
          (Se = (Se + Math.imul(Me, st)) | 0),
          (ue = (ue + Math.imul(Me, ot)) | 0),
          (ue = (ue + Math.imul(Be, st)) | 0),
          (Ae = (Ae + Math.imul(Be, ot)) | 0),
          (Se = (Se + Math.imul(me, Ze)) | 0),
          (ue = (ue + Math.imul(me, Ye)) | 0),
          (ue = (ue + Math.imul(we, Ze)) | 0),
          (Ae = (Ae + Math.imul(we, Ye)) | 0),
          (Se = (Se + Math.imul(z, Et)) | 0),
          (ue = (ue + Math.imul(z, St)) | 0),
          (ue = (ue + Math.imul(H, Et)) | 0),
          (Ae = (Ae + Math.imul(H, St)) | 0),
          (Se = (Se + Math.imul(ee, At)) | 0),
          (ue = (ue + Math.imul(ee, vt)) | 0),
          (ue = (ue + Math.imul(ae, At)) | 0),
          (Ae = (Ae + Math.imul(ae, vt)) | 0),
          (Se = (Se + Math.imul(U, It)) | 0),
          (ue = (ue + Math.imul(U, Ot)) | 0),
          (ue = (ue + Math.imul(X, It)) | 0),
          (Ae = (Ae + Math.imul(X, Ot)) | 0),
          (Se = (Se + Math.imul($, Dt)) | 0),
          (ue = (ue + Math.imul($, Lt)) | 0),
          (ue = (ue + Math.imul(g, Dt)) | 0),
          (Ae = (Ae + Math.imul(g, Lt)) | 0)
        let Fe = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Fe >>> 26)) | 0),
          (Fe &= 67108863),
          (Se = Math.imul(ft, Ge)),
          (ue = Math.imul(ft, He)),
          (ue = (ue + Math.imul(We, Ge)) | 0),
          (Ae = Math.imul(We, He)),
          (Se = (Se + Math.imul(ut, tt)) | 0),
          (ue = (ue + Math.imul(ut, Xe)) | 0),
          (ue = (ue + Math.imul(at, tt)) | 0),
          (Ae = (Ae + Math.imul(at, Xe)) | 0),
          (Se = (Se + Math.imul(Qe, nt)) | 0),
          (ue = (ue + Math.imul(Qe, it)) | 0),
          (ue = (ue + Math.imul(et, nt)) | 0),
          (Ae = (Ae + Math.imul(et, it)) | 0),
          (Se = (Se + Math.imul(Pe, st)) | 0),
          (ue = (ue + Math.imul(Pe, ot)) | 0),
          (ue = (ue + Math.imul(Oe, st)) | 0),
          (Ae = (Ae + Math.imul(Oe, ot)) | 0),
          (Se = (Se + Math.imul(Me, Ze)) | 0),
          (ue = (ue + Math.imul(Me, Ye)) | 0),
          (ue = (ue + Math.imul(Be, Ze)) | 0),
          (Ae = (Ae + Math.imul(Be, Ye)) | 0),
          (Se = (Se + Math.imul(me, Et)) | 0),
          (ue = (ue + Math.imul(me, St)) | 0),
          (ue = (ue + Math.imul(we, Et)) | 0),
          (Ae = (Ae + Math.imul(we, St)) | 0),
          (Se = (Se + Math.imul(z, At)) | 0),
          (ue = (ue + Math.imul(z, vt)) | 0),
          (ue = (ue + Math.imul(H, At)) | 0),
          (Ae = (Ae + Math.imul(H, vt)) | 0),
          (Se = (Se + Math.imul(ee, It)) | 0),
          (ue = (ue + Math.imul(ee, Ot)) | 0),
          (ue = (ue + Math.imul(ae, It)) | 0),
          (Ae = (Ae + Math.imul(ae, Ot)) | 0),
          (Se = (Se + Math.imul(U, Dt)) | 0),
          (ue = (ue + Math.imul(U, Lt)) | 0),
          (ue = (ue + Math.imul(X, Dt)) | 0),
          (Ae = (Ae + Math.imul(X, Lt)) | 0),
          (Se = (Se + Math.imul($, Ut)) | 0),
          (ue = (ue + Math.imul($, qt)) | 0),
          (ue = (ue + Math.imul(g, Ut)) | 0),
          (Ae = (Ae + Math.imul(g, qt)) | 0)
        let Tt = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Tt >>> 26)) | 0),
          (Tt &= 67108863),
          (Se = Math.imul(ft, tt)),
          (ue = Math.imul(ft, Xe)),
          (ue = (ue + Math.imul(We, tt)) | 0),
          (Ae = Math.imul(We, Xe)),
          (Se = (Se + Math.imul(ut, nt)) | 0),
          (ue = (ue + Math.imul(ut, it)) | 0),
          (ue = (ue + Math.imul(at, nt)) | 0),
          (Ae = (Ae + Math.imul(at, it)) | 0),
          (Se = (Se + Math.imul(Qe, st)) | 0),
          (ue = (ue + Math.imul(Qe, ot)) | 0),
          (ue = (ue + Math.imul(et, st)) | 0),
          (Ae = (Ae + Math.imul(et, ot)) | 0),
          (Se = (Se + Math.imul(Pe, Ze)) | 0),
          (ue = (ue + Math.imul(Pe, Ye)) | 0),
          (ue = (ue + Math.imul(Oe, Ze)) | 0),
          (Ae = (Ae + Math.imul(Oe, Ye)) | 0),
          (Se = (Se + Math.imul(Me, Et)) | 0),
          (ue = (ue + Math.imul(Me, St)) | 0),
          (ue = (ue + Math.imul(Be, Et)) | 0),
          (Ae = (Ae + Math.imul(Be, St)) | 0),
          (Se = (Se + Math.imul(me, At)) | 0),
          (ue = (ue + Math.imul(me, vt)) | 0),
          (ue = (ue + Math.imul(we, At)) | 0),
          (Ae = (Ae + Math.imul(we, vt)) | 0),
          (Se = (Se + Math.imul(z, It)) | 0),
          (ue = (ue + Math.imul(z, Ot)) | 0),
          (ue = (ue + Math.imul(H, It)) | 0),
          (Ae = (Ae + Math.imul(H, Ot)) | 0),
          (Se = (Se + Math.imul(ee, Dt)) | 0),
          (ue = (ue + Math.imul(ee, Lt)) | 0),
          (ue = (ue + Math.imul(ae, Dt)) | 0),
          (Ae = (Ae + Math.imul(ae, Lt)) | 0),
          (Se = (Se + Math.imul(U, Ut)) | 0),
          (ue = (ue + Math.imul(U, qt)) | 0),
          (ue = (ue + Math.imul(X, Ut)) | 0),
          (Ae = (Ae + Math.imul(X, qt)) | 0)
        let Gt = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Gt >>> 26)) | 0),
          (Gt &= 67108863),
          (Se = Math.imul(ft, nt)),
          (ue = Math.imul(ft, it)),
          (ue = (ue + Math.imul(We, nt)) | 0),
          (Ae = Math.imul(We, it)),
          (Se = (Se + Math.imul(ut, st)) | 0),
          (ue = (ue + Math.imul(ut, ot)) | 0),
          (ue = (ue + Math.imul(at, st)) | 0),
          (Ae = (Ae + Math.imul(at, ot)) | 0),
          (Se = (Se + Math.imul(Qe, Ze)) | 0),
          (ue = (ue + Math.imul(Qe, Ye)) | 0),
          (ue = (ue + Math.imul(et, Ze)) | 0),
          (Ae = (Ae + Math.imul(et, Ye)) | 0),
          (Se = (Se + Math.imul(Pe, Et)) | 0),
          (ue = (ue + Math.imul(Pe, St)) | 0),
          (ue = (ue + Math.imul(Oe, Et)) | 0),
          (Ae = (Ae + Math.imul(Oe, St)) | 0),
          (Se = (Se + Math.imul(Me, At)) | 0),
          (ue = (ue + Math.imul(Me, vt)) | 0),
          (ue = (ue + Math.imul(Be, At)) | 0),
          (Ae = (Ae + Math.imul(Be, vt)) | 0),
          (Se = (Se + Math.imul(me, It)) | 0),
          (ue = (ue + Math.imul(me, Ot)) | 0),
          (ue = (ue + Math.imul(we, It)) | 0),
          (Ae = (Ae + Math.imul(we, Ot)) | 0),
          (Se = (Se + Math.imul(z, Dt)) | 0),
          (ue = (ue + Math.imul(z, Lt)) | 0),
          (ue = (ue + Math.imul(H, Dt)) | 0),
          (Ae = (Ae + Math.imul(H, Lt)) | 0),
          (Se = (Se + Math.imul(ee, Ut)) | 0),
          (ue = (ue + Math.imul(ee, qt)) | 0),
          (ue = (ue + Math.imul(ae, Ut)) | 0),
          (Ae = (Ae + Math.imul(ae, qt)) | 0)
        let tr = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (tr >>> 26)) | 0),
          (tr &= 67108863),
          (Se = Math.imul(ft, st)),
          (ue = Math.imul(ft, ot)),
          (ue = (ue + Math.imul(We, st)) | 0),
          (Ae = Math.imul(We, ot)),
          (Se = (Se + Math.imul(ut, Ze)) | 0),
          (ue = (ue + Math.imul(ut, Ye)) | 0),
          (ue = (ue + Math.imul(at, Ze)) | 0),
          (Ae = (Ae + Math.imul(at, Ye)) | 0),
          (Se = (Se + Math.imul(Qe, Et)) | 0),
          (ue = (ue + Math.imul(Qe, St)) | 0),
          (ue = (ue + Math.imul(et, Et)) | 0),
          (Ae = (Ae + Math.imul(et, St)) | 0),
          (Se = (Se + Math.imul(Pe, At)) | 0),
          (ue = (ue + Math.imul(Pe, vt)) | 0),
          (ue = (ue + Math.imul(Oe, At)) | 0),
          (Ae = (Ae + Math.imul(Oe, vt)) | 0),
          (Se = (Se + Math.imul(Me, It)) | 0),
          (ue = (ue + Math.imul(Me, Ot)) | 0),
          (ue = (ue + Math.imul(Be, It)) | 0),
          (Ae = (Ae + Math.imul(Be, Ot)) | 0),
          (Se = (Se + Math.imul(me, Dt)) | 0),
          (ue = (ue + Math.imul(me, Lt)) | 0),
          (ue = (ue + Math.imul(we, Dt)) | 0),
          (Ae = (Ae + Math.imul(we, Lt)) | 0),
          (Se = (Se + Math.imul(z, Ut)) | 0),
          (ue = (ue + Math.imul(z, qt)) | 0),
          (ue = (ue + Math.imul(H, Ut)) | 0),
          (Ae = (Ae + Math.imul(H, qt)) | 0)
        let Zt = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Zt >>> 26)) | 0),
          (Zt &= 67108863),
          (Se = Math.imul(ft, Ze)),
          (ue = Math.imul(ft, Ye)),
          (ue = (ue + Math.imul(We, Ze)) | 0),
          (Ae = Math.imul(We, Ye)),
          (Se = (Se + Math.imul(ut, Et)) | 0),
          (ue = (ue + Math.imul(ut, St)) | 0),
          (ue = (ue + Math.imul(at, Et)) | 0),
          (Ae = (Ae + Math.imul(at, St)) | 0),
          (Se = (Se + Math.imul(Qe, At)) | 0),
          (ue = (ue + Math.imul(Qe, vt)) | 0),
          (ue = (ue + Math.imul(et, At)) | 0),
          (Ae = (Ae + Math.imul(et, vt)) | 0),
          (Se = (Se + Math.imul(Pe, It)) | 0),
          (ue = (ue + Math.imul(Pe, Ot)) | 0),
          (ue = (ue + Math.imul(Oe, It)) | 0),
          (Ae = (Ae + Math.imul(Oe, Ot)) | 0),
          (Se = (Se + Math.imul(Me, Dt)) | 0),
          (ue = (ue + Math.imul(Me, Lt)) | 0),
          (ue = (ue + Math.imul(Be, Dt)) | 0),
          (Ae = (Ae + Math.imul(Be, Lt)) | 0),
          (Se = (Se + Math.imul(me, Ut)) | 0),
          (ue = (ue + Math.imul(me, qt)) | 0),
          (ue = (ue + Math.imul(we, Ut)) | 0),
          (Ae = (Ae + Math.imul(we, qt)) | 0)
        let Lr = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (Lr >>> 26)) | 0),
          (Lr &= 67108863),
          (Se = Math.imul(ft, Et)),
          (ue = Math.imul(ft, St)),
          (ue = (ue + Math.imul(We, Et)) | 0),
          (Ae = Math.imul(We, St)),
          (Se = (Se + Math.imul(ut, At)) | 0),
          (ue = (ue + Math.imul(ut, vt)) | 0),
          (ue = (ue + Math.imul(at, At)) | 0),
          (Ae = (Ae + Math.imul(at, vt)) | 0),
          (Se = (Se + Math.imul(Qe, It)) | 0),
          (ue = (ue + Math.imul(Qe, Ot)) | 0),
          (ue = (ue + Math.imul(et, It)) | 0),
          (Ae = (Ae + Math.imul(et, Ot)) | 0),
          (Se = (Se + Math.imul(Pe, Dt)) | 0),
          (ue = (ue + Math.imul(Pe, Lt)) | 0),
          (ue = (ue + Math.imul(Oe, Dt)) | 0),
          (Ae = (Ae + Math.imul(Oe, Lt)) | 0),
          (Se = (Se + Math.imul(Me, Ut)) | 0),
          (ue = (ue + Math.imul(Me, qt)) | 0),
          (ue = (ue + Math.imul(Be, Ut)) | 0),
          (Ae = (Ae + Math.imul(Be, qt)) | 0)
        let An = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (An >>> 26)) | 0),
          (An &= 67108863),
          (Se = Math.imul(ft, At)),
          (ue = Math.imul(ft, vt)),
          (ue = (ue + Math.imul(We, At)) | 0),
          (Ae = Math.imul(We, vt)),
          (Se = (Se + Math.imul(ut, It)) | 0),
          (ue = (ue + Math.imul(ut, Ot)) | 0),
          (ue = (ue + Math.imul(at, It)) | 0),
          (Ae = (Ae + Math.imul(at, Ot)) | 0),
          (Se = (Se + Math.imul(Qe, Dt)) | 0),
          (ue = (ue + Math.imul(Qe, Lt)) | 0),
          (ue = (ue + Math.imul(et, Dt)) | 0),
          (Ae = (Ae + Math.imul(et, Lt)) | 0),
          (Se = (Se + Math.imul(Pe, Ut)) | 0),
          (ue = (ue + Math.imul(Pe, qt)) | 0),
          (ue = (ue + Math.imul(Oe, Ut)) | 0),
          (Ae = (Ae + Math.imul(Oe, qt)) | 0)
        let yr = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (yr >>> 26)) | 0),
          (yr &= 67108863),
          (Se = Math.imul(ft, It)),
          (ue = Math.imul(ft, Ot)),
          (ue = (ue + Math.imul(We, It)) | 0),
          (Ae = Math.imul(We, Ot)),
          (Se = (Se + Math.imul(ut, Dt)) | 0),
          (ue = (ue + Math.imul(ut, Lt)) | 0),
          (ue = (ue + Math.imul(at, Dt)) | 0),
          (Ae = (Ae + Math.imul(at, Lt)) | 0),
          (Se = (Se + Math.imul(Qe, Ut)) | 0),
          (ue = (ue + Math.imul(Qe, qt)) | 0),
          (ue = (ue + Math.imul(et, Ut)) | 0),
          (Ae = (Ae + Math.imul(et, qt)) | 0)
        let nr = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (nr >>> 26)) | 0),
          (nr &= 67108863),
          (Se = Math.imul(ft, Dt)),
          (ue = Math.imul(ft, Lt)),
          (ue = (ue + Math.imul(We, Dt)) | 0),
          (Ae = Math.imul(We, Lt)),
          (Se = (Se + Math.imul(ut, Ut)) | 0),
          (ue = (ue + Math.imul(ut, qt)) | 0),
          (ue = (ue + Math.imul(at, Ut)) | 0),
          (Ae = (Ae + Math.imul(at, qt)) | 0)
        let ce = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        ;(dt = (((Ae + (ue >>> 13)) | 0) + (ce >>> 26)) | 0),
          (ce &= 67108863),
          (Se = Math.imul(ft, Ut)),
          (ue = Math.imul(ft, qt)),
          (ue = (ue + Math.imul(We, Ut)) | 0),
          (Ae = Math.imul(We, qt))
        let he = (((dt + Se) | 0) + ((ue & 8191) << 13)) | 0
        return (
          (dt = (((Ae + (ue >>> 13)) | 0) + (he >>> 26)) | 0),
          (he &= 67108863),
          (B[0] = Fi),
          (B[1] = de),
          (B[2] = pe),
          (B[3] = ye),
          (B[4] = Te),
          (B[5] = De),
          (B[6] = Le),
          (B[7] = $e),
          (B[8] = Fe),
          (B[9] = Tt),
          (B[10] = Gt),
          (B[11] = tr),
          (B[12] = Zt),
          (B[13] = Lr),
          (B[14] = An),
          (B[15] = yr),
          (B[16] = nr),
          (B[17] = ce),
          (B[18] = he),
          dt !== 0 && ((B[19] = dt), (S.length += 1)),
          S
        )
      }
      Math.imul || (j = be), (f.Red = v), (r.exports = f)
    }
  }),
  nA = te({
    'node_modules/bcrypto/lib/bn-browser.js'(e, r) {
      V(), F(), (r.exports = PD())
    }
  }),
  OD = te({
    'node_modules/bcrypto/lib/js/elliptic.js'(e) {
      V(), F()
      var { custom: r } = rA(),
        t = nA(),
        n = { AFFINE: 0, JACOBIAN: 1, PROJECTIVE: 2, EXTENDED: 3 },
        i = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
        s = !1,
        u = 0,
        o = class {
          constructor(g, N, U) {
            ;(this.Point = null),
              (this.id = null),
              (this.uid = u++),
              (this.ossl = null),
              (this.type = 'base'),
              (this.endian = 'be'),
              (this.hash = null),
              (this.prefix = null),
              (this.context = !1),
              (this.prime = null),
              (this.p = null),
              (this.red = null),
              (this.fieldSize = 0),
              (this.fieldBits = 0),
              (this.adjustedSize = 0),
              (this.signBit = 0),
              (this.mask = 0),
              (this.n = null),
              (this.h = null),
              (this.q = null),
              (this.z = null),
              (this.g = null),
              (this.nh = null),
              (this.scalarSize = 0),
              (this.scalarBits = 0),
              (this.zero = null),
              (this.one = null),
              (this.two = null),
              (this.three = null),
              (this.four = null),
              (this.i2 = null),
              (this.i3 = null),
              (this.i4 = null),
              (this.i6 = null),
              (this.torsion = null),
              (this.endo = null),
              (this.hi = null),
              this._init(g, N, U)
          }
          _init(g, N, U) {
            j(typeof g == 'function'),
              j(typeof N == 'string'),
              j(U && typeof U == 'object'),
              j(U.red == null || U.red instanceof t.Red),
              j(U.p != null, 'Must pass a prime.'),
              j(U.id == null || typeof U.id == 'string'),
              j(U.ossl == null || typeof U.ossl == 'string'),
              j(U.endian == null || typeof U.endian == 'string'),
              j(U.hash == null || typeof U.hash == 'string'),
              j(U.prefix == null || typeof U.prefix == 'string'),
              j(U.context == null || typeof U.context == 'boolean'),
              j(U.prime == null || typeof U.prime == 'string'),
              j(U.torsion == null || Array.isArray(U.torsion)),
              (this.Point = g),
              (this.id = U.id || null),
              (this.ossl = U.ossl || null),
              (this.type = N),
              (this.endian = U.endian || (N === 'short' ? 'be' : 'le')),
              (this.hash = U.hash || null),
              (this.prefix = U.prefix ? Ve.Buffer.from(U.prefix, 'binary') : null),
              (this.context = U.context || !1),
              (this.prime = U.prime || null),
              (this.p = t.fromJSON(U.p)),
              U.red
                ? (this.red = U.red)
                : ((this.red = U.prime ? t.red(U.prime) : t.mont(this.p)), this.red.precompute()),
              (this.fieldSize = this.p.byteLength()),
              (this.fieldBits = this.p.bitLength()),
              (this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) == 0)),
              (this.signBit = this.adjustedSize * 8 - 1),
              (this.mask = 255),
              (this.fieldBits & 7) != 0 && (this.mask = (1 << (this.fieldBits & 7)) - 1),
              (this.n = t.fromJSON(U.n || '0')),
              (this.h = t.fromJSON(U.h || '1')),
              (this.q = this.n.mul(this.h)),
              (this.z = t.fromJSON(U.z || '0').toRed(this.red)),
              (this.g = null),
              (this.nh = this.n.ushrn(1)),
              (this.scalarSize = this.n.byteLength()),
              (this.scalarBits = this.n.bitLength()),
              (this.zero = new t(0).toRed(this.red)),
              (this.one = new t(1).toRed(this.red)),
              (this.two = new t(2).toRed(this.red)),
              (this.three = new t(3).toRed(this.red)),
              (this.four = new t(4).toRed(this.red)),
              (this.i2 = this.two.redInvert()),
              (this.i3 = this.three.redInvert()),
              (this.i4 = this.i2.redSqr()),
              (this.i6 = this.i2.redMul(this.i3)),
              (this.torsion = new Array(this.h.word(0)))
            for (let X = 0; X < this.torsion.length; X++) this.torsion[X] = this.point()
            return (
              (this.endo = null),
              (this.hi = null),
              (this._scale = D(this._scale, this)),
              (this.isIsomorphic = D(this.isIsomorphic, this)),
              (this.isIsogenous = D(this.isIsogenous, this)),
              j(this.p.sign() > 0 && this.p.isOdd()),
              j(this.n.sign() >= 0),
              j(this.h.sign() > 0 && this.h.cmpn(255) <= 0),
              j(this.endian === 'be' || this.endian === 'le'),
              this
            )
          }
          _finalize(g) {
            if ((j(g && typeof g == 'object'), (this.g = g.g ? this.pointFromJSON(g.g) : this.point()), g.torsion)) {
              j(g.torsion.length === this.torsion.length)
              for (let N = 0; N < this.torsion.length; N++) this.torsion[N] = this.pointFromJSON(g.torsion[N])
            }
            return this
          }
          _findTorsion() {
            j(!this.n.isZero())
            let g = this.h.word(0),
              N = this.one.redNeg(),
              U = [this.point()],
              X = new Set(),
              ne = g
            for (; U.length < ne; ) {
              let ee
              N.redIAdd(this.one)
              try {
                ee = this.pointFromX(N.clone())
              } catch (ae) {
                continue
              }
              try {
                ee = ee.mul(this.n)
              } catch (ae) {
                ne = 2
                continue
              }
              if (!ee.isInfinity()) {
                ee.normalize()
                for (let ae of [ee, ee.neg()]) {
                  let Y = ae.key()
                  X.has(Y) || (U.push(ae), X.add(Y))
                }
              }
            }
            for (U.sort((ee, ae) => ee.cmp(ae)); U.length < g; ) U.push(this.point())
            return U
          }
          _fixedMul(g, N) {
            j(g instanceof l), j(N instanceof t), j(g.pre && g.pre.windows)
            let { width: U, points: X } = g._getWindows(0, 0),
              ne = 1 << U,
              ae = ((N.bitLength() + U - 1) / U) >>> 0,
              Y = this.jpoint()
            for (let z = 0; z < ae; z++) {
              let H = N.bits(z * U, U)
              Y = Y.add(X[z * ne + H])
            }
            return N.isNeg() && (Y = Y.neg()), Y
          }
          _fixedNafMul(g, N) {
            j(g instanceof l), j(N instanceof t), j(g.pre && g.pre.doubles)
            let { step: U, points: X } = g._getDoubles(0, 0),
              ne = be(N, 2, N.bitLength() + 1, U),
              ee = ((1 << (U + 1)) - (U % 2 == 0 ? 2 : 1)) / 3,
              ae = this.jpoint(),
              Y = this.jpoint()
            for (let z = ee; z > 0; z--) {
              for (let H = 0; H < ne.length; H++) {
                let se = ne[H]
                se === z ? (Y = Y.add(X[H])) : se === -z && (Y = Y.sub(X[H]))
              }
              ae = ae.add(Y)
            }
            return ae
          }
          _wnafMul(g, N, U) {
            j(N instanceof l), j(U instanceof t)
            let { width: X, points: ne } = N._safeNAF(g),
              ee = oe(U, X, U.bitLength() + 1),
              ae = this.jpoint()
            for (let Y = ee.length - 1; Y >= 0; Y--) {
              let z = ee[Y]
              Y !== ee.length - 1 && (ae = ae.dbl()),
                z > 0 ? (ae = ae.add(ne[(z - 1) >> 1])) : z < 0 && (ae = ae.sub(ne[(-z - 1) >> 1]))
            }
            return ae
          }
          _wnafMulAdd(g, N, U) {
            j(g >>> 0 === g), j(Array.isArray(N)), j(Array.isArray(U)), j(N.length === U.length)
            let X = N.length,
              ne = new Array(X),
              ee = new Array(X),
              ae = 0
            for (let me = 0; me < X; me++) {
              let we = N[me],
                Ee = U[me]
              if ((j(we instanceof l), j(Ee instanceof t), me > 0 && we.type !== N[me - 1].type))
                throw new Error('Cannot mix points.')
              ;(ne[me] = null), (ee[me] = null), (ae = Math.max(ae, Ee.bitLength() + 1))
            }
            let Y = null,
              z = null,
              H = 0
            for (let me = 0; me < X; me++) {
              let we = N[me],
                Ee = U[me],
                Me = we._getNAF(0)
              if (Me) {
                ;(ne[H] = Me.points), (ee[H] = oe(Ee, Me.width, ae)), (H += 1)
                continue
              }
              if (!Y) {
                ;(Y = we), (z = Ee)
                continue
              }
              ;(ne[H] = Y._getJNAF(we)), (ee[H] = re(z, Ee, ae)), (Y = null), (z = null), (H += 1)
            }
            if (Y) {
              let me = Y._safeNAF(g)
              ;(ne[H] = me.points), (ee[H] = oe(z, me.width, ae)), (H += 1)
            }
            let se = this.jpoint()
            for (let me = ae - 1; me >= 0; me--) {
              me !== ae - 1 && (se = se.dbl())
              for (let we = 0; we < H; we++) {
                let Ee = ee[we][me]
                Ee > 0 ? (se = se.add(ne[we][(Ee - 1) >> 1])) : Ee < 0 && (se = se.sub(ne[we][(-Ee - 1) >> 1]))
              }
            }
            return se
          }
          _endoWnafMulAdd(g, N) {
            throw new Error('Not implemented.')
          }
          _scale(g, N) {
            switch ((j(g instanceof o), j(g.p.eq(this.p)), g.type)) {
              case 'short':
                return this._scaleShort(g, N)
              case 'mont':
                return this._scaleMont(g, N)
              case 'edwards':
                return this._scaleEdwards(g, N)
              default:
                throw new Error('Not implemented.')
            }
          }
          _scaleShort(g, N) {
            throw new Error('Not implemented.')
          }
          _scaleMont(g, N) {
            throw new Error('Not implemented.')
          }
          _scaleEdwards(g, N) {
            throw new Error('Not implemented.')
          }
          isElliptic() {
            throw new Error('Not implemented.')
          }
          jinv() {
            throw new Error('Not implemented.')
          }
          isComplete() {
            return !1
          }
          precompute(g) {
            return (
              j(!this.g.isInfinity(), 'Must have base point.'),
              j(!this.n.isZero(), 'Must have order.'),
              this.g.precompute(this.n.bitLength(), g),
              this
            )
          }
          scalar(g, N, U) {
            let X = new t(g, N, U)
            return j(!X.red), this.n.isZero() ? X : X.imod(this.n)
          }
          field(g, N, U) {
            let X = t.cast(g, N, U)
            return X.red ? X.forceRed(this.red) : X.toRed(this.red)
          }
          point(g, N) {
            throw new Error('Not implemented.')
          }
          jpoint(g, N, U) {
            throw new Error('Not implemented.')
          }
          xpoint(g, N) {
            throw new Error('Not implemented.')
          }
          cpoint(g, N, U, X) {
            if ((j(g instanceof t), j(N instanceof t), j(U instanceof t), j(X instanceof t), N.isZero() || X.isZero()))
              return this.point()
            let ne = N.redMul(X).redInvert(),
              ee = g.redMul(X).redMul(ne),
              ae = U.redMul(N).redMul(ne)
            return this.point(ee, ae)
          }
          solveX2(g) {
            throw new Error('Not implemented.')
          }
          solveX(g) {
            return this.solveX2(g).redSqrt()
          }
          solveY2(g) {
            throw new Error('Not implemented.')
          }
          solveY(g) {
            return this.solveY2(g).redSqrt()
          }
          validate(g) {
            throw new Error('Not implemented.')
          }
          pointFromX(g, N) {
            throw new Error('Not implemented.')
          }
          pointFromY(g, N) {
            throw new Error('Not implemented.')
          }
          isIsomorphic(g) {
            throw new Error('Not implemented.')
          }
          isIsogenous(g) {
            throw new Error('Not implemented.')
          }
          pointFromShort(g) {
            throw new Error('Not implemented.')
          }
          pointFromMont(g, N) {
            throw new Error('Not implemented.')
          }
          pointFromEdwards(g) {
            throw new Error('Not implemented.')
          }
          pointFromUniform(g) {
            throw new Error('Not implemented.')
          }
          pointToUniform(g) {
            throw new Error('Not implemented.')
          }
          pointFromHash(g, N = !1) {
            if ((j(Ve.Buffer.isBuffer(g)), j(typeof N == 'boolean'), g.length !== this.fieldSize * 2))
              throw new Error('Invalid hash size.')
            let U = g.slice(0, this.fieldSize),
              X = g.slice(this.fieldSize),
              ne = this.decodeUniform(U),
              ee = this.decodeUniform(X),
              ae = this.pointFromUniform(ne),
              Y = this.pointFromUniform(ee),
              z = ae.add(Y)
            return N ? z.mulH() : z
          }
          pointToHash(g, N, U) {
            j(g instanceof this.Point), j(N >>> 0 === N)
            let X = N % this.torsion.length,
              ne = g.add(this.torsion[X])
            for (;;) {
              let ee = this.randomField(U),
                ae = this.pointFromUniform(ee)
              if (ae.neg().eq(ae)) continue
              let Y = ne.sub(ae),
                z = B(U),
                H
              try {
                H = this.pointToUniform(Y, z & 15)
              } catch (we) {
                if (we.message === 'Invalid point.') continue
                throw we
              }
              let se = this.encodeUniform(ee, z >>> 8),
                me = this.encodeUniform(H, z >>> 16)
              return Ve.Buffer.concat([se, me])
            }
          }
          randomScalar(g) {
            let N = this.n.isZero() ? this.p : this.n
            return t.random(g, 1, N)
          }
          randomField(g) {
            return t.random(g, 1, this.p).toRed(this.red)
          }
          randomPoint(g) {
            let N
            for (;;) {
              let U = this.randomField(g),
                X = (B(g) & 1) != 0
              try {
                N = this.pointFromX(U, X)
              } catch (ne) {
                continue
              }
              return j(N.validate()), N.mulH()
            }
          }
          mulAll(g, N) {
            return this.jmulAll(g, N)
          }
          jmulAll(g, N) {
            return (
              j(Array.isArray(g)),
              j(g.length === 0 || g[0] instanceof l),
              this.endo && g.length > 0 && g[0].type === n.AFFINE
                ? this._endoWnafMulAdd(g, N)
                : this._wnafMulAdd(5, g, N)
            )
          }
          mulH(g) {
            return j(g instanceof t), this.imulH(g.clone())
          }
          imulH(g) {
            j(g instanceof t), j(!g.red)
            let N = this.h.word(0)
            if ((N & (N - 1)) == 0) {
              let U = this.h.bitLength()
              return g.iushln(U - 1).imod(this.n)
            }
            return g.imuln(N).imod(this.n)
          }
          normalizeAll(g) {
            j(Array.isArray(g))
            let N = g.length,
              U = new Array(N)
            for (let ee = 0; ee < N; ee++) {
              let ae = g[ee]
              if ((j(ae instanceof l), j(ae.curve === this), ae.type === n.AFFINE)) {
                U[ee] = this.one
                continue
              }
              U[ee] = ae.z
            }
            let X = this.red.invertAll(U),
              ne = new Array(N)
            for (let ee = 0; ee < N; ee++) ne[ee] = g[ee].scale(X[ee])
            return ne
          }
          affinizeAll(g) {
            return this.normalizeAll(g)
          }
          clamp(g) {
            j(Ve.Buffer.isBuffer(g)), j(g.length === this.scalarSize), j(this.scalarSize <= this.fieldSize)
            let N = this.fieldBits & 7 || 8,
              U = 0,
              X = this.scalarSize - 1
            return (
              this.endian === 'be' && ([U, X] = [X, U]),
              this.scalarSize < this.fieldSize && (N = 8),
              (g[U] &= -this.h.word(0) & 255),
              (g[X] &= (1 << N) - 1),
              (g[X] |= 1 << (N - 1)),
              g
            )
          }
          splitHash(g) {
            j(Ve.Buffer.isBuffer(g)), j(g.length === this.adjustedSize * 2), j(this.scalarSize <= this.adjustedSize)
            let N = 0
            this.endian === 'be' && (N = this.adjustedSize - this.scalarSize)
            let U = g.slice(N, N + this.scalarSize),
              X = g.slice(this.adjustedSize)
            return this.clamp(U), [U, X]
          }
          encodeField(g) {
            return j(g instanceof t), j(!g.red), g.encode(this.endian, this.fieldSize)
          }
          decodeField(g) {
            if ((j(Ve.Buffer.isBuffer(g)), g.length !== this.fieldSize)) throw new Error('Invalid field element size.')
            return t.decode(g, this.endian)
          }
          encodeAdjusted(g) {
            return j(g instanceof t), j(!g.red), g.encode(this.endian, this.adjustedSize)
          }
          decodeAdjusted(g) {
            if ((j(Ve.Buffer.isBuffer(g)), g.length !== this.adjustedSize))
              throw new Error('Invalid field element size.')
            return t.decode(g, this.endian)
          }
          encodeScalar(g) {
            return j(g instanceof t), j(!g.red), g.encode(this.endian, this.scalarSize)
          }
          decodeScalar(g) {
            if ((j(Ve.Buffer.isBuffer(g)), g.length !== this.scalarSize)) throw new Error('Invalid scalar size.')
            return t.decode(g, this.endian)
          }
          encodeClamped(g) {
            return this.clamp(this.encodeScalar(g))
          }
          decodeClamped(g) {
            if ((j(Ve.Buffer.isBuffer(g)), g.length !== this.scalarSize)) throw new Error('Invalid scalar size.')
            let N = this.clamp(Ve.Buffer.from(g))
            return t.decode(N, this.endian)
          }
          encodeUniform(g, N) {
            j(g instanceof t), j(N >>> 0 === N)
            let U = this.endian === 'le' ? this.fieldSize - 1 : 0,
              X = g.fromRed().encode(this.endian, this.fieldSize)
            return (X[U] |= N & ~this.mask & 255), X
          }
          decodeUniform(g) {
            if ((j(Ve.Buffer.isBuffer(g)), g.length !== this.fieldSize)) throw new Error('Invalid field size.')
            let N = t.decode(g, this.endian)
            return N.iumaskn(this.fieldBits), N.toRed(this.red)
          }
          encodePoint(g, N) {
            return j(g instanceof l), g.encode(N)
          }
          decodePoint(g) {
            throw new Error('Not implemented.')
          }
          encodeX(g) {
            throw new Error('Not implemented.')
          }
          decodeX(g) {
            throw new Error('Not implemented.')
          }
          decodeEven(g) {
            throw new Error('Not implemented.')
          }
          decodeSquare(g) {
            throw new Error('Not implemented.')
          }
          toShort() {
            throw new Error('Not implemented.')
          }
          toMont(g) {
            throw new Error('Not implemented.')
          }
          toEdwards(g) {
            throw new Error('Not implemented.')
          }
          pointToJSON(g, N) {
            return j(g instanceof l), g.toJSON(N)
          }
          pointFromJSON(g) {
            throw new Error('Not implemented.')
          }
          toJSON(g) {
            let N, U, X, ne, ee
            return (
              this.type === 'edwards' && ((N = this.prefix ? this.prefix.toString() : null), (U = this.context)),
              this.n.isZero() || (X = this.n.toJSON()),
              this.z.isZero() ||
                ((ne = this.z.fromRed()), this.z.redIsHigh() && ne.isub(this.p), (ne = ne.toString(16))),
              this.endo && (ee = this.endo.toJSON()),
              {
                id: this.id,
                ossl: this.ossl,
                type: this.type,
                endian: this.endian,
                hash: this.hash,
                prefix: N,
                context: U,
                prime: this.prime,
                p: this.p.toJSON(),
                a: void 0,
                b: void 0,
                d: void 0,
                n: X,
                h: this.h.toString(16),
                s: void 0,
                z: ne,
                c: void 0,
                g: this.g.toJSON(g),
                endo: ee
              }
            )
          }
          static fromJSON(g) {
            return new this(g)
          }
        },
        l = class {
          constructor(g, N) {
            j(g instanceof o), j(N >>> 0 === N), (this.curve = g), (this.type = N), (this.pre = null)
          }
          _init() {
            throw new Error('Not implemented.')
          }
          _safeNAF(g) {
            if ((j(g >>> 0 === g), this.pre && this.pre.naf)) return this.pre.naf
            if (g === 0) return null
            let N = 1 << (g - 2),
              U = new Array(N),
              X = this.toJ(),
              ne = N === 1 ? null : X.dbl()
            U[0] = X
            for (let ee = 1; ee < N; ee++) U[ee] = U[ee - 1].add(ne)
            return new A(g, U)
          }
          _getNAF(g) {
            if ((j(g >>> 0 === g), this.pre && this.pre.naf)) return this.pre.naf
            if (g === 0) return null
            let N = this._safeNAF(g).points,
              U = this.curve.affinizeAll(N)
            return new A(g, U)
          }
          _getWindows(g, N) {
            if ((j(g >>> 0 === g), j(N >>> 0 === N), this.pre && this.pre.windows)) return this.pre.windows
            if (g === 0) return null
            let U = 1 << g,
              X = ((N + g - 1) / g) >>> 0,
              ne = new Array(X * U),
              ee = this.toJ()
            for (let Y = 0; Y < X; Y++) {
              ne[Y * U] = this.curve.jpoint()
              for (let z = 1; z < U; z++) ne[Y * U + z] = ne[Y * U + z - 1].add(ee)
              ee = ee.dblp(g)
            }
            let ae = this.curve.affinizeAll(ne)
            return new T(g, N, ae)
          }
          _getDoubles(g, N) {
            if ((j(g >>> 0 === g), j(N >>> 0 === N), this.pre && this.pre.doubles)) return this.pre.doubles
            if (g === 0) return null
            let U = Math.ceil(N / g) + 1,
              X = new Array(U),
              ne = this.toJ(),
              ee = 0
            X[ee++] = ne
            for (let Y = 0; Y < N; Y += g) {
              for (let z = 0; z < g; z++) ne = ne.dbl()
              X[ee++] = ne
            }
            j(ee === U)
            let ae = this.curve.affinizeAll(X)
            return new E(g, ae)
          }
          _getBeta() {
            return null
          }
          _getBlinding(g) {
            if (this.pre && this.pre.blinding) return this.pre.blinding
            if (!g || this.curve.n.isZero()) return null
            let N = this.curve.randomScalar(g),
              U = this.mul(N)
            return new k(N, U)
          }
          _hasWindows(g) {
            if ((j(g instanceof t), !this.pre || !this.pre.windows)) return !1
            let { width: N, bits: U } = this.pre.windows,
              X = ((U + N - 1) / N) >>> 0
            return g.bitLength() <= X * N
          }
          _hasDoubles(g) {
            if ((j(g instanceof t), !this.pre || !this.pre.doubles)) return !1
            let { step: N, points: U } = this.pre.doubles,
              X = g.bitLength() + 1
            return U.length >= Math.ceil(X / N) + 1
          }
          _getJNAF(g) {
            return j(g instanceof l), j(g.type === this.type), [this, this.add(g), this.sub(g), g]
          }
          _blind(g, N) {
            if ((j(g instanceof t), j(!g.red), this.pre && this.pre.blinding)) {
              let { blind: X, unblind: ne } = this.pre.blinding,
                ee = g.sub(X)
              return [this, ee, ne]
            }
            if (!N) return [this, g, null]
            if (this.pre) {
              if (this.curve.n.isZero()) return [this, g, null]
              let ee = this.curve.randomScalar(N).mul(this.curve.n).iadd(g)
              return [this, ee, null]
            }
            return [this.randomize(N), g, null]
          }
          clone() {
            throw new Error('Not implemented.')
          }
          precompute(g, N) {
            return (
              j(g >>> 0 === g),
              this.pre || (this.pre = new _()),
              this.pre.naf || (this.pre.naf = this._getNAF(9)),
              s && !this.pre.windows && (this.pre.windows = this._getWindows(4, g)),
              this.pre.doubles || (this.pre.doubles = this._getDoubles(4, g + 1)),
              this.pre.beta || (this.pre.beta = this._getBeta()),
              this.pre.blinding || (this.pre.blinding = this._getBlinding(N)),
              this
            )
          }
          validate() {
            return this.curve.validate(this)
          }
          normalize() {
            return this
          }
          scale(g) {
            throw new Error('Not implemented.')
          }
          randomize(g) {
            let N = this.curve.randomField(g)
            return this.scale(N)
          }
          neg() {
            throw new Error('Not implemented.')
          }
          add(g) {
            throw new Error('Not implemented.')
          }
          sub(g) {
            return j(g instanceof l), this.add(g.neg())
          }
          dbl() {
            throw new Error('Not implemented.')
          }
          dblp(g) {
            j(g >>> 0 === g)
            let N = this
            for (let U = 0; U < g; U++) N = N.dbl()
            return N
          }
          diffAddDbl(g, N) {
            throw new Error('Not implemented.')
          }
          getX() {
            throw new Error('Not implemented.')
          }
          getY() {
            throw new Error('Not implemented.')
          }
          eq(g) {
            throw new Error('Not implemented.')
          }
          cmp(g) {
            throw new Error('Not implemented.')
          }
          isInfinity() {
            throw new Error('Not implemented.')
          }
          isOrder2() {
            throw new Error('Not implemented.')
          }
          isOdd() {
            throw new Error('Not implemented.')
          }
          isEven() {
            throw new Error('Not implemented.')
          }
          isSquare() {
            throw new Error('Not implemented.')
          }
          eqX(g) {
            throw new Error('Not implemented.')
          }
          eqR(g) {
            throw new Error('Not implemented.')
          }
          isSmall() {
            return this.isInfinity() ? !1 : this.jmulH().isInfinity()
          }
          hasTorsion() {
            return this.isInfinity() ? !1 : !this.jmul(this.curve.n).isInfinity()
          }
          order() {
            let { h: g, n: N } = this.curve,
              U = this.toJ(),
              X = new t(1)
            for (; !U.isInfinity(); ) {
              if ((X.iaddn(1), X.cmp(g) > 0)) {
                X = N.clone()
                break
              }
              U = U.add(this)
            }
            return X
          }
          mul(g) {
            return this.jmul(g)
          }
          muln(g) {
            return this.jmuln(g)
          }
          mulBlind(g, N) {
            return this.jmulBlind(g, N)
          }
          mulAdd(g, N, U) {
            return this.jmulAdd(g, N, U)
          }
          mulH() {
            return this.jmulH()
          }
          div(g) {
            return this.jdiv(g)
          }
          divn(g) {
            return this.jdivn(g)
          }
          divH() {
            return this.jdivH()
          }
          jmul(g) {
            return s && this._hasWindows(g)
              ? this.curve._fixedMul(this, g)
              : this._hasDoubles(g)
              ? this.curve._fixedNafMul(this, g)
              : this.curve.endo && this.type === n.AFFINE
              ? this.curve._endoWnafMulAdd([this], [g])
              : this.curve._wnafMul(5, this, g)
          }
          jmuln(g) {
            return j((g | 0) === g), this.jmul(new t(g))
          }
          jmulBlind(g, N = null) {
            let [U, X, ne] = this._blind(g, N),
              ee = U.jmul(X)
            return ne ? ee.add(ne) : ee
          }
          jmulAdd(g, N, U) {
            return this.curve.endo && this.type === n.AFFINE
              ? this.curve._endoWnafMulAdd([this, N], [g, U])
              : this.curve._wnafMulAdd(5, [this, N], [g, U])
          }
          jmulH() {
            let g = this.curve.h.word(0)
            if ((g & (g - 1)) == 0) {
              let N = this.curve.h.bitLength()
              return this.toJ().dblp(N - 1)
            }
            return this.jmul(this.curve.h)
          }
          jdiv(g) {
            return j(g instanceof t), j(!g.red), this.jmul(g.invert(this.curve.n))
          }
          jdivn(g) {
            return j(!this.curve.n.isZero()), this.curve.h.cmpn(g) === 0 ? this.jdivH() : this.jdiv(new t(g))
          }
          jdivH() {
            return this.curve.n.isZero()
              ? this.toJ()
              : this.curve.h.cmpn(1) === 0
              ? this.toJ()
              : (this.curve.hi === null && (this.curve.hi = this.curve.h.invert(this.curve.n)),
                this.jmul(this.curve.hi))
          }
          toP() {
            return this.normalize()
          }
          toJ() {
            return this
          }
          toX() {
            return this
          }
          key() {
            if (this.isInfinity()) return `${this.curve.uid}:oo`
            this.normalize()
            let g = this.getX().toString(16),
              N = this.getY().toString(16)
            return `${this.curve.uid}:${g},${N}`
          }
          encode(g) {
            throw new Error('Not implemented.')
          }
          static decode(g, N) {
            throw new Error('Not implemented.')
          }
          encodeX() {
            throw new Error('Not implemented.')
          }
          static decodeX(g, N) {
            throw new Error('Not implemented.')
          }
          static decodeEven(g, N) {
            throw new Error('Not implemented.')
          }
          static decodeSquare(g, N) {
            throw new Error('Not implemented.')
          }
          toJSON(g) {
            throw new Error('Not implemented.')
          }
          static fromJSON(g, N) {
            throw new Error('Not implemented.')
          }
          [r]() {
            return '<Point>'
          }
        },
        a = class extends o {
          constructor(g) {
            super(c, 'short', g)
            ;(this.a = t.fromJSON(g.a).toRed(this.red)),
              (this.b = t.fromJSON(g.b).toRed(this.red)),
              (this.c = t.fromJSON(g.c || '0').toRed(this.red)),
              (this.ai = this.a.isZero() ? this.zero : this.a.redInvert()),
              (this.zi = this.z.isZero() ? this.zero : this.z.redInvert()),
              (this.zeroA = this.a.isZero()),
              (this.threeA = this.a.eq(this.three.redNeg())),
              (this.redN = this.n.toRed(this.red)),
              (this.pmodn = this.p.clone()),
              (this.highOrder = this.n.cmp(this.p) >= 0),
              (this.smallGap = !1),
              this._finalize(g)
          }
          _finalize(g) {
            return (
              super._finalize(g),
              g.endo != null ? (this.endo = w.fromJSON(this, g.endo)) : (this.endo = this._getEndomorphism()),
              this.n.isZero() || ((this.pmodn = this.p.mod(this.n)), (this.smallGap = this.p.div(this.n).cmpn(1) <= 0)),
              this
            )
          }
          static _isomorphism(g, N, U, X) {
            if (
              (j(g instanceof t),
              j(N instanceof t),
              j(U instanceof t),
              j(X == null || typeof X == 'boolean'),
              j(!g.isZero() || !N.isZero()),
              U.isZero())
            )
              throw new Error('Invalid coefficient.')
            if (g.isZero()) {
              let se = U,
                me = se.redDiv(N),
                we = P(me)
              return j(we.redJacobi() === 1), [g.clone(), se.clone()]
            }
            if (N.isZero()) {
              let se = U,
                we = se.redDiv(g).redSqrt()
              if ((we.redJacobi() !== 1 && we.redINeg(), we.redJacobi() !== 1))
                throw new Error('Invalid `a` coefficient.')
              return [se.clone(), N.clone()]
            }
            let ne = U,
              ee = ne.redDiv(g),
              ae = ee.redSqrt()
            if (
              (X != null ? ae.redIsOdd() !== X && ae.redINeg() : ae.redJacobi() !== 1 && ae.redINeg(),
              ae.redJacobi() !== 1)
            )
              throw new Error('Invalid `a` coefficient.')
            let Y = ee.redMul(ae),
              z = g.redMul(ee),
              H = N.redMul(Y)
            return j(z.eq(ne)), [z, H]
          }
          _short(g, N) {
            return a._isomorphism(this.a, this.b, g, N)
          }
          _mont(g, N) {
            let [U, X] = this._findRS(N),
              ne = X.redInvert(),
              ee = U.redMuln(3).redMul(ne)
            return g != null ? p._isomorphism(ee, ne, g) : [ee, ne]
          }
          _edwards(g, N) {
            let [U, X] = this._findRS(N),
              ne = U.redMuln(3),
              ee = X.redMuln(2),
              ae = ne.redAdd(ee),
              Y = ne.redSub(ee)
            return g != null ? h._isomorphism(ae, Y, g) : [ae, Y]
          }
          _findRS(g) {
            j(g == null || typeof g == 'boolean'), j(this.h.word(0) >= 4), j(!this.n.isZero())
            let N = this.one.redNeg(),
              U
            for (;;) {
              N.redIAdd(this.one)
              try {
                U = this.pointFromX(N.clone())
              } catch (ae) {
                continue
              }
              if (((U = U.mul(this.n)), !U.isInfinity() && !!U.y.isZero())) break
            }
            let X = U.x,
              ee = X.redSqr().redMuln(3).redIAdd(this.a).redSqrt()
            return g != null && ee.redIsOdd() !== g && ee.redINeg(), [X, ee]
          }
          _scale0(g, N) {
            if ((j(this.a.isZero() === g.isZero()), j(this.b.isZero() === N.isZero()), this.a.isZero())) {
              let Y = this.b.redDiv(this.field(N)),
                z = P(Y),
                H = z.redSqrt(),
                se = z.redMul(H)
              return j(se.redSqr().eq(Y)), j(!H.isZero()), [z, se]
            }
            if (this.b.isZero()) {
              let Y = this.a.redDiv(this.field(g)),
                z = Y.redSqrt()
              z.redJacobi() !== 1 && z.redINeg()
              let H = z.redSqrt(),
                se = z.redMul(H)
              return j(se.redMul(H).eq(Y)), j(!H.isZero()), [z, se]
            }
            let U = this.a.redDiv(this.field(g)),
              X = this.b.redDiv(this.field(N)),
              ne = U.redSqrt()
            U.redMul(ne).eq(X) || ne.redINeg(), j(U.redMul(ne).eq(X))
            let ee = ne.redSqrt(),
              ae = ne.redMul(ee)
            return j(!ee.isZero()), [ne, ae]
          }
          _scale1(g, N) {
            let U = this.g.x.redDiv(this.field(g)),
              X = this.g.y.redDiv(this.field(N)),
              ne = U.redSqrt()
            return U.redMul(ne).eq(X) || ne.redINeg(), j(U.redMul(ne).eq(X)), j(!ne.isZero()), [U, X]
          }
          _scaleShort(g) {
            return (
              j(g instanceof a),
              this.g.isInfinity() || g.g.isInfinity() ? this._scale0(g.a, g.b) : this._scale1(g.g.x, g.g.y)
            )
          }
          _scaleMont(g) {
            if ((j(g instanceof p), this.g.isInfinity() || g.g.isInfinity())) {
              let [ee, ae] = g._short()
              return this._scale0(ee, ae)
            }
            let { x: N, y: U } = g.g,
              X = N.redAdd(g.a3).redMul(g.bi),
              ne = U.redMul(g.bi)
            return this._scale1(X, ne)
          }
          _scaleEdwards(g) {
            if ((j(g instanceof h), this.g.isInfinity() || g.g.isInfinity())) {
              let [Oe, ht] = g._short()
              return this._scale0(Oe, ht)
            }
            let { x: N, y: U, z: X } = g.g,
              ne = g.a.redMuln(5),
              ee = g.d.redMuln(5),
              ae = g.d.redSub(g.a),
              Y = ee.redSub(g.a),
              z = g.d.redSub(ne),
              H = U.redAdd(X),
              se = U.redSub(X),
              me = Y.redMul(U).redIAdd(z.redMul(X)),
              we = se.redMuln(12),
              Ee = ae.redMul(H).redMul(X),
              Me = se.redMul(N).redIMuln(4),
              Be = we.redMul(Me).redInvert(),
              je = me.redMul(Me).redMul(Be),
              Pe = Ee.redMul(we).redMul(Be)
            return this._scale1(je, Pe)
          }
          _getEndomorphism(g = 0) {
            if (this.n.isZero() || this.g.isInfinity() || !this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
              return null
            let [N, U] = this._getEndoRoots(this.p),
              X = [N, U][g & 1].toRed(this.red),
              [ne, ee] = this._getEndoRoots(this.n),
              ae = this.point(this.g.x.redMul(X), this.g.y),
              Y
            this.g.mul(ne).eq(ae) ? (Y = ne) : (j(this.g.mul(ee).eq(ae)), (Y = ee))
            let z = this._getEndoBasis(Y),
              H = this._getEndoPrecomp(z)
            return new w(X, Y, z, H)
          }
          _getEndoRoots(g) {
            let N = g === this.p ? this.red : t.mont(g),
              U = new t(2).toRed(N),
              X = new t(3).toRed(N),
              ne = U.redInvert(),
              ee = X.redNeg().redSqrt().redMul(ne),
              ae = ee.redNeg(),
              Y = ee.redSub(ne).fromRed(),
              z = ae.redSub(ne).fromRed()
            return [Y, z].sort(t.cmp)
          }
          _getEndoBasis(g) {
            let [N, U, X, ne, ee, ae] = this._egcdSqrt(g),
              Y = X,
              z = ne.neg(),
              H = N.sqr().iadd(U.sqr()),
              se = ee.sqr().iadd(ae.sqr()),
              me,
              we
            return (
              H.cmp(se) <= 0 ? ((me = N), (we = U.neg())) : ((me = ee), (we = ae.neg())), [new v(Y, z), new v(me, we)]
            )
          }
          _egcdSqrt(g) {
            j(g instanceof t), j(!g.red), j(g.sign() > 0), j(this.n.sign() > 0)
            let N = this.n.ushrn(this.n.bitLength() >>> 1),
              U = g,
              X = this.n.clone(),
              ne = new t(1),
              ee = new t(0),
              ae = new t(0),
              Y = new t(1),
              z,
              H,
              se,
              me,
              we = 0,
              Ee = 0,
              Me
            for (; !U.isZero() && we < 2; ) {
              let Pe = X.quo(U),
                Oe = X.sub(Pe.mul(U)),
                ht = ae.sub(Pe.mul(ne)),
                Qe = Y.sub(Pe.mul(ee))
              Ee === 0 && Oe.cmp(N) < 0 && ((z = Me), (H = ne), (se = Oe), (me = ht), (Ee = 1)),
                (Me = Oe),
                (X = U),
                (U = Oe),
                (ae = ne),
                (ne = ht),
                (Y = ee),
                (ee = Qe),
                (we += Ee)
            }
            return j(Ee !== 0, 'Could not find r < sqrt(n).'), [z, H, se, me, ae, ne]
          }
          _getEndoPrecomp(g) {
            j(Array.isArray(g)), j(g.length === 2), j(g[0] instanceof v), j(g[1] instanceof v)
            let [N, U] = g,
              X = N.a.mul(U.b).isub(N.b.mul(U.a)),
              ne = X.bitLength(),
              ee = ne >= 160
            j(X.eq(this.n))
            let ae = ne + Math.ceil(ne / 2) + 1,
              Y,
              z
            for (
              ee && (ae -= ae & 63);
              ae > ne &&
              ((Y = U.b.ushln(ae).divRound(X)), (z = N.b.ushln(ae).divRound(X)), !(Y.ucmp(X) < 0 && z.ucmp(X) < 0));

            )
              ee ? (ae -= 64) : (ae -= 1)
            if (ae <= ne) throw new Error('Could not calculate g1 and g2.')
            return [ae, Y, z]
          }
          _endoSplit(g) {
            j(g instanceof t), j(!g.red), j(!this.n.isZero())
            let [N, U] = this.endo.basis,
              X = U.b.mul(g).divRound(this.n),
              ne = N.b.neg().mul(g).divRound(this.n),
              ee = X.mul(N.a),
              ae = ne.mul(U.a),
              Y = X.ineg().mul(N.b),
              z = ne.mul(U.b),
              H = g.sub(ee).isub(ae),
              se = Y.isub(z)
            return [H, se]
          }
          _endoBeta(g) {
            return j(g instanceof c), [g, g._getBeta()]
          }
          _endoWnafMulAdd(g, N) {
            j(Array.isArray(g)), j(Array.isArray(N)), j(g.length === N.length), j(this.endo != null)
            let U = g.length,
              X = new Array(U * 2),
              ne = new Array(U * 2)
            for (let ee = 0; ee < U; ee++) {
              let [ae, Y] = this._endoBeta(g[ee]),
                [z, H] = this._endoSplit(N[ee])
              ;(X[ee * 2 + 0] = ae), (ne[ee * 2 + 0] = z), (X[ee * 2 + 1] = Y), (ne[ee * 2 + 1] = H)
            }
            return this._wnafMulAdd(5, X, ne)
          }
          _sswu(g) {
            let { b: N, z: U, ai: X, zi: ne, one: ee } = this,
              ae = U.redSqr(),
              Y = N.redNeg().redMul(X),
              z = N.redMul(ne).redMul(X),
              H = g.redSqr(),
              se = H.redSqr(),
              me = ae.redMul(se).redIAdd(U.redMul(H)),
              we = me.isZero() ? me : me.redInvert(),
              Ee = we.isZero() ? z : Y.redMul(ee.redAdd(we)),
              Me = U.redMul(H).redMul(Ee),
              Be = this.solveY2(Ee),
              je = this.solveY2(Me),
              Pe = Be.redIsSquare() | 0,
              Oe = [Ee, Me][Pe ^ 1],
              ht = [Be, je][Pe ^ 1].redSqrt()
            return ht.redIsOdd() !== g.redIsOdd() && ht.redINeg(), this.point(Oe, ht)
          }
          _sswui(g, N) {
            let { a: U, b: X, z: ne } = this,
              { x: ee, y: ae } = g,
              Y = N & 3,
              z = U.redSqr().redMul(ee.redSqr()),
              H = U.redMul(X).redMul(ee).redIMuln(2),
              se = X.redSqr().redMuln(3),
              me = U.redMul(ee).redIAdd(X),
              we = z.redISub(H).redISub(se).redSqrt(),
              Ee = me.redSub(we).redINeg(),
              Me = me.redAdd(we).redINeg(),
              Be = me.redMul(ne).redIMuln(2),
              je = X.redMul(ne).redIMuln(2),
              Pe = [Ee, Me][Y & 1],
              Oe = [Be, je][Y >>> 1],
              ht = Pe.redDivSqrt(Oe)
            return ht.redIsOdd() !== ae.redIsOdd() && ht.redINeg(), ht
          }
          _svdwf(g) {
            let { c: N, z: U, zi: X, i2: ne, i3: ee } = this,
              ae = this.solveY2(U),
              Y = ee.redMul(X.redSqr()),
              z = g.redSqr(),
              H = z.redSqr(),
              se = z.redAdd(ae),
              me = z.redMul(se),
              we = me.isZero() ? me : me.redInvert(),
              Ee = H.redMul(we).redMul(N),
              Me = se.redSqr().redMul(se),
              Be = N.redSub(U).redMul(ne).redISub(Ee),
              je = Ee.redSub(N.redAdd(U).redMul(ne)),
              Pe = U.redSub(Me.redMul(we).redMul(Y)),
              Oe = this.solveY2(Be),
              ht = this.solveY2(je),
              Qe = this.solveY2(Pe),
              et = Oe.redJacobi() | 1,
              Mt = ht.redJacobi() | 1,
              ut = C((et - 1) * Mt, 3),
              at = [Be, je, Pe][ut],
              Pt = [Oe, ht, Qe][ut]
            return [at, Pt]
          }
          _svdw(g) {
            let [N, U] = this._svdwf(g),
              X = U.redSqrt()
            return X.redIsOdd() !== g.redIsOdd() && X.redINeg(), this.point(N, X)
          }
          _svdwi(g, N) {
            let { b: U, c: X, z: ne, zero: ee, two: ae } = this,
              { x: Y, y: z } = g,
              H = N & 3,
              se = ne.redSqr(),
              me = se.redMul(ne),
              we = se.redSqr(),
              Ee = me.redAdd(U),
              Me = Ee.redMuln(2),
              Be = Y.redSqr(),
              je = Y.redMuln(2).redIAdd(ne),
              Pe = Y.redMul(se),
              Oe = X.redSub(je),
              ht = X.redAdd(je),
              Qe = Be.redMul(se).redIAdd(we).redIMuln(9),
              et = Y.redMul(me).redIMuln(18),
              Mt = Ee.redMul(Y.redSub(ne)).redIMuln(12),
              at = (H >= 2 ? Qe.redISub(et).redIAdd(Mt).redSqrt() : ee).redMul(ne),
              Pt = me.redISub(Pe).redIMuln(3).redISub(Me),
              ft = Ee.redMul(Oe),
              We = Ee.redMul(ht),
              gt = Pt.redAdd(at),
              Ge = Pt.redSub(at),
              He = ae,
              wt = [ft, We, gt, Ge][H],
              tt = [ht, Oe, He, He][H],
              Xe = wt.redDivSqrt(tt),
              [_t] = this._svdwf(Xe)
            if (!_t.eq(Y)) throw new Error('Invalid point.')
            return Xe.redIsOdd() !== z.redIsOdd() && Xe.redINeg(), Xe
          }
          isElliptic() {
            let { a: g, b: N } = this,
              X = g.redSqr().redMul(g)
            return !N.redSqr().redMuln(27).redIAdd(X.redMuln(4)).isZero()
          }
          jinv() {
            let { a: g, b: N } = this,
              X = g.redSqr().redMul(g),
              ne = N.redSqr(),
              ee = X.redMuln(4),
              ae = ee.redMuln(1728),
              Y = ne.redMuln(27).redIAdd(ee)
            if (Y.isZero()) throw new Error('Curve is not elliptic.')
            return ae.redDiv(Y).fromRed()
          }
          point(g, N) {
            return new c(this, g, N)
          }
          jpoint(g, N, U) {
            return new f(this, g, N, U)
          }
          solveX(g) {
            if ((j(g instanceof t), !this.a.isZero())) throw new Error('Not implemented.')
            let U = g.redSqr().redSub(this.b)
            return R(U)
          }
          solveY2(g) {
            j(g instanceof t)
            let U = g.redSqr().redMul(g).redIAdd(this.b)
            return this.zeroA || (this.threeA ? U.redIAdd(g.redMuln(-3)) : U.redIAdd(this.a.redMul(g))), U
          }
          validate(g) {
            if ((j(g instanceof c), g.inf)) return !0
            let { x: N, y: U } = g,
              X = this.solveY2(N)
            return U.redSqr().eq(X)
          }
          pointFromX(g, N = null) {
            j(g instanceof t), j(N == null || typeof N == 'boolean'), g.red || (g = g.toRed(this.red))
            let U = this.solveY(g)
            if (N != null) {
              if (this.h.cmpn(1) > 0 && U.isZero() && N) throw new Error('Invalid point.')
              U.redIsOdd() !== N && U.redINeg()
            }
            return this.point(g, U)
          }
          pointFromY(g, N = 0) {
            j(g instanceof t), j(N >>> 0 === N), g.red || (g = g.toRed(this.red))
            let U = this.solveX(g)
            if (N >= U.length) throw new Error('Invalid X coordinate index.')
            let X = U[N]
            return this.point(X, g)
          }
          isIsomorphic(g) {
            if ((j(g instanceof o), !g.p.eq(this.p))) return !1
            let N, U
            try {
              ;[N, U] = this._scale(g)
            } catch (X) {
              return !1
            }
            if (g.type === 'short') {
              let X = this.field(g.a).redMul(N.redSqr()),
                ne = this.field(g.b).redMul(U.redSqr())
              return this.a.eq(X) && this.b.eq(ne)
            }
            if (g.type === 'mont') {
              let { a3: X, bi: ne } = g,
                ee = this.field(X.redMul(ne)).redMul(N)
              return this.solveY2(ee).isZero()
            }
            if (g.type === 'edwards') {
              let X = this.field(g.ad6).redMul(N)
              return this.solveY2(X).isZero()
            }
            return !1
          }
          isIsogenous(g) {
            return j(g instanceof o), !1
          }
          pointFromShort(g) {
            if ((j(g instanceof c), this.isIsomorphic(g.curve))) {
              if (g.isInfinity()) return this.point()
              let [N, U] = this._scale(g.curve),
                X = this.field(g.x),
                ne = this.field(g.y),
                ee = X.redMul(N),
                ae = ne.redMul(U)
              return this.point(ee, ae)
            }
            throw new Error('Not implemented.')
          }
          pointFromMont(g) {
            if ((j(g instanceof y), this.isIsomorphic(g.curve))) {
              if (g.isInfinity()) return this.point()
              let { a3: N, bi: U } = g.curve,
                [X, ne] = this._scale(g.curve),
                ee = g.x.redAdd(N).redMul(U),
                ae = g.y.redMul(U)
              return this.point(this.field(ee).redMul(X), this.field(ae).redMul(ne))
            }
            throw new Error('Not implemented.')
          }
          pointFromEdwards(g) {
            if ((j(g instanceof m), this.isIsomorphic(g.curve))) {
              let { a: N, d: U, ad6: X } = g.curve,
                [ne, ee] = this._scale(g.curve)
              if (g.isInfinity()) return this.point()
              if (g.x.isZero()) {
                let Qe = this.field(X).redMul(ne)
                return this.point(Qe, this.zero)
              }
              let { x: ae, y: Y, z } = g,
                H = N.redMuln(5),
                se = U.redMuln(5),
                me = U.redSub(N),
                we = se.redSub(N),
                Ee = U.redSub(H),
                Me = Y.redAdd(z),
                Be = Y.redSub(z),
                je = we.redMul(Y).redIAdd(Ee.redMul(z)),
                Pe = Be.redMuln(12),
                Oe = me.redMul(Me).redMul(z),
                ht = Be.redMul(ae).redIMuln(4)
              return this.cpoint(this.field(je).redMul(ne), this.field(Pe), this.field(Oe).redMul(ee), this.field(ht))
            }
            throw new Error('Not implemented.')
          }
          pointFromUniform(g) {
            if ((j(g instanceof t), this.z.isZero() || this.b.isZero())) throw new Error('Not implemented.')
            if (!this.a.isZero()) return this._sswu(g)
            if (!this.c.isZero()) return this._svdw(g)
            throw new Error('Not implemented.')
          }
          pointToUniform(g, N) {
            if ((j(g instanceof c), j(N >>> 0 === N), this.z.isZero() || this.b.isZero()))
              throw new Error('Not implemented.')
            if (g.isInfinity()) throw new Error('Invalid point.')
            let U = ((N >>> 4) & 15) % this.torsion.length,
              X = g.add(this.torsion[U])
            return b(() => {
              if (!this.a.isZero()) return this._sswui(X, N)
              if (!this.c.isZero()) return this._svdwi(X, N)
              throw new Error('Not implemented.')
            })
          }
          mulAll(g, N) {
            return super.mulAll(g, N).toP()
          }
          affinizeAll(g) {
            let N = this.normalizeAll(g)
            for (let U = 0; U < N.length; U++) N[U] = N[U].toP()
            return N
          }
          decodePoint(g) {
            return c.decode(this, g)
          }
          encodeX(g) {
            return j(g instanceof l), g.encodeX()
          }
          decodeEven(g) {
            return c.decodeEven(this, g)
          }
          decodeSquare(g) {
            return c.decodeSquare(this, g)
          }
          toShort(g, N, U = null) {
            let [X, ne] = this._short(g, N),
              ee = new a({ red: this.red, prime: this.prime, p: this.p, a: X, b: ne, n: this.n, h: this.h })
            if (U != null) {
              let [, ae] = ee._scale(this)
              ae.redIsOdd() !== U && ae.redINeg()
            }
            this.g.isInfinity() || (ee.g = ee.pointFromShort(this.g))
            for (let ae = 0; ae < this.h.word(0); ae++) ee.torsion[ae] = ee.pointFromShort(this.torsion[ae])
            return ee
          }
          toMont(g, N, U = null) {
            let [X, ne] = this._mont(g, N),
              ee = new p({ red: this.red, prime: this.prime, p: this.p, a: X, b: ne, n: this.n, h: this.h })
            if (U != null) {
              let [, ae] = this._scale(ee)
              ae.redIsOdd() !== U && ae.redINeg()
            }
            this.g.isInfinity() || (ee.g = ee.pointFromShort(this.g))
            for (let ae = 0; ae < this.h.word(0); ae++) ee.torsion[ae] = ee.pointFromShort(this.torsion[ae])
            return ee
          }
          toEdwards(g, N, U = null) {
            let [X, ne] = this._edwards(g, N),
              ee = new h({ red: this.red, prime: this.prime, p: this.p, a: X, d: ne, n: this.n, h: this.h })
            if (U != null) {
              let [, ae] = this._scale(ee)
              ae.redIsOdd() !== U && ae.redINeg()
            }
            if ((this.g.isInfinity() || ((ee.g = ee.pointFromShort(this.g)), ee.g.normalize()), ee.isComplete()))
              for (let ae = 0; ae < this.h.word(0); ae++)
                (ee.torsion[ae] = ee.pointFromShort(this.torsion[ae])), ee.torsion[ae].normalize()
            return ee
          }
          pointFromJSON(g) {
            return c.fromJSON(this, g)
          }
          toJSON(g) {
            let N = super.toJSON(g)
            return (
              (N.a = this.a.fromRed().toJSON()),
              (N.b = this.b.fromRed().toJSON()),
              this.c.isZero() || (N.c = this.c.fromRed().toJSON()),
              N
            )
          }
        },
        c = class extends l {
          constructor(g, N, U) {
            j(g instanceof a)
            super(g, n.AFFINE)
            ;(this.x = this.curve.zero), (this.y = this.curve.zero), (this.inf = !0), N != null && this._init(N, U)
          }
          _init(g, N) {
            j(g instanceof t),
              j(N instanceof t),
              (this.x = g),
              (this.y = N),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              (this.inf = !1)
          }
          _getBeta() {
            if (!this.curve.endo) return null
            if (this.pre && this.pre.beta) return this.pre.beta
            let g = this.x.redMul(this.curve.endo.beta),
              N = this.curve.point(g, this.y)
            return (
              this.pre &&
                ((N.pre = this.pre.map((U) => {
                  let X = U.x.redMul(this.curve.endo.beta)
                  return this.curve.point(X, U.y)
                })),
                (this.pre.beta = N)),
              N
            )
          }
          _getJNAF(g) {
            if ((j(g instanceof c), this.inf || g.inf)) return super._getJNAF(g)
            let N = [this, null, null, g]
            return (
              this.y.eq(g.y)
                ? ((N[1] = this.add(g)), (N[2] = this.toJ().sub(g)))
                : this.y.eq(g.y.redNeg())
                ? ((N[1] = this.toJ().add(g)), (N[2] = this.sub(g)))
                : ((N[1] = this.toJ().add(g)), (N[2] = this.toJ().sub(g))),
              N
            )
          }
          clone() {
            return this.inf ? this.curve.point() : this.curve.point(this.x, this.y)
          }
          scale(g) {
            return this.toJ().scale(g)
          }
          neg() {
            return this.inf ? this : this.curve.point(this.x, this.y.redNeg())
          }
          add(g) {
            if ((j(g instanceof c), this.inf)) return g
            if (g.inf) return this
            if (this.x.eq(g.x)) return this.y.eq(g.y) ? this.dbl() : this.curve.point()
            if (this.y.eq(g.y)) {
              let ae = this.x.redNeg().redISub(g.x),
                Y = this.y.redNeg()
              return this.curve.point(ae, Y)
            }
            let N = this.x.redSub(g.x),
              X = this.y.redSub(g.y).redDiv(N),
              ne = X.redSqr().redISub(this.x).redISub(g.x),
              ee = X.redMul(this.x.redSub(ne)).redISub(this.y)
            return this.curve.point(ne, ee)
          }
          dbl() {
            if (this.inf) return this
            if (this.y.isZero()) return this.curve.point()
            let N = this.x.redSqr().redIMuln(3).redIAdd(this.curve.a),
              U = this.y.redMuln(2),
              X = N.redDiv(U),
              ne = X.redSqr().redISub(this.x).redISub(this.x),
              ee = X.redMul(this.x.redSub(ne)).redISub(this.y)
            return this.curve.point(ne, ee)
          }
          dblp(g) {
            return this.toJ().dblp(g).toP()
          }
          getX() {
            if (this.inf) throw new Error('Invalid point.')
            return this.x.fromRed()
          }
          getY() {
            if (this.inf) throw new Error('Invalid point.')
            return this.y.fromRed()
          }
          eq(g) {
            return j(g instanceof c), this === g ? !0 : this.inf ? g.inf : g.inf ? !1 : this.x.eq(g.x) && this.y.eq(g.y)
          }
          cmp(g) {
            return (
              j(g instanceof c),
              this.inf && !g.inf
                ? -1
                : !this.inf && g.inf
                ? 1
                : this.inf && g.inf
                ? 0
                : this.order().cmp(g.order()) || this.getX().cmp(g.getX()) || this.getY().cmp(g.getY())
            )
          }
          isInfinity() {
            return this.inf
          }
          isOrder2() {
            return this.inf ? !1 : this.y.isZero()
          }
          isOdd() {
            return this.inf ? !1 : this.y.redIsOdd()
          }
          isEven() {
            return this.inf ? !1 : this.y.redIsEven()
          }
          isSquare() {
            return this.inf ? !1 : this.y.redJacobi() !== -1
          }
          eqX(g) {
            return j(g instanceof t), j(!g.red), this.inf ? !1 : this.getX().eq(g)
          }
          eqR(g) {
            return (
              j(g instanceof t),
              j(!g.red),
              j(!this.curve.n.isZero()),
              this.inf ? !1 : this.getX().imod(this.curve.n).eq(g)
            )
          }
          mul(g) {
            return super.mul(g).toP()
          }
          muln(g) {
            return super.muln(g).toP()
          }
          mulBlind(g, N) {
            return super.mulBlind(g, N).toP()
          }
          mulAdd(g, N, U) {
            return super.mulAdd(g, N, U).toP()
          }
          mulH() {
            return super.mulH().toP()
          }
          div(g) {
            return super.div(g).toP()
          }
          divn(g) {
            return super.divn(g).toP()
          }
          divH() {
            return super.divH().toP()
          }
          toP() {
            return this
          }
          toJ() {
            return this.inf ? this.curve.jpoint() : this.curve.jpoint(this.x, this.y, this.curve.one)
          }
          encode(g) {
            g == null && (g = !0), j(typeof g == 'boolean')
            let { fieldSize: N } = this.curve
            if (this.inf) throw new Error('Invalid point.')
            if (g) {
              let ee = Ve.Buffer.alloc(1 + N),
                ae = this.curve.encodeField(this.getX())
              return (ee[0] = 2 | this.y.redIsOdd()), ae.copy(ee, 1), ee
            }
            let U = Ve.Buffer.alloc(1 + N * 2),
              X = this.curve.encodeField(this.getX()),
              ne = this.curve.encodeField(this.getY())
            return (U[0] = 4), X.copy(U, 1), ne.copy(U, 1 + N), U
          }
          static decode(g, N) {
            j(g instanceof a), j(Ve.Buffer.isBuffer(N))
            let U = g.fieldSize
            if (N.length < 1 + U) throw new Error('Not a point.')
            let X = N[0]
            switch (X) {
              case 2:
              case 3: {
                if (N.length !== 1 + U) throw new Error('Invalid point size for compressed.')
                let ne = g.decodeField(N.slice(1, 1 + U))
                if (ne.cmp(g.p) >= 0) throw new Error('Invalid point.')
                let ee = g.pointFromX(ne, X === 3)
                return j(!ee.isInfinity()), ee
              }
              case 4:
              case 6:
              case 7: {
                if (N.length !== 1 + U * 2) throw new Error('Invalid point size for uncompressed.')
                let ne = g.decodeField(N.slice(1, 1 + U)),
                  ee = g.decodeField(N.slice(1 + U, 1 + 2 * U))
                if (ne.cmp(g.p) >= 0 || ee.cmp(g.p) >= 0) throw new Error('Invalid point.')
                if (X !== 4 && X !== (6 | ee.isOdd())) throw new Error('Invalid hybrid encoding.')
                let ae = g.point(ne, ee)
                if (!ae.validate()) throw new Error('Invalid point.')
                return j(!ae.isInfinity()), ae
              }
              default:
                throw new Error('Unknown point format.')
            }
          }
          encodeX() {
            return this.curve.encodeField(this.getX())
          }
          static decodeEven(g, N) {
            j(g instanceof a)
            let U = g.decodeField(N)
            if (U.cmp(g.p) >= 0) throw new Error('Invalid point.')
            return g.pointFromX(U, !1)
          }
          static decodeSquare(g, N) {
            j(g instanceof a)
            let U = g.decodeField(N)
            if (U.cmp(g.p) >= 0) throw new Error('Invalid point.')
            return g.pointFromX(U)
          }
          toJSON(g) {
            if (this.inf) return []
            let N = this.getX().toJSON(),
              U = this.getY().toJSON()
            return g === !0 && this.pre ? [N, U, this.pre.toJSON()] : [N, U]
          }
          toPretty() {
            if (this.inf) return []
            let g = this.curve.fieldSize * 2,
              N = $(this.getX(), g),
              U = $(this.getY(), g)
            return [N, U]
          }
          static fromJSON(g, N) {
            if (
              (j(g instanceof a),
              j(Array.isArray(N)),
              j(N.length === 0 || N.length === 2 || N.length === 3),
              N.length === 0)
            )
              return g.point()
            let U = t.fromJSON(N[0]),
              X = t.fromJSON(N[1]),
              ne = g.point(U, X)
            return N.length > 2 && N[2] != null && (ne.pre = _.fromJSON(ne, N[2])), ne
          }
          [r]() {
            return this.inf
              ? '<ShortPoint: Infinity>'
              : '<ShortPoint: x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>'
          }
        },
        f = class extends l {
          constructor(g, N, U, X) {
            j(g instanceof a)
            super(g, n.JACOBIAN)
            ;(this.x = this.curve.one),
              (this.y = this.curve.one),
              (this.z = this.curve.zero),
              (this.zOne = !1),
              N != null && this._init(N, U, X)
          }
          _init(g, N, U) {
            j(g instanceof t),
              j(N instanceof t),
              j(U == null || U instanceof t),
              (this.x = g),
              (this.y = N),
              (this.z = U || this.curve.one),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              this.z.red || (this.z = this.z.toRed(this.curve.red)),
              (this.zOne = this.z.eq(this.curve.one))
          }
          clone() {
            return this.curve.jpoint(this.x, this.y, this.z)
          }
          validate() {
            let { a: g, b: N } = this.curve
            if (this.isInfinity()) return !0
            if (this.zOne) return this.curve.validate(this.toP())
            let U = this.y.redSqr(),
              X = this.x.redSqr().redMul(this.x),
              ne = this.z.redSqr(),
              ee = ne.redSqr(),
              ae = ee.redMul(ne),
              Y = X.redIAdd(N.redMul(ae))
            return (
              this.curve.zeroA ||
                (this.curve.threeA
                  ? Y.redIAdd(ee.redIMuln(-3).redMul(this.x))
                  : Y.redIAdd(g.redMul(ee).redMul(this.x))),
              U.eq(Y)
            )
          }
          normalize() {
            if (this.zOne) return this
            if (this.isInfinity()) return this
            let g = this.z.redInvert(),
              N = g.redSqr()
            return (
              (this.x = this.x.redMul(N)),
              (this.y = this.y.redMul(N).redMul(g)),
              (this.z = this.curve.one),
              (this.zOne = !0),
              this
            )
          }
          scale(g) {
            if ((j(g instanceof t), this.isInfinity())) return this.curve.jpoint()
            let N = g.redSqr(),
              U = this.x.redMul(N),
              X = this.y.redMul(N).redMul(g),
              ne = this.z.redMul(g)
            return this.curve.jpoint(U, X, ne)
          }
          neg() {
            return this.curve.jpoint(this.x, this.y.redNeg(), this.z)
          }
          add(g) {
            return j(g instanceof l), g.type === n.AFFINE ? this._mixedAdd(g) : this._add(g)
          }
          _add(g) {
            return (
              j(g instanceof f),
              this.isInfinity()
                ? g
                : g.isInfinity()
                ? this
                : this.zOne
                ? g._addJA(this)
                : g.zOne
                ? this._addJA(g)
                : this._addJJ(g)
            )
          }
          _mixedAdd(g) {
            return j(g instanceof c), this.isInfinity() ? g.toJ() : g.isInfinity() ? this : this._addJA(g)
          }
          _addJJ(g) {
            let N = this.z.redSqr(),
              U = g.z.redSqr(),
              X = this.x.redMul(U),
              ne = g.x.redMul(N),
              ee = this.y.redMul(g.z).redMul(U),
              ae = g.y.redMul(this.z).redMul(N),
              Y = ne.redISub(X),
              z = ae.redISub(ee)
            if (Y.isZero()) return z.isZero() ? this.dbl() : this.curve.jpoint()
            let H = Y.redSqr(),
              se = Y.redMul(H),
              me = X.redMul(H),
              we = z.redSqr().redISub(se).redISub(me).redISub(me),
              Ee = z.redMul(me.redISub(we)).redISub(ee.redMul(se)),
              Me = this.z.redMul(g.z).redMul(Y)
            return this.curve.jpoint(we, Ee, Me)
          }
          _addJA(g) {
            let N = this.z.redSqr(),
              U = g.x.redMul(N),
              X = g.y.redMul(this.z).redMul(N),
              ne = U.redISub(this.x),
              ee = X.redISub(this.y).redIMuln(2)
            if (ne.isZero()) return ee.isZero() ? this.dbl() : this.curve.jpoint()
            let ae = ne.redMuln(2).redSqr(),
              Y = ne.redMul(ae),
              z = this.x.redMul(ae),
              H = ee.redSqr().redISub(Y).redISub(z).redISub(z),
              se = ee.redMul(z.redISub(H)).redISub(this.y.redMul(Y).redIMuln(2)),
              me = this.z.redMul(ne).redIMuln(2)
            return this.curve.jpoint(H, se, me)
          }
          dbl() {
            return this.isInfinity()
              ? this
              : this.y.isZero()
              ? this.curve.jpoint()
              : this.curve.zeroA
              ? this._dbl0()
              : this.curve.threeA
              ? this._dbl3()
              : this._dblJ()
          }
          _dblJ() {
            let g = this.x.redSqr(),
              N = this.y.redSqr(),
              U = this.z.redSqr(),
              X = this.x.redMul(N).redIMuln(4),
              ne = g.redIMuln(3).redIAdd(this.curve.a.redMul(U.redSqr())),
              ee = ne.redSqr().redISub(X).redISub(X),
              ae = ee,
              Y = ne.redMul(X.redISub(ee)).redISub(N.redSqr().redIMuln(8)),
              z = this.y.redMul(this.z).redIMuln(2)
            return this.curve.jpoint(ae, Y, z)
          }
          _dbl0() {
            let g = this.x.redSqr(),
              N = this.y.redSqr(),
              U = N.redSqr(),
              ne = N.redIAdd(this.x).redSqr().redISub(g).redISub(U).redIMuln(2),
              ee = g.redIMuln(3),
              Y = ee.redSqr().redISub(ne).redISub(ne),
              z = ee.redMul(ne.redISub(Y)).redISub(U.redIMuln(8)),
              H = this.y.redMul(this.z).redIMuln(2)
            return this.curve.jpoint(Y, z, H)
          }
          _dbl3() {
            let g = this.z.redSqr(),
              N = this.y.redSqr(),
              U = this.x.redMul(N),
              X = this.x.redSub(g),
              ne = this.x.redAdd(g),
              ee = X.redMul(ne).redIMuln(3),
              ae = U.redIMuln(4),
              Y = ae.redMuln(2),
              z = N.redSqr().redIMuln(8),
              H = ee.redSqr().redISub(Y),
              se = this.y.redAdd(this.z).redSqr().redISub(N).redISub(g),
              me = ee.redMul(ae.redISub(H)).redISub(z)
            return this.curve.jpoint(H, me, se)
          }
          getX() {
            if (this.isInfinity()) throw new Error('Invalid point.')
            return this.normalize(), this.x.fromRed()
          }
          getY() {
            if (this.isInfinity()) throw new Error('Invalid point.')
            return this.normalize(), this.y.fromRed()
          }
          eq(g) {
            if ((j(g instanceof f), this === g)) return !0
            if (this.isInfinity()) return g.isInfinity()
            if (g.isInfinity()) return !1
            if (this.z.eq(g.z)) return this.x.eq(g.x) && this.y.eq(g.y)
            let N = this.z.redSqr(),
              U = g.z.redSqr(),
              X = this.x.redMul(U),
              ne = g.x.redMul(N)
            if (!X.eq(ne)) return !1
            let ee = N.redMul(this.z),
              ae = U.redMul(g.z),
              Y = this.y.redMul(ae),
              z = g.y.redMul(ee)
            return Y.eq(z)
          }
          cmp(g) {
            j(g instanceof f)
            let N = this.isInfinity(),
              U = g.isInfinity()
            return N && !U
              ? -1
              : !N && U
              ? 1
              : N && U
              ? 0
              : this.order().cmp(g.order()) || this.getX().cmp(g.getX()) || this.getY().cmp(g.getY())
          }
          isInfinity() {
            return this.z.isZero()
          }
          isOrder2() {
            return this.isInfinity() ? !1 : this.y.isZero()
          }
          isOdd() {
            return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsOdd())
          }
          isEven() {
            return this.isInfinity() ? !1 : (this.normalize(), this.y.redIsEven())
          }
          isSquare() {
            return this.isInfinity() ? !1 : this.y.redMul(this.z).redJacobi() !== -1
          }
          eqX(g) {
            if ((j(g instanceof t), j(!g.red), this.isInfinity())) return !1
            let N = this.z.redSqr(),
              U = g.toRed(this.curve.red).redMul(N)
            return this.x.eq(U)
          }
          eqR(g) {
            if ((j(g instanceof t), j(!g.red), !this.curve.smallGap)) return this.toP().eqR(g)
            if (this.isInfinity() || g.cmp(this.curve.p) >= 0) return !1
            let N = this.z.redSqr(),
              U = g.toRed(this.curve.red).redMul(N)
            if (this.x.eq(U)) return !0
            if (this.curve.highOrder || g.cmp(this.curve.pmodn) >= 0) return !1
            let X = this.curve.redN.redMul(N)
            return U.redIAdd(X), this.x.eq(U)
          }
          toP() {
            return this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.point(this.x, this.y))
          }
          toJ() {
            return this
          }
          encode(g) {
            return this.toP().encode(g)
          }
          static decode(g, N) {
            return c.decode(g, N).toJ()
          }
          encodeX() {
            return this.toP().encodeX()
          }
          static decodeEven(g, N) {
            return c.decodeEven(g, N).toJ()
          }
          static decodeSquare(g, N) {
            return c.decodeSquare(g, N).toJ()
          }
          toJSON(g) {
            return this.toP().toJSON(g)
          }
          toPretty() {
            return this.toP().toPretty()
          }
          static fromJSON(g, N) {
            return c.fromJSON(g, N).toJ()
          }
          [r]() {
            return this.isInfinity()
              ? '<JPoint: Infinity>'
              : '<JPoint: x=' +
                  this.x.fromRed().toString(16, 2) +
                  ' y=' +
                  this.y.fromRed().toString(16, 2) +
                  ' z=' +
                  this.z.fromRed().toString(16, 2) +
                  '>'
          }
        },
        p = class extends o {
          constructor(g) {
            super(y, 'mont', g)
            ;(this.a = t.fromJSON(g.a).toRed(this.red)),
              (this.b = t.fromJSON(g.b).toRed(this.red)),
              (this.bi = this.b.redInvert()),
              (this.a2 = this.a.redAdd(this.two)),
              (this.a24 = this.a2.redMul(this.i4)),
              (this.a3 = this.a.redMul(this.i3)),
              (this.a0 = this.a.redMul(this.bi)),
              (this.b0 = this.bi.redSqr()),
              this._finalize(g)
          }
          static _isomorphism(g, N, U) {
            j(g instanceof t), j(N instanceof t), j(U instanceof t)
            let X = g.clone(),
              ne = U.clone()
            if (N.redDiv(U).redJacobi() !== 1) throw new Error('Invalid `b` coefficient.')
            return [X, ne]
          }
          _short(g, N) {
            let { a: U, b: X, three: ne } = this,
              ee = U.redSqr(),
              ae = ee.redMul(U),
              Y = X.redSqr(),
              z = Y.redMul(X),
              H = ne.redSub(ee),
              se = Y.redMuln(3),
              me = ae.redMuln(2).redISub(U.redMuln(9)),
              we = z.redMuln(27),
              Ee = H.redDiv(se),
              Me = me.redDiv(we)
            return g != null ? a._isomorphism(Ee, Me, g, N) : [Ee, Me]
          }
          _mont(g) {
            return p._isomorphism(this.a, this.b, g)
          }
          _edwards(g, N = !1) {
            j(typeof N == 'boolean')
            let { two: U, bi: X } = this,
              ne = this.a.redAdd(U).redMul(X),
              ee = this.a.redSub(U).redMul(X)
            return N && ne.swap(ee), g != null ? h._isomorphism(ne, ee, g) : [ne, ee]
          }
          _scaleShort(g) {
            j(g instanceof a)
            let [N, U] = g._scale(this)
            return [this.field(N.redInvert()), this.field(U.redInvert())]
          }
          _scaleMont(g) {
            return (
              j(g instanceof p),
              this.g.isInfinity() || g.g.isInfinity()
                ? this.field(g.b).redDivSqrt(this.b)
                : this.g.y.redDiv(this.field(g.g.y))
            )
          }
          _scaleEdwards(g, N) {
            j(g instanceof h)
            let U = g._scale(this, N)
            return this.field(U)
          }
          _solveY0(g) {
            j(g instanceof t)
            let N = this.a0,
              U = this.b0,
              X = g.redSqr()
            return X.redMul(g).redIAdd(N.redMul(X)).redIAdd(U.redMul(g))
          }
          _elligator2(g) {
            let N = this.a0.redNeg(),
              U = this.one.redAdd(this.z.redMul(g.redSqr()))
            U.isZero() && U.inject(this.one)
            let X = N.redMul(U.redInvert()),
              ne = X.redNeg().redISub(this.a0),
              ee = this._solveY0(X),
              ae = this._solveY0(ne),
              Y = ee.redIsSquare() | 0,
              z = [X, ne][Y ^ 1],
              H = [ee, ae][Y ^ 1].redSqrt()
            H.redIsOdd() !== g.redIsOdd() && H.redINeg()
            let se = this.b.redMul(z),
              me = this.b.redMul(H)
            return this.point(se, me)
          }
          _invert2(g, N) {
            let { x: U, y: X } = g,
              ne = N & 1,
              ee = U.redMul(this.bi),
              ae = X.redMul(this.bi),
              Y = ee.redAdd(this.a0),
              z = ee,
              H = [Y, z][ne].redINeg(),
              se = [z, Y][ne].redMul(this.z),
              me = H.redDivSqrt(se)
            return me.redIsOdd() !== ae.redIsOdd() && me.redINeg(), me
          }
          isElliptic() {
            let g = this.a.redSqr()
            return !this.b.redMul(g.redSub(this.four)).isZero()
          }
          jinv() {
            let { a: g, three: N, four: U } = this,
              X = g.redSqr(),
              ee = X.redSub(N).redPown(3).redIMuln(256),
              ae = X.redSub(U)
            if (ae.isZero()) throw new Error('Curve is not elliptic.')
            return ee.redDiv(ae).fromRed()
          }
          point(g, N) {
            return new y(this, g, N)
          }
          jpoint(g, N, U) {
            return j(g == null && N == null && U == null), this.point()
          }
          xpoint(g, N) {
            return new d(this, g, N)
          }
          solveY2(g) {
            j(g instanceof t)
            let N = g.redSqr()
            return N.redMul(g).redIAdd(this.a.redMul(N)).redIAdd(g).redMul(this.bi)
          }
          validate(g) {
            if ((j(g instanceof y), g.isInfinity())) return !0
            let { x: N, y: U } = g,
              X = this.solveY2(N)
            return U.redSqr().eq(X)
          }
          pointFromX(g, N = null) {
            j(g instanceof t), j(N == null || typeof N == 'boolean'), g.red || (g = g.toRed(this.red))
            let U = this.solveY(g)
            if (N != null) {
              if (U.isZero() && N) throw new Error('Invalid point.')
              U.redIsOdd() !== N && U.redINeg()
            }
            return this.point(g, U)
          }
          isIsomorphic(g, N) {
            if ((j(g instanceof o), !g.p.eq(this.p))) return !1
            if (g.type === 'mont') {
              let U = this.field(g.a),
                X = this.field(g.b)
              return !this.a.eq(U) || this.b.isZero() ? !1 : X.redDiv(this.b).redJacobi() === 1
            }
            return g.isIsomorphic(this, N)
          }
          isIsogenous(g) {
            return j(g instanceof o), g.type === 'mont' ? !1 : g.isIsogenous(this)
          }
          pointFromShort(g) {
            if ((j(g instanceof c), this.isIsomorphic(g.curve))) {
              if (g.isInfinity()) return this.point()
              let { a3: N, b: U } = this,
                [X, ne] = this._scale(g.curve),
                ee = this.field(g.x).redMul(X),
                ae = this.field(g.y).redMul(ne),
                Y = U.redMul(ee).redISub(N),
                z = U.redMul(ae)
              return this.point(Y, z)
            }
            throw new Error('Not implemented.')
          }
          pointFromMont(g) {
            if ((j(g instanceof y), this.isIsomorphic(g.curve))) {
              if (g.isInfinity()) return this.point()
              let N = this._scale(g.curve),
                U = this.field(g.x),
                X = this.field(g.y),
                ne = U,
                ee = N.redMul(X)
              return this.point(ne, ee)
            }
            throw new Error('Not implemented.')
          }
          pointFromEdwards(g) {
            j(g instanceof m), j(g.curve.p.eq(this.p))
            let N = this.field(g.x),
              U = this.field(g.y),
              X = this.field(g.z)
            if (this.isIsogenous(g.curve)) {
              if (g.isInfinity()) return this.point()
              if (g.x.isZero()) return this.point(this.zero, this.zero)
              let ne = X.redSqr().redIMuln(2),
                ee = U.redSqr(),
                ae = N.redSqr(),
                Y = ne.redISub(ae).redISub(ee).redMul(U),
                z = ae.redMul(N)
              return this.cpoint(ee, ae, Y, z)
            }
            if (this.isIsomorphic(g.curve, !0)) {
              if (g.isInfinity()) return this.point()
              if (g.x.isZero()) return this.point(this.zero, this.zero)
              let ne = this._scale(g.curve, !0),
                ee = U.redAdd(X),
                ae = U.redSub(X),
                Y = ne.redMul(X).redMul(ee),
                z = N.redMul(ae)
              return this.cpoint(ee, ae, Y, z)
            }
            if (this.isIsomorphic(g.curve, !1)) {
              if (g.isInfinity()) return this.point()
              if (g.x.isZero()) return this.point(this.zero, this.zero)
              let ne = this._scale(g.curve, !1),
                ee = X.redAdd(U),
                ae = X.redSub(U),
                Y = ne.redMul(X).redMul(ee),
                z = N.redMul(ae)
              return this.cpoint(ee, ae, Y, z)
            }
            throw new Error('Not implemented.')
          }
          pointFromUniform(g) {
            if ((j(g instanceof t), this.z.isZero() || this.a.isZero())) throw new Error('Not implemented.')
            return this._elligator2(g)
          }
          pointToUniform(g, N) {
            if ((j(g instanceof y), j(N >>> 0 === N), this.z.isZero() || this.a.isZero()))
              throw new Error('Not implemented.')
            if (g.isInfinity()) throw new Error('Invalid point.')
            let U = ((N >>> 4) & 15) % this.torsion.length,
              X = g.add(this.torsion[U])
            return b(() => this._invert2(X, N))
          }
          decodePoint(g, N) {
            return y.decode(this, g, N)
          }
          encodeX(g) {
            return j(g instanceof d), g.encode()
          }
          decodeX(g) {
            return d.decode(this, g)
          }
          toShort(g, N, U = null) {
            let [X, ne] = this._short(g, N),
              ee = new a({ red: this.red, prime: this.prime, p: this.p, a: X, b: ne, n: this.n, h: this.h })
            if (U != null) {
              let [, ae] = ee._scale(this)
              ae.redIsOdd() !== U && ae.redINeg()
            }
            this.g.isInfinity() || (ee.g = ee.pointFromMont(this.g))
            for (let ae = 0; ae < this.h.word(0); ae++) ee.torsion[ae] = ee.pointFromMont(this.torsion[ae])
            return ee
          }
          toMont(g, N = null) {
            let [U, X] = this._mont(g),
              ne = new p({ red: this.red, prime: this.prime, p: this.p, a: U, b: X, n: this.n, h: this.h, z: this.z })
            if (N != null) {
              let ee = ne._scale(this)
              ee.redIsOdd() !== N && ee.redINeg()
            }
            this.g.isInfinity() || (ne.g = ne.pointFromMont(this.g))
            for (let ee = 0; ee < this.h.word(0); ee++) ne.torsion[ee] = ne.pointFromMont(this.torsion[ee])
            return ne
          }
          toEdwards(g, N, U = null) {
            let [X, ne] = this._edwards(g, N),
              ee = new h({ red: this.red, prime: this.prime, p: this.p, a: X, d: ne, n: this.n, h: this.h, z: this.z })
            if (U != null) {
              let ae = ee._scale(this, N)
              ae.redIsOdd() !== U && ae.redINeg()
            }
            if ((this.g.isInfinity() || ((ee.g = ee.pointFromMont(this.g)), ee.g.normalize()), ee.isComplete()))
              for (let ae = 0; ae < this.h.word(0); ae++)
                (ee.torsion[ae] = ee.pointFromMont(this.torsion[ae])), ee.torsion[ae].normalize()
            return ee
          }
          pointFromJSON(g) {
            return y.fromJSON(this, g)
          }
          toJSON(g) {
            let N = super.toJSON(g)
            return (N.a = this.a.fromRed().toJSON()), (N.b = this.b.fromRed().toJSON()), N
          }
        },
        y = class extends l {
          constructor(g, N, U) {
            j(g instanceof p)
            super(g, n.AFFINE)
            ;(this.x = this.curve.zero), (this.y = this.curve.zero), (this.inf = !0), N != null && this._init(N, U)
          }
          _init(g, N) {
            j(g instanceof t),
              j(N instanceof t),
              (this.x = g),
              (this.y = N),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              (this.inf = !1)
          }
          clone() {
            return this.inf ? this.curve.point() : this.curve.point(this.x, this.y)
          }
          scale(g) {
            return this.clone()
          }
          randomize(g) {
            return this.clone()
          }
          neg() {
            return this.inf ? this : this.curve.point(this.x, this.y.redNeg())
          }
          add(g) {
            if ((j(g instanceof y), this.inf)) return g
            if (g.inf) return this
            if (this.x.eq(g.x)) return this.y.eq(g.y) ? this.dbl() : this.curve.point()
            let N = g.x.redSub(this.x),
              X = g.y.redSub(this.y).redDiv(N),
              ee = this.curve.b.redMul(X.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(g.x),
              ae = X.redMul(this.x.redSub(ee)).redISub(this.y)
            return this.curve.point(ee, ae)
          }
          dbl() {
            if (this.inf) return this
            if (this.y.isZero()) return this.curve.point()
            let g = this.x.redSqr().redIMuln(3),
              N = this.curve.a.redMul(this.x).redIMuln(2),
              U = g.redIAdd(N).redIAdd(this.curve.one),
              X = this.curve.b.redMul(this.y).redIMuln(2),
              ne = U.redDiv(X),
              ae = this.curve.b.redMul(ne.redSqr()).redISub(this.curve.a).redISub(this.x).redISub(this.x),
              Y = ne.redMul(this.x.redSub(ae)).redISub(this.y)
            return this.curve.point(ae, Y)
          }
          getX() {
            if (this.inf) throw new Error('Invalid point.')
            return this.x.fromRed()
          }
          getY() {
            if (this.inf) throw new Error('Invalid point.')
            return this.y.fromRed()
          }
          eq(g) {
            return j(g instanceof y), this === g ? !0 : this.inf ? g.inf : g.inf ? !1 : this.x.eq(g.x) && this.y.eq(g.y)
          }
          cmp(g) {
            return (
              j(g instanceof y),
              this.inf && !g.inf
                ? -1
                : !this.inf && g.inf
                ? 1
                : this.inf && g.inf
                ? 0
                : this.order().cmp(g.order()) || this.getX().cmp(g.getX()) || this.getY().cmp(g.getY())
            )
          }
          isInfinity() {
            return this.inf
          }
          isOrder2() {
            return this.inf ? !1 : this.y.isZero()
          }
          isOdd() {
            return this.inf ? !1 : this.y.redIsOdd()
          }
          isEven() {
            return this.inf ? !1 : this.y.redIsEven()
          }
          toP() {
            return this
          }
          toJ() {
            return this
          }
          toX() {
            return this.inf ? this.curve.xpoint() : this.curve.xpoint(this.x, this.curve.one)
          }
          encode() {
            return this.toX().encode()
          }
          static decode(g, N, U) {
            return j(g instanceof p), g.decodeX(N).toP(U)
          }
          toJSON(g) {
            if (this.inf) return []
            let N = this.getX().toJSON(),
              U = this.getY().toJSON()
            return [N, U]
          }
          toPretty() {
            if (this.inf) return []
            let g = this.curve.fieldSize * 2,
              N = $(this.getX(), g),
              U = $(this.getY(), g)
            return [N, U]
          }
          static fromJSON(g, N) {
            if (
              (j(g instanceof p),
              j(Array.isArray(N)),
              j(N.length === 0 || N.length === 2 || N.length === 3),
              N.length === 0)
            )
              return g.point()
            let U = t.fromJSON(N[0]),
              X = t.fromJSON(N[1])
            return g.point(U, X)
          }
          [r]() {
            return this.inf
              ? '<MontPoint: Infinity>'
              : '<MontPoint: x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>'
          }
        },
        d = class extends l {
          constructor(g, N, U) {
            j(g instanceof p)
            super(g, n.PROJECTIVE)
            ;(this.x = this.curve.one), (this.z = this.curve.zero), N != null && this._init(N, U)
          }
          _init(g, N) {
            j(g instanceof t),
              j(N == null || N instanceof t),
              (this.x = g),
              (this.z = N || this.curve.one),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.z.red || (this.z = this.z.toRed(this.curve.red))
          }
          clone() {
            return this.curve.xpoint(this.x, this.z)
          }
          precompute(g, N) {
            return this
          }
          validate() {
            if (this.isInfinity()) return !0
            let { x: g, z: N } = this,
              U = g.redSqr(),
              X = U.redMul(g),
              ne = N.redSqr(),
              ee = this.curve.a.redMul(U).redMul(N)
            return X.redIAdd(ee).redIAdd(g.redMul(ne)).redMul(this.curve.bi).redMul(N).redJacobi() !== -1
          }
          normalize() {
            return this.isInfinity()
              ? this
              : this.z.eq(this.curve.one)
              ? this
              : ((this.x = this.x.redDiv(this.z)), (this.z = this.curve.one), this)
          }
          scale(g) {
            if ((j(g instanceof t), this.isInfinity())) return this.curve.xpoint()
            let N = this.x.redMul(g),
              U = this.z.redMul(g)
            return this.curve.xpoint(N, U)
          }
          neg() {
            return this
          }
          dbl() {
            let N = this.x.redAdd(this.z).redSqr(),
              X = this.x.redSub(this.z).redSqr(),
              ne = N.redSub(X),
              ee = N.redMul(X),
              ae = ne.redMul(X.redIAdd(this.curve.a24.redMul(ne)))
            return this.curve.xpoint(ee, ae)
          }
          diffAddDbl(g, N) {
            j(g instanceof d), j(N instanceof d)
            let U = g.x.redAdd(g.z),
              X = U.redSqr(),
              ne = g.x.redSub(g.z),
              ee = ne.redSqr(),
              ae = X.redSub(ee),
              Y = N.x.redAdd(N.z),
              H = N.x.redSub(N.z).redMul(U),
              se = Y.redMul(ne),
              me = this.z.redMul(H.redAdd(se).redSqr()),
              we = this.x.redMul(H.redISub(se).redSqr()),
              Ee = X.redMul(ee),
              Me = ae.redMul(ee.redIAdd(this.curve.a24.redMul(ae)))
            return [this.curve.xpoint(Ee, Me), this.curve.xpoint(me, we)]
          }
          getX() {
            if (this.isInfinity()) throw new Error('Invalid point.')
            return this.normalize(), this.x.fromRed()
          }
          getY(g) {
            return this.toP(g).getY()
          }
          eq(g) {
            if ((j(g instanceof d), this === g)) return !0
            if (this.isInfinity()) return g.isInfinity()
            if (g.isInfinity()) return !1
            if (this.z.eq(g.z)) return this.x.eq(g.x)
            let N = this.x.redMul(g.z),
              U = g.x.redMul(this.z)
            return N.eq(U)
          }
          cmp(g) {
            j(g instanceof d)
            let N = this.isInfinity(),
              U = g.isInfinity()
            return N && !U ? -1 : !N && U ? 1 : N && U ? 0 : this.order().cmp(g.order()) || this.getX().cmp(g.getX())
          }
          isInfinity() {
            return this.z.isZero()
          }
          isOrder2() {
            return this.isInfinity() ? !1 : this.x.isZero()
          }
          isOdd() {
            return !1
          }
          isEven() {
            return !1
          }
          hasTorsion() {
            return this.isInfinity() ? !1 : this.x.isZero() ? !0 : super.hasTorsion()
          }
          order() {
            try {
              return this.toP().order()
            } catch (g) {
              return new t(1)
            }
          }
          jmul(g) {
            j(g instanceof t), j(!g.red)
            let N = g.bitLength(),
              U = this.curve.xpoint(),
              X = this
            for (let ne = N - 1; ne >= 0; ne--)
              g.bit(ne) === 0 ? ([U, X] = this.diffAddDbl(U, X)) : ([X, U] = this.diffAddDbl(X, U))
            return U
          }
          jmulBlind(g, N) {
            return N ? this.randomize(N).jmul(g) : this.jmul(g)
          }
          jmulAdd(g, N, U) {
            throw new Error('Not implemented.')
          }
          toP(g = null) {
            return (
              j(g == null || typeof g == 'boolean'),
              this.isInfinity() ? this.curve.point() : (this.normalize(), this.curve.pointFromX(this.x, g))
            )
          }
          toJ() {
            return this
          }
          toX() {
            return this
          }
          key() {
            if (this.isInfinity()) return `${this.curve.uid}:oo`
            this.normalize()
            let g = this.getX().toString(16)
            return `${this.curve.uid}:${g}`
          }
          encode() {
            return this.curve.encodeField(this.getX())
          }
          static decode(g, N) {
            j(g instanceof p)
            let U = g.decodeField(N)
            U.iumaskn(g.fieldBits)
            let X = g.xpoint(U, g.one)
            return j(!X.isInfinity()), X
          }
          toJSON(g) {
            return this.toP().toJSON(g)
          }
          toPretty() {
            return this.toP().toPretty()
          }
          static fromJSON(g, N) {
            return y.fromJSON(g, N).toX()
          }
          [r]() {
            return this.isInfinity()
              ? '<XPoint: Infinity>'
              : '<XPoint: x=' + this.x.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>'
          }
        },
        h = class extends o {
          constructor(g) {
            super(m, 'edwards', g)
            ;(this.a = t.fromJSON(g.a).toRed(this.red)),
              (this.d = t.fromJSON(g.d).toRed(this.red)),
              (this.s = t.fromJSON(g.s || '0').toRed(this.red)),
              (this.si = this.s.isZero() ? this.zero : this.s.redInvert()),
              (this.k = this.d.redMuln(2)),
              (this.smi = -this.d.redNeg().word(0)),
              (this.ad6 = this.a.redAdd(this.d).redMul(this.i6)),
              (this.twisted = !this.a.eq(this.one)),
              (this.oneA = this.a.eq(this.one)),
              (this.mOneA = this.a.eq(this.one.redNeg())),
              (this.smallD = this.prime != null && this.d.redNeg().length === 1),
              (this.alt = null),
              this._finalize(g)
          }
          static _isomorphism(g, N, U) {
            j(g instanceof t), j(N instanceof t), j(U instanceof t)
            let X = U.clone(),
              ne = U.redMul(N).redDiv(g)
            if (g.redDiv(U).redJacobi() !== 1) throw new Error('Invalid `a` coefficient.')
            return [X, ne]
          }
          _short(g, N) {
            let { a: U, d: X } = this,
              ne = U.redSqr(),
              ee = ne.redMul(U),
              ae = X.redSqr(),
              Y = ae.redMul(X),
              z = U.redMul(X).redIMuln(14),
              H = ne.redMul(X),
              se = U.redMul(ae),
              me = H.redIAdd(se).redIMuln(33),
              we = ne.redAdd(z).redIAdd(ae).redDivn(-48),
              Ee = me.redISub(ee).redISub(Y).redDivn(864)
            return g != null ? a._isomorphism(we, Ee, g, N) : [we, Ee]
          }
          _mont(g, N = !1) {
            j(typeof N == 'boolean')
            let U, X
            N
              ? ((U = this.d.redAdd(this.a)), (X = this.d.redSub(this.a)))
              : ((U = this.a.redAdd(this.d)), (X = this.a.redSub(this.d)))
            let ne = X.redInvert(),
              ee = U.redMuln(2).redMul(ne),
              ae = ne.redMuln(4)
            return g != null ? p._isomorphism(ee, ae, g) : [ee, ae]
          }
          _edwards(g) {
            return h._isomorphism(this.a, this.d, g)
          }
          _scaleShort(g) {
            j(g instanceof a)
            let [N, U] = g._scale(this)
            return [this.field(N.redInvert()), this.field(U.redInvert())]
          }
          _scaleMont(g, N = !1) {
            if ((j(g instanceof p), j(typeof N == 'boolean'), this.g.isInfinity() || g.g.isInfinity())) {
              let [X] = g._edwards(null, N)
              return this.field(X).redDivSqrt(this.a)
            }
            let U = g.g.x.redDiv(g.g.y)
            return this.g.x.redDiv(this.field(U))
          }
          _scaleEdwards(g) {
            return (
              j(g instanceof h),
              this.g.isInfinity() || g.g.isInfinity()
                ? this.field(g.a).redDivSqrt(this.a)
                : this.g.x.redDiv(this.field(g.g.x))
            )
          }
          _mulA(g) {
            return j(g instanceof t), this.oneA ? g.clone() : this.mOneA ? g.redNeg() : this.a.redMul(g)
          }
          _mulD(g) {
            return j(g instanceof t), this.smallD ? g.redMuln(this.smi) : this.d.redMul(g)
          }
          _elligator1(g) {
            let { s: N, si: U, i2: X, one: ne, two: ee } = this,
              ae = U.redSqr().redIMuln(2),
              Y = N.redSqr().redMul(X),
              z = Y.redSqr(),
              H = ae.redAdd(Y),
              se = H.redSqr().redISub(ee),
              me = ae.redSub(ne),
              we = ne.redSub(g),
              Ee = ne.redAdd(g),
              Me = Ee.isZero() ? Ee : we.redDiv(Ee),
              Be = Me.redSqr(),
              je = Be.redMul(Me),
              Oe = je.redMul(Be).redAdd(se.redMul(je)).redIAdd(Me),
              ht = this.field(Oe.redJacobi()),
              Qe = this.field(Be.redAdd(z).redJacobi()),
              et = ht.redMul(Qe),
              Mt = ht.redMul(Me),
              ut = ht.redMul(Oe).redSqrt().redMul(et),
              at = ne.redAdd(Mt),
              Pt = H.redMul(Mt),
              ft = at.redSqr(),
              We = me.redMul(N).redMul(Mt).redMul(at),
              gt = Me.isZero() ? this.one : ut,
              Ge = Pt.redSub(ft),
              He = Pt.redAdd(ft)
            return this.cpoint(We, gt, Ge, He)
          }
          _invert1(g, N) {
            let { s: U, si: X, i2: ne, one: ee } = this,
              { x: ae, y: Y, z } = g,
              H = N & 1,
              se = X.redSqr().redIMuln(2),
              me = U.redSqr().redMul(ne),
              we = me.redSqr(),
              Ee = se.redAdd(me),
              Me = se.redSub(ee),
              Be = Y.redSub(z),
              je = Y.redAdd(z).redIMuln(2),
              Pe = je.isZero() ? je : Be.redDiv(je),
              Oe = ee.redAdd(Pe.redMul(Ee)),
              et = Oe.redSqr().redISub(ee).redSqrt().redSub(Oe),
              Mt = ee.redAdd(et),
              at = Me.redMul(U).redMul(et).redMul(Mt).redMul(ae.redMul(z)),
              Pt = et.redSqr().redIAdd(we),
              We = this.field(at.redMul(Pt).redJacobi()).redMul(et),
              gt = ee.redSub(We),
              Ge = ee.redAdd(We),
              He = Ge.isZero() ? Ge : gt.redDiv(Ge)
            return He.redIsOdd() !== Boolean(H) && He.redINeg(), He
          }
          _alt() {
            return this.alt || (this.alt = this.toMont()), this.alt
          }
          isElliptic() {
            let g = this.a.redMul(this.d),
              N = this.a.redSub(this.d)
            return !g.redMul(N).isZero()
          }
          jinv() {
            let { a: g, d: N } = this,
              U = g.redMul(N),
              X = g.redSub(N).redPown(4),
              ne = g.redSqr(),
              ee = N.redSqr(),
              Y = ne.redAdd(U.redMuln(14)).redIAdd(ee).redPown(3).redIMuln(16),
              z = U.redMul(X)
            if (z.isZero()) throw new Error('Curve is not elliptic.')
            return Y.redDiv(z).fromRed()
          }
          isComplete() {
            return this.a.redJacobi() === 1 && this.d.redJacobi() === -1
          }
          point(g, N, U, X) {
            return new m(this, g, N, U, X)
          }
          jpoint(g, N, U) {
            return j(g == null && N == null && U == null), this.point()
          }
          cpoint(g, N, U, X) {
            j(g instanceof t), j(N instanceof t), j(U instanceof t), j(X instanceof t)
            let ne = g.redMul(X),
              ee = U.redMul(N),
              ae = N.redMul(X),
              Y = g.redMul(U)
            return this.point(ne, ee, ae, Y)
          }
          solveX2(g) {
            j(g instanceof t)
            let N = g.redSqr(),
              U = this._mulD(N).redISub(this.a)
            return N.redISub(this.one).redDiv(U)
          }
          solveX(g) {
            let N = g.redSqr(),
              U = this._mulD(N).redISub(this.a)
            return N.redISub(this.one).redDivSqrt(U)
          }
          solveY2(g) {
            j(g instanceof t)
            let N = g.redSqr(),
              U = this._mulA(N).redISub(this.one),
              X = this._mulD(N).redISub(this.one)
            return U.redDiv(X)
          }
          solveY(g) {
            let N = g.redSqr(),
              U = this._mulA(N).redISub(this.one),
              X = this._mulD(N).redISub(this.one)
            return U.redDivSqrt(X)
          }
          validate(g) {
            if ((j(g instanceof m), g.zOne)) {
              let se = g.x.redSqr(),
                me = g.y.redSqr(),
                we = this._mulD(se).redMul(me),
                Ee = this._mulA(se).redIAdd(me),
                Me = this.one.redAdd(we),
                Be = g.t,
                je = g.x.redMul(g.y)
              return Ee.eq(Me) && Be.eq(je)
            }
            let N = g.x.redSqr(),
              U = g.y.redSqr(),
              X = g.z.redSqr(),
              ne = X.redSqr(),
              ee = this._mulD(N).redMul(U),
              ae = this._mulA(N).redIAdd(U).redMul(X),
              Y = ne.redIAdd(ee),
              z = g.t.redMul(g.z),
              H = g.x.redMul(g.y)
            return ae.eq(Y) && z.eq(H)
          }
          pointFromX(g, N = null) {
            j(g instanceof t), j(N == null || typeof N == 'boolean'), g.red || (g = g.toRed(this.red))
            let U = this.solveY(g)
            if (N != null) {
              if (U.isZero() && N) throw new Error('Invalid point.')
              U.redIsOdd() !== N && U.redINeg()
            }
            return this.point(g, U)
          }
          pointFromY(g, N = null) {
            j(g instanceof t), j(N == null || typeof N == 'boolean'), g.red || (g = g.toRed(this.red))
            let U = this.solveX(g)
            if (N != null) {
              if (U.isZero() && N) throw new Error('Invalid point.')
              U.redIsOdd() !== N && U.redINeg()
            }
            return this.point(U, g)
          }
          isIsomorphic(g, N = !1) {
            if ((j(g instanceof o), j(typeof N == 'boolean'), !g.p.eq(this.p))) return !1
            if (g.type === 'short') return g.isIsomorphic(this)
            if (g.type === 'mont') {
              let U = this.field(g.a),
                X,
                ne
              return (
                N
                  ? ((X = this.d.redAdd(this.a)), (ne = this.d.redSub(this.a)))
                  : ((X = this.a.redAdd(this.d)), (ne = this.a.redSub(this.d))),
                U.redMul(ne).eq(X.redIMuln(2))
              )
            }
            if (g.type === 'edwards') {
              let U = this.field(g.a),
                X = this.field(g.d)
              return this.a.redMul(X).eq(U.redMul(this.d))
            }
            return !1
          }
          isIsogenous(g) {
            if ((j(g instanceof o), !g.p.eq(this.p))) return !1
            if (g.type === 'mont') {
              if (!this.a.eq(this.one)) return !1
              let N = this.field(g.a),
                U = this.field(g.b),
                X = this.two.redSub(this.d.redMuln(4))
              return N.eq(X) && U.eq(this.one)
            }
            if (g.type === 'edwards') {
              let N = this.field(g.a),
                U = this.field(g.d)
              return N.eq(this.a.redNeg()) && U.eq(this.d.redSub(this.a))
            }
            return !1
          }
          pointFromShort(g) {
            if ((j(g instanceof c), this.isIsomorphic(g.curve))) {
              if (g.isInfinity()) return this.point()
              if (g.y.isZero()) return this.point(this.zero, this.one.redNeg())
              let { a: N, d: U } = this,
                [X, ne] = this._scale(g.curve),
                ee = N.redMuln(5),
                ae = U.redMuln(5),
                Y = this.field(g.x).redMul(X),
                z = this.field(g.y).redMul(ne),
                H = Y.redMuln(6),
                se = Y.redMuln(12),
                me = H.redSub(N).redISub(U),
                we = z.redMuln(6),
                Ee = se.redSub(ee).redIAdd(U),
                Me = se.redAdd(N).redISub(ae)
              return this.cpoint(me, we, Ee, Me)
            }
            throw new Error('Not implemented.')
          }
          pointFromMont(g) {
            j(g instanceof y), j(g.curve.p.eq(this.p))
            let N = this.field(g.x),
              U = this.field(g.y)
            if (this.isIsogenous(g.curve)) {
              if (g.isInfinity()) return this.point()
              if (g.x.isZero()) return this.point()
              let X = N.redSqr(),
                ne = X.redMul(N),
                ee = ne.redMul(N),
                ae = ee.redMul(N),
                Y = U.redSqr(),
                z = U.redMuln(4),
                H = X.redSub(this.one),
                se = X.redMuln(2),
                me = Y.redMuln(4),
                we = ne.redIMuln(2),
                Ee = N.redMul(Y).redIMuln(4),
                Me = X.redMul(Y).redIMuln(2),
                Be = Y.redIMuln(2),
                je = z.redMul(H),
                Pe = ee.redISub(se).redIAdd(me).redIAdd(this.one),
                Oe = ae.redSub(we).redISub(Ee).redIAdd(N).redINeg(),
                ht = ae.redISub(Me).redISub(we).redISub(Be).redIAdd(N)
              return this.cpoint(je, Pe, Oe, ht).divn(4)
            }
            if (this.isIsomorphic(g.curve, !0)) {
              if (g.isInfinity()) return this.point()
              if (g.x.isZero()) return this.point(this.zero, this.one.redNeg())
              let ne = this._scale(g.curve, !0).redMul(N),
                ee = U,
                ae = N.redAdd(this.one),
                Y = N.redSub(this.one)
              return this.cpoint(ne, ee, ae, Y)
            }
            if (this.isIsomorphic(g.curve, !1)) {
              if (g.isInfinity()) return this.point()
              if (g.x.isZero()) return this.point(this.zero, this.one.redNeg())
              let ne = this._scale(g.curve, !1).redMul(N),
                ee = U,
                ae = N.redSub(this.one),
                Y = N.redAdd(this.one)
              return this.cpoint(ne, ee, ae, Y)
            }
            throw new Error('Not implemented.')
          }
          pointFromEdwards(g) {
            j(g instanceof m), j(g.curve.p.eq(this.p))
            let N = this.field(g.curve.a),
              U = this.field(g.x),
              X = this.field(g.y),
              ne = this.field(g.z),
              ee = this.field(g.t)
            if (this.isIsogenous(g.curve)) {
              let ae = U.redMul(X),
                Y = U.redSqr(),
                z = X.redSqr(),
                H = ne.redSqr(),
                se = N.redMul(Y),
                me = ae.redIMuln(2),
                we = z.redSub(se),
                Ee = z.redAdd(se),
                Me = H.redIMuln(2).redISub(Ee),
                Be = this.cpoint(me, we, Ee, Me)
              return this.twisted ? Be : Be.divn(4)
            }
            if (this.isIsomorphic(g.curve)) {
              let ae = this._scale(g.curve),
                Y = ae.redMul(U),
                z = X,
                H = ne,
                se = ae.redMul(ee)
              return this.point(Y, z, H, se)
            }
            throw new Error('Not implemented.')
          }
          pointFromUniform(g, N = null) {
            j(g instanceof t), j(g.red === this.red), j(N == null || N instanceof p), N || (N = this._alt())
            let U = N.field(g),
              X = N.pointFromUniform(U)
            return this.pointFromMont(X)
          }
          pointToUniform(g, N, U = null) {
            j(g instanceof m), j(N >>> 0 === N), j(U == null || U instanceof p), U || (U = this._alt())
            let X = ((N >> 4) & 15) % this.torsion.length,
              ne = g.add(this.torsion[X]),
              ee = U.pointFromEdwards(ne),
              ae = U.pointToUniform(ee, N & 15)
            return this.field(ae)
          }
          pointFromHash(g, N, U = null) {
            j(U == null || U instanceof p), U || (U = this._alt())
            let X = U.pointFromHash(g, N)
            return this.pointFromMont(X)
          }
          pointToHash(g, N, U, X = null) {
            j(g instanceof m), j(N >>> 0 === N), j(X == null || X instanceof p), X || (X = this._alt())
            let ne = N % this.torsion.length,
              ee = g.add(this.torsion[ne]),
              ae = X.pointFromEdwards(ee)
            return X.pointToHash(ae, 0, U)
          }
          decodePoint(g) {
            return m.decode(this, g)
          }
          toShort(g, N, U = null) {
            let [X, ne] = this._short(g, N),
              ee = new a({ red: this.red, prime: this.prime, p: this.p, a: X, b: ne, n: this.n, h: this.h })
            if (U != null) {
              let [, ae] = ee._scale(this)
              ae.redIsOdd() !== U && ae.redINeg()
            }
            this.g.isInfinity() || (ee.g = ee.pointFromEdwards(this.g))
            for (let ae = 0; ae < this.h.word(0); ae++) ee.torsion[ae] = ee.pointFromEdwards(this.torsion[ae])
            return ee
          }
          toMont(g, N, U = null) {
            let [X, ne] = this._mont(g, N),
              ee = new p({ red: this.red, prime: this.prime, p: this.p, a: X, b: ne, n: this.n, h: this.h, z: this.z })
            if (U != null) {
              let ae = this._scale(ee, N)
              ae.redIsOdd() !== U && ae.redINeg()
            }
            this.g.isInfinity() || (ee.g = ee.pointFromEdwards(this.g))
            for (let ae = 0; ae < this.h.word(0); ae++) ee.torsion[ae] = ee.pointFromEdwards(this.torsion[ae])
            return ee
          }
          toEdwards(g, N = null) {
            let [U, X] = this._edwards(g),
              ne = new h({ red: this.red, prime: this.prime, p: this.p, a: U, d: X, n: this.n, h: this.h, z: this.z })
            if (N != null) {
              let ee = ne._scale(this)
              ee.redIsOdd() !== N && ee.redINeg()
            }
            if ((this.g.isInfinity() || ((ne.g = ne.pointFromEdwards(this.g)), ne.g.normalize()), ne.isComplete()))
              for (let ee = 0; ee < this.h.word(0); ee++)
                (ne.torsion[ee] = ne.pointFromEdwards(this.torsion[ee])), ne.torsion[ee].normalize()
            return ne
          }
          pointFromJSON(g) {
            return m.fromJSON(this, g)
          }
          toJSON(g) {
            let N = super.toJSON(g)
            return (
              (N.a = this.a.fromRed().toJSON()),
              (N.d = this.d.fromRed().toJSON()),
              this.s.isZero() || (N.s = this.s.fromRed().toJSON()),
              N
            )
          }
        },
        m = class extends l {
          constructor(g, N, U, X, ne) {
            j(g instanceof h)
            super(g, n.EXTENDED)
            ;(this.x = this.curve.zero),
              (this.y = this.curve.one),
              (this.z = this.curve.one),
              (this.t = this.curve.zero),
              (this.zOne = !0),
              N != null && this._init(N, U, X, ne)
          }
          _init(g, N, U, X) {
            j(g instanceof t),
              j(N instanceof t),
              j(U == null || U instanceof t),
              j(X == null || X instanceof t),
              (this.x = g),
              (this.y = N),
              (this.z = U || this.curve.one),
              (this.t = X || null),
              this.x.red || (this.x = this.x.toRed(this.curve.red)),
              this.y.red || (this.y = this.y.toRed(this.curve.red)),
              this.z.red || (this.z = this.z.toRed(this.curve.red)),
              this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)),
              (this.zOne = this.z.eq(this.curve.one)),
              this._check(),
              this.t || ((this.t = this.x.redMul(this.y)), this.zOne || (this.t = this.t.redDiv(this.z)))
          }
          _check() {
            if (this.z.isZero()) throw new Error('Invalid point.')
          }
          clone() {
            return this.curve.point(this.x, this.y, this.z, this.t)
          }
          normalize() {
            if (this.zOne) return this
            let g = this.z.redInvert()
            return (
              (this.x = this.x.redMul(g)),
              (this.y = this.y.redMul(g)),
              (this.t = this.t.redMul(g)),
              (this.z = this.curve.one),
              (this.zOne = !0),
              this
            )
          }
          scale(g) {
            j(g instanceof t)
            let N = this.x.redMul(g),
              U = this.y.redMul(g),
              X = this.z.redMul(g),
              ne = this.t.redMul(g)
            return this.curve.point(N, U, X, ne)
          }
          neg() {
            let g = this.x.redNeg(),
              N = this.y,
              U = this.z,
              X = this.t.redNeg()
            return this.curve.point(g, N, U, X)
          }
          add(g) {
            return (
              j(g instanceof m), this.isInfinity() ? g : g.isInfinity() ? this : this.zOne ? g._add(this) : this._add(g)
            )
          }
          _add(g) {
            return this.curve.mOneA ? this._addM1(g) : this._addA(g)
          }
          _addM1(g) {
            let N = this.y.redSub(this.x).redMul(g.y.redSub(g.x)),
              U = this.y.redAdd(this.x).redMul(g.y.redAdd(g.x)),
              X = this.t.redMul(this.curve.k).redMul(g.t),
              ne = g.zOne ? this.z.redAdd(this.z) : this.z.redMul(g.z).redIMuln(2),
              ee = U.redSub(N),
              ae = ne.redSub(X),
              Y = ne.redIAdd(X),
              z = U.redIAdd(N),
              H = ee.redMul(ae),
              se = Y.redMul(z),
              me = ee.redMul(z),
              we = ae.redMul(Y)
            return this.curve.point(H, se, we, me)
          }
          _addA(g) {
            let N = this.x.redMul(g.x),
              U = this.y.redMul(g.y),
              X = this.curve._mulD(this.t).redMul(g.t),
              ne = g.zOne ? this.z.clone() : this.z.redMul(g.z),
              ae = this.x.redAdd(this.y).redMul(g.x.redAdd(g.y)).redISub(N).redISub(U),
              Y = ne.redSub(X),
              z = ne.redIAdd(X),
              H = U.redISub(this.curve._mulA(N)),
              se = ae.redMul(Y),
              me = z.redMul(H),
              we = ae.redMul(H),
              Ee = Y.redMul(z)
            return this.curve.point(se, me, Ee, we)
          }
          dbl() {
            return this.isInfinity() ? this : this._dbl()
          }
          _dbl() {
            let g = this.x.redSqr(),
              N = this.y.redSqr(),
              U = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2),
              X = this.curve._mulA(g),
              ne = this.x.redAdd(this.y).redSqr().redISub(g).redISub(N),
              ee = X.redAdd(N),
              ae = ee.redSub(U),
              Y = X.redISub(N),
              z = ne.redMul(ae),
              H = ee.redMul(Y),
              se = ne.redMul(Y),
              me = ae.redMul(ee)
            return this.curve.point(z, H, me, se)
          }
          getX() {
            return this.normalize(), this.x.fromRed()
          }
          getY() {
            return this.normalize(), this.y.fromRed()
          }
          eq(g) {
            if ((j(g instanceof m), j(!this.z.isZero()), j(!g.z.isZero()), this === g)) return !0
            if (this.z.eq(g.z)) return this.x.eq(g.x) && this.y.eq(g.y)
            let N = this.x.redMul(g.z),
              U = g.x.redMul(this.z)
            if (!N.eq(U)) return !1
            let X = this.y.redMul(g.z),
              ne = g.y.redMul(this.z)
            return X.eq(ne)
          }
          cmp(g) {
            return (
              j(g instanceof m), this.order().cmp(g.order()) || this.getY().cmp(g.getY()) || this.getX().cmp(g.getX())
            )
          }
          isInfinity() {
            return j(!this.z.isZero()), this.x.isZero() ? this.y.eq(this.z) : !1
          }
          isOrder2() {
            return this.isInfinity() ? !1 : this.x.isZero()
          }
          isOdd() {
            return this.normalize(), this.x.redIsOdd()
          }
          isEven() {
            return this.normalize(), this.x.redIsEven()
          }
          toP() {
            return this.normalize()
          }
          toJ() {
            return this
          }
          encode() {
            let g = this.getY()
            return g.setn(this.curve.signBit, this.x.redIsOdd()), this.curve.encodeAdjusted(g)
          }
          static decode(g, N) {
            j(g instanceof h)
            let U = g.decodeAdjusted(N),
              X = U.testn(g.signBit) !== 0
            if ((U.setn(g.signBit, 0), U.cmp(g.p) >= 0)) throw new Error('Invalid point.')
            return g.pointFromY(U, X)
          }
          toJSON(g) {
            if (this.isInfinity()) return []
            let N = this.getX().toJSON(),
              U = this.getY().toJSON()
            return g === !0 && this.pre ? [N, U, this.pre.toJSON()] : [N, U]
          }
          toPretty() {
            let g = this.curve.fieldSize * 2,
              N = $(this.getX(), g),
              U = $(this.getY(), g)
            return [N, U]
          }
          static fromJSON(g, N) {
            if (
              (j(g instanceof h),
              j(Array.isArray(N)),
              j(N.length === 0 || N.length === 2 || N.length === 3),
              N.length === 0)
            )
              return g.point()
            let U = t.fromJSON(N[0]),
              X = t.fromJSON(N[1]),
              ne = g.point(U, X)
            return N.length > 2 && N[2] != null && (ne.pre = _.fromJSON(ne, N[2])), ne
          }
          [r]() {
            return this.isInfinity()
              ? '<EdwardsPoint: Infinity>'
              : '<EdwardsPoint: x=' +
                  this.x.fromRed().toString(16, 2) +
                  ' y=' +
                  this.y.fromRed().toString(16, 2) +
                  ' z=' +
                  this.z.fromRed().toString(16, 2) +
                  '>'
          }
        },
        _ = class {
          constructor() {
            ;(this.naf = null), (this.windows = null), (this.doubles = null), (this.blinding = null), (this.beta = null)
          }
          map(g) {
            j(typeof g == 'function')
            let N = new this.constructor()
            return this.naf && (N.naf = this.naf.map(g)), this.doubles && (N.doubles = this.doubles.map(g)), N
          }
          toJSON() {
            return {
              naf: this.naf ? this.naf.toJSON() : null,
              windows: this.windows ? this.windows.toJSON() : null,
              doubles: this.doubles ? this.doubles.toJSON() : null,
              blinding: this.blinding ? this.blinding.toJSON() : void 0
            }
          }
          fromJSON(g, N) {
            return (
              j(g instanceof l),
              j(N && typeof N == 'object'),
              N.naf != null && (this.naf = A.fromJSON(g, N.naf)),
              N.windows != null && (this.windows = T.fromJSON(g, N.windows)),
              N.doubles != null && (this.doubles = E.fromJSON(g, N.doubles)),
              N.blinding != null && (this.blinding = k.fromJSON(g, N.blinding)),
              this
            )
          }
          static fromJSON(g, N) {
            return new this().fromJSON(g, N)
          }
        },
        A = class {
          constructor(g, N) {
            ;(this.width = g), (this.points = N)
          }
          map(g) {
            j(typeof g == 'function')
            let { width: N } = this,
              U = []
            for (let X of this.points) U.push(g(X))
            return new this.constructor(N, U)
          }
          toJSON() {
            return { width: this.width, points: this.points.slice(1).map((g) => g.toJSON()) }
          }
          static fromJSON(g, N) {
            j(g instanceof l), j(N && typeof N == 'object'), j(N.width >>> 0 === N.width), j(Array.isArray(N.points))
            let { curve: U } = g,
              { width: X } = N,
              ne = [g]
            for (let ee of N.points) ne.push(U.pointFromJSON(ee))
            return new this(X, ne)
          }
        },
        T = class {
          constructor(g, N, U) {
            ;(this.width = g), (this.bits = N), (this.points = U)
          }
          toJSON() {
            return { width: this.width, bits: this.bits, points: this.points.slice(1).map((g) => g.toJSON()) }
          }
          static fromJSON(g, N) {
            j(g instanceof l),
              j(N && typeof N == 'object'),
              j(N.width >>> 0 === N.width),
              j(N.bits >>> 0 === N.bits),
              j(Array.isArray(N.points))
            let { curve: U } = g,
              { width: X, bits: ne } = N,
              ee = [g]
            for (let ae of N.points) ee.push(U.pointFromJSON(ae))
            return new this(X, ne, ee)
          }
        },
        E = class {
          constructor(g, N) {
            ;(this.step = g), (this.points = N)
          }
          map(g) {
            j(typeof g == 'function')
            let { step: N } = this,
              U = []
            for (let X of this.points) U.push(g(X))
            return new this.constructor(N, U)
          }
          toJSON() {
            return { step: this.step, points: this.points.slice(1).map((g) => g.toJSON()) }
          }
          static fromJSON(g, N) {
            j(g instanceof l), j(N && typeof N == 'object'), j(N.step >>> 0 === N.step), j(Array.isArray(N.points))
            let { curve: U } = g,
              { step: X } = N,
              ne = [g]
            for (let ee of N.points) ne.push(U.pointFromJSON(ee))
            return new this(X, ne)
          }
        },
        k = class {
          constructor(g, N) {
            ;(this.blind = g), (this.unblind = N)
          }
          toJSON() {
            return { blind: this.blind.toJSON(), unblind: this.unblind.toJSON() }
          }
          static fromJSON(g, N) {
            j(g instanceof l), j(N && typeof N == 'object')
            let { curve: U } = g,
              X = t.fromJSON(N.blind),
              ne = U.pointFromJSON(N.unblind)
            return new this(X, ne)
          }
        },
        w = class {
          constructor(g, N, U, X) {
            ;(this.beta = g), (this.lambda = N), (this.basis = U), (this.pre = X)
          }
          toJSON() {
            return {
              beta: this.beta.fromRed().toJSON(),
              lambda: this.lambda.toJSON(),
              basis: [this.basis[0].toJSON(), this.basis[1].toJSON()],
              pre: [this.pre[0], this.pre[1].toJSON(), this.pre[2].toJSON()]
            }
          }
          static fromJSON(g, N) {
            j(g instanceof o),
              j(N && typeof N == 'object'),
              j(Array.isArray(N.basis)),
              j(Array.isArray(N.pre)),
              j(N.basis.length === 2),
              j(N.pre.length === 3),
              j(N.pre[0] >>> 0 === N.pre[0])
            let U = t.fromJSON(N.beta).toRed(g.red),
              X = t.fromJSON(N.lambda),
              ne = [v.fromJSON(N.basis[0]), v.fromJSON(N.basis[1])],
              ee = [N.pre[0], t.fromJSON(N.pre[1]), t.fromJSON(N.pre[2])]
            return new this(U, X, ne, ee)
          }
        },
        v = class {
          constructor(g, N) {
            ;(this.a = g), (this.b = N)
          }
          toJSON() {
            return { a: this.a.toJSON(), b: this.b.toJSON() }
          }
          static fromJSON(g) {
            j(g && typeof g == 'object')
            let N = t.fromJSON(g.a),
              U = t.fromJSON(g.b)
            return new this(N, U)
          }
        },
        I = class extends a {
          constructor(g) {
            super({
              id: 'P192',
              ossl: 'prime192v1',
              type: 'short',
              endian: 'be',
              hash: 'SHA256',
              prime: 'p192',
              p: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff'],
              a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff fffffffc'],
              b: ['64210519 e59c80e7 0fa7e9ab 72243049', 'feb8deec c146b9b1'],
              n: ['ffffffff ffffffff ffffffff 99def836', '146bc9b1 b4d22831'],
              h: '1',
              z: '-5',
              g: [
                ['188da80e b03090f6 7cbf20eb 43a18800', 'f4ff0afd 82ff1012'],
                ['07192b95 ffc8da78 631011ed 6b24cdd5', '73f977a1 1e794811'],
                g
              ]
            })
          }
        },
        M = class extends a {
          constructor(g) {
            super({
              id: 'P224',
              ossl: 'secp224r1',
              type: 'short',
              endian: 'be',
              hash: 'SHA256',
              prime: 'p224',
              p: ['ffffffff ffffffff ffffffff ffffffff', '00000000 00000000 00000001'],
              a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff fffffffe'],
              b: ['b4050a85 0c04b3ab f5413256 5044b0b7', 'd7bfd8ba 270b3943 2355ffb4'],
              n: ['ffffffff ffffffff ffffffff ffff16a2', 'e0b8f03e 13dd2945 5c5c2a3d'],
              h: '1',
              z: '1f',
              g: [
                ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3', '56c21122 343280d6 115c1d21'],
                ['bd376388 b5f723fb 4c22dfe6 cd4375a0', '5a074764 44d58199 85007e34'],
                g
              ]
            })
          }
        },
        q = class extends a {
          constructor(g) {
            super({
              id: 'P256',
              ossl: 'prime256v1',
              type: 'short',
              endian: 'be',
              hash: 'SHA256',
              prime: null,
              p: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff ffffffff'],
              a: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff fffffffc'],
              b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc', '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],
              n: ['ffffffff 00000000 ffffffff ffffffff', 'bce6faad a7179e84 f3b9cac2 fc632551'],
              h: '1',
              z: '-a',
              g: [
                ['6b17d1f2 e12c4247 f8bce6e5 63a440f2', '77037d81 2deb33a0 f4a13945 d898c296'],
                ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16', '2bce3357 6b315ece cbb64068 37bf51f5'],
                g
              ]
            })
          }
        },
        G = class extends a {
          constructor(g) {
            super({
              id: 'P384',
              ossl: 'secp384r1',
              type: 'short',
              endian: 'be',
              hash: 'SHA384',
              prime: null,
              p: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff fffffffe',
                'ffffffff 00000000 00000000 ffffffff'
              ],
              a: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff fffffffe',
                'ffffffff 00000000 00000000 fffffffc'
              ],
              b: [
                'b3312fa7 e23ee7e4 988e056b e3f82d19',
                '181d9c6e fe814112 0314088f 5013875a',
                'c656398d 8a2ed19d 2a85c8ed d3ec2aef'
              ],
              n: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff c7634d81 f4372ddf',
                '581a0db2 48b0a77a ecec196a ccc52973'
              ],
              h: '1',
              z: '-c',
              g: [
                [
                  'aa87ca22 be8b0537 8eb1c71e f320ad74',
                  '6e1d3b62 8ba79b98 59f741e0 82542a38',
                  '5502f25d bf55296c 3a545e38 72760ab7'
                ],
                [
                  '3617de4a 96262c6f 5d9e98bf 9292dc29',
                  'f8f41dbd 289a147c e9da3113 b5f0b8c0',
                  '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'
                ],
                g
              ]
            })
          }
        },
        O = class extends a {
          constructor(g) {
            super({
              id: 'P521',
              ossl: 'secp521r1',
              type: 'short',
              endian: 'be',
              hash: 'SHA512',
              prime: 'p521',
              p: [
                '000001ff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff'
              ],
              a: [
                '000001ff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'fffffffc'
              ],
              b: [
                '00000051 953eb961 8e1c9a1f 929a21a0',
                'b68540ee a2da725b 99b315f3 b8b48991',
                '8ef109e1 56193951 ec7e937b 1652c0bd',
                '3bb1bf07 3573df88 3d2c34f1 ef451fd4',
                '6b503f00'
              ],
              n: [
                '000001ff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'fffffffa 51868783 bf2f966b 7fcc0148',
                'f709a5d0 3bb5c9b8 899c47ae bb6fb71e',
                '91386409'
              ],
              h: '1',
              z: '-4',
              g: [
                [
                  '000000c6 858e06b7 0404e9cd 9e3ecb66',
                  '2395b442 9c648139 053fb521 f828af60',
                  '6b4d3dba a14b5e77 efe75928 fe1dc127',
                  'a2ffa8de 3348b3c1 856a429b f97e7e31',
                  'c2e5bd66'
                ],
                [
                  '00000118 39296a78 9a3bc004 5c8a5fb4',
                  '2c7d1bd9 98f54449 579b4468 17afbd17',
                  '273e662c 97ee7299 5ef42640 c550b901',
                  '3fad0761 353c7086 a272c240 88be9476',
                  '9fd16650'
                ],
                g
              ]
            })
          }
        },
        x = class extends a {
          constructor(g) {
            super({
              id: 'SECP256K1',
              ossl: 'secp256k1',
              type: 'short',
              endian: 'be',
              hash: 'SHA256',
              prime: 'k256',
              p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe fffffc2f'],
              a: '0',
              b: '7',
              n: ['ffffffff ffffffff ffffffff fffffffe', 'baaedce6 af48a03b bfd25e8c d0364141'],
              h: '1',
              z: '1',
              c: ['0a2d2ba9 3507f1df 233770c2 a797962c', 'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],
              g: [
                ['79be667e f9dcbbac 55a06295 ce870b07', '029bfcdb 2dce28d9 59f2815b 16f81798'],
                ['483ada77 26a3c465 5da4fbfc 0e1108a8', 'fd17b448 a6855419 9c47d08f fb10d4b8'],
                g
              ],
              endo: {
                beta: ['7ae96a2b 657c0710 6e64479e ac3434e9', '9cf04975 12f58995 c1396c28 719501ee'],
                lambda: ['5363ad4c c05c30e0 a5261c02 8812645a', '122e22ea 20816678 df02967c 1b23bd72'],
                basis: [
                  { a: '3086d221a7d46bcde86c90e49284eb15', b: '-e4437ed6010e88286f547fa90abfe4c3' },
                  { a: '114ca50f7a8e2f3f657c1108d9d44cfd8', b: '3086d221a7d46bcde86c90e49284eb15' }
                ],
                pre: [
                  384,
                  ['3086d221 a7d46bcd e86c90e4 9284eb15', '3daa8a14 71e8ca7f e893209a 45dbb031'],
                  ['-', 'e4437ed6 010e8828 6f547fa9 0abfe4c4', '221208ac 9df506c6 1571b4ae 8ac47f71']
                ]
              }
            })
          }
        },
        L = class extends a {
          constructor(g) {
            super({
              id: 'BRAINPOOLP256',
              ossl: 'brainpoolP256r1',
              type: 'short',
              endian: 'be',
              hash: 'SHA256',
              prime: null,
              p: ['a9fb57db a1eea9bc 3e660a90 9d838d72', '6e3bf623 d5262028 2013481d 1f6e5377'],
              a: ['7d5a0975 fc2c3057 eef67530 417affe7', 'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],
              b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf', '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],
              n: ['a9fb57db a1eea9bc 3e660a90 9d838d71', '8c397aa3 b561a6f7 901e0e82 974856a7'],
              h: '1',
              z: '-2',
              g: [
                ['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af', 'b9de27e1 e3bd23c2 3a4453bd 9ace3262'],
                ['547ef835 c3dac4fd 97f8461a 14611dc9', 'c2774513 2ded8e54 5c1d54c7 2f046997'],
                g
              ]
            })
          }
        },
        K = class extends a {
          constructor(g) {
            super({
              id: 'BRAINPOOLP384',
              ossl: 'brainpoolP384r1',
              type: 'short',
              endian: 'be',
              hash: 'SHA384',
              prime: null,
              p: [
                '8cb91e82 a3386d28 0f5d6f7e 50e641df',
                '152f7109 ed5456b4 12b1da19 7fb71123',
                'acd3a729 901d1a71 87470013 3107ec53'
              ],
              a: [
                '7bc382c6 3d8c150c 3c72080a ce05afa0',
                'c2bea28e 4fb22787 139165ef ba91f90f',
                '8aa5814a 503ad4eb 04a8c7dd 22ce2826'
              ],
              b: [
                '04a8c7dd 22ce2826 8b39b554 16f0447c',
                '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5',
                '7cb43902 95dbc994 3ab78696 fa504c11'
              ],
              n: [
                '8cb91e82 a3386d28 0f5d6f7e 50e641df',
                '152f7109 ed5456b3 1f166e6c ac0425a7',
                'cf3ab6af 6b7fc310 3b883202 e9046565'
              ],
              h: '1',
              z: '-5',
              g: [
                [
                  '1d1c64f0 68cf45ff a2a63a81 b7c13f6b',
                  '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8',
                  'e826e034 36d646aa ef87b2e2 47d4af1e'
                ],
                [
                  '8abe1d75 20f9c2a4 5cb1eb8e 95cfd552',
                  '62b70b29 feec5864 e19c054f f9912928',
                  '0e464621 77918111 42820341 263c5315'
                ],
                g
              ]
            })
          }
        },
        J = class extends a {
          constructor(g) {
            super({
              id: 'BRAINPOOLP512',
              ossl: 'brainpoolP512r1',
              type: 'short',
              endian: 'be',
              hash: 'SHA512',
              prime: null,
              p: [
                'aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',
                'cb308db3 b3c9d20e d6639cca 70330871',
                '7d4d9b00 9bc66842 aecda12a e6a380e6',
                '2881ff2f 2d82c685 28aa6056 583a48f3'
              ],
              a: [
                '7830a331 8b603b89 e2327145 ac234cc5',
                '94cbdd8d 3df91610 a83441ca ea9863bc',
                '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5',
                '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'
              ],
              b: [
                '3df91610 a83441ca ea9863bc 2ded5d5a',
                'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7',
                '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67',
                '984050b7 5ebae5dd 2809bd63 8016f723'
              ],
              n: [
                'aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07',
                'cb308db3 b3c9d20e d6639cca 70330870',
                '553e5c41 4ca92619 41866119 7fac1047',
                '1db1d381 085ddadd b5879682 9ca90069'
              ],
              h: '1',
              z: '7',
              g: [
                [
                  '81aee4bd d82ed964 5a21322e 9c4c6a93',
                  '85ed9f70 b5d916c1 b43b62ee f4d0098e',
                  'ff3b1f78 e2d0d48d 50d1687b 93b97d5f',
                  '7c6d5047 406a5e68 8b352209 bcb9f822'
                ],
                [
                  '7dde385d 566332ec c0eabfa9 cf7822fd',
                  'f209f700 24a57b1a a000c55b 881f8111',
                  'b2dcde49 4a5f485e 5bca4bd8 8a2763ae',
                  'd1ca2b2f a8f05406 78cd1e0f 3ad80892'
                ],
                g
              ]
            })
          }
        },
        Z = class extends p {
          constructor() {
            super({
              id: 'X25519',
              ossl: 'X25519',
              type: 'mont',
              endian: 'le',
              hash: 'SHA512',
              prime: 'p25519',
              p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],
              a: '76d06',
              b: '1',
              n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],
              h: '8',
              z: '2',
              g: [
                ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000009'],
                ['5f51e65e 475f794b 1fe122d3 88b72eb3', '6dc2b281 92839e4d d6163a5d 81312c14']
              ],
              torsion: [
                [],
                [
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'],
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']
                ],
                [
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001'],
                  ['6be4f497 f9a9c2af c21fa77a d7f4a6ef', '635a11c7 284a9363 e9a248ef 9c884415']
                ],
                [
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001'],
                  ['141b0b68 06563d50 3de05885 280b5910', '9ca5ee38 d7b56c9c 165db710 6377bbd8']
                ],
                [
                  ['57119fd0 dd4e22d8 868e1c58 c45c4404', '5bef839c 55b1d0b1 248c50a3 bc959c5f'],
                  ['68c59389 3d458e64 31c6ca00 45fb5015', '20a44346 8eaa68dd 0f103842 048065b7']
                ],
                [
                  ['57119fd0 dd4e22d8 868e1c58 c45c4404', '5bef839c 55b1d0b1 248c50a3 bc959c5f'],
                  ['173a6c76 c2ba719b ce3935ff ba04afea', 'df5bbcb9 71559722 f0efc7bd fb7f9a36']
                ],
                [
                  ['00b8495f 16056286 fdb1329c eb8d09da', '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],
                  ['3931c129 569e83a5 29482c14 e628b457', '933bfc29 ed801b4d 68871483 92507b1a']
                ],
                [
                  ['00b8495f 16056286 fdb1329c eb8d09da', '6ac49ff1 fae35616 aeb8413b 7c7aebe0'],
                  ['46ce3ed6 a9617c5a d6b7d3eb 19d74ba8', '6cc403d6 127fe4b2 9778eb7c 6daf84d3']
                ]
              ]
            })
          }
        },
        Q = class extends p {
          constructor() {
            super({
              id: 'X448',
              ossl: 'X448',
              type: 'mont',
              endian: 'le',
              hash: 'SHAKE256',
              prime: 'p448',
              p: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff fffffffe ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff'
              ],
              a: '262a6',
              b: '1',
              n: [
                '3fffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff 7cca23e9',
                'c44edb49 aed63690 216cc272 8dc58f55',
                '2378c292 ab5844f3'
              ],
              h: '4',
              z: '-1',
              g: [
                [
                  '00000000 00000000 00000000 00000000',
                  '00000000 00000000 00000000 00000000',
                  '00000000 00000000 00000000 00000000',
                  '00000000 00000005'
                ],
                [
                  '7d235d12 95f5b1f6 6c98ab6e 58326fce',
                  'cbae5d34 f55545d0 60f75dc2 8df3f6ed',
                  'b8027e23 46430d21 1312c4b1 50677af7',
                  '6fd7223d 457b5b1a'
                ]
              ],
              torsion: [
                [],
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ]
                ],
                [
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ],
                  [
                    'ba4d3a08 29b6112f 8812e51b a0bb2abe',
                    'bc1cb08e b48e5569 36ba50fd d2e7d68a',
                    'f8cb3216 0522425b 3f990812 abbe635a',
                    'd37a21e1 7551b193'
                  ]
                ],
                [
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ],
                  [
                    '45b2c5f7 d649eed0 77ed1ae4 5f44d541',
                    '43e34f71 4b71aa96 c945af01 2d182975',
                    '0734cde9 faddbda4 c066f7ed 54419ca5',
                    '2c85de1e 8aae4e6c'
                  ]
                ]
              ]
            })
          }
        },
        fe = class extends p {
          constructor() {
            super({
              id: 'MONT448',
              ossl: null,
              type: 'mont',
              endian: 'le',
              hash: 'SHAKE256',
              prime: 'p448',
              p: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff fffffffe ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff'
              ],
              a: [
                'b2cf97d2 d43459a9 31ed36b1 fc4e3cb5',
                '5d93f8d2 22746997 60ccffc6 49961ed6',
                'c5b05fca c24864ed 6fb59697 931b78da',
                '84ddecd8 ca2b5cfb'
              ],
              b: '1',
              n: [
                '3fffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff 7cca23e9',
                'c44edb49 aed63690 216cc272 8dc58f55',
                '2378c292 ab5844f3'
              ],
              h: '4',
              z: '-1',
              g: [
                [
                  'ac0d24cc c6c75cb0 eb71f81e 7a6edf51',
                  '48e88aee 009a2a24 e795687e c28e125a',
                  '3e6730a6 0d46367b aa7fe99d 152128dc',
                  '41321bc7 7817f059'
                ],
                [
                  '5a4437f6 80c0d0db 9b061276 d5d0ffcc',
                  'e786ff33 b6a53d30 98746425 82e66f09',
                  '4433dae7 7244a6e2 6b11e905 7228f483',
                  '556c41a5 913f55fe'
                ]
              ],
              torsion: [
                [],
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ]
                ],
                [
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ],
                  [
                    'bec92fd0 6da2acf2 b4e261e8 7cef0d34',
                    '22e75c18 3c589857 b71924e5 73c2f9ce',
                    'e18da5f2 466e2f39 3c2eedf0 f105a60a',
                    'b40c717d 4f1e1fd7'
                  ]
                ],
                [
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ],
                  [
                    '4136d02f 925d530d 4b1d9e17 8310f2cb',
                    'dd18a3e7 c3a767a8 48e6db19 8c3d0631',
                    '1e725a0d b991d0c6 c3d1120f 0efa59f5',
                    '4bf38e82 b0e1e028'
                  ]
                ]
              ]
            })
          }
        },
        ie = class extends h {
          constructor(g) {
            super({
              id: 'ED25519',
              ossl: 'ED25519',
              type: 'edwards',
              endian: 'le',
              hash: 'SHA512',
              prefix: 'SigEd25519 no Ed25519 collisions',
              context: !1,
              prime: 'p25519',
              p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],
              a: '-1',
              d: ['52036cee 2b6ffe73 8cc74079 7779e898', '00700a4d 4141d8ab 75eb4dca 135978a3'],
              n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],
              h: '8',
              z: '2',
              g: [
                ['216936d3 cd6e53fe c0a4e231 fdd6dc5c', '692cc760 9525a7b2 c9562d60 8f25d51a'],
                ['66666666 66666666 66666666 66666666', '66666666 66666666 66666666 66666658'],
                g
              ],
              torsion: [
                [
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'],
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000001']
                ],
                [
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000'],
                  ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffec']
                ],
                [
                  ['2b832480 4fc1df0b 2b4d0099 3dfbd7a7', '2f431806 ad2fe478 c4ee1b27 4a0ea0b0'],
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']
                ],
                [
                  ['547cdb7f b03e20f4 d4b2ff66 c2042858', 'd0bce7f9 52d01b87 3b11e4d8 b5f15f3d'],
                  ['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000']
                ],
                [
                  ['1fd5b9a0 06394a28 e9339932 38de4abb', '5c193c70 13e5e238 dea14646 c545d14a'],
                  ['05fc536d 880238b1 3933c6d3 05acdfd5', 'f098eff2 89f4c345 b027b2c2 8f95e826']
                ],
                [
                  ['602a465f f9c6b5d7 16cc66cd c721b544', 'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],
                  ['05fc536d 880238b1 3933c6d3 05acdfd5', 'f098eff2 89f4c345 b027b2c2 8f95e826']
                ],
                [
                  ['1fd5b9a0 06394a28 e9339932 38de4abb', '5c193c70 13e5e238 dea14646 c545d14a'],
                  ['7a03ac92 77fdc74e c6cc392c fa53202a', '0f67100d 760b3cba 4fd84d3d 706a17c7']
                ],
                [
                  ['602a465f f9c6b5d7 16cc66cd c721b544', 'a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3'],
                  ['7a03ac92 77fdc74e c6cc392c fa53202a', '0f67100d 760b3cba 4fd84d3d 706a17c7']
                ]
              ]
            })
          }
        },
        W = class extends h {
          constructor(g) {
            super({
              id: 'ISO448',
              ossl: null,
              type: 'edwards',
              endian: 'le',
              hash: 'SHAKE256',
              prefix: 'SigEd448',
              context: !0,
              prime: 'p448',
              p: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff fffffffe ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff'
              ],
              a: '1',
              d: [
                'd78b4bdc 7f0daf19 f24f38c2 9373a2cc',
                'ad461572 42a50f37 809b1da3 412a12e7',
                '9ccc9c81 264cfe9a d0809970 58fb61c4',
                '243cc32d baa156b9'
              ],
              n: [
                '3fffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff 7cca23e9',
                'c44edb49 aed63690 216cc272 8dc58f55',
                '2378c292 ab5844f3'
              ],
              h: '4',
              z: '-1',
              g: [
                [
                  '79a70b2b 70400553 ae7c9df4 16c792c6',
                  '1128751a c9296924 0c25a07d 728bdc93',
                  'e21f7787 ed697224 9de732f3 8496cd11',
                  '69871309 3e9c04fc'
                ],
                [
                  '7fffffff ffffffff ffffffff ffffffff',
                  'ffffffff ffffffff ffffffff 80000000',
                  '00000000 00000000 00000000 00000000',
                  '00000000 00000001'
                ],
                g
              ],
              torsion: [
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000001'
                  ]
                ],
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ],
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ]
                ],
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000001'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ]
                ],
                [
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ]
                ]
              ]
            })
          }
        },
        le = class extends h {
          constructor(g) {
            super({
              id: 'ED448',
              ossl: 'ED448',
              type: 'edwards',
              endian: 'le',
              hash: 'SHAKE256',
              prefix: 'SigEd448',
              context: !0,
              prime: 'p448',
              p: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff fffffffe ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff'
              ],
              a: '1',
              d: [
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff fffffffe ffffffff',
                'ffffffff ffffffff ffffffff ffffffff',
                'ffffffff ffff6756'
              ],
              n: [
                '3fffffff ffffffff ffffffff ffffffff',
                'ffffffff ffffffff ffffffff 7cca23e9',
                'c44edb49 aed63690 216cc272 8dc58f55',
                '2378c292 ab5844f3'
              ],
              h: '4',
              z: '-1',
              g: [
                [
                  '4f1970c6 6bed0ded 221d15a6 22bf36da',
                  '9e146570 470f1767 ea6de324 a3d3a464',
                  '12ae1af7 2ab66511 433b80e1 8b00938e',
                  '2626a82b c70cc05e'
                ],
                [
                  '693f4671 6eb6bc24 88762037 56c9c762',
                  '4bea7373 6ca39840 87789c1e 05a0c2d7',
                  '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad',
                  '9808795b f230fa14'
                ],
                g
              ],
              torsion: [
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000001'
                  ]
                ],
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ],
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ]
                ],
                [
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000001'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ]
                ],
                [
                  [
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff ffffffff fffffffe ffffffff',
                    'ffffffff ffffffff ffffffff ffffffff',
                    'ffffffff fffffffe'
                  ],
                  [
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000 00000000 00000000',
                    '00000000 00000000'
                  ]
                ]
              ]
            })
          }
        },
        xe = {
          __proto__: null,
          P192: I,
          P224: M,
          P256: q,
          P384: G,
          P521: O,
          SECP256K1: x,
          BRAINPOOLP256: L,
          BRAINPOOLP384: K,
          BRAINPOOLP512: J,
          X25519: Z,
          X448: Q,
          MONT448: fe,
          ED25519: ie,
          ISO448: W,
          ED448: le
        },
        _e = {
          __proto__: null,
          P192: null,
          P224: null,
          P256: null,
          P384: null,
          P521: null,
          SECP256K1: null,
          BRAINPOOLP256: null,
          BRAINPOOLP384: null,
          BRAINPOOLP512: null,
          X25519: null,
          X448: null,
          MONT448: null,
          ED25519: null,
          ISO448: null,
          ED448: null
        }
      function Ne(g, ...N) {
        j(typeof g == 'string')
        let U = g.toUpperCase(),
          X = _e[U]
        if (!X) {
          let ne = xe[U]
          if (!ne) throw new Error(`Curve not found: "${g}".`)
          ;(X = new ne(...N)), (_e[U] = X)
        }
        return X
      }
      function ke(g, N) {
        j(typeof g == 'string'), j(typeof N == 'function')
        let U = g.toUpperCase()
        if (xe[U]) throw new Error(`Curve already registered: "${g}".`)
        ;(xe[U] = N), (_e[U] = null)
      }
      function oe(g, N, U) {
        j(g instanceof t), j(!g.red), j(N >>> 0 === N), j(U >>> 0 === U)
        let X = new Array(U),
          ne = g.bitLength() + 1,
          ee = g.sign() | 1
        j(ne <= U)
        for (let H = 0; H < U; H++) X[H] = 0
        let ae = 0,
          Y = 0,
          z
        for (; ae < ne; ) {
          if (g.bit(ae) === Y) {
            ae += 1
            continue
          }
          ;(z = g.bits(ae, N) + Y), (Y = (z >> (N - 1)) & 1), (z -= Y << N), (X[ae] = ee * z), (ae += N)
        }
        return j(Y === 0), X
      }
      function be(g, N, U, X) {
        j(X >>> 0 === X)
        let ne = oe(g, N, U),
          ee = Math.ceil(ne.length / X),
          ae = new Array(ee),
          Y = 0
        for (let z = 0; z < ne.length; z += X) {
          let H = 0
          for (let se = z + X - 1; se >= z; se--) H = (H << 1) + ne[se]
          ae[Y++] = H
        }
        return j(Y === ee), ae
      }
      function ge(g, N, U) {
        j(g instanceof t), j(N instanceof t), j(!g.red), j(!N.red), j(U >>> 0 === U)
        let X = [new Array(U), new Array(U)],
          ne = Math.max(g.bitLength(), N.bitLength()) + 1,
          ee = g.sign() | 1,
          ae = N.sign() | 1
        j(ne <= U)
        let Y = 0,
          z = 0
        for (let H = 0; H < ne; H++) {
          let se = g.bits(H, 3),
            me = N.bits(H, 3),
            we = ((se & 3) + Y) & 3,
            Ee = ((me & 3) + z) & 3,
            Me = 0,
            Be = 0
          if ((we === 3 && (we = -1), Ee === 3 && (Ee = -1), we & 1)) {
            let je = ((se & 7) + Y) & 7
            ;(je === 3 || je === 5) && Ee === 2 ? (Me = -we) : (Me = we)
          }
          if (Ee & 1) {
            let je = ((me & 7) + z) & 7
            ;(je === 3 || je === 5) && we === 2 ? (Be = -Ee) : (Be = Ee)
          }
          ;(X[0][H] = Me * ee), (X[1][H] = Be * ae), 2 * Y === 1 + Me && (Y = 1 - Y), 2 * z === 1 + Be && (z = 1 - z)
        }
        for (let H = ne; H < U; H++) (X[0][H] = 0), (X[1][H] = 0)
        return X
      }
      function re(g, N, U) {
        let X = ge(g, N, U),
          ne = new Array(U)
        for (let ee = 0; ee < U; ee++) {
          let ae = X[0][ee],
            Y = X[1][ee]
          ne[ee] = i[(ae + 1) * 3 + (Y + 1)]
        }
        return ne
      }
      function j(g, N) {
        if (!g) {
          let U = new Error(N || 'Assertion failed')
          throw (Error.captureStackTrace && Error.captureStackTrace(U, j), U)
        }
      }
      function b(g) {
        j(typeof g == 'function')
        try {
          return g()
        } catch (N) {
          throw N.message === 'X is not a square mod P.' || N.message === 'Not invertible.'
            ? new Error('Invalid point.')
            : N
        }
      }
      function C(g, N) {
        let U = g % N
        return U < 0 && (N < 0 ? (U -= N) : (U += N)), U
      }
      function S(g) {
        j(g instanceof t), j(g.red)
        let N = g.red.m
        if (N.cmpn(3) <= 0) return g.clone()
        if (N.modrn(3) === 2) {
          let X = N.ushln(1).isubn(1).idivn(3)
          return g.redPow(X)
        }
        let U = N.modrn(9)
        if (U === 4) {
          let X = N.ushln(1).iaddn(1).idivn(9),
            ne = g.redPow(X)
          if (!ne.redSqr().redMul(ne).eq(g)) throw new Error('X is not a cube mod P.')
          return ne
        }
        if (U === 7) {
          let X = N.addn(2).idivn(9),
            ne = g.redPow(X)
          if (!ne.redSqr().redMul(ne).eq(g)) throw new Error('X is not a cube mod P.')
          return ne
        }
        throw new Error('Not implemented.')
      }
      function R(g) {
        let N = S(g)
        if (g.red.m.modrn(3) === 1) {
          let U = new t(2).toRed(g.red),
            X = new t(3).toRed(g.red),
            ne = U.redInvert(),
            ee = X.redNeg().redSqrt().redMul(ne),
            ae = ee.redNeg(),
            Y = ee.redSub(ne),
            z = ae.redSub(ne),
            H = N.redMul(Y),
            se = N.redMul(z)
          return [N, H, se]
        }
        return [N]
      }
      function P(g) {
        for (let N of R(g)) if (N.redJacobi() >= 0) return N
        throw new Error('X^(1/3) is not a square mod P.')
      }
      function B(g) {
        return t.randomBits(g, 32).toNumber()
      }
      function D(g, N) {
        let U = new WeakMap()
        return function (ne, ee) {
          let ae = ee & 1,
            Y = U.get(ne)
          if (Y && Y[ae] !== null) return Y[ae]
          let z = g.call(N, ne, ee)
          return U.has(ne) || U.set(ne, [null, null]), (U.get(ne)[ae] = z), z
        }
      }
      function $(g, N) {
        j(g instanceof t), j(N >>> 0 === N), N & 7 && (N += 8 - (N & 7))
        let U = g.toString(16, N),
          X = [],
          ne = []
        j((U.length & 7) == 0)
        for (let ee = 0; ee < U.length; ee += 8) X.push(U.slice(ee, ee + 8))
        for (let ee = 0; ee < X.length; ee += 4) ne.push(X.slice(ee, ee + 4).join(' '))
        return ne
      }
      ;(e.Curve = o),
        (e.Point = l),
        (e.ShortCurve = a),
        (e.ShortPoint = c),
        (e.JPoint = f),
        (e.MontCurve = p),
        (e.MontPoint = y),
        (e.XPoint = d),
        (e.EdwardsCurve = h),
        (e.EdwardsPoint = m),
        (e.curves = xe),
        (e.curve = Ne),
        (e.register = ke)
    }
  }),
  DD = te({
    'node_modules/bcrypto/lib/js/random.js'(e) {
      V(), F()
      var r = ji(),
        t = globalThis.crypto || globalThis.msCrypto,
        n = t && typeof t.getRandomValues == 'function',
        i = n ? t.getRandomValues.bind(t) : null,
        s = new Uint32Array(16),
        u = 65536,
        o = 0
      function l(d) {
        r(d >>> 0 === d)
        let h = Ve.Buffer.alloc(d)
        return y(h, 0, d), h
      }
      function a(d, h, m) {
        return (
          r(Ve.Buffer.isBuffer(d)),
          h == null && (h = 0),
          r(h >>> 0 === h),
          m == null && (m = d.length - h),
          r(m >>> 0 === m),
          r(h + m <= d.length),
          y(d, h, m),
          d
        )
      }
      function c() {
        return (o & 15) == 0 && (p(s), (o = 0)), s[o++]
      }
      function f(d, h) {
        r(d >>> 0 === d), r(h >>> 0 === h), r(h >= d)
        let m = h - d
        if (m === 0) return d
        let _ = -m >>> 0,
          A,
          T
        do (A = c()), (T = A % m)
        while (A - T > _)
        return T + d
      }
      function p(d) {
        if (!n) throw new Error('Entropy source not available.')
        return i(d)
      }
      function y(d, h, m) {
        if (
          (r(Ve.Buffer.isBuffer(d)),
          r(d.buffer instanceof ArrayBuffer),
          r(d.byteOffset >>> 0 === d.byteOffset),
          r(d.byteLength >>> 0 === d.byteLength),
          r(h >>> 0 === h),
          r(m >>> 0 === m),
          r(h + m <= d.byteLength),
          m > 2 ** 31 - 1)
        )
          throw new RangeError('The value "size" is out of range.')
        let _ = d.byteOffset + h,
          A = new Uint8Array(d.buffer, _, m)
        if (A.length > u)
          for (let T = 0; T < A.length; T += u) {
            let E = T + u
            E > A.length && (E = A.length), p(A.subarray(T, E))
          }
        else A.length > 0 && p(A)
      }
      ;(e.native = 0), (e.randomBytes = l), (e.randomFill = a), (e.randomInt = c), (e.randomRange = f)
    }
  }),
  LD = te({
    'node_modules/bcrypto/lib/random-browser.js'(e, r) {
      V(), F(), (r.exports = DD())
    }
  }),
  UD = te({
    'node_modules/bcrypto/lib/js/ecdh.js'(e, r) {
      V(), F()
      var t = ji(),
        n = nA(),
        i = OD(),
        s = LD(),
        u = class {
          constructor(o, l, a) {
            t(typeof o == 'string'),
              t(!l || typeof l == 'string'),
              (this.id = o),
              (this.type = 'ecdh'),
              (this.eid = l || null),
              (this._pre = a || null),
              (this._curve = null),
              (this._edwards = null),
              (this.native = 0)
          }
          get curve() {
            return this._curve || (this._curve = i.curve(this.id)), this._curve
          }
          get edwards() {
            return (
              this.eid &&
                !this._edwards &&
                ((this._edwards = i.curve(this.eid, this._pre)), this._edwards.precompute(s), (this._pre = null)),
              this._edwards
            )
          }
          get size() {
            return this.curve.fieldSize
          }
          get bits() {
            return this.curve.fieldBits
          }
          privateKeyGenerate() {
            let o = s.randomBytes(this.curve.scalarSize)
            return this.curve.clamp(o)
          }
          privateKeyVerify(o) {
            return t(Ve.Buffer.isBuffer(o)), o.length === this.curve.scalarSize
          }
          privateKeyExport(o, l) {
            let a = this.publicKeyCreate(o),
              { x: c, y: f } = this.publicKeyExport(a, l)
            return { d: Ve.Buffer.from(o), x: c, y: f }
          }
          privateKeyImport(o) {
            t(o && typeof o == 'object')
            let l = n.decode(o.d, this.curve.endian)
            if (l.byteLength() > this.curve.scalarSize) throw new Error('Invalid private key.')
            return this.curve.encodeScalar(l)
          }
          publicKeyCreate(o) {
            let l = this.curve.decodeClamped(o)
            if (this.edwards && this.edwards.g.pre) {
              let f = this.edwards.g.mulBlind(l)
              return this.curve.pointFromEdwards(f).encode()
            }
            return this.curve.g.toX().mulBlind(l, s).encode()
          }
          publicKeyConvert(o, l) {
            if ((t(l == null || typeof l == 'boolean'), !this.edwards)) throw new Error('No equivalent edwards curve.')
            let a = this.curve.decodePoint(o),
              c = this.edwards.pointFromMont(a)
            return l != null && c.isOdd() !== l ? c.neg().encode() : c.encode()
          }
          publicKeyFromUniform(o) {
            let l = this.curve.decodeUniform(o)
            return this.curve.pointFromUniform(l).encode()
          }
          publicKeyToUniform(o, l = s.randomInt()) {
            let a = this.curve.decodePoint(o),
              c = this.curve.pointToUniform(a, l)
            return this.curve.encodeUniform(c, l >>> 8)
          }
          publicKeyFromHash(o, l = !1) {
            return this.curve.pointFromHash(o, l).encode()
          }
          publicKeyToHash(o, l = s.randomInt()) {
            let a = this.curve.decodePoint(o)
            return this.curve.pointToHash(a, l, s)
          }
          publicKeyVerify(o) {
            t(Ve.Buffer.isBuffer(o))
            let l
            try {
              l = this.curve.decodeX(o)
            } catch (a) {
              return !1
            }
            return l.validate()
          }
          publicKeyIsSmall(o) {
            t(Ve.Buffer.isBuffer(o))
            let l
            try {
              l = this.curve.decodeX(o)
            } catch (a) {
              return !1
            }
            return l.validate() ? l.isSmall() : !1
          }
          publicKeyHasTorsion(o) {
            t(Ve.Buffer.isBuffer(o))
            let l
            try {
              l = this.curve.decodeX(o)
            } catch (a) {
              return !1
            }
            return l.validate() ? l.hasTorsion() : !1
          }
          publicKeyExport(o, l) {
            let { x: a, y: c } = this.curve.decodePoint(o, l)
            return { x: this.curve.encodeField(a.fromRed()), y: this.curve.encodeField(c.fromRed()) }
          }
          publicKeyImport(o) {
            t(o && typeof o == 'object')
            let l = n.decode(o.x, this.curve.endian)
            if (l.cmp(this.curve.p) >= 0) throw new Error('Invalid point.')
            if (o.y != null) {
              let c = n.decode(o.y, this.curve.endian)
              if (c.cmp(this.curve.p) >= 0) throw new Error('Invalid point.')
              let f = this.curve.point(l, c)
              if (!f.validate()) throw new Error('Invalid point.')
              return f.encode()
            }
            return this.curve.pointFromX(l).encode()
          }
          derive(o, l) {
            let a = this.curve.decodeX(o),
              c = this.curve.decodeClamped(l)
            return a.mulBlind(c, s).encode()
          }
        }
      r.exports = u
    }
  }),
  qD = te({
    'node_modules/bcrypto/lib/js/precomputed/ed25519.json'(e, r) {
      r.exports = {
        naf: {
          width: 9,
          points: [
            [
              '67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c',
              '1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4'
            ],
            [
              '49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233',
              '5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed'
            ],
            [
              '14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107',
              '31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8'
            ],
            [
              '357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c',
              '7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0'
            ],
            [
              '14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb',
              '2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713'
            ],
            [
              '107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed',
              '12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80'
            ],
            [
              '4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1',
              '12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf'
            ],
            [
              '7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a',
              '6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04'
            ],
            [
              '1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472',
              '3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9'
            ],
            [
              '6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716',
              '6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e'
            ],
            [
              '2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95',
              '23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee'
            ],
            [
              '794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455',
              '71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0'
            ],
            [
              '163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079',
              '631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939'
            ],
            [
              '39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d',
              '4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491'
            ],
            [
              '38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9',
              '42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a'
            ],
            [
              '5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1',
              '54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871'
            ],
            [
              '7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb',
              '01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3'
            ],
            [
              '05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3',
              '6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903'
            ],
            [
              '624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3',
              '5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3'
            ],
            [
              '1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9',
              '5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e'
            ],
            [
              '396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101',
              '7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644'
            ],
            [
              '53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50',
              '2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1'
            ],
            [
              '34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368',
              '299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e'
            ],
            [
              '5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618',
              '680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4'
            ],
            [
              '27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb',
              '0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3'
            ],
            [
              '0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a',
              '42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e'
            ],
            [
              '4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a',
              '5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8'
            ],
            [
              '1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817',
              '0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699'
            ],
            [
              '4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc',
              '503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd'
            ],
            [
              '3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6',
              '62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8'
            ],
            [
              '649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a',
              '1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c'
            ],
            [
              '3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56',
              '15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7'
            ],
            [
              '2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1',
              '08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c'
            ],
            [
              '642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385',
              '21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e'
            ],
            [
              '38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef',
              '458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0'
            ],
            [
              '372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db',
              '32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8'
            ],
            [
              '1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77',
              '42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae'
            ],
            [
              '38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5',
              '1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa'
            ],
            [
              '176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7',
              '7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852'
            ],
            [
              '042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6',
              '42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90'
            ],
            [
              '1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108',
              '1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8'
            ],
            [
              '613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5',
              '3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353'
            ],
            [
              '27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9',
              '16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea'
            ],
            [
              '769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2',
              '22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25'
            ],
            [
              '795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d',
              '756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5'
            ],
            [
              '644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46',
              '173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc'
            ],
            [
              '5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110',
              '4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396'
            ],
            [
              '296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848',
              '0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b'
            ],
            [
              '408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f',
              '4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8'
            ],
            [
              '07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07',
              '6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295'
            ],
            [
              '2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873',
              '215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6'
            ],
            [
              '1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a',
              '5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c'
            ],
            [
              '5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97',
              '69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8'
            ],
            [
              '24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb',
              '6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687'
            ],
            [
              '64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538',
              '513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4'
            ],
            [
              '47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e',
              '7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be'
            ],
            [
              '4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f',
              '4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d'
            ],
            [
              '3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5',
              '689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968'
            ],
            [
              '61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10',
              '63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d'
            ],
            [
              '03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414',
              '74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183'
            ],
            [
              '0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9',
              '1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4'
            ],
            [
              '797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe',
              '5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc'
            ],
            [
              '735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd',
              '384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c'
            ],
            [
              '6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac',
              '61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10'
            ],
            [
              '5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773',
              '7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e'
            ],
            [
              '31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8',
              '1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0'
            ],
            [
              '424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0',
              '34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43'
            ],
            [
              '33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247',
              '37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602'
            ],
            [
              '5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb',
              '382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27'
            ],
            [
              '3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036',
              '09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4'
            ],
            [
              '62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973',
              '5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de'
            ],
            [
              '0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3',
              '6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2'
            ],
            [
              '6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e',
              '74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b'
            ],
            [
              '4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f',
              '41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c'
            ],
            [
              '65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741',
              '67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235'
            ],
            [
              '1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8',
              '7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77'
            ],
            [
              '2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71',
              '7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f'
            ],
            [
              '1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6',
              '153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597'
            ],
            [
              '0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129',
              '7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1'
            ],
            [
              '01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4',
              '60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc'
            ],
            [
              '79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150',
              '53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b'
            ],
            [
              '220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498',
              '05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a'
            ],
            [
              '1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18',
              '22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d'
            ],
            [
              '35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b',
              '155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39'
            ],
            [
              '3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd',
              '379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921'
            ],
            [
              '6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf',
              '1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea'
            ],
            [
              '7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123',
              '34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f'
            ],
            [
              '354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf',
              '7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a'
            ],
            [
              '1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850',
              '2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07'
            ],
            [
              '533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d',
              '6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764'
            ],
            [
              '4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b',
              '1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4'
            ],
            [
              '3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265',
              '025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9'
            ],
            [
              '5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6',
              '5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee'
            ],
            [
              '2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9',
              '2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964'
            ],
            [
              '79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1',
              '6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b'
            ],
            [
              '57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63',
              '14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc'
            ],
            [
              '6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523',
              '2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150'
            ],
            [
              '749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9',
              '7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d'
            ],
            [
              '340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1',
              '64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea'
            ],
            [
              '4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109',
              '3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21'
            ],
            [
              '34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb',
              '7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605'
            ],
            [
              '820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e',
              '756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9'
            ],
            [
              '0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3',
              '34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f'
            ],
            [
              '5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b',
              '54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c'
            ],
            [
              '755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc',
              '0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9'
            ],
            [
              '5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b',
              '6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba'
            ],
            [
              '1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46',
              '5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92'
            ],
            [
              '4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d',
              '45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b'
            ],
            [
              '63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91',
              '46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da'
            ],
            [
              '5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87',
              '3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa'
            ],
            [
              '62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec',
              '562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066'
            ],
            [
              '14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556',
              '447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3'
            ],
            [
              '1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6',
              '52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317'
            ],
            [
              '5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3',
              '41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64'
            ],
            [
              '4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607',
              '3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe'
            ],
            [
              '62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08',
              '4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8'
            ],
            [
              '4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757',
              '2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01'
            ],
            [
              '5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3',
              '547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722'
            ],
            [
              '424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015',
              '74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32'
            ],
            [
              '54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd',
              '6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676'
            ],
            [
              '732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb',
              '1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165'
            ],
            [
              '74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb',
              '501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014'
            ],
            [
              '04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7',
              '71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338'
            ],
            [
              '2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794',
              '2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5'
            ],
            [
              '555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6',
              '6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f'
            ],
            [
              '4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6',
              '2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154'
            ],
            [
              '5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16',
              '315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc'
            ]
          ]
        },
        doubles: {
          step: 4,
          points: [
            [
              '23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8',
              '709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb'
            ],
            [
              '5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556',
              '0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7'
            ],
            [
              '7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea',
              '59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5'
            ],
            [
              '5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565',
              '2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36'
            ],
            [
              '06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed',
              '07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8'
            ],
            [
              '0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77',
              '21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5'
            ],
            [
              '1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b',
              '0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76'
            ],
            [
              '4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb',
              '6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a'
            ],
            [
              '2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0',
              '7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2'
            ],
            [
              '0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5',
              '3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a'
            ],
            [
              '52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e',
              '7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3'
            ],
            [
              '52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52',
              '50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196'
            ],
            [
              '6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4',
              '727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5'
            ],
            [
              '71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4',
              '39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411'
            ],
            [
              '57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5',
              '6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34'
            ],
            [
              '6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202',
              '0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313'
            ],
            [
              '71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226',
              '3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25'
            ],
            [
              '1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f',
              '779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19'
            ],
            [
              '22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc',
              '631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb'
            ],
            [
              '608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4',
              '3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa'
            ],
            [
              '3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02',
              '0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e'
            ],
            [
              '69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5',
              '3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e'
            ],
            [
              '1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622',
              '295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79'
            ],
            [
              '51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0',
              '35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1'
            ],
            [
              '3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845',
              '7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc'
            ],
            [
              '1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f',
              '0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de'
            ],
            [
              '49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac',
              '3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8'
            ],
            [
              '4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b',
              '6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e'
            ],
            [
              '6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb',
              '2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36'
            ],
            [
              '4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424',
              '314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65'
            ],
            [
              '0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586',
              '47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea'
            ],
            [
              '4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824',
              '5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b'
            ],
            [
              '53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534',
              '5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559'
            ],
            [
              '7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6',
              '1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85'
            ],
            [
              '78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe',
              '0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5'
            ],
            [
              '2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91',
              '7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f'
            ],
            [
              '0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7',
              '16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e'
            ],
            [
              '1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a',
              '7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3'
            ],
            [
              '31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46',
              '77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790'
            ],
            [
              '543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031',
              '0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20'
            ],
            [
              '0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a',
              '187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6'
            ],
            [
              '7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a',
              '0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda'
            ],
            [
              '472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b',
              '10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc'
            ],
            [
              '04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a',
              '3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130'
            ],
            [
              '2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e',
              '653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d'
            ],
            [
              '0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325',
              '3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b'
            ],
            [
              '0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128',
              '1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7'
            ],
            [
              '1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d',
              '61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833'
            ],
            [
              '469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d',
              '0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb'
            ],
            [
              '5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb',
              '505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab'
            ],
            [
              '11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1',
              '43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0'
            ],
            [
              '3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb',
              '2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039'
            ],
            [
              '0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398',
              '54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321'
            ],
            [
              '1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c',
              '299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022'
            ],
            [
              '25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35',
              '179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947'
            ],
            [
              '75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f',
              '696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d'
            ],
            [
              '5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a',
              '10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a'
            ],
            [
              '7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07',
              '604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5'
            ],
            [
              '2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26',
              '68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe'
            ],
            [
              '28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787',
              '552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc'
            ],
            [
              '59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b',
              '3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20'
            ],
            [
              '5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f',
              '67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e'
            ],
            [
              '6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec',
              '5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8'
            ],
            [
              '53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699',
              '404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5'
            ]
          ]
        }
      }
    }
  }),
  F1 = te({
    'node_modules/bcrypto/lib/js/x25519.js'(e, r) {
      V(), F()
      var t = UD(),
        n = qD()
      r.exports = new t('X25519', 'ED25519', n)
    }
  }),
  Nr = te({
    'node_modules/libp2p-noise/node_modules/buffer/index.js'(e) {
      V(), F()
      var r = Yv(),
        t = Zv(),
        n =
          typeof Symbol == 'function' && typeof Symbol.for == 'function'
            ? Symbol.for('nodejs.util.inspect.custom')
            : null
      ;(e.Buffer = o), (e.SlowBuffer = A), (e.INSPECT_MAX_BYTES = 50)
      var i = 2147483647
      ;(e.kMaxLength = i),
        (o.TYPED_ARRAY_SUPPORT = s()),
        !o.TYPED_ARRAY_SUPPORT &&
          typeof console != 'undefined' &&
          typeof console.error == 'function' &&
          console.error(
            'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
          )
      function s() {
        try {
          var P = new Uint8Array(1),
            B = {
              foo: function () {
                return 42
              }
            }
          return Object.setPrototypeOf(B, Uint8Array.prototype), Object.setPrototypeOf(P, B), P.foo() === 42
        } catch (D) {
          return !1
        }
      }
      Object.defineProperty(o.prototype, 'parent', {
        enumerable: !0,
        get: function () {
          if (!!o.isBuffer(this)) return this.buffer
        }
      }),
        Object.defineProperty(o.prototype, 'offset', {
          enumerable: !0,
          get: function () {
            if (!!o.isBuffer(this)) return this.byteOffset
          }
        })
      function u(P) {
        if (P > i) throw new RangeError('The value "' + P + '" is invalid for option "size"')
        var B = new Uint8Array(P)
        return Object.setPrototypeOf(B, o.prototype), B
      }
      function o(P, B, D) {
        if (typeof P == 'number') {
          if (typeof B == 'string')
            throw new TypeError('The "string" argument must be of type string. Received type number')
          return f(P)
        }
        return l(P, B, D)
      }
      o.poolSize = 8192
      function l(P, B, D) {
        if (typeof P == 'string') return p(P, B)
        if (ArrayBuffer.isView(P)) return d(P)
        if (P == null)
          throw new TypeError(
            'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
              typeof P
          )
        if (
          C(P, ArrayBuffer) ||
          (P && C(P.buffer, ArrayBuffer)) ||
          (typeof SharedArrayBuffer != 'undefined' &&
            (C(P, SharedArrayBuffer) || (P && C(P.buffer, SharedArrayBuffer))))
        )
          return h(P, B, D)
        if (typeof P == 'number')
          throw new TypeError('The "value" argument must not be of type number. Received type number')
        var $ = P.valueOf && P.valueOf()
        if ($ != null && $ !== P) return o.from($, B, D)
        var g = m(P)
        if (g) return g
        if (typeof Symbol != 'undefined' && Symbol.toPrimitive != null && typeof P[Symbol.toPrimitive] == 'function')
          return o.from(P[Symbol.toPrimitive]('string'), B, D)
        throw new TypeError(
          'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
            typeof P
        )
      }
      ;(o.from = function (P, B, D) {
        return l(P, B, D)
      }),
        Object.setPrototypeOf(o.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(o, Uint8Array)
      function a(P) {
        if (typeof P != 'number') throw new TypeError('"size" argument must be of type number')
        if (P < 0) throw new RangeError('The value "' + P + '" is invalid for option "size"')
      }
      function c(P, B, D) {
        return a(P), P <= 0 ? u(P) : B !== void 0 ? (typeof D == 'string' ? u(P).fill(B, D) : u(P).fill(B)) : u(P)
      }
      o.alloc = function (P, B, D) {
        return c(P, B, D)
      }
      function f(P) {
        return a(P), u(P < 0 ? 0 : _(P) | 0)
      }
      ;(o.allocUnsafe = function (P) {
        return f(P)
      }),
        (o.allocUnsafeSlow = function (P) {
          return f(P)
        })
      function p(P, B) {
        if (((typeof B != 'string' || B === '') && (B = 'utf8'), !o.isEncoding(B)))
          throw new TypeError('Unknown encoding: ' + B)
        var D = T(P, B) | 0,
          $ = u(D),
          g = $.write(P, B)
        return g !== D && ($ = $.slice(0, g)), $
      }
      function y(P) {
        for (var B = P.length < 0 ? 0 : _(P.length) | 0, D = u(B), $ = 0; $ < B; $ += 1) D[$] = P[$] & 255
        return D
      }
      function d(P) {
        if (C(P, Uint8Array)) {
          var B = new Uint8Array(P)
          return h(B.buffer, B.byteOffset, B.byteLength)
        }
        return y(P)
      }
      function h(P, B, D) {
        if (B < 0 || P.byteLength < B) throw new RangeError('"offset" is outside of buffer bounds')
        if (P.byteLength < B + (D || 0)) throw new RangeError('"length" is outside of buffer bounds')
        var $
        return (
          B === void 0 && D === void 0
            ? ($ = new Uint8Array(P))
            : D === void 0
            ? ($ = new Uint8Array(P, B))
            : ($ = new Uint8Array(P, B, D)),
          Object.setPrototypeOf($, o.prototype),
          $
        )
      }
      function m(P) {
        if (o.isBuffer(P)) {
          var B = _(P.length) | 0,
            D = u(B)
          return D.length === 0 || P.copy(D, 0, 0, B), D
        }
        if (P.length !== void 0) return typeof P.length != 'number' || S(P.length) ? u(0) : y(P)
        if (P.type === 'Buffer' && Array.isArray(P.data)) return y(P.data)
      }
      function _(P) {
        if (P >= i)
          throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' + i.toString(16) + ' bytes')
        return P | 0
      }
      function A(P) {
        return +P != P && (P = 0), o.alloc(+P)
      }
      ;(o.isBuffer = function (B) {
        return B != null && B._isBuffer === !0 && B !== o.prototype
      }),
        (o.compare = function (B, D) {
          if (
            (C(B, Uint8Array) && (B = o.from(B, B.offset, B.byteLength)),
            C(D, Uint8Array) && (D = o.from(D, D.offset, D.byteLength)),
            !o.isBuffer(B) || !o.isBuffer(D))
          )
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array')
          if (B === D) return 0
          for (var $ = B.length, g = D.length, N = 0, U = Math.min($, g); N < U; ++N)
            if (B[N] !== D[N]) {
              ;($ = B[N]), (g = D[N])
              break
            }
          return $ < g ? -1 : g < $ ? 1 : 0
        }),
        (o.isEncoding = function (B) {
          switch (String(B).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return !0
            default:
              return !1
          }
        }),
        (o.concat = function (B, D) {
          if (!Array.isArray(B)) throw new TypeError('"list" argument must be an Array of Buffers')
          if (B.length === 0) return o.alloc(0)
          var $
          if (D === void 0) for (D = 0, $ = 0; $ < B.length; ++$) D += B[$].length
          var g = o.allocUnsafe(D),
            N = 0
          for ($ = 0; $ < B.length; ++$) {
            var U = B[$]
            if (C(U, Uint8Array))
              N + U.length > g.length ? o.from(U).copy(g, N) : Uint8Array.prototype.set.call(g, U, N)
            else if (o.isBuffer(U)) U.copy(g, N)
            else throw new TypeError('"list" argument must be an Array of Buffers')
            N += U.length
          }
          return g
        })
      function T(P, B) {
        if (o.isBuffer(P)) return P.length
        if (ArrayBuffer.isView(P) || C(P, ArrayBuffer)) return P.byteLength
        if (typeof P != 'string')
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof P
          )
        var D = P.length,
          $ = arguments.length > 2 && arguments[2] === !0
        if (!$ && D === 0) return 0
        for (var g = !1; ; )
          switch (B) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return D
            case 'utf8':
            case 'utf-8':
              return be(P).length
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return D * 2
            case 'hex':
              return D >>> 1
            case 'base64':
              return j(P).length
            default:
              if (g) return $ ? -1 : be(P).length
              ;(B = ('' + B).toLowerCase()), (g = !0)
          }
      }
      o.byteLength = T
      function E(P, B, D) {
        var $ = !1
        if (
          ((B === void 0 || B < 0) && (B = 0),
          B > this.length ||
            ((D === void 0 || D > this.length) && (D = this.length), D <= 0) ||
            ((D >>>= 0), (B >>>= 0), D <= B))
        )
          return ''
        for (P || (P = 'utf8'); ; )
          switch (P) {
            case 'hex':
              return fe(this, B, D)
            case 'utf8':
            case 'utf-8':
              return L(this, B, D)
            case 'ascii':
              return Z(this, B, D)
            case 'latin1':
            case 'binary':
              return Q(this, B, D)
            case 'base64':
              return x(this, B, D)
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return ie(this, B, D)
            default:
              if ($) throw new TypeError('Unknown encoding: ' + P)
              ;(P = (P + '').toLowerCase()), ($ = !0)
          }
      }
      o.prototype._isBuffer = !0
      function k(P, B, D) {
        var $ = P[B]
        ;(P[B] = P[D]), (P[D] = $)
      }
      ;(o.prototype.swap16 = function () {
        var B = this.length
        if (B % 2 != 0) throw new RangeError('Buffer size must be a multiple of 16-bits')
        for (var D = 0; D < B; D += 2) k(this, D, D + 1)
        return this
      }),
        (o.prototype.swap32 = function () {
          var B = this.length
          if (B % 4 != 0) throw new RangeError('Buffer size must be a multiple of 32-bits')
          for (var D = 0; D < B; D += 4) k(this, D, D + 3), k(this, D + 1, D + 2)
          return this
        }),
        (o.prototype.swap64 = function () {
          var B = this.length
          if (B % 8 != 0) throw new RangeError('Buffer size must be a multiple of 64-bits')
          for (var D = 0; D < B; D += 8)
            k(this, D, D + 7), k(this, D + 1, D + 6), k(this, D + 2, D + 5), k(this, D + 3, D + 4)
          return this
        }),
        (o.prototype.toString = function () {
          var B = this.length
          return B === 0 ? '' : arguments.length === 0 ? L(this, 0, B) : E.apply(this, arguments)
        }),
        (o.prototype.toLocaleString = o.prototype.toString),
        (o.prototype.equals = function (B) {
          if (!o.isBuffer(B)) throw new TypeError('Argument must be a Buffer')
          return this === B ? !0 : o.compare(this, B) === 0
        }),
        (o.prototype.inspect = function () {
          var B = '',
            D = e.INSPECT_MAX_BYTES
          return (
            (B = this.toString('hex', 0, D)
              .replace(/(.{2})/g, '$1 ')
              .trim()),
            this.length > D && (B += ' ... '),
            '<Buffer ' + B + '>'
          )
        }),
        n && (o.prototype[n] = o.prototype.inspect),
        (o.prototype.compare = function (B, D, $, g, N) {
          if ((C(B, Uint8Array) && (B = o.from(B, B.offset, B.byteLength)), !o.isBuffer(B)))
            throw new TypeError(
              'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof B
            )
          if (
            (D === void 0 && (D = 0),
            $ === void 0 && ($ = B ? B.length : 0),
            g === void 0 && (g = 0),
            N === void 0 && (N = this.length),
            D < 0 || $ > B.length || g < 0 || N > this.length)
          )
            throw new RangeError('out of range index')
          if (g >= N && D >= $) return 0
          if (g >= N) return -1
          if (D >= $) return 1
          if (((D >>>= 0), ($ >>>= 0), (g >>>= 0), (N >>>= 0), this === B)) return 0
          for (
            var U = N - g, X = $ - D, ne = Math.min(U, X), ee = this.slice(g, N), ae = B.slice(D, $), Y = 0;
            Y < ne;
            ++Y
          )
            if (ee[Y] !== ae[Y]) {
              ;(U = ee[Y]), (X = ae[Y])
              break
            }
          return U < X ? -1 : X < U ? 1 : 0
        })
      function w(P, B, D, $, g) {
        if (P.length === 0) return -1
        if (
          (typeof D == 'string'
            ? (($ = D), (D = 0))
            : D > 2147483647
            ? (D = 2147483647)
            : D < -2147483648 && (D = -2147483648),
          (D = +D),
          S(D) && (D = g ? 0 : P.length - 1),
          D < 0 && (D = P.length + D),
          D >= P.length)
        ) {
          if (g) return -1
          D = P.length - 1
        } else if (D < 0)
          if (g) D = 0
          else return -1
        if ((typeof B == 'string' && (B = o.from(B, $)), o.isBuffer(B))) return B.length === 0 ? -1 : v(P, B, D, $, g)
        if (typeof B == 'number')
          return (
            (B = B & 255),
            typeof Uint8Array.prototype.indexOf == 'function'
              ? g
                ? Uint8Array.prototype.indexOf.call(P, B, D)
                : Uint8Array.prototype.lastIndexOf.call(P, B, D)
              : v(P, [B], D, $, g)
          )
        throw new TypeError('val must be string, number or Buffer')
      }
      function v(P, B, D, $, g) {
        var N = 1,
          U = P.length,
          X = B.length
        if (
          $ !== void 0 &&
          (($ = String($).toLowerCase()), $ === 'ucs2' || $ === 'ucs-2' || $ === 'utf16le' || $ === 'utf-16le')
        ) {
          if (P.length < 2 || B.length < 2) return -1
          ;(N = 2), (U /= 2), (X /= 2), (D /= 2)
        }
        function ne(H, se) {
          return N === 1 ? H[se] : H.readUInt16BE(se * N)
        }
        var ee
        if (g) {
          var ae = -1
          for (ee = D; ee < U; ee++)
            if (ne(P, ee) === ne(B, ae === -1 ? 0 : ee - ae)) {
              if ((ae === -1 && (ae = ee), ee - ae + 1 === X)) return ae * N
            } else ae !== -1 && (ee -= ee - ae), (ae = -1)
        } else
          for (D + X > U && (D = U - X), ee = D; ee >= 0; ee--) {
            for (var Y = !0, z = 0; z < X; z++)
              if (ne(P, ee + z) !== ne(B, z)) {
                Y = !1
                break
              }
            if (Y) return ee
          }
        return -1
      }
      ;(o.prototype.includes = function (B, D, $) {
        return this.indexOf(B, D, $) !== -1
      }),
        (o.prototype.indexOf = function (B, D, $) {
          return w(this, B, D, $, !0)
        }),
        (o.prototype.lastIndexOf = function (B, D, $) {
          return w(this, B, D, $, !1)
        })
      function I(P, B, D, $) {
        D = Number(D) || 0
        var g = P.length - D
        $ ? (($ = Number($)), $ > g && ($ = g)) : ($ = g)
        var N = B.length
        $ > N / 2 && ($ = N / 2)
        for (var U = 0; U < $; ++U) {
          var X = parseInt(B.substr(U * 2, 2), 16)
          if (S(X)) return U
          P[D + U] = X
        }
        return U
      }
      function M(P, B, D, $) {
        return b(be(B, P.length - D), P, D, $)
      }
      function q(P, B, D, $) {
        return b(ge(B), P, D, $)
      }
      function G(P, B, D, $) {
        return b(j(B), P, D, $)
      }
      function O(P, B, D, $) {
        return b(re(B, P.length - D), P, D, $)
      }
      ;(o.prototype.write = function (B, D, $, g) {
        if (D === void 0) (g = 'utf8'), ($ = this.length), (D = 0)
        else if ($ === void 0 && typeof D == 'string') (g = D), ($ = this.length), (D = 0)
        else if (isFinite(D))
          (D = D >>> 0), isFinite($) ? (($ = $ >>> 0), g === void 0 && (g = 'utf8')) : ((g = $), ($ = void 0))
        else throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported')
        var N = this.length - D
        if ((($ === void 0 || $ > N) && ($ = N), (B.length > 0 && ($ < 0 || D < 0)) || D > this.length))
          throw new RangeError('Attempt to write outside buffer bounds')
        g || (g = 'utf8')
        for (var U = !1; ; )
          switch (g) {
            case 'hex':
              return I(this, B, D, $)
            case 'utf8':
            case 'utf-8':
              return M(this, B, D, $)
            case 'ascii':
            case 'latin1':
            case 'binary':
              return q(this, B, D, $)
            case 'base64':
              return G(this, B, D, $)
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return O(this, B, D, $)
            default:
              if (U) throw new TypeError('Unknown encoding: ' + g)
              ;(g = ('' + g).toLowerCase()), (U = !0)
          }
      }),
        (o.prototype.toJSON = function () {
          return { type: 'Buffer', data: Array.prototype.slice.call(this._arr || this, 0) }
        })
      function x(P, B, D) {
        return B === 0 && D === P.length ? r.fromByteArray(P) : r.fromByteArray(P.slice(B, D))
      }
      function L(P, B, D) {
        D = Math.min(P.length, D)
        for (var $ = [], g = B; g < D; ) {
          var N = P[g],
            U = null,
            X = N > 239 ? 4 : N > 223 ? 3 : N > 191 ? 2 : 1
          if (g + X <= D) {
            var ne, ee, ae, Y
            switch (X) {
              case 1:
                N < 128 && (U = N)
                break
              case 2:
                ;(ne = P[g + 1]), (ne & 192) == 128 && ((Y = ((N & 31) << 6) | (ne & 63)), Y > 127 && (U = Y))
                break
              case 3:
                ;(ne = P[g + 1]),
                  (ee = P[g + 2]),
                  (ne & 192) == 128 &&
                    (ee & 192) == 128 &&
                    ((Y = ((N & 15) << 12) | ((ne & 63) << 6) | (ee & 63)),
                    Y > 2047 && (Y < 55296 || Y > 57343) && (U = Y))
                break
              case 4:
                ;(ne = P[g + 1]),
                  (ee = P[g + 2]),
                  (ae = P[g + 3]),
                  (ne & 192) == 128 &&
                    (ee & 192) == 128 &&
                    (ae & 192) == 128 &&
                    ((Y = ((N & 15) << 18) | ((ne & 63) << 12) | ((ee & 63) << 6) | (ae & 63)),
                    Y > 65535 && Y < 1114112 && (U = Y))
            }
          }
          U === null
            ? ((U = 65533), (X = 1))
            : U > 65535 && ((U -= 65536), $.push(((U >>> 10) & 1023) | 55296), (U = 56320 | (U & 1023))),
            $.push(U),
            (g += X)
        }
        return J($)
      }
      var K = 4096
      function J(P) {
        var B = P.length
        if (B <= K) return String.fromCharCode.apply(String, P)
        for (var D = '', $ = 0; $ < B; ) D += String.fromCharCode.apply(String, P.slice($, ($ += K)))
        return D
      }
      function Z(P, B, D) {
        var $ = ''
        D = Math.min(P.length, D)
        for (var g = B; g < D; ++g) $ += String.fromCharCode(P[g] & 127)
        return $
      }
      function Q(P, B, D) {
        var $ = ''
        D = Math.min(P.length, D)
        for (var g = B; g < D; ++g) $ += String.fromCharCode(P[g])
        return $
      }
      function fe(P, B, D) {
        var $ = P.length
        ;(!B || B < 0) && (B = 0), (!D || D < 0 || D > $) && (D = $)
        for (var g = '', N = B; N < D; ++N) g += R[P[N]]
        return g
      }
      function ie(P, B, D) {
        for (var $ = P.slice(B, D), g = '', N = 0; N < $.length - 1; N += 2)
          g += String.fromCharCode($[N] + $[N + 1] * 256)
        return g
      }
      o.prototype.slice = function (B, D) {
        var $ = this.length
        ;(B = ~~B),
          (D = D === void 0 ? $ : ~~D),
          B < 0 ? ((B += $), B < 0 && (B = 0)) : B > $ && (B = $),
          D < 0 ? ((D += $), D < 0 && (D = 0)) : D > $ && (D = $),
          D < B && (D = B)
        var g = this.subarray(B, D)
        return Object.setPrototypeOf(g, o.prototype), g
      }
      function W(P, B, D) {
        if (P % 1 != 0 || P < 0) throw new RangeError('offset is not uint')
        if (P + B > D) throw new RangeError('Trying to access beyond buffer length')
      }
      ;(o.prototype.readUintLE = o.prototype.readUIntLE =
        function (B, D, $) {
          ;(B = B >>> 0), (D = D >>> 0), $ || W(B, D, this.length)
          for (var g = this[B], N = 1, U = 0; ++U < D && (N *= 256); ) g += this[B + U] * N
          return g
        }),
        (o.prototype.readUintBE = o.prototype.readUIntBE =
          function (B, D, $) {
            ;(B = B >>> 0), (D = D >>> 0), $ || W(B, D, this.length)
            for (var g = this[B + --D], N = 1; D > 0 && (N *= 256); ) g += this[B + --D] * N
            return g
          }),
        (o.prototype.readUint8 = o.prototype.readUInt8 =
          function (B, D) {
            return (B = B >>> 0), D || W(B, 1, this.length), this[B]
          }),
        (o.prototype.readUint16LE = o.prototype.readUInt16LE =
          function (B, D) {
            return (B = B >>> 0), D || W(B, 2, this.length), this[B] | (this[B + 1] << 8)
          }),
        (o.prototype.readUint16BE = o.prototype.readUInt16BE =
          function (B, D) {
            return (B = B >>> 0), D || W(B, 2, this.length), (this[B] << 8) | this[B + 1]
          }),
        (o.prototype.readUint32LE = o.prototype.readUInt32LE =
          function (B, D) {
            return (
              (B = B >>> 0),
              D || W(B, 4, this.length),
              (this[B] | (this[B + 1] << 8) | (this[B + 2] << 16)) + this[B + 3] * 16777216
            )
          }),
        (o.prototype.readUint32BE = o.prototype.readUInt32BE =
          function (B, D) {
            return (
              (B = B >>> 0),
              D || W(B, 4, this.length),
              this[B] * 16777216 + ((this[B + 1] << 16) | (this[B + 2] << 8) | this[B + 3])
            )
          }),
        (o.prototype.readIntLE = function (B, D, $) {
          ;(B = B >>> 0), (D = D >>> 0), $ || W(B, D, this.length)
          for (var g = this[B], N = 1, U = 0; ++U < D && (N *= 256); ) g += this[B + U] * N
          return (N *= 128), g >= N && (g -= Math.pow(2, 8 * D)), g
        }),
        (o.prototype.readIntBE = function (B, D, $) {
          ;(B = B >>> 0), (D = D >>> 0), $ || W(B, D, this.length)
          for (var g = D, N = 1, U = this[B + --g]; g > 0 && (N *= 256); ) U += this[B + --g] * N
          return (N *= 128), U >= N && (U -= Math.pow(2, 8 * D)), U
        }),
        (o.prototype.readInt8 = function (B, D) {
          return (B = B >>> 0), D || W(B, 1, this.length), this[B] & 128 ? (255 - this[B] + 1) * -1 : this[B]
        }),
        (o.prototype.readInt16LE = function (B, D) {
          ;(B = B >>> 0), D || W(B, 2, this.length)
          var $ = this[B] | (this[B + 1] << 8)
          return $ & 32768 ? $ | 4294901760 : $
        }),
        (o.prototype.readInt16BE = function (B, D) {
          ;(B = B >>> 0), D || W(B, 2, this.length)
          var $ = this[B + 1] | (this[B] << 8)
          return $ & 32768 ? $ | 4294901760 : $
        }),
        (o.prototype.readInt32LE = function (B, D) {
          return (
            (B = B >>> 0),
            D || W(B, 4, this.length),
            this[B] | (this[B + 1] << 8) | (this[B + 2] << 16) | (this[B + 3] << 24)
          )
        }),
        (o.prototype.readInt32BE = function (B, D) {
          return (
            (B = B >>> 0),
            D || W(B, 4, this.length),
            (this[B] << 24) | (this[B + 1] << 16) | (this[B + 2] << 8) | this[B + 3]
          )
        }),
        (o.prototype.readFloatLE = function (B, D) {
          return (B = B >>> 0), D || W(B, 4, this.length), t.read(this, B, !0, 23, 4)
        }),
        (o.prototype.readFloatBE = function (B, D) {
          return (B = B >>> 0), D || W(B, 4, this.length), t.read(this, B, !1, 23, 4)
        }),
        (o.prototype.readDoubleLE = function (B, D) {
          return (B = B >>> 0), D || W(B, 8, this.length), t.read(this, B, !0, 52, 8)
        }),
        (o.prototype.readDoubleBE = function (B, D) {
          return (B = B >>> 0), D || W(B, 8, this.length), t.read(this, B, !1, 52, 8)
        })
      function le(P, B, D, $, g, N) {
        if (!o.isBuffer(P)) throw new TypeError('"buffer" argument must be a Buffer instance')
        if (B > g || B < N) throw new RangeError('"value" argument is out of bounds')
        if (D + $ > P.length) throw new RangeError('Index out of range')
      }
      ;(o.prototype.writeUintLE = o.prototype.writeUIntLE =
        function (B, D, $, g) {
          if (((B = +B), (D = D >>> 0), ($ = $ >>> 0), !g)) {
            var N = Math.pow(2, 8 * $) - 1
            le(this, B, D, $, N, 0)
          }
          var U = 1,
            X = 0
          for (this[D] = B & 255; ++X < $ && (U *= 256); ) this[D + X] = (B / U) & 255
          return D + $
        }),
        (o.prototype.writeUintBE = o.prototype.writeUIntBE =
          function (B, D, $, g) {
            if (((B = +B), (D = D >>> 0), ($ = $ >>> 0), !g)) {
              var N = Math.pow(2, 8 * $) - 1
              le(this, B, D, $, N, 0)
            }
            var U = $ - 1,
              X = 1
            for (this[D + U] = B & 255; --U >= 0 && (X *= 256); ) this[D + U] = (B / X) & 255
            return D + $
          }),
        (o.prototype.writeUint8 = o.prototype.writeUInt8 =
          function (B, D, $) {
            return (B = +B), (D = D >>> 0), $ || le(this, B, D, 1, 255, 0), (this[D] = B & 255), D + 1
          }),
        (o.prototype.writeUint16LE = o.prototype.writeUInt16LE =
          function (B, D, $) {
            return (
              (B = +B),
              (D = D >>> 0),
              $ || le(this, B, D, 2, 65535, 0),
              (this[D] = B & 255),
              (this[D + 1] = B >>> 8),
              D + 2
            )
          }),
        (o.prototype.writeUint16BE = o.prototype.writeUInt16BE =
          function (B, D, $) {
            return (
              (B = +B),
              (D = D >>> 0),
              $ || le(this, B, D, 2, 65535, 0),
              (this[D] = B >>> 8),
              (this[D + 1] = B & 255),
              D + 2
            )
          }),
        (o.prototype.writeUint32LE = o.prototype.writeUInt32LE =
          function (B, D, $) {
            return (
              (B = +B),
              (D = D >>> 0),
              $ || le(this, B, D, 4, 4294967295, 0),
              (this[D + 3] = B >>> 24),
              (this[D + 2] = B >>> 16),
              (this[D + 1] = B >>> 8),
              (this[D] = B & 255),
              D + 4
            )
          }),
        (o.prototype.writeUint32BE = o.prototype.writeUInt32BE =
          function (B, D, $) {
            return (
              (B = +B),
              (D = D >>> 0),
              $ || le(this, B, D, 4, 4294967295, 0),
              (this[D] = B >>> 24),
              (this[D + 1] = B >>> 16),
              (this[D + 2] = B >>> 8),
              (this[D + 3] = B & 255),
              D + 4
            )
          }),
        (o.prototype.writeIntLE = function (B, D, $, g) {
          if (((B = +B), (D = D >>> 0), !g)) {
            var N = Math.pow(2, 8 * $ - 1)
            le(this, B, D, $, N - 1, -N)
          }
          var U = 0,
            X = 1,
            ne = 0
          for (this[D] = B & 255; ++U < $ && (X *= 256); )
            B < 0 && ne === 0 && this[D + U - 1] !== 0 && (ne = 1), (this[D + U] = (((B / X) >> 0) - ne) & 255)
          return D + $
        }),
        (o.prototype.writeIntBE = function (B, D, $, g) {
          if (((B = +B), (D = D >>> 0), !g)) {
            var N = Math.pow(2, 8 * $ - 1)
            le(this, B, D, $, N - 1, -N)
          }
          var U = $ - 1,
            X = 1,
            ne = 0
          for (this[D + U] = B & 255; --U >= 0 && (X *= 256); )
            B < 0 && ne === 0 && this[D + U + 1] !== 0 && (ne = 1), (this[D + U] = (((B / X) >> 0) - ne) & 255)
          return D + $
        }),
        (o.prototype.writeInt8 = function (B, D, $) {
          return (
            (B = +B),
            (D = D >>> 0),
            $ || le(this, B, D, 1, 127, -128),
            B < 0 && (B = 255 + B + 1),
            (this[D] = B & 255),
            D + 1
          )
        }),
        (o.prototype.writeInt16LE = function (B, D, $) {
          return (
            (B = +B),
            (D = D >>> 0),
            $ || le(this, B, D, 2, 32767, -32768),
            (this[D] = B & 255),
            (this[D + 1] = B >>> 8),
            D + 2
          )
        }),
        (o.prototype.writeInt16BE = function (B, D, $) {
          return (
            (B = +B),
            (D = D >>> 0),
            $ || le(this, B, D, 2, 32767, -32768),
            (this[D] = B >>> 8),
            (this[D + 1] = B & 255),
            D + 2
          )
        }),
        (o.prototype.writeInt32LE = function (B, D, $) {
          return (
            (B = +B),
            (D = D >>> 0),
            $ || le(this, B, D, 4, 2147483647, -2147483648),
            (this[D] = B & 255),
            (this[D + 1] = B >>> 8),
            (this[D + 2] = B >>> 16),
            (this[D + 3] = B >>> 24),
            D + 4
          )
        }),
        (o.prototype.writeInt32BE = function (B, D, $) {
          return (
            (B = +B),
            (D = D >>> 0),
            $ || le(this, B, D, 4, 2147483647, -2147483648),
            B < 0 && (B = 4294967295 + B + 1),
            (this[D] = B >>> 24),
            (this[D + 1] = B >>> 16),
            (this[D + 2] = B >>> 8),
            (this[D + 3] = B & 255),
            D + 4
          )
        })
      function xe(P, B, D, $, g, N) {
        if (D + $ > P.length) throw new RangeError('Index out of range')
        if (D < 0) throw new RangeError('Index out of range')
      }
      function _e(P, B, D, $, g) {
        return (
          (B = +B),
          (D = D >>> 0),
          g || xe(P, B, D, 4, 34028234663852886e22, -34028234663852886e22),
          t.write(P, B, D, $, 23, 4),
          D + 4
        )
      }
      ;(o.prototype.writeFloatLE = function (B, D, $) {
        return _e(this, B, D, !0, $)
      }),
        (o.prototype.writeFloatBE = function (B, D, $) {
          return _e(this, B, D, !1, $)
        })
      function Ne(P, B, D, $, g) {
        return (
          (B = +B),
          (D = D >>> 0),
          g || xe(P, B, D, 8, 17976931348623157e292, -17976931348623157e292),
          t.write(P, B, D, $, 52, 8),
          D + 8
        )
      }
      ;(o.prototype.writeDoubleLE = function (B, D, $) {
        return Ne(this, B, D, !0, $)
      }),
        (o.prototype.writeDoubleBE = function (B, D, $) {
          return Ne(this, B, D, !1, $)
        }),
        (o.prototype.copy = function (B, D, $, g) {
          if (!o.isBuffer(B)) throw new TypeError('argument should be a Buffer')
          if (
            ($ || ($ = 0),
            !g && g !== 0 && (g = this.length),
            D >= B.length && (D = B.length),
            D || (D = 0),
            g > 0 && g < $ && (g = $),
            g === $ || B.length === 0 || this.length === 0)
          )
            return 0
          if (D < 0) throw new RangeError('targetStart out of bounds')
          if ($ < 0 || $ >= this.length) throw new RangeError('Index out of range')
          if (g < 0) throw new RangeError('sourceEnd out of bounds')
          g > this.length && (g = this.length), B.length - D < g - $ && (g = B.length - D + $)
          var N = g - $
          return (
            this === B && typeof Uint8Array.prototype.copyWithin == 'function'
              ? this.copyWithin(D, $, g)
              : Uint8Array.prototype.set.call(B, this.subarray($, g), D),
            N
          )
        }),
        (o.prototype.fill = function (B, D, $, g) {
          if (typeof B == 'string') {
            if (
              (typeof D == 'string'
                ? ((g = D), (D = 0), ($ = this.length))
                : typeof $ == 'string' && ((g = $), ($ = this.length)),
              g !== void 0 && typeof g != 'string')
            )
              throw new TypeError('encoding must be a string')
            if (typeof g == 'string' && !o.isEncoding(g)) throw new TypeError('Unknown encoding: ' + g)
            if (B.length === 1) {
              var N = B.charCodeAt(0)
              ;((g === 'utf8' && N < 128) || g === 'latin1') && (B = N)
            }
          } else typeof B == 'number' ? (B = B & 255) : typeof B == 'boolean' && (B = Number(B))
          if (D < 0 || this.length < D || this.length < $) throw new RangeError('Out of range index')
          if ($ <= D) return this
          ;(D = D >>> 0), ($ = $ === void 0 ? this.length : $ >>> 0), B || (B = 0)
          var U
          if (typeof B == 'number') for (U = D; U < $; ++U) this[U] = B
          else {
            var X = o.isBuffer(B) ? B : o.from(B, g),
              ne = X.length
            if (ne === 0) throw new TypeError('The value "' + B + '" is invalid for argument "value"')
            for (U = 0; U < $ - D; ++U) this[U + D] = X[U % ne]
          }
          return this
        })
      var ke = /[^+/0-9A-Za-z-_]/g
      function oe(P) {
        if (((P = P.split('=')[0]), (P = P.trim().replace(ke, '')), P.length < 2)) return ''
        for (; P.length % 4 != 0; ) P = P + '='
        return P
      }
      function be(P, B) {
        B = B || 1 / 0
        for (var D, $ = P.length, g = null, N = [], U = 0; U < $; ++U) {
          if (((D = P.charCodeAt(U)), D > 55295 && D < 57344)) {
            if (!g) {
              if (D > 56319) {
                ;(B -= 3) > -1 && N.push(239, 191, 189)
                continue
              } else if (U + 1 === $) {
                ;(B -= 3) > -1 && N.push(239, 191, 189)
                continue
              }
              g = D
              continue
            }
            if (D < 56320) {
              ;(B -= 3) > -1 && N.push(239, 191, 189), (g = D)
              continue
            }
            D = (((g - 55296) << 10) | (D - 56320)) + 65536
          } else g && (B -= 3) > -1 && N.push(239, 191, 189)
          if (((g = null), D < 128)) {
            if ((B -= 1) < 0) break
            N.push(D)
          } else if (D < 2048) {
            if ((B -= 2) < 0) break
            N.push((D >> 6) | 192, (D & 63) | 128)
          } else if (D < 65536) {
            if ((B -= 3) < 0) break
            N.push((D >> 12) | 224, ((D >> 6) & 63) | 128, (D & 63) | 128)
          } else if (D < 1114112) {
            if ((B -= 4) < 0) break
            N.push((D >> 18) | 240, ((D >> 12) & 63) | 128, ((D >> 6) & 63) | 128, (D & 63) | 128)
          } else throw new Error('Invalid code point')
        }
        return N
      }
      function ge(P) {
        for (var B = [], D = 0; D < P.length; ++D) B.push(P.charCodeAt(D) & 255)
        return B
      }
      function re(P, B) {
        for (var D, $, g, N = [], U = 0; U < P.length && !((B -= 2) < 0); ++U)
          (D = P.charCodeAt(U)), ($ = D >> 8), (g = D % 256), N.push(g), N.push($)
        return N
      }
      function j(P) {
        return r.toByteArray(oe(P))
      }
      function b(P, B, D, $) {
        for (var g = 0; g < $ && !(g + D >= B.length || g >= P.length); ++g) B[g + D] = P[g]
        return g
      }
      function C(P, B) {
        return (
          P instanceof B ||
          (P != null && P.constructor != null && P.constructor.name != null && P.constructor.name === B.name)
        )
      }
      function S(P) {
        return P !== P
      }
      var R = (function () {
        for (var P = '0123456789abcdef', B = new Array(256), D = 0; D < 16; ++D)
          for (var $ = D * 16, g = 0; g < 16; ++g) B[$ + g] = P[D] + P[g]
        return B
      })()
    }
  }),
  jD = te({
    'node_modules/is-buffer/index.js'(e, r) {
      V(),
        F(),
        (r.exports = function (n) {
          return (
            n != null &&
            n.constructor != null &&
            typeof n.constructor.isBuffer == 'function' &&
            n.constructor.isBuffer(n)
          )
        })
    }
  }),
  ui = te({
    'node_modules/bl/BufferList.js'(e, r) {
      V(), F()
      var { Buffer: t } = $r(),
        n = Symbol.for('BufferList')
      function i(s) {
        if (!(this instanceof i)) return new i(s)
        i._init.call(this, s)
      }
      ;(i._init = function (u) {
        Object.defineProperty(this, n, { value: !0 }), (this._bufs = []), (this.length = 0), u && this.append(u)
      }),
        (i.prototype._new = function (u) {
          return new i(u)
        }),
        (i.prototype._offset = function (u) {
          if (u === 0) return [0, 0]
          let o = 0
          for (let l = 0; l < this._bufs.length; l++) {
            let a = o + this._bufs[l].length
            if (u < a || l === this._bufs.length - 1) return [l, u - o]
            o = a
          }
        }),
        (i.prototype._reverseOffset = function (s) {
          let u = s[0],
            o = s[1]
          for (let l = 0; l < u; l++) o += this._bufs[l].length
          return o
        }),
        (i.prototype.get = function (u) {
          if (u > this.length || u < 0) return
          let o = this._offset(u)
          return this._bufs[o[0]][o[1]]
        }),
        (i.prototype.slice = function (u, o) {
          return (
            typeof u == 'number' && u < 0 && (u += this.length),
            typeof o == 'number' && o < 0 && (o += this.length),
            this.copy(null, 0, u, o)
          )
        }),
        (i.prototype.copy = function (u, o, l, a) {
          if (
            ((typeof l != 'number' || l < 0) && (l = 0),
            (typeof a != 'number' || a > this.length) && (a = this.length),
            l >= this.length || a <= 0)
          )
            return u || t.alloc(0)
          let c = !!u,
            f = this._offset(l),
            p = a - l,
            y = p,
            d = (c && o) || 0,
            h = f[1]
          if (l === 0 && a === this.length) {
            if (!c) return this._bufs.length === 1 ? this._bufs[0] : t.concat(this._bufs, this.length)
            for (let m = 0; m < this._bufs.length; m++) this._bufs[m].copy(u, d), (d += this._bufs[m].length)
            return u
          }
          if (y <= this._bufs[f[0]].length - h)
            return c ? this._bufs[f[0]].copy(u, o, h, h + y) : this._bufs[f[0]].slice(h, h + y)
          c || (u = t.allocUnsafe(p))
          for (let m = f[0]; m < this._bufs.length; m++) {
            let _ = this._bufs[m].length - h
            if (y > _) this._bufs[m].copy(u, d, h), (d += _)
            else {
              this._bufs[m].copy(u, d, h, h + y), (d += _)
              break
            }
            ;(y -= _), h && (h = 0)
          }
          return u.length > d ? u.slice(0, d) : u
        }),
        (i.prototype.shallowSlice = function (u, o) {
          if (
            ((u = u || 0),
            (o = typeof o != 'number' ? this.length : o),
            u < 0 && (u += this.length),
            o < 0 && (o += this.length),
            u === o)
          )
            return this._new()
          let l = this._offset(u),
            a = this._offset(o),
            c = this._bufs.slice(l[0], a[0] + 1)
          return (
            a[1] === 0 ? c.pop() : (c[c.length - 1] = c[c.length - 1].slice(0, a[1])),
            l[1] !== 0 && (c[0] = c[0].slice(l[1])),
            this._new(c)
          )
        }),
        (i.prototype.toString = function (u, o, l) {
          return this.slice(o, l).toString(u)
        }),
        (i.prototype.consume = function (u) {
          if (((u = Math.trunc(u)), Number.isNaN(u) || u <= 0)) return this
          for (; this._bufs.length; )
            if (u >= this._bufs[0].length)
              (u -= this._bufs[0].length), (this.length -= this._bufs[0].length), this._bufs.shift()
            else {
              ;(this._bufs[0] = this._bufs[0].slice(u)), (this.length -= u)
              break
            }
          return this
        }),
        (i.prototype.duplicate = function () {
          let u = this._new()
          for (let o = 0; o < this._bufs.length; o++) u.append(this._bufs[o])
          return u
        }),
        (i.prototype.append = function (u) {
          if (u == null) return this
          if (u.buffer) this._appendBuffer(t.from(u.buffer, u.byteOffset, u.byteLength))
          else if (Array.isArray(u)) for (let o = 0; o < u.length; o++) this.append(u[o])
          else if (this._isBufferList(u)) for (let o = 0; o < u._bufs.length; o++) this.append(u._bufs[o])
          else typeof u == 'number' && (u = u.toString()), this._appendBuffer(t.from(u))
          return this
        }),
        (i.prototype._appendBuffer = function (u) {
          this._bufs.push(u), (this.length += u.length)
        }),
        (i.prototype.indexOf = function (s, u, o) {
          if (
            (o === void 0 && typeof u == 'string' && ((o = u), (u = void 0)),
            typeof s == 'function' || Array.isArray(s))
          )
            throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
          if (
            (typeof s == 'number'
              ? (s = t.from([s]))
              : typeof s == 'string'
              ? (s = t.from(s, o))
              : this._isBufferList(s)
              ? (s = s.slice())
              : Array.isArray(s.buffer)
              ? (s = t.from(s.buffer, s.byteOffset, s.byteLength))
              : t.isBuffer(s) || (s = t.from(s)),
            (u = Number(u || 0)),
            isNaN(u) && (u = 0),
            u < 0 && (u = this.length + u),
            u < 0 && (u = 0),
            s.length === 0)
          )
            return u > this.length ? this.length : u
          let l = this._offset(u),
            a = l[0],
            c = l[1]
          for (; a < this._bufs.length; a++) {
            let f = this._bufs[a]
            for (; c < f.length; )
              if (f.length - c >= s.length) {
                let y = f.indexOf(s, c)
                if (y !== -1) return this._reverseOffset([a, y])
                c = f.length - s.length + 1
              } else {
                let y = this._reverseOffset([a, c])
                if (this._match(y, s)) return y
                c++
              }
            c = 0
          }
          return -1
        }),
        (i.prototype._match = function (s, u) {
          if (this.length - s < u.length) return !1
          for (let o = 0; o < u.length; o++) if (this.get(s + o) !== u[o]) return !1
          return !0
        }),
        (function () {
          let s = {
            readDoubleBE: 8,
            readDoubleLE: 8,
            readFloatBE: 4,
            readFloatLE: 4,
            readInt32BE: 4,
            readInt32LE: 4,
            readUInt32BE: 4,
            readUInt32LE: 4,
            readInt16BE: 2,
            readInt16LE: 2,
            readUInt16BE: 2,
            readUInt16LE: 2,
            readInt8: 1,
            readUInt8: 1,
            readIntBE: null,
            readIntLE: null,
            readUIntBE: null,
            readUIntLE: null
          }
          for (let u in s)
            (function (o) {
              s[o] === null
                ? (i.prototype[o] = function (l, a) {
                    return this.slice(l, l + a)[o](0, a)
                  })
                : (i.prototype[o] = function (l = 0) {
                    return this.slice(l, l + s[o])[o](0)
                  })
            })(u)
        })(),
        (i.prototype._isBufferList = function (u) {
          return u instanceof i || i.isBufferList(u)
        }),
        (i.isBufferList = function (u) {
          return u != null && u[n]
        }),
        (r.exports = i)
    }
  }),
  iA = te({
    'node_modules/it-reader/index.js'(e, r) {
      V(), F()
      var t = ui()
      r.exports = (n) => {
        let i = (async function* () {
          let s = yield,
            u = new t()
          for await (let o of n) {
            if (!s) {
              ;(s = yield u.append(o)), (u = new t())
              continue
            }
            for (u.append(o); u.length >= s; ) {
              let l = u.shallowSlice(0, s)
              if ((u.consume(s), (s = yield l), !s)) {
                u.length && ((s = yield u), (u = new t()))
                break
              }
            }
          }
          if (s)
            throw Object.assign(new Error(`stream ended before ${s} bytes became available`), {
              code: 'ERR_UNDER_READ',
              buffer: u
            })
        })()
        return i.next(), i
      }
    }
  }),
  zD = te({
    'node_modules/fast-fifo/fixed-size.js'(e, r) {
      V(),
        F(),
        (r.exports = class {
          constructor(n) {
            if (!(n > 0) || ((n - 1) & n) != 0) throw new Error('Max size for a FixedFIFO should be a power of two')
            ;(this.buffer = new Array(n)), (this.mask = n - 1), (this.top = 0), (this.btm = 0), (this.next = null)
          }
          push(n) {
            return this.buffer[this.top] !== void 0
              ? !1
              : ((this.buffer[this.top] = n), (this.top = (this.top + 1) & this.mask), !0)
          }
          shift() {
            let n = this.buffer[this.btm]
            if (n !== void 0) return (this.buffer[this.btm] = void 0), (this.btm = (this.btm + 1) & this.mask), n
          }
          isEmpty() {
            return this.buffer[this.btm] === void 0
          }
        })
    }
  }),
  sA = te({
    'node_modules/fast-fifo/index.js'(e, r) {
      V(), F()
      var t = zD()
      r.exports = class {
        constructor(i) {
          ;(this.hwm = i || 16), (this.head = new t(this.hwm)), (this.tail = this.head)
        }
        push(i) {
          if (!this.head.push(i)) {
            let s = this.head
            ;(this.head = s.next = new t(2 * this.head.buffer.length)), this.head.push(i)
          }
        }
        shift() {
          let i = this.tail.shift()
          if (i === void 0 && this.tail.next) {
            let s = this.tail.next
            return (this.tail.next = null), (this.tail = s), this.tail.shift()
          }
          return i
        }
        isEmpty() {
          return this.head.isEmpty()
        }
      }
    }
  }),
  df = te({
    'node_modules/it-pushable/index.js'(e, r) {
      V(), F()
      var t = sA()
      r.exports = (n) => {
        n = n || {}
        let i
        typeof n == 'function' ? ((i = n), (n = {})) : (i = n.onEnd)
        let s = new t(),
          u,
          o,
          l,
          a = () => {
            if (!s.isEmpty()) {
              if (n.writev) {
                let A,
                  T = []
                for (; !s.isEmpty(); ) {
                  if (((A = s.shift()), A.error)) throw A.error
                  T.push(A.value)
                }
                return { done: A.done, value: T }
              }
              let _ = s.shift()
              if (_.error) throw _.error
              return _
            }
            return l
              ? { done: !0 }
              : new Promise((_, A) => {
                  o = (T) => (
                    (o = null),
                    T.error ? A(T.error) : n.writev && !T.done ? _({ done: T.done, value: [T.value] }) : _(T),
                    u
                  )
                })
          },
          c = (_) => (o ? o(_) : (s.push(_), u)),
          f = (_) => ((s = new t()), o ? o({ error: _ }) : (s.push({ error: _ }), u)),
          p = (_) => (l ? u : c({ done: !1, value: _ })),
          y = (_) => (l ? u : ((l = !0), _ ? f(_) : c({ done: !0 }))),
          d = () => ((s = new t()), y(), { done: !0 }),
          h = (_) => (y(_), { done: !0 })
        if (
          ((u = {
            [Symbol.asyncIterator]() {
              return this
            },
            next: a,
            return: d,
            throw: h,
            push: p,
            end: y
          }),
          !i)
        )
          return u
        let m = u
        return (
          (u = {
            [Symbol.asyncIterator]() {
              return this
            },
            next() {
              return m.next()
            },
            throw(_) {
              return m.throw(_), i && (i(_), (i = null)), { done: !0 }
            },
            return() {
              return m.return(), i && (i(), (i = null)), { done: !0 }
            },
            push: p,
            end(_) {
              return m.end(_), i && (i(_), (i = null)), u
            }
          }),
          u
        )
      }
    }
  }),
  Yc = te({
    'node_modules/it-handshake/src/index.js'(e, r) {
      V(), F()
      var t = iA(),
        n = df(),
        i = Vl()
      r.exports = (s) => {
        let u = n(),
          o = t(s.source),
          l = i(),
          a,
          c = s.sink(
            (async function* () {
              yield* u, yield* await l.promise
            })()
          )
        return (
          c.catch((p) => {
            a = p
          }),
          {
            reader: o,
            writer: u,
            stream: { sink: (p) => (a ? Promise.reject(a) : (l.resolve(p), c)), source: o },
            rest: () => u.end(),
            write: u.push,
            read: async () => (await o.next()).value
          }
        )
      }
    }
  }),
  oA = te({
    'node_modules/it-length-prefixed/src/varint-encode.js'(e, r) {
      V(), F()
      var t = $t(),
        { Buffer: n } = $r(),
        i = (s, u, o) => {
          let l = t.encode(s, u, o)
          return (i.bytes = t.encode.bytes), u || n.from(l)
        }
      r.exports = i
    }
  }),
  KD = te({
    'node_modules/it-length-prefixed/src/encode.js'(e, r) {
      V(), F()
      var { Buffer: t } = $r(),
        n = ui(),
        i = oA(),
        s = 8,
        u = 10 * 1024
      function o(l) {
        l = l || {}
        let a = Math.max(l.poolSize || u, l.minPoolSize || s),
          c = l.lengthEncoder || i
        return async function* (p) {
          let y = t.alloc(a),
            d = 0
          for await (let h of p) {
            c(h.length, y, d)
            let m = y.slice(d, d + c.bytes)
            ;(d += c.bytes), y.length - d < s && ((y = t.alloc(a)), (d = 0)), yield new n().append(m).append(h)
          }
        }
      }
      ;(o.single = (l, a) => {
        a = a || {}
        let c = a.lengthEncoder || i
        return new n([c(l.length), l.slice()])
      }),
        (r.exports = o),
        (r.exports.MIN_POOL_SIZE = s),
        (r.exports.DEFAULT_POOL_SIZE = u)
    }
  }),
  aA = te({
    'node_modules/it-length-prefixed/src/varint-decode.js'(e, r) {
      V(), F()
      var t = $t(),
        { Buffer: n } = $r(),
        i = (u) => new Proxy({}, { get: (o, l) => (l[0] === 'l' ? u[l] : u.get(parseInt(l))) }),
        s = (u) => {
          let o = t.decode(n.isBuffer(u) ? u : i(u))
          return (s.bytes = t.decode.bytes), o
        }
      r.exports = s
    }
  }),
  FD = te({
    'node_modules/it-length-prefixed/src/decode.js'(e, r) {
      V(), F()
      var { Buffer: t } = $r(),
        n = ui(),
        i = aA(),
        s = 8,
        u = 1024 * 1024 * 4,
        o = t.alloc(0),
        l = { LENGTH: 'readLength', DATA: 'readData' },
        a = {
          [l.LENGTH]: (f, p, y, d) => {
            p = p.append(f)
            let h
            try {
              h = d.lengthDecoder(p)
            } catch (m) {
              if (p.length > d.maxLengthLength)
                throw Object.assign(m, { message: 'message length too long', code: 'ERR_MSG_LENGTH_TOO_LONG' })
              if (m instanceof RangeError)
                return { mode: l.LENGTH, buffer: p, chunk: void 0, state: void 0, data: void 0 }
              throw m
            }
            if (h > d.maxDataLength)
              throw Object.assign(new Error('message data too long'), { code: 'ERR_MSG_DATA_TOO_LONG' })
            return (
              (f = p.shallowSlice(d.lengthDecoder.bytes)),
              (p = new n()),
              d.onLength && d.onLength(h),
              h <= 0
                ? (d.onData && d.onData(o), { mode: l.LENGTH, chunk: f, buffer: p, data: o })
                : { mode: l.DATA, chunk: f, buffer: p, state: { dataLength: h }, data: void 0 }
            )
          },
          [l.DATA]: (f, p, y, d) => {
            if (((p = p.append(f)), !y)) throw new Error('state is required')
            if (p.length < y.dataLength) return { mode: l.DATA, buffer: p, state: y, chunk: void 0, data: void 0 }
            let { dataLength: h } = y,
              m = p.shallowSlice(0, h),
              _ = p.length > h ? p.shallowSlice(h) : void 0
            return (
              (p = new n()), d.onData && d.onData(m), { mode: l.LENGTH, chunk: _, buffer: p, state: void 0, data: m }
            )
          }
        }
      function c(f) {
        f = f || {}
        let p = {
          lengthDecoder: f.lengthDecoder || i,
          maxLengthLength: f.maxLengthLength || s,
          maxDataLength: f.maxDataLength || u,
          onLength: f.onLength,
          onData: f.onData
        }
        return async function* (d) {
          let h = new n(),
            m = l.LENGTH,
            _
          for await (let A of d) {
            let T = A
            for (; T; ) {
              let E = a[m](T, h, _, p)
              ;(m = E.mode), (T = E.chunk), (h = E.buffer), (_ = E.state), E.data && (yield E.data)
            }
          }
          if (h.length) throw Object.assign(new Error('unexpected end of input'), { code: 'ERR_UNEXPECTED_EOF' })
        }
      }
      ;(c.fromReader = (f, p) => {
        let y = 1,
          d = {
            [Symbol.asyncIterator]() {
              return this
            },
            next: async () => {
              try {
                return await f.next(y)
              } catch (m) {
                if (m.code === 'ERR_UNDER_READ') return { done: !0, value: null }
                throw m
              } finally {
                y = 1
              }
            }
          }
        return c({
          ...(p || {}),
          onLength: (m) => {
            y = m
          }
        })(d)
      }),
        (r.exports = c),
        (r.exports.MAX_LENGTH_LENGTH = s),
        (r.exports.MAX_DATA_LENGTH = u)
    }
  }),
  VD = te({
    'node_modules/it-length-prefixed/src/int32BE-encode.js'(e, r) {
      V(), F()
      var { Buffer: t } = $r(),
        n = (i, s, u) => ((s = s || t.allocUnsafe(4)), s.writeInt32BE(i, u), s)
      ;(n.bytes = 4), (r.exports = n)
    }
  }),
  HD = te({
    'node_modules/it-length-prefixed/src/int32BE-decode.js'(e, r) {
      V(), F()
      var t = (n) => {
        if (n.length < 4) throw RangeError('Could not decode int32BE')
        return n.readInt32BE(0)
      }
      ;(t.bytes = 4), (r.exports = t)
    }
  }),
  Zc = te({
    'node_modules/it-length-prefixed/src/index.js'(e) {
      V(),
        F(),
        (e.encode = KD()),
        (e.decode = FD()),
        (e.varintEncode = oA()),
        (e.varintDecode = aA()),
        (e.int32BEEncode = VD()),
        (e.int32BEDecode = HD())
    }
  }),
  $D = te({
    'node_modules/it-pb-rpc/src/index.js'(e, r) {
      V(), F()
      var t = jD(),
        n = Yc(),
        i = Zc()
      r.exports = (s, u = {}) => {
        let o = n(s),
          l = i.decode.fromReader(o.reader, u),
          a = !1,
          c = {
            read: async (f) => {
              let { value: p, done: y } = await o.reader.next(f)
              if (y && p.length < f) throw new Error("Couldn't read enough bytes")
              if (((a = y), !p)) throw new Error('Value is null')
              return p
            },
            readLP: async () => {
              let { value: f, done: p } = await l.next()
              if (((a = p), !f)) throw new Error('Value is null')
              return f
            },
            readPB: async (f) => {
              let p = await c.readLP()
              if (!p) throw new Error('Value is null')
              let y = t(p) ? p : p.slice()
              return f.decode(y)
            },
            write: (f) => {
              o.writer.push(f)
            },
            writeLP: (f) => {
              c.write(i.encode.single(f, u))
            },
            writePB: (f, p) => {
              c.writeLP(p.encode(f))
            },
            pb: (f) => ({ read: () => c.readPB(f), write: (p) => c.writePB(p, f) }),
            unwrap: () => (o.rest(), o.stream)
          }
        return c
      }
    }
  }),
  GD = te({
    'node_modules/it-pair/index.js'(e, r) {
      V(), F()
      var t = H0()
      r.exports = function () {
        let i,
          s,
          u = async (l) => {
            if (i) throw new Error('already piped')
            ;(i = t(l)), s && s(i)
          },
          o = {
            [Symbol.asyncIterator]() {
              return this
            },
            next() {
              return i
                ? i.next()
                : new Promise((l) => {
                    s = (a) => {
                      ;(s = null), l(a.next())
                    }
                  })
            }
          }
        return { sink: u, source: o }
      }
    }
  }),
  WD = te({
    'node_modules/it-pair/duplex.js'(e, r) {
      V(), F()
      var t = GD()
      r.exports = function () {
        var n = t(),
          i = t()
        return [
          { source: n.source, sink: i.sink },
          { source: i.source, sink: n.sink }
        ]
      }
    }
  }),
  V1 = te({
    'node_modules/it-buffer/index.js'(e, r) {
      V(), F()
      var { Buffer: t } = $r(),
        n = ui()
      ;(r.exports = async function* (i) {
        for await (let s of i) t.isBuffer(s) ? yield s : n.isBufferList(s) ? yield s.slice() : yield t.from(s)
      }),
        (r.exports.toBuffer = r.exports),
        (r.exports.toList = async function* (i) {
          for await (let s of i)
            t.isBuffer(s) ? yield new n().append(s) : n.isBufferList(s) ? yield s : yield new n().append(t.from(s))
        })
    }
  }),
  wn = te({
    'node_modules/it-pipe/index.js'(e, r) {
      V(), F()
      var t = (...o) => {
          let l
          for (; o.length; ) l = o.shift()(l)
          return l
        },
        n = (o) =>
          o &&
          (typeof o[Symbol.asyncIterator] == 'function' ||
            typeof o[Symbol.iterator] == 'function' ||
            typeof o.next == 'function'),
        i = (o) => o && typeof o.sink == 'function' && n(o.source),
        s = (o) => (l) => o.sink(l), o.source,
        u = (...o) => {
          if (i(o[0])) {
            let l = o[0]
            o[0] = () => l.source
          } else if (n(o[0])) {
            let l = o[0]
            o[0] = () => l
          }
          if ((o.length > 1 && i(o[o.length - 1]) && (o[o.length - 1] = o[o.length - 1].sink), o.length > 2))
            for (let l = 1; l < o.length - 1; l++) i(o[l]) && (o[l] = s(o[l]))
          return t(...o)
        }
      ;(r.exports = u),
        (r.exports.pipe = u),
        (r.exports.rawPipe = t),
        (r.exports.isIterable = n),
        (r.exports.isDuplex = i)
    }
  }),
  cA = te({
    'node_modules/libp2p-noise/node_modules/bl/BufferList.js'(e, r) {
      V(), F()
      var { Buffer: t } = Nr(),
        n = Symbol.for('BufferList')
      function i(s) {
        if (!(this instanceof i)) return new i(s)
        i._init.call(this, s)
      }
      ;(i._init = function (u) {
        Object.defineProperty(this, n, { value: !0 }), (this._bufs = []), (this.length = 0), u && this.append(u)
      }),
        (i.prototype._new = function (u) {
          return new i(u)
        }),
        (i.prototype._offset = function (u) {
          if (u === 0) return [0, 0]
          let o = 0
          for (let l = 0; l < this._bufs.length; l++) {
            let a = o + this._bufs[l].length
            if (u < a || l === this._bufs.length - 1) return [l, u - o]
            o = a
          }
        }),
        (i.prototype._reverseOffset = function (s) {
          let u = s[0],
            o = s[1]
          for (let l = 0; l < u; l++) o += this._bufs[l].length
          return o
        }),
        (i.prototype.get = function (u) {
          if (u > this.length || u < 0) return
          let o = this._offset(u)
          return this._bufs[o[0]][o[1]]
        }),
        (i.prototype.slice = function (u, o) {
          return (
            typeof u == 'number' && u < 0 && (u += this.length),
            typeof o == 'number' && o < 0 && (o += this.length),
            this.copy(null, 0, u, o)
          )
        }),
        (i.prototype.copy = function (u, o, l, a) {
          if (
            ((typeof l != 'number' || l < 0) && (l = 0),
            (typeof a != 'number' || a > this.length) && (a = this.length),
            l >= this.length || a <= 0)
          )
            return u || t.alloc(0)
          let c = !!u,
            f = this._offset(l),
            p = a - l,
            y = p,
            d = (c && o) || 0,
            h = f[1]
          if (l === 0 && a === this.length) {
            if (!c) return this._bufs.length === 1 ? this._bufs[0] : t.concat(this._bufs, this.length)
            for (let m = 0; m < this._bufs.length; m++) this._bufs[m].copy(u, d), (d += this._bufs[m].length)
            return u
          }
          if (y <= this._bufs[f[0]].length - h)
            return c ? this._bufs[f[0]].copy(u, o, h, h + y) : this._bufs[f[0]].slice(h, h + y)
          c || (u = t.allocUnsafe(p))
          for (let m = f[0]; m < this._bufs.length; m++) {
            let _ = this._bufs[m].length - h
            if (y > _) this._bufs[m].copy(u, d, h), (d += _)
            else {
              this._bufs[m].copy(u, d, h, h + y), (d += _)
              break
            }
            ;(y -= _), h && (h = 0)
          }
          return u.length > d ? u.slice(0, d) : u
        }),
        (i.prototype.shallowSlice = function (u, o) {
          if (
            ((u = u || 0),
            (o = typeof o != 'number' ? this.length : o),
            u < 0 && (u += this.length),
            o < 0 && (o += this.length),
            u === o)
          )
            return this._new()
          let l = this._offset(u),
            a = this._offset(o),
            c = this._bufs.slice(l[0], a[0] + 1)
          return (
            a[1] === 0 ? c.pop() : (c[c.length - 1] = c[c.length - 1].slice(0, a[1])),
            l[1] !== 0 && (c[0] = c[0].slice(l[1])),
            this._new(c)
          )
        }),
        (i.prototype.toString = function (u, o, l) {
          return this.slice(o, l).toString(u)
        }),
        (i.prototype.consume = function (u) {
          if (((u = Math.trunc(u)), Number.isNaN(u) || u <= 0)) return this
          for (; this._bufs.length; )
            if (u >= this._bufs[0].length)
              (u -= this._bufs[0].length), (this.length -= this._bufs[0].length), this._bufs.shift()
            else {
              ;(this._bufs[0] = this._bufs[0].slice(u)), (this.length -= u)
              break
            }
          return this
        }),
        (i.prototype.duplicate = function () {
          let u = this._new()
          for (let o = 0; o < this._bufs.length; o++) u.append(this._bufs[o])
          return u
        }),
        (i.prototype.append = function (u) {
          if (u == null) return this
          if (u.buffer) this._appendBuffer(t.from(u.buffer, u.byteOffset, u.byteLength))
          else if (Array.isArray(u)) for (let o = 0; o < u.length; o++) this.append(u[o])
          else if (this._isBufferList(u)) for (let o = 0; o < u._bufs.length; o++) this.append(u._bufs[o])
          else typeof u == 'number' && (u = u.toString()), this._appendBuffer(t.from(u))
          return this
        }),
        (i.prototype._appendBuffer = function (u) {
          this._bufs.push(u), (this.length += u.length)
        }),
        (i.prototype.indexOf = function (s, u, o) {
          if (
            (o === void 0 && typeof u == 'string' && ((o = u), (u = void 0)),
            typeof s == 'function' || Array.isArray(s))
          )
            throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.')
          if (
            (typeof s == 'number'
              ? (s = t.from([s]))
              : typeof s == 'string'
              ? (s = t.from(s, o))
              : this._isBufferList(s)
              ? (s = s.slice())
              : Array.isArray(s.buffer)
              ? (s = t.from(s.buffer, s.byteOffset, s.byteLength))
              : t.isBuffer(s) || (s = t.from(s)),
            (u = Number(u || 0)),
            isNaN(u) && (u = 0),
            u < 0 && (u = this.length + u),
            u < 0 && (u = 0),
            s.length === 0)
          )
            return u > this.length ? this.length : u
          let l = this._offset(u),
            a = l[0],
            c = l[1]
          for (; a < this._bufs.length; a++) {
            let f = this._bufs[a]
            for (; c < f.length; )
              if (f.length - c >= s.length) {
                let y = f.indexOf(s, c)
                if (y !== -1) return this._reverseOffset([a, y])
                c = f.length - s.length + 1
              } else {
                let y = this._reverseOffset([a, c])
                if (this._match(y, s)) return y
                c++
              }
            c = 0
          }
          return -1
        }),
        (i.prototype._match = function (s, u) {
          if (this.length - s < u.length) return !1
          for (let o = 0; o < u.length; o++) if (this.get(s + o) !== u[o]) return !1
          return !0
        }),
        (function () {
          let s = {
            readDoubleBE: 8,
            readDoubleLE: 8,
            readFloatBE: 4,
            readFloatLE: 4,
            readInt32BE: 4,
            readInt32LE: 4,
            readUInt32BE: 4,
            readUInt32LE: 4,
            readInt16BE: 2,
            readInt16LE: 2,
            readUInt16BE: 2,
            readUInt16LE: 2,
            readInt8: 1,
            readUInt8: 1,
            readIntBE: null,
            readIntLE: null,
            readUIntBE: null,
            readUIntLE: null
          }
          for (let u in s)
            (function (o) {
              s[o] === null
                ? (i.prototype[o] = function (l, a) {
                    return this.slice(l, l + a)[o](0, a)
                  })
                : (i.prototype[o] = function (l = 0) {
                    return this.slice(l, l + s[o])[o](0)
                  })
            })(u)
        })(),
        (i.prototype._isBufferList = function (u) {
          return u instanceof i || i.isBufferList(u)
        }),
        (i.isBufferList = function (u) {
          return u != null && u[n]
        }),
        (r.exports = i)
    }
  }),
  JD = te({
    'node_modules/libp2p-noise/node_modules/varint/encode.js'(e, r) {
      V(), F(), (r.exports = u)
      var t = 128,
        n = 127,
        i = ~n,
        s = Math.pow(2, 31)
      function u(o, l, a) {
        ;(l = l || []), (a = a || 0)
        for (var c = a; o >= s; ) (l[a++] = (o & 255) | t), (o /= 128)
        for (; o & i; ) (l[a++] = (o & 255) | t), (o >>>= 7)
        return (l[a] = o | 0), (u.bytes = a - c + 1), l
      }
    }
  }),
  XD = te({
    'node_modules/libp2p-noise/node_modules/varint/decode.js'(e, r) {
      V(), F(), (r.exports = i)
      var t = 128,
        n = 127
      function i(s, u) {
        var o = 0,
          u = u || 0,
          l = 0,
          a = u,
          c,
          f = s.length
        do {
          if (a >= f) throw ((i.bytes = 0), new RangeError('Could not decode varint'))
          ;(c = s[a++]), (o += l < 28 ? (c & n) << l : (c & n) * Math.pow(2, l)), (l += 7)
        } while (c >= t)
        return (i.bytes = a - u), o
      }
    }
  }),
  YD = te({
    'node_modules/libp2p-noise/node_modules/varint/length.js'(e, r) {
      V(), F()
      var t = Math.pow(2, 7),
        n = Math.pow(2, 14),
        i = Math.pow(2, 21),
        s = Math.pow(2, 28),
        u = Math.pow(2, 35),
        o = Math.pow(2, 42),
        l = Math.pow(2, 49),
        a = Math.pow(2, 56),
        c = Math.pow(2, 63)
      r.exports = function (f) {
        return f < t
          ? 1
          : f < n
          ? 2
          : f < i
          ? 3
          : f < s
          ? 4
          : f < u
          ? 5
          : f < o
          ? 6
          : f < l
          ? 7
          : f < a
          ? 8
          : f < c
          ? 9
          : 10
      }
    }
  }),
  uA = te({
    'node_modules/libp2p-noise/node_modules/varint/index.js'(e, r) {
      V(), F(), (r.exports = { encode: JD(), decode: XD(), encodingLength: YD() })
    }
  }),
  lA = te({
    'node_modules/libp2p-noise/node_modules/it-length-prefixed/src/varint-encode.js'(e, r) {
      V(), F()
      var t = uA(),
        { Buffer: n } = Nr(),
        i = (s, u, o) => {
          let l = t.encode(s, u, o)
          return (i.bytes = t.encode.bytes), u || n.from(l)
        }
      r.exports = i
    }
  }),
  ZD = te({
    'node_modules/libp2p-noise/node_modules/it-length-prefixed/src/encode.js'(e, r) {
      V(), F()
      var { Buffer: t } = Nr(),
        n = cA(),
        i = lA(),
        s = 8,
        u = 10 * 1024
      function o(l) {
        l = l || {}
        let a = Math.max(l.poolSize || u, l.minPoolSize || s),
          c = l.lengthEncoder || i
        return (f) =>
          (async function* () {
            let p = t.alloc(a),
              y = 0
            for await (let d of f) {
              c(d.length, p, y)
              let h = p.slice(y, y + c.bytes)
              ;(y += c.bytes), p.length - y < s && ((p = t.alloc(a)), (y = 0)), yield new n().append(h).append(d)
            }
          })()
      }
      ;(o.single = (l, a) => {
        a = a || {}
        let c = a.lengthEncoder || i
        return new n([c(l.length), l])
      }),
        (r.exports = o),
        (r.exports.MIN_POOL_SIZE = s),
        (r.exports.DEFAULT_POOL_SIZE = u)
    }
  }),
  fA = te({
    'node_modules/libp2p-noise/node_modules/it-length-prefixed/src/varint-decode.js'(e, r) {
      V(), F()
      var { Buffer: t } = Nr(),
        n = uA(),
        i = (u) => new Proxy({}, { get: (o, l) => (l[0] === 'l' ? u[l] : u.get(parseInt(l))) }),
        s = (u) => {
          let o = n.decode(t.isBuffer(u) ? u : i(u))
          return (s.bytes = n.decode.bytes), o
        }
      r.exports = s
    }
  }),
  QD = te({
    'node_modules/libp2p-noise/node_modules/it-length-prefixed/src/decode.js'(e, r) {
      V(), F()
      var { Buffer: t } = Nr(),
        n = cA(),
        i = fA(),
        s = 8,
        u = 1024 * 1024 * 4,
        o = t.alloc(0),
        l = { LENGTH: 'readLength', DATA: 'readData' },
        a = {
          [l.LENGTH]: (f, p, y, d) => {
            p = p.append(f)
            let h
            try {
              h = d.lengthDecoder(p)
            } catch (m) {
              if (p.length > d.maxLengthLength)
                throw Object.assign(m, { message: 'message length too long', code: 'ERR_MSG_LENGTH_TOO_LONG' })
              if (m instanceof RangeError) return { mode: l.LENGTH, buffer: p }
              throw m
            }
            if (h > d.maxDataLength)
              throw Object.assign(new Error('message data too long'), { code: 'ERR_MSG_DATA_TOO_LONG' })
            return (
              (f = p.shallowSlice(d.lengthDecoder.bytes)),
              (p = new n()),
              d.onLength && d.onLength(h),
              h <= 0
                ? (d.onData && d.onData(o), { mode: l.LENGTH, chunk: f, buffer: p, data: o })
                : { mode: l.DATA, chunk: f, buffer: p, state: { dataLength: h } }
            )
          },
          [l.DATA]: (f, p, y, d) => {
            if (((p = p.append(f)), p.length < y.dataLength)) return { mode: l.DATA, buffer: p, state: y }
            let { dataLength: h } = y,
              m = p.shallowSlice(0, h)
            return (
              (f = p.length > h ? p.shallowSlice(h) : null),
              (p = new n()),
              d.onData && d.onData(m),
              { mode: l.LENGTH, chunk: f, buffer: p, data: m }
            )
          }
        }
      function c(f) {
        return (
          (f = f || {}),
          (f.lengthDecoder = f.lengthDecoder || i),
          (f.maxLengthLength = f.maxLengthLength || s),
          (f.maxDataLength = f.maxDataLength || u),
          (p) =>
            (async function* () {
              let y = new n(),
                d = l.LENGTH,
                h
              for await (let m of p)
                for (; m; ) {
                  let _ = a[d](m, y, h, f)
                  ;({ mode: d, chunk: m, buffer: y, state: h } = _), _.data && (yield _.data)
                }
              if (y.length) throw Object.assign(new Error('unexpected end of input'), { code: 'ERR_UNEXPECTED_EOF' })
            })()
        )
      }
      ;(c.fromReader = (f, p) => {
        p = p || {}
        let y = 1,
          d = {
            [Symbol.asyncIterator]() {
              return this
            },
            next: async () => {
              try {
                return await f.next(y)
              } catch (h) {
                if (h.code === 'ERR_UNDER_READ') return { done: !0, value: null }
                throw h
              } finally {
                y = 1
              }
            }
          }
        return (
          (p.onLength = (h) => {
            y = h
          }),
          c(p)(d)
        )
      }),
        (r.exports = c),
        (r.exports.MAX_LENGTH_LENGTH = s),
        (r.exports.MAX_DATA_LENGTH = u)
    }
  }),
  eL = te({
    'node_modules/libp2p-noise/node_modules/it-length-prefixed/src/int32BE-encode.js'(e, r) {
      V(), F()
      var { Buffer: t } = Nr(),
        n = (i, s, u) => ((s = s || t.allocUnsafe(4)), s.writeInt32BE(i, u), s)
      ;(n.bytes = 4), (r.exports = n)
    }
  }),
  tL = te({
    'node_modules/libp2p-noise/node_modules/it-length-prefixed/src/int32BE-decode.js'(e, r) {
      V(), F()
      var t = (n) => {
        if (n.length < 4) throw RangeError('Could not decode int32BE')
        return n.readInt32BE(0)
      }
      ;(t.bytes = 4), (r.exports = t)
    }
  }),
  rL = te({
    'node_modules/libp2p-noise/node_modules/it-length-prefixed/src/index.js'(e) {
      V(),
        F(),
        (e.encode = ZD()),
        (e.decode = QD()),
        (e.varintEncode = lA()),
        (e.varintDecode = fA()),
        (e.int32BEEncode = eL()),
        (e.int32BEDecode = tL())
    }
  }),
  nL = te({
    'node_modules/bcrypto/lib/js/hkdf.js'(e) {
      V(), F()
      var r = ji()
      function t(s, u, o) {
        return (
          r(s && typeof s.id == 'string'),
          u == null && (u = Ve.Buffer.alloc(0)),
          o == null && (o = Ve.Buffer.alloc(s.size, 0)),
          s.mac(u, o)
        )
      }
      function n(s, u, o, l) {
        if (
          (o == null && (o = Ve.Buffer.alloc(0)),
          r(s && typeof s.id == 'string'),
          r(Ve.Buffer.isBuffer(u)),
          r(Ve.Buffer.isBuffer(o)),
          r(l >>> 0 === l),
          u.length !== s.size)
        )
          throw new RangeError('Invalid PRK length.')
        let a = Math.ceil(l / s.size)
        if (a > 255) throw new RangeError('Invalid output length.')
        let c = Ve.Buffer.alloc(a * s.size),
          f = Ve.Buffer.from([0]),
          p = s.hmac(),
          y = Ve.Buffer.alloc(0),
          d = 0
        for (let h = 0; h < a; h++)
          (f[0] += 1), p.init(u), p.update(y), p.update(o), p.update(f), (y = p.final()), (d += y.copy(c, d))
        return c.slice(0, l)
      }
      function i(s, u, o, l, a) {
        let c = t(s, u, o)
        return n(s, c, l, a)
      }
      ;(e.native = 0), (e.extract = t), (e.expand = n), (e.derive = i)
    }
  }),
  iL = te({
    'node_modules/bcrypto/lib/hkdf-browser.js'(e, r) {
      V(), F(), (r.exports = nL())
    }
  }),
  sL = te({
    'node_modules/bcrypto/lib/internal/hmac.js'(e, r) {
      V(), F()
      var t = ji(),
        n = class {
          constructor(i, s, u = [], o = []) {
            t(typeof i == 'function'),
              t(s >>> 0 === s),
              t(Array.isArray(u)),
              t(Array.isArray(o)),
              (this.hash = i),
              (this.size = s),
              (this.x = u),
              (this.y = o),
              (this.inner = new i()),
              (this.outer = new i())
          }
          init(i) {
            if ((t(Ve.Buffer.isBuffer(i)), i.length > this.size)) {
              let u = this.hash,
                o = new u()
              o.init(...this.x), o.update(i), (i = o.final(...this.y)), t(i.length <= this.size)
            }
            let s = Ve.Buffer.alloc(this.size)
            for (let u = 0; u < i.length; u++) s[u] = i[u] ^ 54
            for (let u = i.length; u < s.length; u++) s[u] = 54
            this.inner.init(...this.x), this.inner.update(s)
            for (let u = 0; u < i.length; u++) s[u] = i[u] ^ 92
            for (let u = i.length; u < s.length; u++) s[u] = 92
            return this.outer.init(...this.x), this.outer.update(s), this
          }
          update(i) {
            return this.inner.update(i), this
          }
          final() {
            return this.outer.update(this.inner.final(...this.y)), this.outer.final(...this.y)
          }
        }
      r.exports = n
    }
  }),
  dA = te({
    'node_modules/bcrypto/lib/js/sha256.js'(e, r) {
      V(), F()
      var t = ji(),
        n = sL(),
        i = -1,
        s = Ve.Buffer.alloc(8, 0),
        u = Ve.Buffer.alloc(64, 0)
      u[0] = 128
      var o = new Uint32Array([
          1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080,
          310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774,
          264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808,
          3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
          1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817,
          3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
          1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479,
          3329325298
        ]),
        l = class {
          constructor() {
            ;(this.state = new Uint32Array(8)),
              (this.msg = new Uint32Array(64)),
              (this.block = Ve.Buffer.alloc(64)),
              (this.size = i)
          }
          init() {
            return (
              (this.state[0] = 1779033703),
              (this.state[1] = 3144134277),
              (this.state[2] = 1013904242),
              (this.state[3] = 2773480762),
              (this.state[4] = 1359893119),
              (this.state[5] = 2600822924),
              (this.state[6] = 528734635),
              (this.state[7] = 1541459225),
              (this.size = 0),
              this
            )
          }
          update(_) {
            return t(Ve.Buffer.isBuffer(_)), this._update(_, _.length), this
          }
          final() {
            return this._final(Ve.Buffer.alloc(32))
          }
          _update(_, A) {
            t(this.size !== i, 'Context is not initialized.')
            let T = this.size & 63,
              E = 0
            if (((this.size += A), T > 0)) {
              let k = 64 - T
              if ((k > A && (k = A), _.copy(this.block, T, E, E + k), (T += k), (A -= k), (E += k), T < 64)) return
              this._transform(this.block, 0)
            }
            for (; A >= 64; ) this._transform(_, E), (E += 64), (A -= 64)
            A > 0 && _.copy(this.block, 0, E, E + A)
          }
          _final(_) {
            t(this.size !== i, 'Context is not initialized.')
            let A = this.size & 63,
              T = this.size * 8
            m(s, (T * (1 / 4294967296)) >>> 0, 0),
              m(s, T >>> 0, 4),
              this._update(u, 1 + ((119 - A) & 63)),
              this._update(s, 8)
            for (let E = 0; E < 8; E++) m(_, this.state[E], E * 4), (this.state[E] = 0)
            for (let E = 0; E < 64; E++) this.msg[E] = 0
            for (let E = 0; E < 64; E++) this.block[E] = 0
            return (this.size = i), _
          }
          _transform(_, A) {
            let T = this.msg,
              E = this.state[0],
              k = this.state[1],
              w = this.state[2],
              v = this.state[3],
              I = this.state[4],
              M = this.state[5],
              q = this.state[6],
              G = this.state[7],
              O = 0
            for (; O < 16; O++) T[O] = h(_, A + O * 4)
            for (; O < 64; O++) T[O] = p(T[O - 2]) + T[O - 7] + f(T[O - 15]) + T[O - 16]
            for (O = 0; O < 64; O++) {
              let x = G + c(I) + y(I, M, q) + o[O] + T[O],
                L = a(E) + d(E, k, w)
              ;(G = q), (q = M), (M = I), (I = (v + x) >>> 0), (v = w), (w = k), (k = E), (E = (x + L) >>> 0)
            }
            ;(this.state[0] += E),
              (this.state[1] += k),
              (this.state[2] += w),
              (this.state[3] += v),
              (this.state[4] += I),
              (this.state[5] += M),
              (this.state[6] += q),
              (this.state[7] += G)
          }
          static hash() {
            return new l()
          }
          static hmac() {
            return new n(l, 64)
          }
          static digest(_) {
            return l.ctx.init().update(_).final()
          }
          static root(_, A) {
            return (
              t(Ve.Buffer.isBuffer(_) && _.length === 32),
              t(Ve.Buffer.isBuffer(A) && A.length === 32),
              l.ctx.init().update(_).update(A).final()
            )
          }
          static multi(_, A, T) {
            let { ctx: E } = l
            return E.init(), E.update(_), E.update(A), T && E.update(T), E.final()
          }
          static mac(_, A) {
            return l.hmac().init(A).update(_).final()
          }
        }
      ;(l.native = 0),
        (l.id = 'SHA256'),
        (l.size = 32),
        (l.bits = 256),
        (l.blockSize = 64),
        (l.zero = Ve.Buffer.alloc(32, 0)),
        (l.ctx = new l())
      function a(_) {
        return ((_ >>> 2) | (_ << 30)) ^ ((_ >>> 13) | (_ << 19)) ^ ((_ >>> 22) | (_ << 10))
      }
      function c(_) {
        return ((_ >>> 6) | (_ << 26)) ^ ((_ >>> 11) | (_ << 21)) ^ ((_ >>> 25) | (_ << 7))
      }
      function f(_) {
        return ((_ >>> 7) | (_ << 25)) ^ ((_ >>> 18) | (_ << 14)) ^ (_ >>> 3)
      }
      function p(_) {
        return ((_ >>> 17) | (_ << 15)) ^ ((_ >>> 19) | (_ << 13)) ^ (_ >>> 10)
      }
      function y(_, A, T) {
        return T ^ (_ & (A ^ T))
      }
      function d(_, A, T) {
        return (_ & A) | (T & (_ | A))
      }
      function h(_, A) {
        return _[A++] * 16777216 + _[A++] * 65536 + _[A++] * 256 + _[A]
      }
      function m(_, A, T) {
        return (_[T++] = A >>> 24), (_[T++] = A >>> 16), (_[T++] = A >>> 8), (_[T++] = A), T
      }
      r.exports = l
    }
  }),
  oL = te({
    'node_modules/libp2p-crypto/src/aes/ciphers-browser.js'(e, r) {
      V(), F(), qc()
      var t = yt(),
        { toString: n } = (On(), vn),
        { fromString: i } = (gn(), un)
      r.exports = {
        createCipheriv: (s, u, o) => {
          let l = t.cipher.createCipher('AES-CTR', n(u, 'ascii'))
          return (
            l.start({ iv: n(o, 'ascii') }),
            { update: (a) => (l.update(t.util.createBuffer(n(a, 'ascii'))), i(l.output.getBytes(), 'ascii')) }
          )
        },
        createDecipheriv: (s, u, o) => {
          let l = t.cipher.createDecipher('AES-CTR', n(u, 'ascii'))
          return (
            l.start({ iv: n(o, 'ascii') }),
            { update: (a) => (l.update(t.util.createBuffer(n(a, 'ascii'))), i(l.output.getBytes(), 'ascii')) }
          )
        }
      }
    }
  }),
  aL = te({
    'node_modules/libp2p-crypto/src/aes/cipher-mode.js'(e, r) {
      V(), F()
      var t = pt(),
        n = { 16: 'aes-128-ctr', 32: 'aes-256-ctr' }
      r.exports = function (i) {
        let s = n[i.length]
        if (!s) {
          let u = Object.entries(n)
            .map(([o, l]) => `${o} (${l})`)
            .join(' / ')
          throw t(new Error(`Invalid key length ${i.length} bytes. Must be ${u}`), 'ERR_INVALID_KEY_LENGTH')
        }
        return s
      }
    }
  }),
  cL = te({
    'node_modules/libp2p-crypto/src/aes/index.js'(e) {
      V(), F()
      var r = oL(),
        t = aL()
      e.create = async function (n, i) {
        let s = t(n),
          u = r.createCipheriv(s, n, i),
          o = r.createDecipheriv(s, n, i)
        return {
          async encrypt(a) {
            return u.update(a)
          },
          async decrypt(a) {
            return o.update(a)
          }
        }
      }
    }
  }),
  uL = te({
    'node_modules/libp2p-crypto/src/pbkdf2.js'(e, r) {
      V(), F()
      var t = e9(),
        n = zt(),
        i = pt(),
        s = { sha1: 'sha1', 'sha2-256': 'sha256', 'sha2-512': 'sha512' }
      function u(o, l, a, c, f) {
        let p = s[f]
        if (!p) {
          let d = Object.keys(s).join(' / ')
          throw i(new Error(`Hash '${f}' is unknown or not supported. Must be ${d}`), 'ERR_UNSUPPORTED_HASH_TYPE')
        }
        let y = t(o, l, a, c, p)
        return n.encode64(y)
      }
      r.exports = u
    }
  }),
  H1 = te({
    'node_modules/libp2p-crypto/src/index.js'(e) {
      V(), F()
      var r = eE(),
        t = cL(),
        n = g1()
      ;(e.aes = t), (e.hmac = r), (e.keys = n), (e.randomBytes = p1()), (e.pbkdf2 = uL())
    }
  }),
  lL = te({
    'node_modules/libp2p-noise/dist/src/proto/payload.js'(e, r) {
      V(),
        F(),
        (function (t, n) {
          typeof define == 'function' && define.amd
            ? define(['protobufjs/minimal'], n)
            : typeof c0 == 'function' && typeof r == 'object' && r && r.exports && (r.exports = n(oi()))
        })(e, function (t) {
          var n = t.Reader,
            i = t.Writer,
            s = t.util,
            u = t.roots.default || (t.roots.default = {})
          return (
            (u.pb = (function () {
              var o = {}
              return (
                (o.NoiseHandshakePayload = (function () {
                  function l(a) {
                    if (a)
                      for (var c = Object.keys(a), f = 0; f < c.length; ++f) a[c[f]] != null && (this[c[f]] = a[c[f]])
                  }
                  return (
                    (l.prototype.identityKey = s.newBuffer([])),
                    (l.prototype.identitySig = s.newBuffer([])),
                    (l.prototype.data = s.newBuffer([])),
                    (l.create = function (c) {
                      return new l(c)
                    }),
                    (l.encode = function (c, f) {
                      return (
                        f || (f = i.create()),
                        c.identityKey != null && c.hasOwnProperty('identityKey') && f.uint32(10).bytes(c.identityKey),
                        c.identitySig != null && c.hasOwnProperty('identitySig') && f.uint32(18).bytes(c.identitySig),
                        c.data != null && c.hasOwnProperty('data') && f.uint32(26).bytes(c.data),
                        f
                      )
                    }),
                    (l.encodeDelimited = function (c, f) {
                      return this.encode(c, f).ldelim()
                    }),
                    (l.decode = function (c, f) {
                      c instanceof n || (c = n.create(c))
                      for (
                        var p = f === void 0 ? c.len : c.pos + f, y = new u.pb.NoiseHandshakePayload();
                        c.pos < p;

                      ) {
                        var d = c.uint32()
                        switch (d >>> 3) {
                          case 1:
                            y.identityKey = c.bytes()
                            break
                          case 2:
                            y.identitySig = c.bytes()
                            break
                          case 3:
                            y.data = c.bytes()
                            break
                          default:
                            c.skipType(d & 7)
                            break
                        }
                      }
                      return y
                    }),
                    (l.decodeDelimited = function (c) {
                      return c instanceof n || (c = new n(c)), this.decode(c, c.uint32())
                    }),
                    (l.verify = function (c) {
                      return typeof c != 'object' || c === null
                        ? 'object expected'
                        : c.identityKey != null &&
                          c.hasOwnProperty('identityKey') &&
                          !((c.identityKey && typeof c.identityKey.length == 'number') || s.isString(c.identityKey))
                        ? 'identityKey: buffer expected'
                        : c.identitySig != null &&
                          c.hasOwnProperty('identitySig') &&
                          !((c.identitySig && typeof c.identitySig.length == 'number') || s.isString(c.identitySig))
                        ? 'identitySig: buffer expected'
                        : c.data != null &&
                          c.hasOwnProperty('data') &&
                          !((c.data && typeof c.data.length == 'number') || s.isString(c.data))
                        ? 'data: buffer expected'
                        : null
                    }),
                    (l.fromObject = function (c) {
                      if (c instanceof u.pb.NoiseHandshakePayload) return c
                      var f = new u.pb.NoiseHandshakePayload()
                      return (
                        c.identityKey != null &&
                          (typeof c.identityKey == 'string'
                            ? s.base64.decode(
                                c.identityKey,
                                (f.identityKey = s.newBuffer(s.base64.length(c.identityKey))),
                                0
                              )
                            : c.identityKey.length && (f.identityKey = c.identityKey)),
                        c.identitySig != null &&
                          (typeof c.identitySig == 'string'
                            ? s.base64.decode(
                                c.identitySig,
                                (f.identitySig = s.newBuffer(s.base64.length(c.identitySig))),
                                0
                              )
                            : c.identitySig.length && (f.identitySig = c.identitySig)),
                        c.data != null &&
                          (typeof c.data == 'string'
                            ? s.base64.decode(c.data, (f.data = s.newBuffer(s.base64.length(c.data))), 0)
                            : c.data.length && (f.data = c.data)),
                        f
                      )
                    }),
                    (l.toObject = function (c, f) {
                      f || (f = {})
                      var p = {}
                      return (
                        f.defaults &&
                          (f.bytes === String
                            ? (p.identityKey = '')
                            : ((p.identityKey = []), f.bytes !== Array && (p.identityKey = s.newBuffer(p.identityKey))),
                          f.bytes === String
                            ? (p.identitySig = '')
                            : ((p.identitySig = []), f.bytes !== Array && (p.identitySig = s.newBuffer(p.identitySig))),
                          f.bytes === String
                            ? (p.data = '')
                            : ((p.data = []), f.bytes !== Array && (p.data = s.newBuffer(p.data)))),
                        c.identityKey != null &&
                          c.hasOwnProperty('identityKey') &&
                          (p.identityKey =
                            f.bytes === String
                              ? s.base64.encode(c.identityKey, 0, c.identityKey.length)
                              : f.bytes === Array
                              ? Array.prototype.slice.call(c.identityKey)
                              : c.identityKey),
                        c.identitySig != null &&
                          c.hasOwnProperty('identitySig') &&
                          (p.identitySig =
                            f.bytes === String
                              ? s.base64.encode(c.identitySig, 0, c.identitySig.length)
                              : f.bytes === Array
                              ? Array.prototype.slice.call(c.identitySig)
                              : c.identitySig),
                        c.data != null &&
                          c.hasOwnProperty('data') &&
                          (p.data =
                            f.bytes === String
                              ? s.base64.encode(c.data, 0, c.data.length)
                              : f.bytes === Array
                              ? Array.prototype.slice.call(c.data)
                              : c.data),
                        p
                      )
                    }),
                    (l.prototype.toJSON = function () {
                      return this.constructor.toObject(this, t.util.toJSONOptions)
                    }),
                    l
                  )
                })()),
                o
              )
            })()),
            u
          )
        })
    }
  }),
  fL = te({
    'node_modules/libp2p-noise/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  }),
  Cs = te({
    'node_modules/libp2p-noise/dist/src/utils.js'(e) {
      V(), F()
      var r =
        (e && e.__importDefault) ||
        function (w) {
          return w && w.__esModule ? w : { default: w }
        }
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.isValidPublicKey =
          e.getHkdf =
          e.verifySignedPayload =
          e.getHandshakePayload =
          e.decodePayload =
          e.getPeerIdFromPayload =
          e.signPayload =
          e.createHandshakePayload =
          e.getPayload =
          e.generateKeypair =
            void 0)
      var t = r(iL()),
        n = r(F1()),
        i = r(dA()),
        s = Nr(),
        u = r(er()),
        o = H1(),
        l = lL(),
        a = r(fL()),
        c = l.pb.NoiseHandshakePayload
      function f() {
        let w = n.default.privateKeyGenerate()
        return { publicKey: n.default.publicKeyCreate(w), privateKey: w }
      }
      e.generateKeypair = f
      async function p(w, v, I) {
        let M = await d(w, _(v)),
          q = I ?? s.Buffer.alloc(0)
        return y(w.marshalPubKey(), M, q)
      }
      e.getPayload = p
      function y(w, v, I) {
        let M = c.create({ identityKey: s.Buffer.from(w), identitySig: v, data: I ?? null })
        return s.Buffer.from(c.encode(M).finish())
      }
      e.createHandshakePayload = y
      async function d(w, v) {
        return s.Buffer.from(await w.privKey.sign(v))
      }
      e.signPayload = d
      async function h(w) {
        return await u.default.createFromPubKey(s.Buffer.from(w.identityKey))
      }
      e.getPeerIdFromPayload = h
      function m(w) {
        return c.toObject(c.decode(s.Buffer.from(w)))
      }
      e.decodePayload = m
      function _(w) {
        return s.Buffer.concat([s.Buffer.from('noise-libp2p-static-key:'), w])
      }
      e.getHandshakePayload = _
      async function A(w, v) {
        let I = await u.default.createFromPubKey(v)
        return a.default(I.id, w)
      }
      async function T(w, v, I) {
        let M = s.Buffer.from(v.identityKey)
        if (!(await A(I.id, M))) throw new Error("Peer ID doesn't match libp2p public key.")
        let q = _(w),
          G = o.keys.unmarshalPublicKey(M)
        if (!v.identitySig || !G.verify(q, s.Buffer.from(v.identitySig)))
          throw new Error("Static key doesn't match to peer that signed payload!")
        return await u.default.createFromPubKey(M)
      }
      e.verifySignedPayload = T
      function E(w, v) {
        let I = s.Buffer.alloc(0),
          M = t.default.extract(i.default, v, w),
          q = t.default.expand(i.default, M, I, 96),
          G = q.slice(0, 32),
          O = q.slice(32, 64),
          x = q.slice(64, 96)
        return [G, O, x]
      }
      e.getHkdf = E
      function k(w) {
        return n.default.publicKeyVerify(w.slice(0, 32))
      }
      e.isValidPublicKey = k
    }
  }),
  dL = te({
    'node_modules/bcrypto/lib/js/chacha20.js'(e, r) {
      V(), F()
      var t = ji(),
        n = new Int8Array(new Int16Array([1]).buffer)[0] === 0,
        i = class {
          constructor() {
            ;(this.state = new Uint32Array(16)),
              (this.stream = new Uint32Array(16)),
              (this.bytes = new Uint8Array(this.stream.buffer)),
              (this.pos = -1),
              n && (this.bytes = Ve.Buffer.alloc(64))
          }
          init(a, c, f) {
            if (
              (f == null && (f = 0),
              t(Ve.Buffer.isBuffer(a)),
              t(Ve.Buffer.isBuffer(c)),
              t(Number.isSafeInteger(f)),
              a.length !== 16 && a.length !== 32)
            )
              throw new RangeError('Invalid key size.')
            if (
              (c.length >= 24 && ((a = i.derive(a, c.slice(0, 16))), (c = c.slice(16))),
              (this.state[0] = 1634760805),
              (this.state[1] = a.length < 32 ? 824206446 : 857760878),
              (this.state[2] = a.length < 32 ? 2036477238 : 2036477234),
              (this.state[3] = 1797285236),
              (this.state[4] = o(a, 0)),
              (this.state[5] = o(a, 4)),
              (this.state[6] = o(a, 8)),
              (this.state[7] = o(a, 12)),
              (this.state[8] = o(a, 16 % a.length)),
              (this.state[9] = o(a, 20 % a.length)),
              (this.state[10] = o(a, 24 % a.length)),
              (this.state[11] = o(a, 28 % a.length)),
              (this.state[12] = f >>> 0),
              c.length === 8)
            )
              (this.state[13] = (f / 4294967296) >>> 0), (this.state[14] = o(c, 0)), (this.state[15] = o(c, 4))
            else if (c.length === 12) (this.state[13] = o(c, 0)), (this.state[14] = o(c, 4)), (this.state[15] = o(c, 8))
            else if (c.length === 16)
              (this.state[12] = o(c, 0)),
                (this.state[13] = o(c, 4)),
                (this.state[14] = o(c, 8)),
                (this.state[15] = o(c, 12))
            else throw new RangeError('Invalid nonce size.')
            return (this.pos = 0), this
          }
          encrypt(a) {
            if ((t(Ve.Buffer.isBuffer(a)), this.pos === -1)) throw new Error('Context is not initialized.')
            for (let c = 0; c < a.length; c++)
              (this.pos & 63) == 0 && (this._block(), (this.pos = 0)), (a[c] ^= this.bytes[this.pos++])
            return a
          }
          _block() {
            for (let a = 0; a < 16; a++) this.stream[a] = this.state[a]
            for (let a = 0; a < 10; a++)
              s(this.stream, 0, 4, 8, 12),
                s(this.stream, 1, 5, 9, 13),
                s(this.stream, 2, 6, 10, 14),
                s(this.stream, 3, 7, 11, 15),
                s(this.stream, 0, 5, 10, 15),
                s(this.stream, 1, 6, 11, 12),
                s(this.stream, 2, 7, 8, 13),
                s(this.stream, 3, 4, 9, 14)
            for (let a = 0; a < 16; a++) this.stream[a] += this.state[a]
            if (n) for (let a = 0; a < 16; a++) l(this.bytes, this.stream[a], a * 4)
            ;(this.state[12] += 1), this.state[12] === 0 && (this.state[13] += 1)
          }
          destroy() {
            for (let a = 0; a < 16; a++) (this.state[a] = 0), (this.stream[a] = 0)
            if (n) for (let a = 0; a < 64; a++) this.bytes[a] = 0
            return (this.pos = -1), this
          }
          static derive(a, c) {
            if ((t(Ve.Buffer.isBuffer(a)), t(Ve.Buffer.isBuffer(c)), a.length !== 16 && a.length !== 32))
              throw new RangeError('Invalid key size.')
            if (c.length !== 16) throw new RangeError('Invalid nonce size.')
            let f = new Uint32Array(16)
            ;(f[0] = 1634760805),
              (f[1] = a.length < 32 ? 824206446 : 857760878),
              (f[2] = a.length < 32 ? 2036477238 : 2036477234),
              (f[3] = 1797285236),
              (f[4] = o(a, 0)),
              (f[5] = o(a, 4)),
              (f[6] = o(a, 8)),
              (f[7] = o(a, 12)),
              (f[8] = o(a, 16 % a.length)),
              (f[9] = o(a, 20 % a.length)),
              (f[10] = o(a, 24 % a.length)),
              (f[11] = o(a, 28 % a.length)),
              (f[12] = o(c, 0)),
              (f[13] = o(c, 4)),
              (f[14] = o(c, 8)),
              (f[15] = o(c, 12))
            for (let y = 0; y < 10; y++)
              s(f, 0, 4, 8, 12),
                s(f, 1, 5, 9, 13),
                s(f, 2, 6, 10, 14),
                s(f, 3, 7, 11, 15),
                s(f, 0, 5, 10, 15),
                s(f, 1, 6, 11, 12),
                s(f, 2, 7, 8, 13),
                s(f, 3, 4, 9, 14)
            let p = Ve.Buffer.alloc(32)
            return (
              l(p, f[0], 0),
              l(p, f[1], 4),
              l(p, f[2], 8),
              l(p, f[3], 12),
              l(p, f[12], 16),
              l(p, f[13], 20),
              l(p, f[14], 24),
              l(p, f[15], 28),
              p
            )
          }
        }
      i.native = 0
      function s(a, c, f, p, y) {
        ;(a[c] += a[f]),
          (a[y] = u(a[y] ^ a[c], 16)),
          (a[p] += a[y]),
          (a[f] = u(a[f] ^ a[p], 12)),
          (a[c] += a[f]),
          (a[y] = u(a[y] ^ a[c], 8)),
          (a[p] += a[y]),
          (a[f] = u(a[f] ^ a[p], 7))
      }
      function u(a, c) {
        return (a << c) | (a >>> (32 - c))
      }
      function o(a, c) {
        return a[c++] + a[c++] * 256 + a[c++] * 65536 + a[c] * 16777216
      }
      function l(a, c, f) {
        return (a[f++] = c), (c >>>= 8), (a[f++] = c), (c >>>= 8), (a[f++] = c), (c >>>= 8), (a[f++] = c), f
      }
      r.exports = i
    }
  }),
  hL = te({
    'node_modules/bcrypto/lib/js/poly1305.js'(e, r) {
      V(), F()
      var t = ji(),
        n = class {
          constructor() {
            ;(this.r = new Uint16Array(10)),
              (this.h = new Uint16Array(10)),
              (this.pad = new Uint16Array(8)),
              (this.buffer = Ve.Buffer.alloc(16)),
              (this.fin = -1),
              (this.leftover = 0)
          }
          init(u) {
            t(Ve.Buffer.isBuffer(u) && u.length >= 32)
            let o = i(u, 0),
              l = i(u, 2),
              a = i(u, 4),
              c = i(u, 6),
              f = i(u, 8),
              p = i(u, 10),
              y = i(u, 12),
              d = i(u, 14)
            ;(this.r[0] = o & 8191),
              (this.r[1] = ((o >>> 13) | (l << 3)) & 8191),
              (this.r[2] = ((l >>> 10) | (a << 6)) & 7939),
              (this.r[3] = ((a >>> 7) | (c << 9)) & 8191),
              (this.r[4] = ((c >>> 4) | (f << 12)) & 255),
              (this.r[5] = (f >>> 1) & 8190),
              (this.r[6] = ((f >>> 14) | (p << 2)) & 8191),
              (this.r[7] = ((p >>> 11) | (y << 5)) & 8065),
              (this.r[8] = ((y >>> 8) | (d << 8)) & 8191),
              (this.r[9] = (d >>> 5) & 127)
            for (let h = 0; h < 10; h++) this.h[h] = 0
            for (let h = 0; h < 8; h++) this.pad[h] = i(u, 16 + 2 * h)
            return (this.fin = 0), (this.leftover = 0), this
          }
          _blocks(u, o, l) {
            let a = this.fin ? 0 : 1 << 11,
              c = new Uint32Array(10)
            for (; o >= 16; ) {
              let f = i(u, l + 0),
                p = i(u, l + 2),
                y = i(u, l + 4),
                d = i(u, l + 6),
                h = i(u, l + 8),
                m = i(u, l + 10),
                _ = i(u, l + 12),
                A = i(u, l + 14)
              ;(this.h[0] += f & 8191),
                (this.h[1] += ((f >>> 13) | (p << 3)) & 8191),
                (this.h[2] += ((p >>> 10) | (y << 6)) & 8191),
                (this.h[3] += ((y >>> 7) | (d << 9)) & 8191),
                (this.h[4] += ((d >>> 4) | (h << 12)) & 8191),
                (this.h[5] += (h >>> 1) & 8191),
                (this.h[6] += ((h >>> 14) | (m << 2)) & 8191),
                (this.h[7] += ((m >>> 11) | (_ << 5)) & 8191),
                (this.h[8] += ((_ >>> 8) | (A << 8)) & 8191),
                (this.h[9] += (A >>> 5) | a)
              let T = 0
              for (let E = 0; E < 10; E++) {
                c[E] = T
                for (let k = 0; k < 10; k++) {
                  let w = this.h[k]
                  k <= E ? (w *= this.r[E - k]) : (w *= 5 * this.r[E + 10 - k]),
                    (c[E] += w),
                    k === 4 && ((T = c[E] >>> 13), (c[E] &= 8191))
                }
                ;(T += c[E] >>> 13), (c[E] &= 8191)
              }
              ;(T = (T << 2) + T), (T += c[0]), (c[0] = T & 8191), (T = T >>> 13), (c[1] += T)
              for (let E = 0; E < 10; E++) this.h[E] = c[E]
              ;(l += 16), (o -= 16)
            }
          }
          update(u) {
            if ((t(Ve.Buffer.isBuffer(u)), this.fin === -1)) throw new Error('Context is not initialized.')
            let o = u.length,
              l = 0
            if (this.leftover) {
              let a = 16 - this.leftover
              a > o && (a = o)
              for (let c = 0; c < a; c++) this.buffer[this.leftover + c] = u[l + c]
              if (((o -= a), (l += a), (this.leftover += a), this.leftover < 16)) return this
              this._blocks(this.buffer, 16, 0), (this.leftover = 0)
            }
            if (o >= 16) {
              let a = o & ~(16 - 1)
              this._blocks(u, a, l), (l += a), (o -= a)
            }
            if (o) {
              for (let a = 0; a < o; a++) this.buffer[this.leftover + a] = u[l + a]
              this.leftover += o
            }
            return this
          }
          final() {
            if (this.fin === -1) throw new Error('Context is not initialized.')
            let u = Ve.Buffer.alloc(16),
              o = new Uint16Array(10)
            if (this.leftover) {
              let f = this.leftover
              for (this.buffer[f++] = 1; f < 16; f++) this.buffer[f] = 0
              ;(this.fin = 1), this._blocks(this.buffer, 16, 0)
            }
            let l = this.h[1] >>> 13
            this.h[1] &= 8191
            for (let f = 2; f < 10; f++) (this.h[f] += l), (l = this.h[f] >>> 13), (this.h[f] &= 8191)
            ;(this.h[0] += l * 5),
              (l = this.h[0] >>> 13),
              (this.h[0] &= 8191),
              (this.h[1] += l),
              (l = this.h[1] >>> 13),
              (this.h[1] &= 8191),
              (this.h[2] += l),
              (o[0] = this.h[0] + 5),
              (l = o[0] >>> 13),
              (o[0] &= 8191)
            for (let f = 1; f < 10; f++) (o[f] = this.h[f] + l), (l = o[f] >>> 13), (o[f] &= 8191)
            let a = (l ^ 1) - 1
            for (let f = 0; f < 10; f++) o[f] &= a
            a = ~a
            for (let f = 0; f < 10; f++) this.h[f] = (this.h[f] & a) | o[f]
            ;(this.h[0] = (this.h[0] | (this.h[1] << 13)) & 65535),
              (this.h[1] = ((this.h[1] >>> 3) | (this.h[2] << 10)) & 65535),
              (this.h[2] = ((this.h[2] >>> 6) | (this.h[3] << 7)) & 65535),
              (this.h[3] = ((this.h[3] >>> 9) | (this.h[4] << 4)) & 65535),
              (this.h[4] = ((this.h[4] >>> 12) | (this.h[5] << 1) | (this.h[6] << 14)) & 65535),
              (this.h[5] = ((this.h[6] >>> 2) | (this.h[7] << 11)) & 65535),
              (this.h[6] = ((this.h[7] >>> 5) | (this.h[8] << 8)) & 65535),
              (this.h[7] = ((this.h[8] >>> 8) | (this.h[9] << 5)) & 65535)
            let c = this.h[0] + this.pad[0]
            this.h[0] = c
            for (let f = 1; f < 8; f++) (c = this.h[f] + this.pad[f] + (c >>> 16)), (this.h[f] = c)
            for (let f = 0; f < 8; f++) s(u, this.h[f], f * 2)
            return this.destroy(), u
          }
          destroy() {
            for (let u = 0; u < 10; u++) (this.r[u] = 0), (this.h[u] = 0)
            for (let u = 0; u < 8; u++) this.pad[u] = 0
            for (let u = 0; u < 16; u++) this.buffer[u] = 0
            ;(this.fin = -1), (this.leftover = 0)
          }
          verify(u) {
            t(Ve.Buffer.isBuffer(u)), t(u.length === 16)
            let o = this.final(),
              l = 0
            for (let a = 0; a < 16; a++) l |= o[a] ^ u[a]
            return (l - 1) >>> 31 != 0
          }
        }
      n.native = 0
      function i(u, o) {
        return u[o++] + u[o] * 256
      }
      function s(u, o, l) {
        return (u[l++] = o), (u[l++] = o >>> 8), l
      }
      r.exports = n
    }
  }),
  pL = te({
    'node_modules/bcrypto/lib/js/aead.js'(e, r) {
      V(), F()
      var t = ji(),
        n = dL(),
        i = hL(),
        s = Ve.Buffer.alloc(16, 0),
        u = class {
          constructor() {
            ;(this.chacha = new n()),
              (this.poly = new i()),
              (this.key = Ve.Buffer.alloc(64)),
              (this.mode = -1),
              (this.aadLen = 0),
              (this.cipherLen = 0)
          }
          init(a, c) {
            return (
              t(Ve.Buffer.isBuffer(a)),
              t(Ve.Buffer.isBuffer(c)),
              this.key.fill(0),
              this.chacha.init(a, c, 0),
              this.chacha.encrypt(this.key),
              this.poly.init(this.key),
              (this.mode = 0),
              (this.aadLen = 0),
              (this.cipherLen = 0),
              this
            )
          }
          aad(a) {
            if (this.mode === -1) throw new Error('Context is not initialized.')
            if (this.mode !== 0) throw new Error('Invalid state for aad.')
            return this.poly.update(a), (this.aadLen += a.length), this
          }
          encrypt(a) {
            if (this.mode === -1) throw new Error('Context is not initialized.')
            if (this.mode !== 0 && this.mode !== 1) throw new Error('Invalid state for encrypt.')
            return (
              this.mode === 0 && (this._pad16(this.aadLen), (this.mode = 1)),
              this.chacha.encrypt(a),
              this.poly.update(a),
              (this.cipherLen += a.length),
              a
            )
          }
          decrypt(a) {
            if ((t(Ve.Buffer.isBuffer(a)), this.mode === -1)) throw new Error('Context is not initialized.')
            if (this.mode !== 0 && this.mode !== 2) throw new Error('Invalid state for decrypt.')
            return (
              this.mode === 0 && (this._pad16(this.aadLen), (this.mode = 2)),
              (this.cipherLen += a.length),
              this.poly.update(a),
              this.chacha.encrypt(a),
              a
            )
          }
          auth(a) {
            if ((t(Ve.Buffer.isBuffer(a)), this.mode === -1)) throw new Error('Context is not initialized.')
            if (this.mode !== 0 && this.mode !== 3) throw new Error('Invalid state for auth.')
            return (
              this.mode === 0 && (this._pad16(this.aadLen), (this.mode = 3)),
              (this.cipherLen += a.length),
              this.poly.update(a),
              a
            )
          }
          final() {
            if (this.mode === -1) throw new Error('Context is not initialized.')
            let a = Ve.Buffer.alloc(16)
            l(a, this.aadLen, 0),
              l(a, this.cipherLen, 8),
              this.mode === 0 && this._pad16(this.aadLen),
              this._pad16(this.cipherLen),
              this.poly.update(a)
            let c = this.poly.final()
            return this.destroy(), c
          }
          destroy() {
            this.chacha.destroy(), this.poly.destroy()
            for (let a = 0; a < 64; a++) this.key[a] = 0
            return (this.mode = -1), (this.aadLen = 0), (this.cipherLen = 0), this
          }
          verify(a) {
            t(Ve.Buffer.isBuffer(a)), t(a.length === 16)
            let c = this.final(),
              f = 0
            for (let p = 0; p < 16; p++) f |= c[p] ^ a[p]
            return (f - 1) >>> 31 != 0
          }
          _pad16(a) {
            let c = a & 15
            c > 0 && this.poly.update(s.slice(0, 16 - c))
          }
          static encrypt(a, c, f, p) {
            let y = new u()
            return y.init(a, c), p && y.aad(p), y.encrypt(f), y.final()
          }
          static decrypt(a, c, f, p, y) {
            let d = new u()
            return d.init(a, c), y && d.aad(y), d.decrypt(f), d.verify(p)
          }
          static auth(a, c, f, p, y) {
            let d = new u()
            return d.init(a, c), y && d.aad(y), d.auth(f), d.verify(p)
          }
        }
      u.native = n.native
      function o(a, c, f) {
        return (a[f++] = c), (c >>>= 8), (a[f++] = c), (c >>>= 8), (a[f++] = c), (c >>>= 8), (a[f++] = c), f
      }
      function l(a, c, f) {
        let p = (c * (1 / 4294967296)) >>> 0,
          y = c >>> 0
        return o(a, y, f + 0), o(a, p, f + 4), f + 8
      }
      r.exports = u
    }
  }),
  $1 = te({
    'node_modules/libp2p-noise/dist/src/constants.js'(e) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.DUMP_SESSION_KEYS = e.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = e.NOISE_MSG_MAX_LENGTH_BYTES = void 0),
        (e.NOISE_MSG_MAX_LENGTH_BYTES = 65535),
        (e.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = e.NOISE_MSG_MAX_LENGTH_BYTES - 16),
        (e.DUMP_SESSION_KEYS = lt.env.DUMP_SESSION_KEYS)
    }
  }),
  Qc = te({
    'node_modules/libp2p-noise/dist/src/logger.js'(e) {
      V(), F()
      var r =
        (e && e.__importDefault) ||
        function (c) {
          return c && c.__esModule ? c : { default: c }
        }
      Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.logCipherState =
          e.logRemoteEphemeralKey =
          e.logRemoteStaticKey =
          e.logLocalEphemeralKeys =
          e.logLocalStaticKeys =
          e.logger =
            void 0)
      var t = r(mt()),
        n = $1()
      e.logger = t.default('libp2p:noise')
      var i
      n.DUMP_SESSION_KEYS ? (i = e.logger) : (i = () => {})
      function s(c) {
        i(`LOCAL_STATIC_PUBLIC_KEY ${c.publicKey.toString('hex')}`),
          i(`LOCAL_STATIC_PRIVATE_KEY ${c.privateKey.toString('hex')}`)
      }
      e.logLocalStaticKeys = s
      function u(c) {
        c
          ? (i(`LOCAL_PUBLIC_EPHEMERAL_KEY ${c.publicKey.toString('hex')}`),
            i(`LOCAL_PRIVATE_EPHEMERAL_KEY ${c.privateKey.toString('hex')}`))
          : i('Missing local ephemeral keys.')
      }
      e.logLocalEphemeralKeys = u
      function o(c) {
        i(`REMOTE_STATIC_PUBLIC_KEY ${c.toString('hex')}`)
      }
      e.logRemoteStaticKey = o
      function l(c) {
        i(`REMOTE_EPHEMERAL_PUBLIC_KEY ${c.toString('hex')}`)
      }
      e.logRemoteEphemeralKey = l
      function a(c) {
        c.cs1 && c.cs2
          ? (i(`CIPHER_STATE_1 ${c.cs1.n} ${c.cs1.k.toString('hex')}`),
            i(`CIPHER_STATE_2 ${c.cs2.n} ${c.cs2.k.toString('hex')}`))
          : i('Missing cipher state.')
      }
      e.logCipherState = a
    }
  }),
  hA = te({
    'node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js'(e) {
      V(), F()
      var r =
        (e && e.__importDefault) ||
        function (a) {
          return a && a.__esModule ? a : { default: a }
        }
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.AbstractHandshake = e.MIN_NONCE = void 0)
      var t = Nr(),
        n = r(pL()),
        i = r(F1()),
        s = r(dA()),
        u = Cs(),
        o = Qc()
      e.MIN_NONCE = 0
      var l = class {
        encryptWithAd(a, c, f) {
          let p = this.encrypt(a.k, a.n, c, f)
          return this.setNonce(a, this.incrementNonce(a.n)), p
        }
        decryptWithAd(a, c, f) {
          let { plaintext: p, valid: y } = this.decrypt(a.k, a.n, c, f)
          return this.setNonce(a, this.incrementNonce(a.n)), { plaintext: p, valid: y }
        }
        hasKey(a) {
          return !this.isEmptyKey(a.k)
        }
        setNonce(a, c) {
          a.n = c
        }
        createEmptyKey() {
          return t.Buffer.alloc(32)
        }
        isEmptyKey(a) {
          return this.createEmptyKey().equals(a)
        }
        incrementNonce(a) {
          return a + 1
        }
        nonceToBytes(a) {
          let c = t.Buffer.alloc(12)
          return c.writeUInt32LE(a, 4), c
        }
        encrypt(a, c, f, p) {
          let y = this.nonceToBytes(c),
            d = new n.default()
          return (p = t.Buffer.from(p)), d.init(a, y), d.aad(f), d.encrypt(p), t.Buffer.concat([p, d.final()])
        }
        encryptAndHash(a, c) {
          let f
          return this.hasKey(a.cs) ? (f = this.encryptWithAd(a.cs, a.h, c)) : (f = c), this.mixHash(a, f), f
        }
        decrypt(a, c, f, p) {
          let y = this.nonceToBytes(c),
            d = new n.default()
          p = t.Buffer.from(p)
          let h = p.slice(p.length - 16)
          return (
            (p = p.slice(0, p.length - 16)), d.init(a, y), d.aad(f), d.decrypt(p), { plaintext: p, valid: d.verify(h) }
          )
        }
        decryptAndHash(a, c) {
          let f,
            p = !0
          return (
            this.hasKey(a.cs) ? ({ plaintext: f, valid: p } = this.decryptWithAd(a.cs, a.h, c)) : (f = c),
            this.mixHash(a, c),
            { plaintext: f, valid: p }
          )
        }
        dh(a, c) {
          try {
            let f = i.default.derive(c, a),
              p = t.Buffer.alloc(32)
            return f.copy(p), p
          } catch (f) {
            return o.logger(f.message), t.Buffer.alloc(32)
          }
        }
        mixHash(a, c) {
          a.h = this.getHash(a.h, c)
        }
        getHash(a, c) {
          return s.default.digest(t.Buffer.from([...a, ...c]))
        }
        mixKey(a, c) {
          let [f, p] = u.getHkdf(a.ck, c)
          ;(a.cs = this.initializeKey(p)), (a.ck = f)
        }
        initializeKey(a) {
          let c = e.MIN_NONCE
          return { k: a, n: c }
        }
        initializeSymmetric(a) {
          let c = t.Buffer.from(a, 'utf-8'),
            f = this.hashProtocolName(c),
            p = f,
            y = this.createEmptyKey()
          return { cs: this.initializeKey(y), ck: p, h: f }
        }
        hashProtocolName(a) {
          if (a.length <= 32) {
            let c = t.Buffer.alloc(32)
            return a.copy(c), c
          } else return this.getHash(a, t.Buffer.alloc(0))
        }
        split(a) {
          let [c, f] = u.getHkdf(a.ck, t.Buffer.alloc(0)),
            p = this.initializeKey(c),
            y = this.initializeKey(f)
          return { cs1: p, cs2: y }
        }
        writeMessageRegular(a, c) {
          let f = this.encryptWithAd(a, t.Buffer.alloc(0), c),
            p = this.createEmptyKey(),
            y = t.Buffer.alloc(0)
          return { ne: p, ns: y, ciphertext: f }
        }
        readMessageRegular(a, c) {
          return this.decryptWithAd(a, t.Buffer.alloc(0), c.ciphertext)
        }
      }
      e.AbstractHandshake = l
    }
  }),
  mL = te({
    'node_modules/libp2p-noise/dist/src/handshakes/xx.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.XX = void 0)
      var r = Nr(),
        t = Cs(),
        n = hA(),
        i = class extends n.AbstractHandshake {
          initializeInitiator(s, u, o, l) {
            let a = 'Noise_XX_25519_ChaChaPoly_SHA256',
              c = this.initializeSymmetric(a)
            this.mixHash(c, s)
            let f = r.Buffer.alloc(32)
            return { ss: c, s: u, rs: o, psk: l, re: f }
          }
          initializeResponder(s, u, o, l) {
            let a = 'Noise_XX_25519_ChaChaPoly_SHA256',
              c = this.initializeSymmetric(a)
            this.mixHash(c, s)
            let f = r.Buffer.alloc(32)
            return { ss: c, s: u, rs: o, psk: l, re: f }
          }
          writeMessageA(s, u, o) {
            let l = r.Buffer.alloc(0)
            o !== void 0 ? (s.e = o) : (s.e = t.generateKeypair())
            let a = s.e.publicKey
            this.mixHash(s.ss, a)
            let c = this.encryptAndHash(s.ss, u)
            return { ne: a, ns: l, ciphertext: c }
          }
          writeMessageB(s, u) {
            s.e = t.generateKeypair()
            let o = s.e.publicKey
            this.mixHash(s.ss, o), this.mixKey(s.ss, this.dh(s.e.privateKey, s.re))
            let l = r.Buffer.from(s.s.publicKey),
              a = this.encryptAndHash(s.ss, l)
            this.mixKey(s.ss, this.dh(s.s.privateKey, s.re))
            let c = this.encryptAndHash(s.ss, u)
            return { ne: o, ns: a, ciphertext: c }
          }
          writeMessageC(s, u) {
            let o = r.Buffer.from(s.s.publicKey),
              l = this.encryptAndHash(s.ss, o)
            this.mixKey(s.ss, this.dh(s.s.privateKey, s.re))
            let a = this.encryptAndHash(s.ss, u),
              f = { ne: this.createEmptyKey(), ns: l, ciphertext: a },
              { cs1: p, cs2: y } = this.split(s.ss)
            return { h: s.ss.h, messageBuffer: f, cs1: p, cs2: y }
          }
          readMessageA(s, u) {
            return (
              t.isValidPublicKey(u.ne) && (s.re = u.ne),
              this.mixHash(s.ss, s.re),
              this.decryptAndHash(s.ss, u.ciphertext)
            )
          }
          readMessageB(s, u) {
            if ((t.isValidPublicKey(u.ne) && (s.re = u.ne), this.mixHash(s.ss, s.re), !s.e))
              throw new Error('Handshake state `e` param is missing.')
            this.mixKey(s.ss, this.dh(s.e.privateKey, s.re))
            let { plaintext: o, valid: l } = this.decryptAndHash(s.ss, u.ns)
            l && o.length === 32 && t.isValidPublicKey(o) && (s.rs = o),
              this.mixKey(s.ss, this.dh(s.e.privateKey, s.rs))
            let { plaintext: a, valid: c } = this.decryptAndHash(s.ss, u.ciphertext)
            return { plaintext: a, valid: l && c }
          }
          readMessageC(s, u) {
            let { plaintext: o, valid: l } = this.decryptAndHash(s.ss, u.ns)
            if ((l && o.length === 32 && t.isValidPublicKey(o) && (s.rs = o), !s.e))
              throw new Error('Handshake state `e` param is missing.')
            this.mixKey(s.ss, this.dh(s.e.privateKey, s.rs))
            let { plaintext: a, valid: c } = this.decryptAndHash(s.ss, u.ciphertext),
              { cs1: f, cs2: p } = this.split(s.ss)
            return { h: s.ss.h, plaintext: a, valid: l && c, cs1: f, cs2: p }
          }
          initSession(s, u, o) {
            let l = this.createEmptyKey(),
              a = r.Buffer.alloc(32),
              c
            return (
              s ? (c = this.initializeInitiator(u, o, a, l)) : (c = this.initializeResponder(u, o, a, l)),
              { hs: c, i: s, mc: 0 }
            )
          }
          sendMessage(s, u, o) {
            let l
            if (s.mc === 0) l = this.writeMessageA(s.hs, u, o)
            else if (s.mc === 1) l = this.writeMessageB(s.hs, u)
            else if (s.mc === 2) {
              let { h: a, messageBuffer: c, cs1: f, cs2: p } = this.writeMessageC(s.hs, u)
              ;(l = c), (s.h = a), (s.cs1 = f), (s.cs2 = p)
            } else if (s.mc > 2)
              if (s.i) {
                if (!s.cs1) throw new Error('CS1 (cipher state) is not defined')
                l = this.writeMessageRegular(s.cs1, u)
              } else {
                if (!s.cs2) throw new Error('CS2 (cipher state) is not defined')
                l = this.writeMessageRegular(s.cs2, u)
              }
            else throw new Error('Session invalid.')
            return s.mc++, l
          }
          recvMessage(s, u) {
            let o = r.Buffer.alloc(0),
              l = !1
            if (s.mc === 0) ({ plaintext: o, valid: l } = this.readMessageA(s.hs, u))
            else if (s.mc === 1) ({ plaintext: o, valid: l } = this.readMessageB(s.hs, u))
            else if (s.mc === 2) {
              let { h: a, plaintext: c, valid: f, cs1: p, cs2: y } = this.readMessageC(s.hs, u)
              ;(o = c), (l = f), (s.h = a), (s.cs1 = p), (s.cs2 = y)
            }
            return s.mc++, { plaintext: o, valid: l }
          }
        }
      e.XX = i
    }
  }),
  hf = te({
    'node_modules/libp2p-noise/dist/src/encoder.js'(e) {
      V(),
        F(),
        Object.defineProperty(e, '__esModule', { value: !0 }),
        (e.decode2 =
          e.decode1 =
          e.decode0 =
          e.encode2 =
          e.encode1 =
          e.encode0 =
          e.uint16BEDecode =
          e.uint16BEEncode =
            void 0)
      var r = Nr(),
        t = (c, f, p) => ((f = f || r.Buffer.allocUnsafe(2)), f.writeUInt16BE(c, p), f)
      ;(e.uint16BEEncode = t), (e.uint16BEEncode.bytes = 2)
      var n = (c) => {
        if (c.length < 2) throw RangeError('Could not decode int16BE')
        return c.readUInt16BE(0)
      }
      ;(e.uint16BEDecode = n), (e.uint16BEDecode.bytes = 2)
      function i(c) {
        return r.Buffer.concat([c.ne, c.ciphertext])
      }
      e.encode0 = i
      function s(c) {
        return r.Buffer.concat([c.ne, c.ns, c.ciphertext])
      }
      e.encode1 = s
      function u(c) {
        return r.Buffer.concat([c.ns, c.ciphertext])
      }
      e.encode2 = u
      function o(c) {
        if (c.length < 32) throw new Error('Cannot decode stage 0 MessageBuffer: length less than 32 bytes.')
        return { ne: c.slice(0, 32), ciphertext: c.slice(32, c.length), ns: r.Buffer.alloc(0) }
      }
      e.decode0 = o
      function l(c) {
        if (c.length < 80) throw new Error('Cannot decode stage 1 MessageBuffer: length less than 80 bytes.')
        return { ne: c.slice(0, 32), ns: c.slice(32, 80), ciphertext: c.slice(80, c.length) }
      }
      e.decode1 = l
      function a(c) {
        if (c.length < 48) throw new Error('Cannot decode stage 2 MessageBuffer: length less than 48 bytes.')
        return { ne: r.Buffer.alloc(0), ns: c.slice(0, 48), ciphertext: c.slice(48, c.length) }
      }
      e.decode2 = a
    }
  }),
  pA = te({
    'node_modules/libp2p-noise/dist/src/handshake-xx.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.XXHandshake = void 0)
      var r = Nr(),
        t = mL(),
        n = Cs(),
        i = Qc(),
        s = hf(),
        u = class {
          constructor(o, l, a, c, f, p, y) {
            ;(this.isInitiator = o),
              (this.payload = l),
              (this.prologue = a),
              (this.staticKeypair = c),
              (this.connection = f),
              p && (this.remotePeer = p),
              (this.xx = y ?? new t.XX()),
              (this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair)),
              (this.remoteEarlyData = r.Buffer.alloc(0))
          }
          async propose() {
            if ((i.logLocalStaticKeys(this.session.hs.s), this.isInitiator)) {
              i.logger('Stage 0 - Initiator starting to send first message.')
              let o = this.xx.sendMessage(this.session, r.Buffer.alloc(0))
              this.connection.writeLP(s.encode0(o)),
                i.logger('Stage 0 - Initiator finished sending first message.'),
                i.logLocalEphemeralKeys(this.session.hs.e)
            } else {
              i.logger('Stage 0 - Responder waiting to receive first message...')
              let o = s.decode0((await this.connection.readLP()).slice()),
                { valid: l } = this.xx.recvMessage(this.session, o)
              if (!l) throw new Error('xx handshake stage 0 validation fail')
              i.logger('Stage 0 - Responder received first message.'), i.logRemoteEphemeralKey(this.session.hs.re)
            }
          }
          async exchange() {
            if (this.isInitiator) {
              i.logger('Stage 1 - Initiator waiting to receive first message from responder...')
              let o = s.decode1((await this.connection.readLP()).slice()),
                { plaintext: l, valid: a } = this.xx.recvMessage(this.session, o)
              if (!a) throw new Error('xx handshake stage 1 validation fail')
              i.logger('Stage 1 - Initiator received the message.'),
                i.logRemoteEphemeralKey(this.session.hs.re),
                i.logRemoteStaticKey(this.session.hs.rs),
                i.logger("Initiator going to check remote's signature...")
              try {
                let c = await n.decodePayload(l)
                ;(this.remotePeer = this.remotePeer || (await n.getPeerIdFromPayload(c))),
                  (this.remotePeer = await n.verifySignedPayload(o.ns, c, this.remotePeer)),
                  this.setRemoteEarlyData(c.data)
              } catch (c) {
                let f = c
                throw new Error(`Error occurred while verifying signed payload: ${f.message}`)
              }
              i.logger('All good with the signature!')
            } else {
              i.logger('Stage 1 - Responder sending out first message with signed payload and static key.')
              let o = this.xx.sendMessage(this.session, this.payload)
              this.connection.writeLP(s.encode1(o)),
                i.logger('Stage 1 - Responder sent the second handshake message with signed payload.'),
                i.logLocalEphemeralKeys(this.session.hs.e)
            }
          }
          async finish() {
            if (this.isInitiator) {
              i.logger('Stage 2 - Initiator sending third handshake message.')
              let o = this.xx.sendMessage(this.session, this.payload)
              this.connection.writeLP(s.encode2(o)), i.logger('Stage 2 - Initiator sent message with signed payload.')
            } else {
              i.logger('Stage 2 - Responder waiting for third handshake message...')
              let o = s.decode2((await this.connection.readLP()).slice()),
                { plaintext: l, valid: a } = this.xx.recvMessage(this.session, o)
              if (!a) throw new Error('xx handshake stage 2 validation fail')
              i.logger('Stage 2 - Responder received the message, finished handshake.')
              try {
                let c = await n.decodePayload(l)
                ;(this.remotePeer = this.remotePeer || (await n.getPeerIdFromPayload(c))),
                  await n.verifySignedPayload(this.session.hs.rs, c, this.remotePeer),
                  this.setRemoteEarlyData(c.data)
              } catch (c) {
                let f = c
                throw new Error(`Error occurred while verifying signed payload: ${f.message}`)
              }
            }
            i.logCipherState(this.session)
          }
          encrypt(o, l) {
            let a = this.getCS(l)
            return this.xx.encryptWithAd(a, r.Buffer.alloc(0), o)
          }
          decrypt(o, l) {
            let a = this.getCS(l, !1)
            return this.xx.decryptWithAd(a, r.Buffer.alloc(0), o)
          }
          getRemoteStaticKey() {
            return this.session.hs.rs
          }
          getCS(o, l = !0) {
            if (!o.cs1 || !o.cs2) throw new Error('Handshake not completed properly, cipher state does not exist.')
            return this.isInitiator ? (l ? o.cs1 : o.cs2) : l ? o.cs2 : o.cs1
          }
          setRemoteEarlyData(o) {
            o && (this.remoteEarlyData = r.Buffer.from(o.buffer, o.byteOffset, o.length))
          }
        }
      e.XXHandshake = u
    }
  }),
  bL = te({
    'node_modules/libp2p-noise/dist/src/handshakes/ik.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.IK = void 0)
      var r = Nr(),
        t = Cs(),
        n = hA(),
        i = class extends n.AbstractHandshake {
          initSession(s, u, o, l) {
            let a = this.createEmptyKey(),
              c
            return (
              s ? (c = this.initializeInitiator(u, o, l, a)) : (c = this.initializeResponder(u, o, l, a)),
              { hs: c, i: s, mc: 0 }
            )
          }
          sendMessage(s, u) {
            let o
            if (s.mc === 0) o = this.writeMessageA(s.hs, u)
            else if (s.mc === 1) {
              let { messageBuffer: l, h: a, cs1: c, cs2: f } = this.writeMessageB(s.hs, u)
              ;(o = l), (s.h = a), (s.cs1 = c), (s.cs2 = f)
            } else if (s.mc > 1)
              if (s.i) {
                if (!s.cs1) throw new Error('CS1 (cipher state) is not defined')
                o = this.writeMessageRegular(s.cs1, u)
              } else {
                if (!s.cs2) throw new Error('CS2 (cipher state) is not defined')
                o = this.writeMessageRegular(s.cs2, u)
              }
            else throw new Error('Session invalid.')
            return s.mc++, o
          }
          recvMessage(s, u) {
            let o = r.Buffer.alloc(0),
              l = !1
            if ((s.mc === 0 && ({ plaintext: o, valid: l } = this.readMessageA(s.hs, u)), s.mc === 1)) {
              let { plaintext: a, valid: c, h: f, cs1: p, cs2: y } = this.readMessageB(s.hs, u)
              ;(o = a), (l = c), (s.h = f), (s.cs1 = p), (s.cs2 = y)
            }
            return s.mc++, { plaintext: o, valid: l }
          }
          writeMessageA(s, u) {
            s.e = t.generateKeypair()
            let o = s.e.publicKey
            this.mixHash(s.ss, o), this.mixKey(s.ss, this.dh(s.e.privateKey, s.rs))
            let l = r.Buffer.from(s.s.publicKey),
              a = this.encryptAndHash(s.ss, l)
            this.mixKey(s.ss, this.dh(s.s.privateKey, s.rs))
            let c = this.encryptAndHash(s.ss, u)
            return { ne: o, ns: a, ciphertext: c }
          }
          writeMessageB(s, u) {
            s.e = t.generateKeypair()
            let o = s.e.publicKey
            this.mixHash(s.ss, o),
              this.mixKey(s.ss, this.dh(s.e.privateKey, s.re)),
              this.mixKey(s.ss, this.dh(s.e.privateKey, s.rs))
            let l = this.encryptAndHash(s.ss, u),
              a = this.createEmptyKey(),
              c = { ne: o, ns: a, ciphertext: l },
              { cs1: f, cs2: p } = this.split(s.ss)
            return { messageBuffer: c, cs1: f, cs2: p, h: s.ss.h }
          }
          readMessageA(s, u) {
            t.isValidPublicKey(u.ne) && (s.re = u.ne),
              this.mixHash(s.ss, s.re),
              this.mixKey(s.ss, this.dh(s.s.privateKey, s.re))
            let { plaintext: o, valid: l } = this.decryptAndHash(s.ss, u.ns)
            l && o.length === 32 && t.isValidPublicKey(o) && (s.rs = o),
              this.mixKey(s.ss, this.dh(s.s.privateKey, s.rs))
            let { plaintext: a, valid: c } = this.decryptAndHash(s.ss, u.ciphertext)
            return { plaintext: a, valid: l && c }
          }
          readMessageB(s, u) {
            if ((t.isValidPublicKey(u.ne) && (s.re = u.ne), this.mixHash(s.ss, s.re), !s.e))
              throw new Error('Handshake state should contain ephemeral key by now.')
            this.mixKey(s.ss, this.dh(s.e.privateKey, s.re)), this.mixKey(s.ss, this.dh(s.s.privateKey, s.re))
            let { plaintext: o, valid: l } = this.decryptAndHash(s.ss, u.ciphertext),
              { cs1: a, cs2: c } = this.split(s.ss)
            return { h: s.ss.h, valid: l, plaintext: o, cs1: a, cs2: c }
          }
          initializeInitiator(s, u, o, l) {
            let a = 'Noise_IK_25519_ChaChaPoly_SHA256',
              c = this.initializeSymmetric(a)
            this.mixHash(c, s), this.mixHash(c, o)
            let f = r.Buffer.alloc(32)
            return { ss: c, s: u, rs: o, re: f, psk: l }
          }
          initializeResponder(s, u, o, l) {
            let a = 'Noise_IK_25519_ChaChaPoly_SHA256',
              c = this.initializeSymmetric(a)
            this.mixHash(c, s), this.mixHash(c, u.publicKey)
            let f = r.Buffer.alloc(32)
            return { ss: c, s: u, rs: o, re: f, psk: l }
          }
        }
      e.IK = i
    }
  }),
  yL = te({
    'node_modules/libp2p-noise/dist/src/errors.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.FailedIKError = void 0)
      var r = class extends Error {
        constructor(t, n) {
          super(n)
          ;(this.initialMsg = t), (this.name = 'FailedIKhandshake')
        }
      }
      e.FailedIKError = r
    }
  }),
  vL = te({
    'node_modules/libp2p-noise/dist/src/handshake-ik.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.IKHandshake = void 0)
      var r = bL(),
        t = Nr(),
        n = hf(),
        i = Cs(),
        s = yL(),
        u = Qc(),
        o = class {
          constructor(l, a, c, f, p, y, d, h) {
            ;(this.isInitiator = l),
              (this.payload = t.Buffer.from(a)),
              (this.prologue = c),
              (this.staticKeypair = f),
              (this.connection = p),
              d && (this.remotePeer = d),
              (this.ik = h ?? new r.IK()),
              (this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, y)),
              (this.remoteEarlyData = t.Buffer.alloc(0))
          }
          async stage0() {
            if ((u.logLocalStaticKeys(this.session.hs.s), u.logRemoteStaticKey(this.session.hs.rs), this.isInitiator)) {
              u.logger('IK Stage 0 - Initiator sending message...')
              let l = this.ik.sendMessage(this.session, this.payload)
              this.connection.writeLP(n.encode1(l)),
                u.logger('IK Stage 0 - Initiator sent message.'),
                u.logLocalEphemeralKeys(this.session.hs.e)
            } else {
              u.logger('IK Stage 0 - Responder receiving message...')
              let l = await this.connection.readLP()
              try {
                let a = n.decode1(l.slice()),
                  { plaintext: c, valid: f } = this.ik.recvMessage(this.session, a)
                if (!f) throw new Error('ik handshake stage 0 decryption validation fail')
                u.logger('IK Stage 0 - Responder got message, going to verify payload.')
                let p = await i.decodePayload(c)
                ;(this.remotePeer = this.remotePeer || (await i.getPeerIdFromPayload(p))),
                  await i.verifySignedPayload(this.session.hs.rs, p, this.remotePeer),
                  this.setRemoteEarlyData(p.data),
                  u.logger('IK Stage 0 - Responder successfully verified payload!'),
                  u.logRemoteEphemeralKey(this.session.hs.re)
              } catch (a) {
                let c = a
                throw (
                  (u.logger('Responder breaking up with IK handshake in stage 0.'),
                  new s.FailedIKError(l, `Error occurred while verifying initiator's signed payload: ${c.message}`))
                )
              }
            }
          }
          async stage1() {
            if (this.isInitiator) {
              u.logger('IK Stage 1 - Initiator receiving message...')
              let l = (await this.connection.readLP()).slice(),
                a = n.decode0(t.Buffer.from(l)),
                { plaintext: c, valid: f } = this.ik.recvMessage(this.session, a)
              u.logger('IK Stage 1 - Initiator got message, going to verify payload.')
              try {
                if (!f) throw new Error('ik stage 1 decryption validation fail')
                let p = await i.decodePayload(c)
                ;(this.remotePeer = this.remotePeer || (await i.getPeerIdFromPayload(p))),
                  await i.verifySignedPayload(a.ns.slice(0, 32), p, this.remotePeer),
                  this.setRemoteEarlyData(p.data),
                  u.logger('IK Stage 1 - Initiator successfully verified payload!'),
                  u.logRemoteEphemeralKey(this.session.hs.re)
              } catch (p) {
                let y = p
                throw (
                  (u.logger('Initiator breaking up with IK handshake in stage 1.'),
                  new s.FailedIKError(l, `Error occurred while verifying responder's signed payload: ${y.message}`))
                )
              }
            } else {
              u.logger('IK Stage 1 - Responder sending message...')
              let l = this.ik.sendMessage(this.session, this.payload)
              this.connection.writeLP(n.encode0(l)),
                u.logger('IK Stage 1 - Responder sent message...'),
                u.logLocalEphemeralKeys(this.session.hs.e)
            }
            u.logCipherState(this.session)
          }
          decrypt(l, a) {
            let c = this.getCS(a, !1)
            return this.ik.decryptWithAd(c, t.Buffer.alloc(0), l)
          }
          encrypt(l, a) {
            let c = this.getCS(a)
            return this.ik.encryptWithAd(c, t.Buffer.alloc(0), l)
          }
          getLocalEphemeralKeys() {
            if (!this.session.hs.e) throw new Error('Ephemeral keys do not exist.')
            return this.session.hs.e
          }
          getCS(l, a = !0) {
            if (!l.cs1 || !l.cs2) throw new Error('Handshake not completed properly, cipher state does not exist.')
            return this.isInitiator ? (a ? l.cs1 : l.cs2) : a ? l.cs2 : l.cs1
          }
          setRemoteEarlyData(l) {
            l && (this.remoteEarlyData = t.Buffer.from(l.buffer, l.byteOffset, l.length))
          }
        }
      e.IKHandshake = o
    }
  }),
  gL = te({
    'node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.XXFallbackHandshake = void 0)
      var r = Nr(),
        t = pA(),
        n = Cs(),
        i = Qc(),
        s = hf(),
        u = class extends t.XXHandshake {
          constructor(o, l, a, c, f, p, y, d, h) {
            super(o, l, a, c, f, y, h)
            d && (this.ephemeralKeys = d), (this.initialMsg = p)
          }
          async propose() {
            if (this.isInitiator)
              this.xx.sendMessage(this.session, r.Buffer.alloc(0), this.ephemeralKeys),
                i.logger('XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.'),
                i.logLocalEphemeralKeys(this.session.hs.e)
            else {
              i.logger('XX Fallback Stage 0 - Responder decoding initial msg from IK.')
              let o = s.decode0(this.initialMsg),
                { valid: l } = this.xx.recvMessage(this.session, {
                  ne: o.ne,
                  ns: r.Buffer.alloc(0),
                  ciphertext: r.Buffer.alloc(0)
                })
              if (!l) throw new Error('xx fallback stage 0 decryption validation fail')
              i.logger('XX Fallback Stage 0 - Responder used received message from IK.'),
                i.logRemoteEphemeralKey(this.session.hs.re)
            }
          }
          async exchange() {
            if (this.isInitiator) {
              let o = s.decode1(this.initialMsg),
                { plaintext: l, valid: a } = this.xx.recvMessage(this.session, o)
              if (!a) throw new Error('xx fallback stage 1 decryption validation fail')
              i.logger('XX Fallback Stage 1 - Initiator used received message from IK.'),
                i.logRemoteEphemeralKey(this.session.hs.re),
                i.logRemoteStaticKey(this.session.hs.rs),
                i.logger("Initiator going to check remote's signature...")
              try {
                let c = await n.decodePayload(l)
                ;(this.remotePeer = this.remotePeer || (await n.getPeerIdFromPayload(c))),
                  await n.verifySignedPayload(this.session.hs.rs, c, this.remotePeer),
                  this.setRemoteEarlyData(c.data)
              } catch (c) {
                let f = c
                throw new Error(`Error occurred while verifying signed payload from responder: ${f.message}`)
              }
              i.logger('All good with the signature!')
            } else
              i.logger('XX Fallback Stage 1 - Responder start'),
                await super.exchange(),
                i.logger('XX Fallback Stage 1 - Responder end')
          }
        }
      e.XXFallbackHandshake = u
    }
  }),
  wL = te({
    'node_modules/libp2p-noise/dist/src/crypto.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.decryptStream = e.encryptStream = void 0)
      var r = Nr(),
        t = $1()
      function n(s) {
        return async function* (u) {
          for await (let o of u) {
            let l = r.Buffer.from(o.buffer, o.byteOffset, o.length)
            for (let a = 0; a < l.length; a += t.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
              let c = a + t.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG
              c > l.length && (c = l.length), yield s.encrypt(l.slice(a, c), s.session)
            }
          }
        }
      }
      e.encryptStream = n
      function i(s) {
        return async function* (u) {
          for await (let o of u) {
            let l = r.Buffer.from(o.buffer, o.byteOffset, o.length)
            for (let a = 0; a < l.length; a += t.NOISE_MSG_MAX_LENGTH_BYTES) {
              let c = a + t.NOISE_MSG_MAX_LENGTH_BYTES
              c > l.length && (c = l.length)
              let f = l.slice(a, c),
                { plaintext: p, valid: y } = await s.decrypt(f, s.session)
              if (!y) throw new Error('Failed to validate decrypted chunk')
              yield p
            }
          }
        }
      }
      e.decryptStream = i
    }
  }),
  _L = te({
    'node_modules/libp2p-noise/dist/src/keycache.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.KeyCache = void 0)
      var r = class {
          constructor() {
            this.storage = new Map()
          }
          store(n, i) {
            this.storage.set(n.id, i)
          }
          load(n) {
            var i
            return n && (i = this.storage.get(n.id)) !== null && i !== void 0 ? i : null
          }
          resetStorage() {
            this.storage.clear()
          }
        },
        t = new r()
      e.KeyCache = t
    }
  }),
  mA = te({
    'node_modules/libp2p-noise/dist/src/noise.js'(e) {
      V(), F()
      var r =
        (e && e.__importDefault) ||
        function (T) {
          return T && T.__esModule ? T : { default: T }
        }
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.Noise = void 0)
      var t = r(F1()),
        n = Nr(),
        i = r($D()),
        s = r(WD()),
        u = r(V1()),
        o = r(wn()),
        l = rL(),
        a = pA(),
        c = vL(),
        f = gL(),
        p = Cs(),
        y = hf(),
        d = wL(),
        h = _L(),
        m = Qc(),
        _ = $1(),
        A = class {
          constructor(T, E) {
            if (
              ((this.protocol = '/noise'),
              (this.prologue = n.Buffer.alloc(0)),
              (this.earlyData = E ?? n.Buffer.alloc(0)),
              (this.useNoisePipes = !1),
              T)
            ) {
              let k = t.default.publicKeyCreate(T)
              this.staticKeys = { privateKey: T, publicKey: k }
            } else this.staticKeys = p.generateKeypair()
          }
          async secureOutbound(T, E, k) {
            let w = i.default(E, {
                lengthEncoder: y.uint16BEEncode,
                lengthDecoder: y.uint16BEDecode,
                maxDataLength: _.NOISE_MSG_MAX_LENGTH_BYTES
              }),
              v = await this.performHandshake({ connection: w, isInitiator: !0, localPeer: T, remotePeer: k })
            return {
              conn: await this.createSecureConnection(w, v),
              remoteEarlyData: v.remoteEarlyData,
              remotePeer: v.remotePeer
            }
          }
          async secureInbound(T, E, k) {
            let w = i.default(E, {
                lengthEncoder: y.uint16BEEncode,
                lengthDecoder: y.uint16BEDecode,
                maxDataLength: _.NOISE_MSG_MAX_LENGTH_BYTES
              }),
              v = await this.performHandshake({ connection: w, isInitiator: !1, localPeer: T, remotePeer: k })
            return {
              conn: await this.createSecureConnection(w, v),
              remoteEarlyData: v.remoteEarlyData,
              remotePeer: v.remotePeer
            }
          }
          async performHandshake(T) {
            var E
            let k = await p.getPayload(T.localPeer, this.staticKeys.publicKey, this.earlyData),
              w = this.useNoisePipes
            if ((T.isInitiator && h.KeyCache.load(T.remotePeer) === null && (w = !1), w)) {
              let { remotePeer: v, connection: I, isInitiator: M } = T,
                q = new c.IKHandshake(
                  M,
                  k,
                  this.prologue,
                  this.staticKeys,
                  I,
                  (E = h.KeyCache.load(T.remotePeer)) !== null && E !== void 0 ? E : n.Buffer.alloc(32),
                  v
                )
              try {
                return await this.performIKHandshake(q)
              } catch (G) {
                let O
                return (
                  T.isInitiator && (O = q.getLocalEphemeralKeys()),
                  await this.performXXFallbackHandshake(T, k, G.initialMsg, O)
                )
              }
            } else return await this.performXXHandshake(T, k)
          }
          async performXXFallbackHandshake(T, E, k, w) {
            let { isInitiator: v, remotePeer: I, connection: M } = T,
              q = new f.XXFallbackHandshake(v, E, this.prologue, this.staticKeys, M, k, I, w)
            try {
              await q.propose(), await q.exchange(), await q.finish()
            } catch (G) {
              m.logger(G)
              let O = G
              throw new Error(`Error occurred during XX Fallback handshake: ${O.message}`)
            }
            return q
          }
          async performXXHandshake(T, E) {
            let { isInitiator: k, remotePeer: w, connection: v } = T,
              I = new a.XXHandshake(k, E, this.prologue, this.staticKeys, v, w)
            try {
              await I.propose(),
                await I.exchange(),
                await I.finish(),
                this.useNoisePipes && I.remotePeer && h.KeyCache.store(I.remotePeer, I.getRemoteStaticKey())
            } catch (M) {
              let q = M
              throw new Error(`Error occurred during XX handshake: ${q.message}`)
            }
            return I
          }
          async performIKHandshake(T) {
            return await T.stage0(), await T.stage1(), T
          }
          async createSecureConnection(T, E) {
            let [k, w] = s.default(),
              v = T.unwrap()
            return (
              await o.default(
                k,
                u.default,
                d.encryptStream(E),
                l.encode({ lengthEncoder: y.uint16BEEncode }),
                v,
                l.decode({ lengthDecoder: y.uint16BEDecode }),
                u.default,
                d.decryptStream(E),
                k
              ),
              w
            )
          }
        }
      e.Noise = A
    }
  }),
  EL = te({
    'node_modules/libp2p-noise/dist/src/index.js'(e) {
      V(), F()
      var r =
          (e && e.__createBinding) ||
          (Object.create
            ? function (i, s, u, o) {
                o === void 0 && (o = u),
                  Object.defineProperty(i, o, {
                    enumerable: !0,
                    get: function () {
                      return s[u]
                    }
                  })
              }
            : function (i, s, u, o) {
                o === void 0 && (o = u), (i[o] = s[u])
              }),
        t =
          (e && e.__exportStar) ||
          function (i, s) {
            for (var u in i) u !== 'default' && !Object.prototype.hasOwnProperty.call(s, u) && r(s, i, u)
          }
      Object.defineProperty(e, '__esModule', { value: !0 }), (e.NOISE = void 0)
      var n = mA()
      t(mA(), e), (e.NOISE = new n.Noise())
    }
  }),
  SL = te({
    'node_modules/libp2p-mplex/src/coder/encode.browser.js'(e, r) {
      V(), F()
      var t = $t(),
        n = ui(),
        i = 10 * 1024,
        s = class {
          constructor() {
            ;(this._pool = new Uint8Array(i)), (this._poolOffset = 0)
          }
          write(o) {
            let l = this._pool,
              a = this._poolOffset
            t.encode((o.id << 3) | o.type, l, a),
              (a += t.encode.bytes),
              t.encode(o.data ? o.data.length : 0, l, a),
              (a += t.encode.bytes)
            let c = l.subarray(this._poolOffset, a)
            return (
              i - a < 100 ? ((this._pool = new Uint8Array(i)), (this._poolOffset = 0)) : (this._poolOffset = a),
              o.data ? [c, o.data] : c
            )
          }
        },
        u = new s()
      r.exports = (o) =>
        (async function* () {
          for await (let a of o) Array.isArray(a) ? yield new n(a.map((c) => u.write(c))) : yield new n(u.write(a))
        })()
    }
  }),
  AL = te({
    'node_modules/libp2p-mplex/src/coder/decode.js'(e, r) {
      V(), F()
      var t = $t(),
        n = ui()
      r.exports = (s) =>
        (async function* () {
          let o = new i()
          for await (let l of s) {
            let a = o.write(l)
            a.length && (yield a)
          }
        })()
      var i = class {
        constructor() {
          ;(this._buffer = new n()),
            (this._bufferProxy = new Proxy(
              {},
              { get: (s, u) => (u[0] === 'l' ? this._buffer[u] : this._buffer.get(parseInt(u))) }
            )),
            (this._headerInfo = null)
        }
        write(s) {
          if (!s || !s.length) return []
          this._buffer.append(s)
          let u = []
          for (;;) {
            if (!this._headerInfo)
              try {
                this._headerInfo = this._decodeHeader(this._bufferProxy)
              } catch (p) {
                break
              }
            let { id: o, type: l, length: a, offset: c } = this._headerInfo
            if (this._buffer.length - c < a) break
            u.push({ id: o, type: l, data: this._buffer.shallowSlice(c, c + a) }),
              this._buffer.consume(c + a),
              (this._headerInfo = null)
          }
          return u
        }
        _decodeHeader(s) {
          let u = t.decode(s),
            o = t.decode.bytes,
            l = t.decode(s, o)
          return (o += t.decode.bytes), { id: u >> 3, type: u & 7, offset: o, length: l }
        }
      }
    }
  }),
  IL = te({
    'node_modules/libp2p-mplex/src/coder/index.js'(e) {
      V(), F(), (e.encode = SL()), (e.decode = AL())
    }
  }),
  bA = te({
    'node_modules/libp2p-mplex/src/restrict-size.js'(e, r) {
      V(), F()
      var t = 1 << 20
      ;(r.exports = (n) => {
        n = n || t
        let i = (s) => {
          if (s.data && s.data.length > n)
            throw Object.assign(new Error('message size too large!'), { code: 'ERR_MSG_TOO_BIG' })
        }
        return (s) =>
          (async function* () {
            for await (let o of s) Array.isArray(o) ? o.forEach(i) : i(o), yield o
          })()
      }),
        (r.exports.MAX_MSG_SIZE = t)
    }
  }),
  yA = te({
    'node_modules/libp2p-mplex/src/message-types.js'(e) {
      V(), F()
      var r = Object.freeze({
        NEW_STREAM: 0,
        MESSAGE_RECEIVER: 1,
        MESSAGE_INITIATOR: 2,
        CLOSE_RECEIVER: 3,
        CLOSE_INITIATOR: 4,
        RESET_RECEIVER: 5,
        RESET_INITIATOR: 6
      })
      ;(e.MessageTypes = r),
        (e.InitiatorMessageTypes = Object.freeze({
          NEW_STREAM: r.NEW_STREAM,
          MESSAGE: r.MESSAGE_INITIATOR,
          CLOSE: r.CLOSE_INITIATOR,
          RESET: r.RESET_INITIATOR
        })),
        (e.ReceiverMessageTypes = Object.freeze({
          MESSAGE: r.MESSAGE_RECEIVER,
          CLOSE: r.CLOSE_RECEIVER,
          RESET: r.RESET_RECEIVER
        })),
        (e.MessageTypeNames = Object.freeze(Object.entries(r).reduce((t, n) => ((t[n[1]] = n[0]), t), {})))
    }
  }),
  pf = te({
    'node_modules/abort-controller/browser.js'(e, r) {
      V(), F()
      var { AbortController: t, AbortSignal: n } =
        typeof self != 'undefined' ? self : typeof window != 'undefined' ? window : void 0
      ;(r.exports = t), (r.exports.AbortSignal = n), (r.exports.default = t)
    }
  }),
  TL = te({
    'node_modules/libp2p-mplex/src/stream.js'(e, r) {
      V(), F()
      var t = Ui(),
        n = pf(),
        i = mt()('libp2p:mplex:stream'),
        s = df(),
        u = ui(),
        o = pt(),
        { MAX_MSG_SIZE: l } = bA(),
        { InitiatorMessageTypes: a, ReceiverMessageTypes: c } = yA(),
        f = 'ERR_MPLEX_STREAM_RESET',
        p = 'ERR_MPLEX_STREAM_ABORT'
      r.exports = ({ id: y, name: d, send: h, onEnd: m = () => {}, type: _ = 'initiator', maxMsgSize: A = l }) => {
        let T = new n(),
          E = new n(),
          k = _ === 'initiator' ? a : c,
          w = _ === 'initiator' ? `i${y}` : `r${y}`
        d = String(d ?? y)
        let v = !1,
          I = !1,
          M,
          q = (x) => {
            v ||
              ((v = !0),
              i('%s stream %s source end', _, d, x),
              x && !M && (M = x),
              I && ((O.timeline.close = Date.now()), m(M)))
          },
          G = (x) => {
            I ||
              ((I = !0),
              i('%s stream %s sink end', _, d, x),
              x && !M && (M = x),
              v && ((O.timeline.close = Date.now()), m(M)))
          },
          O = {
            close: () => O.source.end(),
            abort: (x) => {
              i('%s stream %s abort', _, d, x), O.source.end(x), T.abort(), G(x)
            },
            reset: () => {
              let x = o(new Error('stream reset'), f)
              E.abort(), O.source.end(x), G(x)
            },
            sink: async (x) => {
              ;(x = t(x, [
                { signal: T.signal, options: { abortMessage: 'stream aborted', abortCode: p } },
                { signal: E.signal, options: { abortMessage: 'stream reset', abortCode: f } }
              ])),
                _ === 'initiator' && h({ id: y, type: k.NEW_STREAM, data: d })
              try {
                for await (let L of x)
                  for (; L.length; ) {
                    if (L.length <= A) {
                      h({ id: y, type: k.MESSAGE, data: L })
                      break
                    }
                    ;(L = u.isBufferList(L) ? L : new u(L)),
                      h({ id: y, type: k.MESSAGE, data: L.shallowSlice(0, A) }),
                      L.consume(A)
                  }
              } catch (L) {
                return (
                  L.code === f
                    ? i('%s stream %s reset', _, d)
                    : (i('%s stream %s error', _, d, L), h({ id: y, type: k.RESET })),
                  O.source.end(L),
                  G(L)
                )
              }
              h({ id: y, type: k.CLOSE }), G()
            },
            source: s(q),
            timeline: { open: Date.now(), close: null },
            id: w
          }
        return O
      }
    }
  }),
  CL = te({
    'node_modules/libp2p-mplex/src/mplex.js'(e, r) {
      V(), F()
      var t = wn(),
        n = df(),
        i = mt()('libp2p:mplex'),
        s = Ui(),
        u = IL(),
        o = bA(),
        { MessageTypes: l, MessageTypeNames: a } = yA(),
        c = TL(),
        f = class {
          constructor(p) {
            ;(p = p || {}),
              (p = typeof p == 'function' ? { onStream: p } : p),
              (this._streamId = 0),
              (this._streams = { initiators: new Map(), receivers: new Map() }),
              (this._options = p),
              (this.sink = this._createSink()),
              (this.source = this._createSource()),
              (this.onStream = p.onStream),
              (this.onStreamEnd = p.onStreamEnd)
          }
          get streams() {
            let p = []
            return (
              this._streams.initiators.forEach((y) => {
                p.push(y)
              }),
              this._streams.receivers.forEach((y) => {
                p.push(y)
              }),
              p
            )
          }
          newStream(p) {
            let y = this._streamId++
            p = p == null ? y.toString() : String(p)
            let d = this._streams.initiators
            return this._newStream({ id: y, name: p, type: 'initiator', registry: d })
          }
          _newReceiverStream({ id: p, name: y }) {
            let d = this._streams.receivers
            return this._newStream({ id: p, name: y, type: 'receiver', registry: d })
          }
          _newStream({ id: p, name: y, type: d, registry: h }) {
            if (h.has(p)) throw new Error(`${d} stream ${p} already exists!`)
            i('new %s stream %s %s', d, p, y)
            let A = c({
              id: p,
              name: y,
              send: (T) => (
                i.enabled &&
                  i('%s stream %s %s send', d, p, y, { ...T, type: a[T.type], data: T.data && T.data.slice() }),
                this.source.push(T)
              ),
              type: d,
              onEnd: () => {
                i('%s stream %s %s ended', d, p, y), h.delete(p), this.onStreamEnd && this.onStreamEnd(A)
              },
              maxMsgSize: this._options.maxMsgSize
            })
            return h.set(p, A), A
          }
          _createSink() {
            return async (p) => {
              this._options.signal && (p = s(p, this._options.signal))
              try {
                await t(p, u.decode, o(this._options.maxMsgSize), async (y) => {
                  for await (let d of y) for (let h of d) this._handleIncoming(h)
                })
              } catch (y) {
                return i('error in sink', y), this.source.end(y)
              }
              this.source.end()
            }
          }
          _createSource() {
            let y = n({
              onEnd: (d) => {
                let { initiators: h, receivers: m } = this._streams
                for (let _ of h.values()) _.abort(d)
                for (let _ of m.values()) _.abort(d)
              },
              writev: !0
            })
            return Object.assign(u.encode(y), { push: y.push, end: y.end, return: y.return })
          }
          _handleIncoming({ id: p, type: y, data: d }) {
            if (
              (i.enabled && i('incoming message', { id: p, type: a[y], data: d.slice() }),
              y === l.NEW_STREAM && this.onStream)
            ) {
              let _ = this._newReceiverStream({ id: p, name: d.toString() })
              return this.onStream(_)
            }
            let m = (y & 1 ? this._streams.initiators : this._streams.receivers).get(p)
            if (!m) return i('missing stream %s', p)
            switch (y) {
              case l.MESSAGE_INITIATOR:
              case l.MESSAGE_RECEIVER:
                m.source.push(d)
                break
              case l.CLOSE_INITIATOR:
              case l.CLOSE_RECEIVER:
                m.close()
                break
              case l.RESET_INITIATOR:
              case l.RESET_RECEIVER:
                m.reset()
                break
              default:
                i('unknown message type %s', y)
            }
          }
        }
      ;(f.multicodec = '/mplex/6.7.0'), (r.exports = f)
    }
  }),
  kL = te({
    'node_modules/libp2p-mplex/src/index.js'(e, r) {
      V(), F(), (r.exports = CL())
    }
  })
function ML(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var vA,
  gA,
  wA,
  xL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (vA = ML), (gA = vA), (wA = gA)
    }
  }),
  _A = {}
Re(_A, {
  coerce: () => ks,
  empty: () => G1,
  equals: () => W1,
  fromHex: () => SA,
  fromString: () => J1,
  isBinary: () => AA,
  toHex: () => EA,
  toString: () => X1
})
var G1,
  EA,
  SA,
  W1,
  ks,
  AA,
  J1,
  X1,
  Ms = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (G1 = new Uint8Array(0)),
        (EA = (e) => e.reduce((r, t) => r + t.toString(16).padStart(2, '0'), '')),
        (SA = (e) => {
          let r = e.match(/../g)
          return r ? new Uint8Array(r.map((t) => parseInt(t, 16))) : G1
        }),
        (W1 = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (ks = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (AA = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e)),
        (J1 = (e) => new TextEncoder().encode(e)),
        (X1 = (e) => new TextDecoder().decode(e))
    }
  }),
  IA,
  TA,
  Y1,
  CA,
  mf,
  Jo,
  kA,
  MA,
  mr,
  li = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        xL(),
        Ms(),
        (IA = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (TA = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new Y1(r)
          }
        }),
        (Y1 = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new Y1({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (CA = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new IA(e, r, t)),
              (this.decoder = new TA(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (mf = ({ name: e, prefix: r, encode: t, decode: n }) => new CA(e, r, t, n)),
        (Jo = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = wA(t, r)
          return mf({ prefix: e, name: r, encode: n, decode: (s) => ks(i(s)) })
        }),
        (kA = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (MA = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (mr = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          mf({
            prefix: r,
            name: e,
            encode(i) {
              return MA(i, n, t)
            },
            decode(i) {
              return kA(i, n, t, e)
            }
          }))
    }
  }),
  xA = {}
Re(xA, { identity: () => RA })
var RA,
  RL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), li(), Ms(), (RA = mf({ prefix: '\0', name: 'identity', encode: (e) => X1(e), decode: (e) => J1(e) }))
    }
  }),
  BA = {}
Re(BA, { base2: () => NA })
var NA,
  BL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), li(), (NA = mr({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  PA = {}
Re(PA, { base8: () => OA })
var OA,
  NL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), li(), (OA = mr({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  DA = {}
Re(DA, { base10: () => LA })
var LA,
  PL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), li(), (LA = Jo({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  UA = {}
Re(UA, { base16: () => qA, base16upper: () => jA })
var qA,
  jA,
  OL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        li(),
        (qA = mr({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (jA = mr({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  zA = {}
Re(zA, {
  base32: () => Xo,
  base32hex: () => HA,
  base32hexpad: () => GA,
  base32hexpadupper: () => WA,
  base32hexupper: () => $A,
  base32pad: () => FA,
  base32padupper: () => VA,
  base32upper: () => KA,
  base32z: () => JA
})
var Xo,
  KA,
  FA,
  VA,
  HA,
  $A,
  GA,
  WA,
  JA,
  XA = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        li(),
        (Xo = mr({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (KA = mr({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (FA = mr({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (VA = mr({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (HA = mr({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        ($A = mr({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (GA = mr({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (WA = mr({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (JA = mr({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  YA = {}
Re(YA, { base36: () => ZA, base36upper: () => QA })
var ZA,
  QA,
  DL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        li(),
        (ZA = Jo({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (QA = Jo({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  eI = {}
Re(eI, { base58btc: () => zn, base58flickr: () => tI })
var zn,
  tI,
  rI = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        li(),
        (zn = Jo({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (tI = Jo({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  nI = {}
Re(nI, { base64: () => iI, base64pad: () => sI, base64url: () => oI, base64urlpad: () => aI })
var iI,
  sI,
  oI,
  aI,
  LL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        li(),
        (iI = mr({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (sI = mr({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (oI = mr({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (aI = mr({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function cI(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= dI; ) (r[t++] = (e & 255) | Q1), (e /= 128)
  for (; e & fI; ) (r[t++] = (e & 255) | Q1), (e >>>= 7)
  return (r[t] = e | 0), (cI.bytes = t - n + 1), r
}
function Z1(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((Z1.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & e2) << n : (s & e2) * Math.pow(2, n)), (n += 7)
  } while (s >= pI)
  return (Z1.bytes = i - r), t
}
var uI,
  Q1,
  lI,
  fI,
  dI,
  hI,
  pI,
  e2,
  mI,
  bI,
  yI,
  vI,
  gI,
  wI,
  _I,
  EI,
  SI,
  AI,
  II,
  TI,
  eu,
  UL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        (uI = cI),
        (Q1 = 128),
        (lI = 127),
        (fI = ~lI),
        (dI = Math.pow(2, 31)),
        (hI = Z1),
        (pI = 128),
        (e2 = 127),
        (mI = Math.pow(2, 7)),
        (bI = Math.pow(2, 14)),
        (yI = Math.pow(2, 21)),
        (vI = Math.pow(2, 28)),
        (gI = Math.pow(2, 35)),
        (wI = Math.pow(2, 42)),
        (_I = Math.pow(2, 49)),
        (EI = Math.pow(2, 56)),
        (SI = Math.pow(2, 63)),
        (AI = function (e) {
          return e < mI
            ? 1
            : e < bI
            ? 2
            : e < yI
            ? 3
            : e < vI
            ? 4
            : e < gI
            ? 5
            : e < wI
            ? 6
            : e < _I
            ? 7
            : e < EI
            ? 8
            : e < SI
            ? 9
            : 10
        }),
        (II = { encode: uI, decode: hI, encodingLength: AI }),
        (TI = II),
        (eu = TI)
    }
  }),
  CI = {}
Re(CI, { decode: () => tu, encodeTo: () => Yo, encodingLength: () => Zo })
var tu,
  Yo,
  Zo,
  t2 = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        UL(),
        (tu = (e) => [eu.decode(e), eu.decode.bytes]),
        (Yo = (e, r, t = 0) => (eu.encode(e, r, t), r)),
        (Zo = (e) => eu.encodingLength(e))
    }
  }),
  kI = {}
Re(kI, { Digest: () => ru, create: () => bf, decode: () => r2, equals: () => n2 })
var bf,
  r2,
  n2,
  ru,
  i2 = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        Ms(),
        t2(),
        (bf = (e, r) => {
          let t = r.byteLength,
            n = Zo(e),
            i = n + Zo(t),
            s = new Uint8Array(i + t)
          return Yo(e, s, 0), Yo(t, s, n), s.set(r, i), new ru(e, t, r, s)
        }),
        (r2 = (e) => {
          let r = ks(e),
            [t, n] = tu(r),
            [i, s] = tu(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new ru(t, i, u, r)
        }),
        (n2 = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && W1(e.bytes, r.bytes))),
        (ru = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  MI = {}
Re(MI, { Hasher: () => s2, from: () => nu })
var nu,
  s2,
  o2 = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        i2(),
        (nu = ({ name: e, code: r, encode: t }) => new s2(e, r, t)),
        (s2 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return bf(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  xI = {}
Re(xI, { sha256: () => RI, sha512: () => BI })
var a2,
  RI,
  BI,
  qL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        o2(),
        (a2 = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (RI = nu({ name: 'sha2-256', code: 18, encode: a2('SHA-256') })),
        (BI = nu({ name: 'sha2-512', code: 19, encode: a2('SHA-512') }))
    }
  }),
  NI = {}
Re(NI, { identity: () => PI })
var PI,
  jL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), o2(), Ms(), (PI = nu({ name: 'identity', code: 0, encode: (e) => ks(e) }))
    }
  }),
  OI = {}
Re(OI, { code: () => LI, decode: () => qI, encode: () => UI, name: () => DI })
var c2,
  DI,
  LI,
  UI,
  qI,
  zL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(),
        F(),
        Ms(),
        (c2 = (e) => ks(e)),
        ({ name: DI, code: LI, encode: UI, decode: qI } = { name: 'raw', code: 85, decode: c2, encode: c2 })
    }
  }),
  jI = {}
Re(jI, { code: () => KI, decode: () => VI, encode: () => FI, name: () => zI })
var zI,
  KI,
  FI,
  VI,
  KL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(),
        F(),
        ({
          name: zI,
          code: KI,
          encode: FI,
          decode: VI
        } = {
          name: 'json',
          code: 512,
          encode: (e) => new TextEncoder().encode(JSON.stringify(e)),
          decode: (e) => JSON.parse(new TextDecoder().decode(e))
        })
    }
  }),
  Pr,
  HI,
  $I,
  GI,
  Qo,
  WI,
  u2,
  l2,
  iu,
  su,
  JI,
  XI,
  YI,
  FL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        t2(),
        i2(),
        rI(),
        XA(),
        Ms(),
        (Pr = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: su,
                byteLength: su,
                code: iu,
                version: iu,
                multihash: iu,
                bytes: iu,
                _baseCache: su,
                asCID: su
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== Qo) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== WI) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return Pr.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = bf(e, r)
                return Pr.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && n2(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return $I(r, n, e || zn.encoder)
              default:
                return GI(r, n, e || Xo.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return XI(/^0\.0/, YI), !!(e && (e[l2] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof Pr) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new Pr(r, t, n, i || u2(r, t, n.bytes))
            } else if (e != null && e[l2] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = r2(t)
              return Pr.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== Qo) throw new Error(`Version 0 CID must use dag-pb (code: ${Qo}) block encoding`)
                return new Pr(e, r, t, t.bytes)
              }
              case 1: {
                let n = u2(e, r, t.bytes)
                return new Pr(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return Pr.create(0, Qo, e)
          }
          static createV1(e, r) {
            return Pr.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = Pr.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = Pr.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = ks(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new ru(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? Pr.createV0(s) : Pr.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = tu(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = Qo
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = HI(e, r),
              i = Pr.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (HI = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || zn
              return [zn.prefix, t.decode(`${zn.prefix}${e}`)]
            }
            case zn.prefix: {
              let t = r || zn
              return [zn.prefix, t.decode(e)]
            }
            case Xo.prefix: {
              let t = r || Xo
              return [Xo.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        ($I = (e, r, t) => {
          let { prefix: n } = t
          if (n !== zn.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (GI = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (Qo = 112),
        (WI = 18),
        (u2 = (e, r, t) => {
          let n = Zo(e),
            i = n + Zo(r),
            s = new Uint8Array(i + t.byteLength)
          return Yo(e, s, 0), Yo(r, s, n), s.set(t, i), s
        }),
        (l2 = Symbol.for('@ipld/js-cid/CID')),
        (iu = { writable: !1, configurable: !1, enumerable: !0 }),
        (su = { writable: !1, enumerable: !1, configurable: !1 }),
        (JI = '0.0.0-dev'),
        (XI = (e, r) => {
          if (e.test(JI)) console.warn(r)
          else throw new Error(r)
        }),
        (YI = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  VL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), FL(), t2(), Ms(), o2(), i2()
    }
  }),
  ZI = {}
Re(ZI, {
  CID: () => Pr,
  bases: () => QI,
  bytes: () => _A,
  codecs: () => tT,
  digest: () => kI,
  hasher: () => MI,
  hashes: () => eT,
  varint: () => CI
})
var QI,
  eT,
  tT,
  HL = Ie({
    'node_modules/libp2p/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        RL(),
        BL(),
        NL(),
        PL(),
        OL(),
        XA(),
        DL(),
        rI(),
        LL(),
        qL(),
        jL(),
        zL(),
        KL(),
        VL(),
        (QI = { ...xA, ...BA, ...PA, ...DA, ...UA, ...zA, ...YA, ...eI, ...nI }),
        (eT = { ...xI, ...NI }),
        (tT = { raw: OI, json: jI })
    }
  }),
  rT = te({
    'node_modules/libp2p/node_modules/uint8arrays/util/bases.js'(e, r) {
      V(), F()
      var { bases: t } = (HL(), ZI)
      function n(o, l, a, c) {
        return { name: o, prefix: l, encoder: { name: o, prefix: l, encode: a }, decoder: { decode: c } }
      }
      var i = n(
          'utf8',
          'u',
          (o) => {
            let l = new TextDecoder('utf8')
            return 'u' + l.decode(o)
          },
          (o) => new TextEncoder().encode(o.substring(1))
        ),
        s = n(
          'ascii',
          'a',
          (o) => {
            let l = 'a'
            for (let a = 0; a < o.length; a++) l += String.fromCharCode(o[a])
            return l
          },
          (o) => {
            o = o.substring(1)
            let l = new Uint8Array(o.length)
            for (let a = 0; a < o.length; a++) l[a] = o.charCodeAt(a)
            return l
          }
        ),
        u = { utf8: i, 'utf-8': i, hex: t.base16, latin1: s, ascii: s, binary: s, ...t }
      r.exports = u
    }
  }),
  zi = te({
    'node_modules/libp2p/node_modules/uint8arrays/to-string.js'(e, r) {
      V(), F()
      var t = rT()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.encoder.encode(i).substring(1)
      }
      r.exports = n
    }
  }),
  $L = te({
    'node_modules/libp2p/node_modules/multiaddr/src/ip.js'(e, r) {
      V(), F()
      var t = yo(),
        n = zi(),
        i = t,
        s = t.v4,
        u = t.v6,
        o = function (a, c, f) {
          f = ~~f
          let p
          if (s(a))
            (p = c || new Uint8Array(f + 4)),
              a.split(/\./g).map(function (d) {
                p[f++] = parseInt(d, 10) & 255
              })
          else if (u(a)) {
            let d = a.split(':', 8),
              h
            for (h = 0; h < d.length; h++) {
              let m = s(d[h])
              var y
              m && ((y = o(d[h])), (d[h] = n(y.slice(0, 2), 'base16'))),
                y && ++h < 8 && d.splice(h, 0, n(y.slice(2, 4), 'base16'))
            }
            if (d[0] === '') for (; d.length < 8; ) d.unshift('0')
            else if (d[d.length - 1] === '') for (; d.length < 8; ) d.push('0')
            else if (d.length < 8) {
              for (h = 0; h < d.length && d[h] !== ''; h++);
              let m = [h, '1']
              for (h = 9 - d.length; h > 0; h--) m.push('0')
              d.splice.apply(d, m)
            }
            for (p = c || new Uint8Array(f + 16), h = 0; h < d.length; h++) {
              let m = parseInt(d[h], 16)
              ;(p[f++] = (m >> 8) & 255), (p[f++] = m & 255)
            }
          }
          if (!p) throw Error('Invalid ip address: ' + a)
          return p
        },
        l = function (a, c, f) {
          ;(c = ~~c), (f = f || a.length - c)
          let p = [],
            y,
            d = new DataView(a.buffer)
          if (f === 4) {
            for (let h = 0; h < f; h++) p.push(a[c + h])
            y = p.join('.')
          } else if (f === 16) {
            for (let h = 0; h < f; h += 2) p.push(d.getUint16(c + h).toString(16))
            ;(y = p.join(':')), (y = y.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')), (y = y.replace(/:{3,4}/, '::'))
          }
          return y
        }
      r.exports = { isIP: i, isV4: s, isV6: u, toBytes: o, toString: l }
    }
  }),
  yf = te({
    'node_modules/libp2p/node_modules/multiaddr/src/protocols-table.js'(e, r) {
      V(), F()
      function t(s) {
        if (typeof s == 'number') {
          if (t.codes[s]) return t.codes[s]
          throw new Error('no protocol with code: ' + s)
        } else if (typeof s == 'string') {
          if (t.names[s]) return t.names[s]
          throw new Error('no protocol with name: ' + s)
        }
        throw new Error('invalid protocol id type: ' + s)
      }
      var n = -1
      ;(t.lengthPrefixedVarSize = n),
        (t.V = n),
        (t.table = [
          [4, 32, 'ip4'],
          [6, 16, 'tcp'],
          [33, 16, 'dccp'],
          [41, 128, 'ip6'],
          [42, n, 'ip6zone'],
          [53, n, 'dns', 'resolvable'],
          [54, n, 'dns4', 'resolvable'],
          [55, n, 'dns6', 'resolvable'],
          [56, n, 'dnsaddr', 'resolvable'],
          [132, 16, 'sctp'],
          [273, 16, 'udp'],
          [275, 0, 'p2p-webrtc-star'],
          [276, 0, 'p2p-webrtc-direct'],
          [277, 0, 'p2p-stardust'],
          [290, 0, 'p2p-circuit'],
          [301, 0, 'udt'],
          [302, 0, 'utp'],
          [400, n, 'unix', !1, 'path'],
          [421, n, 'ipfs'],
          [421, n, 'p2p'],
          [443, 0, 'https'],
          [444, 96, 'onion'],
          [445, 296, 'onion3'],
          [446, n, 'garlic64'],
          [460, 0, 'quic'],
          [477, 0, 'ws'],
          [478, 0, 'wss'],
          [479, 0, 'p2p-websocket-star'],
          [480, 0, 'http'],
          [777, n, 'memory']
        ]),
        (t.names = {}),
        (t.codes = {}),
        t.table.map((s) => {
          let u = i.apply(null, s)
          return (t.codes[u.code] = u), (t.names[u.name] = u), null
        }),
        (t.object = i)
      function i(s, u, o, l, a) {
        return { code: s, size: u, name: o, resolvable: Boolean(l), path: Boolean(a) }
      }
      r.exports = t
    }
  }),
  xs = te({
    'node_modules/libp2p/node_modules/uint8arrays/from-string.js'(e, r) {
      V(), F()
      var t = rT()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.decoder.decode(`${u.prefix}${i}`)
      }
      r.exports = n
    }
  }),
  f2 = te({
    'node_modules/libp2p/node_modules/uint8arrays/concat.js'(e, r) {
      V(), F()
      function t(n, i) {
        i || (i = n.reduce((o, l) => o + l.length, 0))
        let s = new Uint8Array(i),
          u = 0
        for (let o of n) s.set(o, u), (u += o.length)
        return s
      }
      r.exports = t
    }
  }),
  GL = te({
    'node_modules/libp2p/node_modules/multiaddr/src/convert.js'(e, r) {
      V(), F()
      var t = $L(),
        n = yf(),
        i = Gr(),
        s = Di(),
        u = $t(),
        o = zi(),
        l = xs(),
        a = f2()
      r.exports = c
      function c(w, v) {
        return v instanceof Uint8Array ? c.toString(w, v) : c.toBytes(w, v)
      }
      ;(c.toString = function (v, I) {
        switch (n(v).code) {
          case 4:
          case 41:
            return p(I)
          case 6:
          case 273:
          case 33:
          case 132:
            return d(I).toString()
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return m(I)
          case 421:
            return A(I)
          case 444:
            return k(I)
          case 445:
            return k(I)
          default:
            return o(I, 'base16')
        }
      }),
        (c.toBytes = function (v, I) {
          switch (n(v).code) {
            case 4:
              return f(I)
            case 41:
              return f(I)
            case 6:
            case 273:
            case 33:
            case 132:
              return y(parseInt(I, 10))
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return h(I)
            case 421:
              return _(I)
            case 444:
              return T(I)
            case 445:
              return E(I)
            default:
              return l(I, 'base16')
          }
        })
      function f(w) {
        if (!t.isIP(w)) throw new Error('invalid ip address')
        return t.toBytes(w)
      }
      function p(w) {
        let v = t.toString(w)
        if (!v || !t.isIP(v)) throw new Error('invalid ip address')
        return v
      }
      function y(w) {
        let v = new ArrayBuffer(2)
        return new DataView(v).setUint16(0, w), new Uint8Array(v)
      }
      function d(w) {
        return new DataView(w.buffer).getUint16(w.byteOffset)
      }
      function h(w) {
        let v = l(w),
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function m(w) {
        let v = u.decode(w)
        if (((w = w.slice(u.decode.bytes)), w.length !== v)) throw new Error('inconsistent lengths')
        return o(w)
      }
      function _(w) {
        let v = new i(w).multihash,
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function A(w) {
        let v = u.decode(w),
          I = w.slice(u.decode.bytes)
        if (I.length !== v) throw new Error('inconsistent lengths')
        return o(I, 'base58btc')
      }
      function T(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 16) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function E(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 56) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion3 address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function k(w) {
        let v = w.slice(0, w.length - 2),
          I = w.slice(w.length - 2),
          M = o(v, 'base32'),
          q = d(I)
        return M + ':' + q
      }
    }
  }),
  WL = te({
    'node_modules/libp2p/node_modules/multiaddr/src/codec.js'(e, r) {
      V(), F()
      var t = GL(),
        n = yf(),
        i = $t(),
        s = f2(),
        u = zi()
      r.exports = {
        stringToStringTuples: o,
        stringTuplesToString: l,
        tuplesToStringTuples: c,
        stringTuplesToTuples: a,
        bytesToTuples: y,
        tuplesToBytes: f,
        bytesToString: d,
        stringToBytes: h,
        fromString: m,
        fromBytes: _,
        validateBytes: A,
        isValidBytes: T,
        cleanPath: E,
        ParseError: k,
        protoFromTuple: w,
        sizeForAddr: p
      }
      function o(v) {
        let I = [],
          M = v.split('/').slice(1)
        if (M.length === 1 && M[0] === '') return []
        for (let q = 0; q < M.length; q++) {
          let G = M[q],
            O = n(G)
          if (O.size === 0) {
            I.push([G])
            continue
          }
          if ((q++, q >= M.length)) throw k('invalid address: ' + v)
          if (O.path) {
            I.push([G, E(M.slice(q).join('/'))])
            break
          }
          I.push([G, M[q]])
        }
        return I
      }
      function l(v) {
        let I = []
        return (
          v.map((M) => {
            let q = w(M)
            return I.push(q.name), M.length > 1 && I.push(M[1]), null
          }),
          E(I.join('/'))
        )
      }
      function a(v) {
        return v.map((I) => {
          Array.isArray(I) || (I = [I])
          let M = w(I)
          return I.length > 1 ? [M.code, t.toBytes(M.code, I[1])] : [M.code]
        })
      }
      function c(v) {
        return v.map((I) => {
          let M = w(I)
          return I[1] ? [M.code, t.toString(M.code, I[1])] : [M.code]
        })
      }
      function f(v) {
        return _(
          s(
            v.map((I) => {
              let M = w(I),
                q = Uint8Array.from(i.encode(M.code))
              return I.length > 1 && (q = s([q, I[1]])), q
            })
          )
        )
      }
      function p(v, I) {
        return v.size > 0 ? v.size / 8 : v.size === 0 ? 0 : i.decode(I) + i.decode.bytes
      }
      function y(v) {
        let I = [],
          M = 0
        for (; M < v.length; ) {
          let q = i.decode(v, M),
            G = i.decode.bytes,
            O = n(q),
            x = p(O, v.slice(M + G))
          if (x === 0) {
            I.push([q]), (M += G)
            continue
          }
          let L = v.slice(M + G, M + G + x)
          if (((M += x + G), M > v.length)) throw k('Invalid address Uint8Array: ' + u(v, 'base16'))
          I.push([q, L])
        }
        return I
      }
      function d(v) {
        let I = y(v),
          M = c(I)
        return l(M)
      }
      function h(v) {
        v = E(v)
        let I = o(v),
          M = a(I)
        return f(M)
      }
      function m(v) {
        return h(v)
      }
      function _(v) {
        let I = A(v)
        if (I) throw I
        return Uint8Array.from(v)
      }
      function A(v) {
        try {
          y(v)
        } catch (I) {
          return I
        }
      }
      function T(v) {
        return A(v) === void 0
      }
      function E(v) {
        return (
          '/' +
          v
            .trim()
            .split('/')
            .filter((I) => I)
            .join('/')
        )
      }
      function k(v) {
        return new Error('Error parsing address: ' + v)
      }
      function w(v) {
        return n(v[0])
      }
    }
  }),
  vf = te({
    'node_modules/libp2p/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  }),
  Zr = te({
    'node_modules/libp2p/node_modules/multiaddr/src/index.js'(e, r) {
      V(), F()
      var t = WL(),
        n = yf(),
        i = $t(),
        s = Gr(),
        u = pt(),
        o = Symbol.for('nodejs.util.inspect.custom'),
        l = zi(),
        a = vf(),
        c = new Map(),
        f = Symbol.for('@multiformats/js-multiaddr/multiaddr'),
        p = class {
          constructor(d) {
            if ((d == null && (d = ''), Object.defineProperty(this, f, { value: !0 }), d instanceof Uint8Array))
              this.bytes = t.fromBytes(d)
            else if (typeof d == 'string') {
              if (d.length > 0 && d.charAt(0) !== '/') throw new Error(`multiaddr "${d}" must start with a "/"`)
              this.bytes = t.fromString(d)
            } else if (p.isMultiaddr(d)) this.bytes = t.fromBytes(d.bytes)
            else throw new Error('addr must be a string, Buffer, or another Multiaddr')
          }
          toString() {
            return t.bytesToString(this.bytes)
          }
          toJSON() {
            return this.toString()
          }
          toOptions() {
            let d = {},
              h = this.toString().split('/')
            return (
              (d.family = h[1] === 'ip4' ? 4 : 6), (d.host = h[2]), (d.transport = h[3]), (d.port = parseInt(h[4])), d
            )
          }
          protos() {
            return this.protoCodes().map((d) => Object.assign({}, n(d)))
          }
          protoCodes() {
            let d = [],
              h = this.bytes,
              m = 0
            for (; m < h.length; ) {
              let _ = i.decode(h, m),
                A = i.decode.bytes,
                T = n(_)
              ;(m += t.sizeForAddr(T, h.slice(m + A)) + A), d.push(_)
            }
            return d
          }
          protoNames() {
            return this.protos().map((d) => d.name)
          }
          tuples() {
            return t.bytesToTuples(this.bytes)
          }
          stringTuples() {
            let d = t.bytesToTuples(this.bytes)
            return t.tuplesToStringTuples(d)
          }
          encapsulate(d) {
            return (d = new p(d)), new p(this.toString() + d.toString())
          }
          decapsulate(d) {
            let h = d.toString(),
              m = this.toString(),
              _ = m.lastIndexOf(h)
            if (_ < 0) throw new Error('Address ' + this + ' does not contain subaddress: ' + d)
            return new p(m.slice(0, _))
          }
          decapsulateCode(d) {
            let h = this.tuples()
            for (let m = h.length - 1; m >= 0; m--) if (h[m][0] === d) return new p(t.tuplesToBytes(h.slice(0, m)))
            return this
          }
          getPeerId() {
            try {
              let h = this.stringTuples()
                .filter((m) => m[0] === n.names.ipfs.code)
                .pop()
              return h && h[1] ? l(new s(h[1]).multihash, 'base58btc') : null
            } catch (d) {
              return null
            }
          }
          getPath() {
            let d = null
            try {
              ;(d = this.stringTuples().filter((h) => !!n(h[0]).path)[0][1]), d || (d = null)
            } catch (h) {
              d = null
            }
            return d
          }
          equals(d) {
            return a(this.bytes, d.bytes)
          }
          async resolve() {
            let d = this.protos().find((_) => _.resolvable)
            if (!d) return [this]
            let h = c.get(d.name)
            if (!h) throw u(new Error(`no available resolver for ${d.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
            return (await h(this)).map((_) => new p(_))
          }
          nodeAddress() {
            let d = this.protoCodes(),
              h = this.protoNames(),
              m = this.toString().split('/').slice(1)
            if (m.length < 4)
              throw new Error(
                'multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'
              )
            if (d[0] !== 4 && d[0] !== 41 && d[0] !== 54 && d[0] !== 55)
              throw new Error(
                `no protocol with name: "'${h[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`
              )
            if (m[2] !== 'tcp' && m[2] !== 'udp')
              throw new Error(`no protocol with name: "'${h[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
            return { family: d[0] === 41 || d[0] === 55 ? 6 : 4, address: m[1], port: parseInt(m[3]) }
          }
          isThinWaistAddress(d) {
            let h = (d || this).protos()
            return !(h.length !== 2 || (h[0].code !== 4 && h[0].code !== 41) || (h[1].code !== 6 && h[1].code !== 273))
          }
          static fromNodeAddress(d, h) {
            if (!d) throw new Error('requires node address object')
            if (!h) throw new Error('requires transport protocol')
            let m
            switch (d.family) {
              case 4:
                m = 'ip4'
                break
              case 6:
                m = 'ip6'
                break
              default:
                throw Error(`Invalid addr family. Got '${d.family}' instead of 4 or 6`)
            }
            return new p('/' + [m, d.address, h, d.port].join('/'))
          }
          static isName(d) {
            return p.isMultiaddr(d) ? d.protos().some((h) => h.resolvable) : !1
          }
          static isMultiaddr(d) {
            return d instanceof p || Boolean(d && d[f])
          }
          [o]() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
          inspect() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
        }
      ;(p.protocols = n), (p.resolvers = c)
      function y(d) {
        return new p(d)
      }
      r.exports = { Multiaddr: p, multiaddr: y, protocols: n, resolvers: c }
    }
  }),
  d2 = te({
    'node_modules/it-filter/index.js'(e, r) {
      V(), F()
      var t = async function* (n, i) {
        for await (let s of n) (await i(s)) && (yield s)
      }
      r.exports = t
    }
  }),
  JL = te({
    'node_modules/it-map/index.js'(e, r) {
      V(), F()
      var t = async function* (n, i) {
        for await (let s of n) yield i(s)
      }
      r.exports = t
    }
  }),
  XL = te({
    'node_modules/libp2p/node_modules/it-take/index.js'(e, r) {
      V(), F()
      var t = async function* (n, i) {
        let s = 0
        if (!(i < 1)) {
          for await (let u of n) if ((yield u, s++, s === i)) return
        }
      }
      r.exports = t
    }
  }),
  nT = te({
    'node_modules/libp2p/src/content-routing/utils.js'(e, r) {
      V(), F()
      var t = pt(),
        n = d2(),
        i = JL(),
        s = XL()
      function u(c, f) {
        return i(c, (p) => (f.addressBook.add(p.id, p.multiaddrs), p))
      }
      function o(c) {
        let f = new Set()
        return n(c, (p) => (f.has(p.id.toString()) ? !1 : (f.add(p.id.toString()), !0)))
      }
      async function* l(c, f = 1) {
        let p = 0
        for await (let y of c) p++, yield y
        if (p < f) throw t(new Error('not found'), 'NOT_FOUND')
      }
      function a(c, f) {
        return f ? s(c, f) : c
      }
      r.exports = { storeAddresses: u, uniquePeers: o, requirePeers: l, maybeLimitSource: a }
    }
  }),
  iT = te({
    'node_modules/it-merge/index.js'(e, r) {
      V(), F()
      var t = df(),
        n = async function* (...i) {
          let s = t()
          setTimeout(async () => {
            try {
              await Promise.all(
                i.map(async (u) => {
                  for await (let o of u) s.push(o)
                })
              ),
                s.end()
            } catch (u) {
              s.end(u)
            }
          }, 0),
            yield* s
        }
      r.exports = n
    }
  }),
  sT = te({
    'node_modules/it-first/index.js'(e, r) {
      V(), F()
      var t = async (n) => {
        for await (let i of n) return i
      }
      r.exports = t
    }
  }),
  oT = te({
    'node_modules/it-drain/index.js'(e, r) {
      V(), F()
      var t = async (n) => {
        for await (let i of n);
      }
      r.exports = t
    }
  }),
  aT = te({
    'node_modules/set-delayed-interval/src/index.js'(e, r) {
      V(), F()
      var t = new Map(),
        n = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`
      async function i(o, l, a) {
        for (; t.get(a); ) {
          try {
            await o()
          } catch (c) {
            setTimeout(() => {
              throw c
            }, 1)
            break
          }
          if (!t.get(a)) break
          await new Promise((c) => {
            let f = setTimeout(c, l)
            t.set(a, f)
          })
        }
      }
      function s(o, l, a) {
        a = a || l
        let c = n(),
          f = setTimeout(() => {
            i(o, l, c)
          }, a)
        return t.set(c, f), c
      }
      function u(o) {
        let l = t.get(o)
        l && (clearTimeout(l), t.delete(o))
      }
      r.exports = { setDelayedInterval: s, clearDelayedInterval: u }
    }
  }),
  YL = te({
    'node_modules/libp2p/src/peer-routing.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:peer-routing'), { error: t('libp2p:peer-routing:err') }),
        i = pt(),
        { storeAddresses: s, uniquePeers: u, requirePeers: o } = nT(),
        l = iT(),
        { pipe: a } = wn(),
        c = sT(),
        f = oT(),
        p = d2(),
        { setDelayedInterval: y, clearDelayedInterval: d } = aT(),
        h = class {
          constructor(m) {
            ;(this._peerId = m.peerId),
              (this._peerStore = m.peerStore),
              (this._routers = m._modules.peerRouting || []),
              m._dht && m._config.dht.enabled && this._routers.push(m._dht),
              (this._refreshManagerOptions = m._options.peerRouting.refreshManager),
              (this._findClosestPeersTask = this._findClosestPeersTask.bind(this))
          }
          start() {
            !this._routers.length ||
              this._timeoutId ||
              !this._refreshManagerOptions.enabled ||
              (this._timeoutId = y(
                this._findClosestPeersTask,
                this._refreshManagerOptions.interval,
                this._refreshManagerOptions.bootDelay
              ))
          }
          async _findClosestPeersTask() {
            try {
              await f(this.getClosestPeers(this._peerId.id))
            } catch (m) {
              n.error(m)
            }
          }
          stop() {
            d(this._timeoutId)
          }
          async findPeer(m, _) {
            if (!this._routers.length) throw i(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')
            if (m.toB58String() === this._peerId.toB58String())
              throw i(new Error('Should not try to find self'), 'ERR_FIND_SELF')
            let A = await a(
              l(...this._routers.map((T) => [T.findPeer(m, _)])),
              (T) => p(T, Boolean),
              (T) => s(T, this._peerStore),
              (T) => c(T)
            )
            if (A) return A
            throw i(new Error('not found'), 'NOT_FOUND')
          }
          async *getClosestPeers(m, _ = { timeout: 3e4 }) {
            if (!this._routers.length) throw i(new Error('No peer routers available'), 'NO_ROUTERS_AVAILABLE')
            yield* a(
              l(...this._routers.map((A) => A.getClosestPeers(m, _))),
              (A) => s(A, this._peerStore),
              (A) => u(A),
              (A) => o(A)
            )
          }
        }
      r.exports = h
    }
  }),
  or = te({
    'node_modules/libp2p/src/errors.js'(e) {
      V(),
        F(),
        (e.messages = {
          NOT_STARTED_YET: 'The libp2p node is not started yet',
          DHT_DISABLED: 'DHT is not available',
          CONN_ENCRYPTION_REQUIRED: 'At least one connection encryption module is required'
        }),
        (e.codes = {
          DHT_DISABLED: 'ERR_DHT_DISABLED',
          PUBSUB_NOT_STARTED: 'ERR_PUBSUB_NOT_STARTED',
          DHT_NOT_STARTED: 'ERR_DHT_NOT_STARTED',
          CONN_ENCRYPTION_REQUIRED: 'ERR_CONN_ENCRYPTION_REQUIRED',
          ERR_INVALID_PROTOCOLS_FOR_STREAM: 'ERR_INVALID_PROTOCOLS_FOR_STREAM',
          ERR_CONNECTION_ENDED: 'ERR_CONNECTION_ENDED',
          ERR_CONNECTION_FAILED: 'ERR_CONNECTION_FAILED',
          ERR_NODE_NOT_STARTED: 'ERR_NODE_NOT_STARTED',
          ERR_ALREADY_ABORTED: 'ERR_ALREADY_ABORTED',
          ERR_NO_VALID_ADDRESSES: 'ERR_NO_VALID_ADDRESSES',
          ERR_RELAYED_DIAL: 'ERR_RELAYED_DIAL',
          ERR_DIALED_SELF: 'ERR_DIALED_SELF',
          ERR_DISCOVERED_SELF: 'ERR_DISCOVERED_SELF',
          ERR_DUPLICATE_TRANSPORT: 'ERR_DUPLICATE_TRANSPORT',
          ERR_ENCRYPTION_FAILED: 'ERR_ENCRYPTION_FAILED',
          ERR_HOP_REQUEST_FAILED: 'ERR_HOP_REQUEST_FAILED',
          ERR_INVALID_KEY: 'ERR_INVALID_KEY',
          ERR_INVALID_MESSAGE: 'ERR_INVALID_MESSAGE',
          ERR_INVALID_PARAMETERS: 'ERR_INVALID_PARAMETERS',
          ERR_INVALID_PEER: 'ERR_INVALID_PEER',
          ERR_MUXER_UNAVAILABLE: 'ERR_MUXER_UNAVAILABLE',
          ERR_TIMEOUT: 'ERR_TIMEOUT',
          ERR_TRANSPORT_UNAVAILABLE: 'ERR_TRANSPORT_UNAVAILABLE',
          ERR_TRANSPORT_DIAL_FAILED: 'ERR_TRANSPORT_DIAL_FAILED',
          ERR_UNSUPPORTED_PROTOCOL: 'ERR_UNSUPPORTED_PROTOCOL',
          ERR_INVALID_MULTIADDR: 'ERR_INVALID_MULTIADDR',
          ERR_SIGNATURE_NOT_VALID: 'ERR_SIGNATURE_NOT_VALID'
        })
    }
  }),
  ZL = te({
    'node_modules/libp2p/src/content-routing/index.js'(e, r) {
      V(), F()
      var t = pt(),
        { messages: n, codes: i } = or(),
        { storeAddresses: s, uniquePeers: u, requirePeers: o, maybeLimitSource: l } = nT(),
        a = iT(),
        { pipe: c } = wn(),
        f = class {
          constructor(p) {
            ;(this.libp2p = p),
              (this.routers = p._modules.contentRouting || []),
              (this.dht = p._dht),
              this.dht && p._config.dht.enabled && this.routers.push(this.dht)
          }
          async *findProviders(p, y = {}) {
            if (!this.routers.length) throw t(new Error('No content this.routers available'), 'NO_ROUTERS_AVAILABLE')
            yield* c(
              a(...this.routers.map((d) => d.findProviders(p, y))),
              (d) => s(d, this.libp2p.peerStore),
              (d) => u(d),
              (d) => l(d, y.maxNumProviders),
              (d) => o(d)
            )
          }
          async provide(p) {
            if (!this.routers.length) throw t(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE')
            await Promise.all(this.routers.map((y) => y.provide(p)))
          }
          put(p, y, d) {
            if (!this.libp2p.isStarted() || !this.dht.isStarted)
              throw t(new Error(n.NOT_STARTED_YET), i.DHT_NOT_STARTED)
            return this.dht.put(p, y, d)
          }
          get(p, y) {
            if (!this.libp2p.isStarted() || !this.dht.isStarted)
              throw t(new Error(n.NOT_STARTED_YET), i.DHT_NOT_STARTED)
            return this.dht.get(p, y)
          }
          async getMany(p, y, d) {
            if (!this.libp2p.isStarted() || !this.dht.isStarted)
              throw t(new Error(n.NOT_STARTED_YET), i.DHT_NOT_STARTED)
            return this.dht.getMany(p, y, d)
          }
        }
      r.exports = f
    }
  }),
  cT = te({
    'node_modules/libp2p/src/get-peer.js'(e, r) {
      V(), F()
      var t = er(),
        { Multiaddr: n } = Zr(),
        i = pt(),
        { codes: s } = or()
      function u(o) {
        typeof o == 'string' && (o = new n(o))
        let l
        if (n.isMultiaddr(o)) {
          l = o
          let a = o.getPeerId()
          if (!a) throw i(new Error(`${o} does not have a valid peer type`), s.ERR_INVALID_MULTIADDR)
          try {
            o = t.createFromB58String(a)
          } catch (c) {
            throw i(new Error(`${o} is not a valid peer type`), s.ERR_INVALID_MULTIADDR)
          }
        }
        return { id: o, multiaddrs: l ? [l] : void 0 }
      }
      r.exports = u
    }
  }),
  QL = te({
    'node_modules/is-plain-obj/index.js'(e, r) {
      V(),
        F(),
        (r.exports = (t) => {
          if (Object.prototype.toString.call(t) !== '[object Object]') return !1
          let n = Object.getPrototypeOf(t)
          return n === null || n === Object.prototype
        })
    }
  }),
  gf = te({
    'node_modules/merge-options/index.js'(e, r) {
      V(), F()
      var t = QL(),
        { hasOwnProperty: n } = Object.prototype,
        { propertyIsEnumerable: i } = Object,
        s = (h, m, _) => Object.defineProperty(h, m, { value: _, writable: !0, enumerable: !0, configurable: !0 }),
        u = e,
        o = { concatArrays: !1, ignoreUndefined: !1 },
        l = (h) => {
          let m = []
          for (let _ in h) n.call(h, _) && m.push(_)
          if (Object.getOwnPropertySymbols) {
            let _ = Object.getOwnPropertySymbols(h)
            for (let A of _) i.call(h, A) && m.push(A)
          }
          return m
        }
      function a(h) {
        return Array.isArray(h) ? c(h) : t(h) ? f(h) : h
      }
      function c(h) {
        let m = h.slice(0, 0)
        return (
          l(h).forEach((_) => {
            s(m, _, a(h[_]))
          }),
          m
        )
      }
      function f(h) {
        let m = Object.getPrototypeOf(h) === null ? Object.create(null) : {}
        return (
          l(h).forEach((_) => {
            s(m, _, a(h[_]))
          }),
          m
        )
      }
      var p = (h, m, _, A) => (
          _.forEach((T) => {
            ;(typeof m[T] == 'undefined' && A.ignoreUndefined) ||
              (T in h && h[T] !== Object.getPrototypeOf(h) ? s(h, T, d(h[T], m[T], A)) : s(h, T, a(m[T])))
          }),
          h
        ),
        y = (h, m, _) => {
          let A = h.slice(0, 0),
            T = 0
          return (
            [h, m].forEach((E) => {
              let k = []
              for (let w = 0; w < E.length; w++)
                !n.call(E, w) || (k.push(String(w)), E === h ? s(A, T++, E[w]) : s(A, T++, a(E[w])))
              A = p(
                A,
                E,
                l(E).filter((w) => !k.includes(w)),
                _
              )
            }),
            A
          )
        }
      function d(h, m, _) {
        return _.concatArrays && Array.isArray(h) && Array.isArray(m)
          ? y(h, m, _)
          : !t(m) || !t(h)
          ? a(m)
          : p(h, m, l(m), _)
      }
      r.exports = function (...h) {
        let m = d(a(o), (this !== u && this) || {}, o),
          _ = { _: {} }
        for (let A of h)
          if (A !== void 0) {
            if (!t(A)) throw new TypeError('`' + A + '` is not an Option Object')
            _ = d(_, { _: A }, m)
          }
        return _._
      }
    }
  }),
  eU = te({
    'node_modules/receptacle/index.js'(e, r) {
      V(), F(), (r.exports = u)
      var t = m3(),
        n = u.prototype,
        i = new Date() % 1e9
      function s() {
        return ((Math.random() * 1e9) >>> 0) + i++
      }
      function u(o) {
        ;(o = o || {}),
          (this.id = o.id || s()),
          (this.max = o.max || 1 / 0),
          (this.items = o.items || []),
          (this._lookup = {}),
          (this.size = this.items.length),
          (this.lastModified = new Date(o.lastModified || new Date()))
        for (var l, a, c = this.items.length; c--; )
          (l = this.items[c]),
            (a = new Date(l.expires) - new Date()),
            (this._lookup[l.key] = l),
            a > 0 ? this.expire(l.key, a) : a <= 0 && this.delete(l.key)
      }
      ;(n.has = function (o) {
        return o in this._lookup
      }),
        (n.get = function (o) {
          if (!this.has(o)) return null
          var l = this._lookup[o]
          return (
            l.refresh && this.expire(o, l.refresh),
            this.items.splice(this.items.indexOf(l), 1),
            this.items.push(l),
            l.value
          )
        }),
        (n.meta = function (o) {
          if (!this.has(o)) return null
          var l = this._lookup[o]
          return 'meta' in l ? l.meta : null
        }),
        (n.set = function (o, l, a) {
          var c = this._lookup[o],
            f = (this._lookup[o] = { key: o, value: l })
          return (
            (this.lastModified = new Date()),
            c
              ? (clearTimeout(c.timeout), this.items.splice(this.items.indexOf(c), 1, f))
              : (this.size >= this.max && this.delete(this.items[0].key), this.items.push(f), this.size++),
            a &&
              ('ttl' in a && this.expire(o, a.ttl), 'meta' in a && (f.meta = a.meta), a.refresh && (f.refresh = a.ttl)),
            this
          )
        }),
        (n.delete = function (o) {
          var l = this._lookup[o]
          return l
            ? ((this.lastModified = new Date()),
              this.items.splice(this.items.indexOf(l), 1),
              clearTimeout(l.timeout),
              delete this._lookup[o],
              this.size--,
              this)
            : !1
        }),
        (n.expire = function (o, l) {
          var a = l || 0,
            c = this._lookup[o]
          if (!c) return this
          if ((typeof a == 'string' && (a = t(l)), typeof a != 'number'))
            throw new TypeError('Expiration time must be a string or number.')
          return (
            clearTimeout(c.timeout),
            (c.timeout = setTimeout(this.delete.bind(this, c.key), a)),
            (c.expires = Number(new Date()) + a),
            this
          )
        }),
        (n.clear = function () {
          for (var o = this.items.length; o--; ) this.delete(this.items[o].key)
          return this
        }),
        (n.toJSON = function () {
          for (var o = new Array(this.items.length), l, a = o.length; a--; )
            (l = this.items[a]),
              (o[a] = { key: l.key, meta: l.meta, value: l.value, expires: l.expires, refresh: l.refresh })
          return { id: this.id, max: isFinite(this.max) ? this.max : void 0, lastModified: this.lastModified, items: o }
        })
    }
  }),
  wf = te({
    'node_modules/node-fetch/browser.js'(e, r) {
      V(), F()
      var t = function () {
          if (typeof self != 'undefined') return self
          if (typeof window != 'undefined') return window
          if (typeof n != 'undefined') return n
          throw new Error('unable to locate global object')
        },
        n = t()
      ;(r.exports = e = n.fetch),
        n.fetch && (e.default = n.fetch.bind(n)),
        (e.Headers = n.Headers),
        (e.Request = n.Request),
        (e.Response = n.Response)
    }
  }),
  tU = te({
    'node_modules/native-fetch/src/index.js'(e, r) {
      V(),
        F(),
        globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response
          ? (r.exports = {
              default: globalThis.fetch,
              Headers: globalThis.Headers,
              Request: globalThis.Request,
              Response: globalThis.Response
            })
          : (r.exports = {
              default: wf().default,
              Headers: wf().Headers,
              Request: wf().Request,
              Response: wf().Response
            })
    }
  }),
  rU = te({
    'node_modules/dns-over-http-resolver/src/utils.js'(e, r) {
      V(), F()
      var { default: t, Headers: n } = tU()
      function i({ serverResolver: o, hostname: l, recordType: a }) {
        return `${o}?name=${l}&type=${a}`
      }
      function s(o) {
        return t(o, { headers: new n({ accept: 'application/dns-json' }) })
      }
      function u(o, l) {
        return `${l}_${o}`
      }
      r.exports = { buildResource: i, fetch: s, getCacheKey: u }
    }
  }),
  nU = te({
    'node_modules/dns-over-http-resolver/src/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = t('dns-over-http-resolver')
      n.error = t('dns-over-http-resolver:error')
      var i = eU(),
        s = rU(),
        u = class {
          constructor({ maxCache: o = 100 } = {}) {
            ;(this._cache = new i({ max: o })),
              (this._servers = ['https://cloudflare-dns.com/dns-query', 'https://dns.google/resolve'])
          }
          getServers() {
            return this._servers
          }
          _getShuffledServers() {
            let o = [].concat(this._servers)
            for (let l = o.length - 1; l > 0; l--) {
              let a = Math.floor(Math.random() * l),
                c = o[l]
              ;(o[l] = o[a]), (o[a] = c)
            }
            return o
          }
          setServers(o) {
            this._servers = o
          }
          resolve(o, l = 'A') {
            switch (l) {
              case 'A':
                return this.resolve4(o)
              case 'AAAA':
                return this.resolve6(o)
              case 'TXT':
                return this.resolveTxt(o)
              default:
                throw new Error(`${l} is not supported`)
            }
          }
          async resolve4(o) {
            let l = 'A',
              a = this._cache.get(s.getCacheKey(o, l))
            if (a) return a
            for (let c of this._getShuffledServers())
              try {
                let p = await (
                    await s.fetch(s.buildResource({ serverResolver: c, hostname: o, recordType: l }))
                  ).json(),
                  y = p.Answer.map((h) => h.data),
                  d = Math.min(p.Answer.map((h) => h.TTL))
                return this._cache.set(s.getCacheKey(o, l), y, { ttl: d }), y
              } catch (f) {
                n.error(`${c} could not resolve ${o} record ${l}`)
              }
            throw new Error(`Could not resolve ${o} record ${l}`)
          }
          async resolve6(o) {
            let l = 'AAAA',
              a = this._cache.get(s.getCacheKey(o, l))
            if (a) return a
            for (let c of this._getShuffledServers())
              try {
                let p = await (
                    await s.fetch(s.buildResource({ serverResolver: c, hostname: o, recordType: l }))
                  ).json(),
                  y = p.Answer.map((h) => h.data),
                  d = Math.min(p.Answer.map((h) => h.TTL))
                return this._cache.set(s.getCacheKey(o, l), y, { ttl: d }), y
              } catch (f) {
                n.error(`${c} could not resolve ${o} record ${l}`)
              }
            throw new Error(`Could not resolve ${o} record ${l}`)
          }
          async resolveTxt(o) {
            let l = 'TXT',
              a = this._cache.get(s.getCacheKey(o, l))
            if (a) return a
            for (let c of this._getShuffledServers())
              try {
                let p = await (
                    await s.fetch(s.buildResource({ serverResolver: c, hostname: o, recordType: l }))
                  ).json(),
                  y = p.Answer.map((h) => [h.data.replace(/['"]+/g, '')]),
                  d = Math.min(p.Answer.map((h) => h.TTL))
                return this._cache.set(s.getCacheKey(o, l), y, { ttl: d }), y
              } catch (f) {
                n.error(`${c} could not resolve ${o} record ${l}`)
              }
            throw new Error(`Could not resolve ${o} record ${l}`)
          }
        }
      ;(u.Resolver = u), (r.exports = u)
    }
  }),
  iU = te({
    'node_modules/libp2p/node_modules/multiaddr/src/resolvers/dns.browser.js'(e, r) {
      V(), F()
      var t = nU()
      r.exports = t
    }
  }),
  sU = te({
    'node_modules/libp2p/node_modules/multiaddr/src/resolvers/index.js'(e, r) {
      V(), F()
      var t = yf(),
        { code: n } = t('dnsaddr')
      async function i(s) {
        let u = iU(),
          o = new u(),
          l = s.getPeerId(),
          [, a] = s.stringTuples().find(([p]) => p === n) || [],
          f = (await o.resolveTxt(`_dnsaddr.${a}`)).flat().map((p) => p.split('=')[1])
        return l && (f = f.filter((p) => p.includes(l))), f
      }
      r.exports = { dnsaddrResolver: i }
    }
  }),
  h2 = te({
    'node_modules/libp2p/src/constants.js'(e, r) {
      V(),
        F(),
        (r.exports = {
          DIAL_TIMEOUT: 3e4,
          MAX_PARALLEL_DIALS: 100,
          MAX_PER_PEER_DIALS: 4,
          METRICS: {
            computeThrottleMaxQueueSize: 1e3,
            computeThrottleTimeout: 2e3,
            movingAverageIntervals: [60 * 1e3, 5 * 60 * 1e3, 15 * 60 * 1e3],
            maxOldPeersRetention: 50
          }
        })
    }
  }),
  uT = te({
    'node_modules/libp2p/package.json'(e, r) {
      r.exports = {
        _args: [['libp2p@0.31.7', '/home/farhoud/workspace/functionland/box/packages/graph']],
        _from: 'libp2p@0.31.7',
        _id: 'libp2p@0.31.7',
        _inBundle: !1,
        _integrity: 'sha512-0FUHYlwoDQ8+x3qQM9iTrZP0Ui1LWYxAbLZ9H8Hs57hqevEv08eX5EDFlkpqu/W9dkl4gsQ3kv3sa7ye8+lokA==',
        _location: '/libp2p',
        _phantomChildren: {
          cids: '1.1.8',
          'dns-over-http-resolver': '1.2.3',
          'err-code': '3.0.1',
          'ipfs-utils': '8.1.6',
          'is-ip': '3.1.0',
          'iso-random-stream': '2.0.0',
          'it-all': '1.0.5',
          'it-drain': '1.0.4',
          'it-filter': '1.0.2',
          multibase: '4.0.6',
          nanoid: '3.1.25',
          varint: '6.0.0'
        },
        _requested: {
          type: 'version',
          registry: !0,
          raw: 'libp2p@0.31.7',
          name: 'libp2p',
          escapedName: 'libp2p',
          rawSpec: '0.31.7',
          saveSpec: null,
          fetchSpec: '0.31.7'
        },
        _requiredBy: ['/'],
        _resolved: 'https://registry.npmjs.org/libp2p/-/libp2p-0.31.7.tgz',
        _spec: '0.31.7',
        _where: '/home/farhoud/workspace/functionland/box/packages/graph',
        browser: { '@motrix/nat-api': !1 },
        bugs: { url: 'https://github.com/libp2p/js-libp2p/issues' },
        contributors: [
          { name: 'David Dias', email: 'daviddias.p@gmail.com' },
          { name: 'Vasco Santos', email: 'vasco.santos@moxy.studio' },
          { name: 'Jacob Heun', email: 'jacobheun@gmail.com' },
          { name: 'Alex Potsides', email: 'alex@achingbrain.net' },
          { name: 'Alan Shaw', email: 'alan@tableflip.io' },
          { name: 'Cayman', email: 'caymannava@gmail.com' },
          { name: 'Pedro Teixeira', email: 'i@pgte.me' },
          { name: 'Friedel Ziegelmayer', email: 'dignifiedquire@gmail.com' },
          { name: 'Maciej Kr\xFCger', email: 'mkg20001@gmail.com' },
          { name: 'Hugo Dias', email: 'mail@hugodias.me' },
          { name: 'dirkmc', email: 'dirkmdev@gmail.com' },
          { name: 'Volker Mische', email: 'volker.mische@gmail.com' },
          { name: 'Richard Littauer', email: 'richard.littauer@gmail.com' },
          { name: 'Ryan Bell', email: 'ryan@piing.net' },
          { name: 'a1300', email: 'matthias-knopp@gmx.net' },
          {
            name: '\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D',
            email: 'victorbjelkholm@gmail.com'
          },
          { name: 'Samlior', email: 'samlior@foxmail.com' },
          { name: 'Andrew Nesbitt', email: 'andrewnez@gmail.com' },
          { name: 'Thomas Eizinger', email: 'thomas@eizinger.io' },
          { name: 'Franck Royer', email: 'franck@royer.one' },
          { name: 'Giovanni T. Parra', email: 'fiatjaf@gmail.com' },
          { name: 'Elven', email: 'mon.samuel@qq.com' },
          { name: 'Didrik Nordstr\xF6m', email: 'didrik.nordstrom@gmail.com' },
          { name: 'RasmusErik Voel Jensen', email: 'github@solsort.com' },
          { name: 'Smite Chow', email: 'xiaopengyou@live.com' },
          { name: 'Soeren', email: 'nikorpoulsen@gmail.com' },
          { name: 'S\xF6nke Hahn', email: 'soenkehahn@gmail.com' },
          { name: 'TJKoury', email: 'TJKoury@gmail.com' },
          { name: 'Tiago Alves', email: 'alvesjtiago@gmail.com' },
          { name: 'Yusef Napora', email: 'yusef@napora.org' },
          { name: 'Zane Starr', email: 'zcstarr@gmail.com' },
          { name: 'ebinks', email: 'elizabethjbinks@gmail.com' },
          { name: 'isan_rivkin', email: 'isanrivkin@gmail.com' },
          { name: 'mcclure', email: 'andi.m.mcclure@gmail.com' },
          { name: 'robertkiel', email: 'robert.kiel@validitylabs.org' },
          { name: 'Aleksei', email: 'vozhdb@gmail.com' },
          { name: 'Bernd Strehl', email: 'bernd.strehl@gmail.com' },
          { name: 'Chris Bratlien', email: 'chrisbratlien@gmail.com' },
          { name: 'Cindy Wu', email: 'ciindy.wu@gmail.com' },
          { name: 'Daijiro Wachi', email: 'daijiro.wachi@gmail.com' },
          { name: 'Diogo Silva', email: 'fsdiogo@gmail.com' },
          { name: 'Dmitriy Ryajov', email: 'dryajov@gmail.com' },
          { name: 'Ethan Lam', email: 'elmemphis2000@gmail.com' },
          { name: 'Fei Liu', email: 'liu.feiwood@gmail.com' },
          { name: 'Felipe Martins', email: 'felipebrasil93@gmail.com' },
          { name: 'Florian-Merle', email: 'florian.david.merle@gmail.com' },
          { name: 'Francis Gulotta', email: 'wizard@roborooter.com' },
          { name: 'Henrique Dias', email: 'hacdias@gmail.com' },
          { name: 'Irakli Gozalishvili', email: 'rfobic@gmail.com' },
          { name: 'Joel Gustafson', email: 'joelg@mit.edu' },
          { name: 'Julien Bouquillon', email: 'contact@revolunet.com' },
          { name: 'Kevin Kwok', email: 'antimatter15@gmail.com' },
          { name: 'Kevin Lacker', email: 'lacker@gmail.com' },
          { name: 'Miguel Mota', email: 'miguelmota2@gmail.com' },
          { name: 'Nuno Nogueira', email: 'nunofmn@gmail.com' },
          { name: 'Philipp Muens', email: 'raute1337@gmx.de' }
        ],
        dependencies: {
          '@motrix/nat-api': '^0.3.1',
          '@vascosantos/moving-average': '^1.1.0',
          'abort-controller': '^3.0.0',
          'aggregate-error': '^3.1.0',
          'any-signal': '^2.1.1',
          'bignumber.js': '^9.0.1',
          cids: '^1.1.5',
          'class-is': '^1.1.0',
          debug: '^4.3.1',
          'err-code': '^3.0.0',
          'es6-promisify': '^6.1.1',
          events: '^3.3.0',
          hashlru: '^2.3.0',
          'interface-datastore': '^4.0.0',
          'it-all': '^1.0.4',
          'it-buffer': '^0.1.2',
          'it-drain': '^1.0.3',
          'it-filter': '^1.0.1',
          'it-first': '^1.0.4',
          'it-handshake': '^2.0.0',
          'it-length-prefixed': '^5.0.2',
          'it-map': '^1.0.4',
          'it-merge': '1.0.0',
          'it-pipe': '^1.1.0',
          'it-take': '1.0.0',
          'libp2p-crypto': '^0.19.4',
          'libp2p-interfaces': '^0.10.4',
          'libp2p-utils': '^0.3.1',
          mafmt: '^9.0.0',
          'merge-options': '^3.0.4',
          multiaddr: '^9.0.1',
          multicodec: '^3.0.1',
          'multihashing-async': '^2.1.2',
          'multistream-select': '^2.0.0',
          'mutable-proxy': '^1.0.0',
          'node-forge': '^0.10.0',
          'p-any': '^3.0.0',
          'p-fifo': '^1.0.0',
          'p-retry': '^4.4.0',
          'p-settle': '^4.1.1',
          'peer-id': '^0.14.2',
          'private-ip': '^2.1.0',
          protobufjs: '^6.10.2',
          retimer: '^3.0.0',
          'sanitize-filename': '^1.6.3',
          'set-delayed-interval': '^1.0.0',
          'streaming-iterables': '^5.0.2',
          'timeout-abort-controller': '^1.1.1',
          varint: '^6.0.0',
          wherearewe: '^1.0.0',
          xsalsa20: '^1.1.0'
        },
        description: 'JavaScript implementation of libp2p, a modular peer to peer network stack',
        devDependencies: {
          '@nodeutils/defaults-deep': '^1.1.0',
          '@types/es6-promisify': '^6.0.0',
          '@types/node-forge': '^0.9.7',
          '@types/varint': '^6.0.0',
          'abortable-iterator': '^3.0.0',
          aegir: '^33.1.1',
          buffer: '^6.0.3',
          delay: '^5.0.0',
          'interop-libp2p': '^0.4.0',
          'into-stream': '^6.0.0',
          'ipfs-http-client': '^50.1.1',
          'it-concat': '^1.0.0',
          'it-pair': '^1.0.0',
          'it-pushable': '^1.4.0',
          libp2p: '.',
          'libp2p-bootstrap': '^0.12.3',
          'libp2p-delegated-content-routing': '^0.10.0',
          'libp2p-delegated-peer-routing': '^0.9.0',
          'libp2p-floodsub': '^0.25.0',
          'libp2p-gossipsub': '^0.9.0',
          'libp2p-kad-dht': '^0.22.0',
          'libp2p-mdns': '^0.16.0',
          'libp2p-mplex': '^0.10.1',
          'libp2p-noise': '^3.0.0',
          'libp2p-tcp': '^0.15.4',
          'libp2p-webrtc-star': '^0.22.2',
          'libp2p-websockets': '^0.15.8',
          multihashes: '^4.0.2',
          nock: '^13.0.3',
          'p-defer': '^3.0.0',
          'p-times': '^3.0.0',
          'p-wait-for': '^3.2.0',
          rimraf: '^3.0.2',
          sinon: '^10.0.0',
          uint8arrays: '^2.1.3',
          util: '^0.12.3'
        },
        engines: { node: '>=14.0.0' },
        eslintConfig: { extends: 'ipfs', ignorePatterns: ['!.aegir.js', 'test/ts-use'] },
        files: ['dist', 'src'],
        homepage: 'https://libp2p.io',
        keywords: ['libp2p', 'network', 'p2p', 'peer', 'peer-to-peer', 'IPFS'],
        leadMaintainer: 'Jacob Heun <jacobheun@gmail.com>',
        license: 'MIT',
        main: 'src/index.js',
        name: 'libp2p',
        repository: { type: 'git', url: 'git+https://github.com/libp2p/js-libp2p.git' },
        scripts: {
          build: 'aegir build',
          'build:proto':
            'npm run build:proto:circuit && npm run build:proto:identify && npm run build:proto:plaintext && npm run build:proto:address-book && npm run build:proto:proto-book && npm run build:proto:peer-record && npm run build:proto:envelope',
          'build:proto-types':
            'npm run build:proto-types:circuit && npm run build:proto-types:identify && npm run build:proto-types:plaintext && npm run build:proto-types:address-book && npm run build:proto-types:proto-book && npm run build:proto-types:peer-record && npm run build:proto-types:envelope',
          'build:proto-types:address-book':
            'pbts -o src/peer-store/persistent/pb/address-book.d.ts src/peer-store/persistent/pb/address-book.js',
          'build:proto-types:circuit': 'pbts -o src/circuit/protocol/index.d.ts src/circuit/protocol/index.js',
          'build:proto-types:envelope': 'pbts -o src/record/envelope/envelope.d.ts src/record/envelope/envelope.js',
          'build:proto-types:identify': 'pbts -o src/identify/message.d.ts src/identify/message.js',
          'build:proto-types:peer-record':
            'pbts -o src/record/peer-record/peer-record.d.ts src/record/peer-record/peer-record.js',
          'build:proto-types:plaintext': 'pbts -o src/insecure/proto.d.ts src/insecure/proto.js',
          'build:proto-types:proto-book':
            'pbts -o src/peer-store/persistent/pb/proto-book.d.ts src/peer-store/persistent/pb/proto-book.js',
          'build:proto:address-book':
            'pbjs -t static-module -w commonjs -r libp2p-address-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/address-book.js ./src/peer-store/persistent/pb/address-book.proto',
          'build:proto:circuit':
            'pbjs -t static-module -w commonjs -r libp2p-circuit --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/circuit/protocol/index.js ./src/circuit/protocol/index.proto',
          'build:proto:envelope':
            'pbjs -t static-module -w commonjs -r libp2p-envelope --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/envelope/envelope.js ./src/record/envelope/envelope.proto',
          'build:proto:identify':
            'pbjs -t static-module -w commonjs -r libp2p-identify --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/identify/message.js ./src/identify/message.proto',
          'build:proto:peer-record':
            'pbjs -t static-module -w commonjs -r libp2p-peer-record --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/peer-record/peer-record.js ./src/record/peer-record/peer-record.proto',
          'build:proto:plaintext':
            'pbjs -t static-module -w commonjs -r libp2p-plaintext --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/insecure/proto.js ./src/insecure/proto.proto',
          'build:proto:proto-book':
            'pbjs -t static-module -w commonjs -r libp2p-proto-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/proto-book.js ./src/peer-store/persistent/pb/proto-book.proto',
          coverage: 'nyc --reporter=text --reporter=lcov npm run test:node',
          lint: 'aegir lint',
          prepare: 'aegir build --no-bundle',
          release: 'aegir release -t node -t browser',
          'release-major': 'aegir release --type major -t node -t browser',
          'release-minor': 'aegir release --type minor -t node -t browser',
          test: 'aegir test',
          'test:browser': 'aegir test -t browser',
          'test:examples': 'cd examples && npm run test:all',
          'test:node': 'aegir test -t node -f "./test/**/*.{node,spec}.js"',
          'test:ts': 'aegir build --no-bundle && npm run test --prefix test/ts-use'
        },
        types: 'dist/src/index.d.ts',
        typesVersions: { '*': { 'src/*': ['dist/src/*', 'dist/src/*/index'] } },
        version: '0.31.7'
      }
    }
  }),
  lT = te({
    'node_modules/libp2p/src/identify/consts.js'(e, r) {
      V(), F()
      var t = uT().version
      ;(r.exports.PROTOCOL_VERSION = 'ipfs/0.1.0'),
        (r.exports.AGENT_VERSION = `js-libp2p/${t}`),
        (r.exports.MULTICODEC_IDENTIFY = '/ipfs/id/1.0.0'),
        (r.exports.MULTICODEC_IDENTIFY_PUSH = '/ipfs/id/push/1.0.0')
    }
  }),
  p2 = te({
    'node_modules/libp2p/src/circuit/constants.js'(e, r) {
      V(), F()
      var t = 60 * 1e3
      r.exports = {
        ADVERTISE_BOOT_DELAY: 15 * t,
        ADVERTISE_TTL: 30 * t,
        CIRCUIT_PROTO_CODE: 290,
        HOP_METADATA_KEY: 'hop_relay',
        HOP_METADATA_VALUE: 'true',
        RELAY_RENDEZVOUS_NS: '/libp2p/relay'
      }
    }
  }),
  oU = te({
    'node_modules/netmask/lib/netmask.js'(e) {
      V(),
        F(),
        function () {
          var r, t, n, i, s, u, o, l
          ;(l = function (a) {
            var c, f, p, y
            return (
              (c = (a & (255 << 24)) >>> 24),
              (f = (a & (255 << 16)) >>> 16),
              (p = (a & (255 << 8)) >>> 8),
              (y = a & 255),
              [c, f, p, y].join('.')
            )
          }),
            (o = function (a) {
              var c, f, p, y, d, h
              for (c = [], p = y = 0; y <= 3 && a.length !== 0; p = ++y) {
                if (p > 0) {
                  if (a[0] !== '.') throw new Error('Invalid IP')
                  a = a.substring(1)
                }
                ;(h = t(a)), (d = h[0]), (f = h[1]), (a = a.substring(f)), c.push(d)
              }
              if (a.length !== 0) throw new Error('Invalid IP')
              switch (c.length) {
                case 1:
                  if (c[0] > 4294967295) throw new Error('Invalid IP')
                  return c[0] >>> 0
                case 2:
                  if (c[0] > 255 || c[1] > 16777215) throw new Error('Invalid IP')
                  return ((c[0] << 24) | c[1]) >>> 0
                case 3:
                  if (c[0] > 255 || c[1] > 255 || c[2] > 65535) throw new Error('Invalid IP')
                  return ((c[0] << 24) | (c[1] << 16) | c[2]) >>> 0
                case 4:
                  if (c[0] > 255 || c[1] > 255 || c[2] > 255 || c[3] > 255) throw new Error('Invalid IP')
                  return ((c[0] << 24) | (c[1] << 16) | (c[2] << 8) | c[3]) >>> 0
                default:
                  throw new Error('Invalid IP')
              }
            }),
            (n = function (a) {
              return a.charCodeAt(0)
            }),
            (i = n('0')),
            (u = n('a')),
            (s = n('A')),
            (t = function (a) {
              var c, f, p, y, d
              for (
                y = 0,
                  c = 10,
                  f = '9',
                  p = 0,
                  a.length > 1 &&
                    a[p] === '0' &&
                    (a[p + 1] === 'x' || a[p + 1] === 'X'
                      ? ((p += 2), (c = 16))
                      : '0' <= a[p + 1] && a[p + 1] <= '9' && (p++, (c = 8), (f = '7'))),
                  d = p;
                p < a.length;

              ) {
                if ('0' <= a[p] && a[p] <= f) y = (y * c + (n(a[p]) - i)) >>> 0
                else if (c === 16)
                  if ('a' <= a[p] && a[p] <= 'f') y = (y * c + (10 + n(a[p]) - u)) >>> 0
                  else if ('A' <= a[p] && a[p] <= 'F') y = (y * c + (10 + n(a[p]) - s)) >>> 0
                  else break
                else break
                if (y > 4294967295) throw new Error('too large')
                p++
              }
              if (p === d) throw new Error('empty octet')
              return [y, p]
            }),
            (r = (function () {
              function a(c, f) {
                var p, y, d, h
                if (typeof c != 'string') throw new Error("Missing `net' parameter")
                if (
                  (f || ((h = c.split('/', 2)), (c = h[0]), (f = h[1])),
                  f || (f = 32),
                  typeof f == 'string' && f.indexOf('.') > -1)
                ) {
                  try {
                    this.maskLong = o(f)
                  } catch (m) {
                    throw ((p = m), new Error('Invalid mask: ' + f))
                  }
                  for (y = d = 32; d >= 0; y = --d)
                    if (this.maskLong === (4294967295 << (32 - y)) >>> 0) {
                      this.bitmask = y
                      break
                    }
                } else if (f || f === 0)
                  (this.bitmask = parseInt(f, 10)),
                    (this.maskLong = 0),
                    this.bitmask > 0 && (this.maskLong = (4294967295 << (32 - this.bitmask)) >>> 0)
                else throw new Error('Invalid mask: empty')
                try {
                  this.netLong = (o(c) & this.maskLong) >>> 0
                } catch (m) {
                  throw ((p = m), new Error('Invalid net address: ' + c))
                }
                if (!(this.bitmask <= 32)) throw new Error('Invalid mask for ip4: ' + f)
                ;(this.size = Math.pow(2, 32 - this.bitmask)),
                  (this.base = l(this.netLong)),
                  (this.mask = l(this.maskLong)),
                  (this.hostmask = l(~this.maskLong)),
                  (this.first = this.bitmask <= 30 ? l(this.netLong + 1) : this.base),
                  (this.last = this.bitmask <= 30 ? l(this.netLong + this.size - 2) : l(this.netLong + this.size - 1)),
                  (this.broadcast = this.bitmask <= 30 ? l(this.netLong + this.size - 1) : void 0)
              }
              return (
                (a.prototype.contains = function (c) {
                  return (
                    typeof c == 'string' && (c.indexOf('/') > 0 || c.split('.').length !== 4) && (c = new a(c)),
                    c instanceof a
                      ? this.contains(c.base) && this.contains(c.broadcast || c.last)
                      : (o(c) & this.maskLong) >>> 0 == (this.netLong & this.maskLong) >>> 0
                  )
                }),
                (a.prototype.next = function (c) {
                  return c == null && (c = 1), new a(l(this.netLong + this.size * c), this.mask)
                }),
                (a.prototype.forEach = function (c) {
                  var f, p, y
                  for (y = o(this.first), p = o(this.last), f = 0; y <= p; ) c(l(y), y, f), f++, y++
                }),
                (a.prototype.toString = function () {
                  return this.base + '/' + this.bitmask
                }),
                a
              )
            })()),
            (e.ip2long = o),
            (e.long2ip = l),
            (e.Netmask = r)
        }.call(e)
    }
  }),
  aU = te({
    'node_modules/private-ip/lib/index.js'(e, r) {
      V(), F()
      var t = oU().Netmask,
        n = eg(),
        i = [
          '0.0.0.0/8',
          '10.0.0.0/8',
          '100.64.0.0/10',
          '127.0.0.0/8',
          '169.254.0.0/16',
          '172.16.0.0/12',
          '192.0.0.0/24',
          '192.0.0.0/29',
          '192.0.0.8/32',
          '192.0.0.9/32',
          '192.0.0.10/32',
          '192.0.0.170/32',
          '192.0.0.171/32',
          '192.0.2.0/24',
          '192.31.196.0/24',
          '192.52.193.0/24',
          '192.88.99.0/24',
          '192.168.0.0/16',
          '192.175.48.0/24',
          '198.18.0.0/15',
          '198.51.100.0/24',
          '203.0.113.0/24',
          '240.0.0.0/4',
          '255.255.255.255/32'
        ],
        s = i.map((l) => new t(l))
      function u(l) {
        for (let a of s) if (a.contains(l)) return !0
        return !1
      }
      function o(l) {
        return (
          /^::$/.test(l) ||
          /^::1$/.test(l) ||
          /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(l) ||
          /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(l) ||
          /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(l) ||
          /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(l) ||
          /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(
            l
          ) ||
          /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(
            l
          ) ||
          /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(
            l
          ) ||
          /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(
            l
          ) ||
          /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(l) ||
          /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(l) ||
          /^ff([0-9a-fA-F]{2,2}):/i.test(l)
        )
      }
      r.exports = (l) => (n.v6().test(l) ? o(l) : n().test(l) || l.startsWith('0') ? u(l) : !1)
    }
  }),
  fT = te({
    'node_modules/private-ip/index.js'(e, r) {
      V(), F(), (r.exports = aU())
    }
  }),
  cU = te({
    'node_modules/libp2p-utils/src/multiaddr/is-private.js'(e, r) {
      V(), F()
      var t = fT()
      function n(i) {
        let { address: s } = i.nodeAddress()
        return t(s)
      }
      r.exports = n
    }
  }),
  dT = te({
    'node_modules/libp2p-utils/src/address-sort.js'(e, r) {
      V(), F()
      var t = cU()
      function n(s, u) {
        let o = t(s.multiaddr),
          l = t(u.multiaddr)
        return o && !l
          ? 1
          : (!o && l) || (s.isCertified && !u.isCertified)
          ? -1
          : !s.isCertified && u.isCertified
          ? 1
          : 0
      }
      function i(s) {
        return [...s].sort(n)
      }
      r.exports.publicAddressesFirst = i
    }
  }),
  uU = te({
    'node_modules/p-reflect/index.js'(e, r) {
      V(), F()
      var t = async (n) => {
        try {
          let i = await n
          return { isFulfilled: !0, isRejected: !1, value: i }
        } catch (i) {
          return { isFulfilled: !1, isRejected: !0, reason: i }
        }
      }
      ;(r.exports = t), (r.exports.default = t)
    }
  }),
  lU = te({
    'node_modules/p-try/index.js'(e, r) {
      V(), F()
      var t = (n, ...i) =>
        new Promise((s) => {
          s(n(...i))
        })
      ;(r.exports = t), (r.exports.default = t)
    }
  }),
  fU = te({
    'node_modules/p-settle/node_modules/p-limit/index.js'(e, r) {
      V(), F()
      var t = lU(),
        n = (i) => {
          if (!((Number.isInteger(i) || i === 1 / 0) && i > 0))
            return Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'))
          let s = [],
            u = 0,
            o = () => {
              u--, s.length > 0 && s.shift()()
            },
            l = (f, p, ...y) => {
              u++
              let d = t(f, ...y)
              p(d), d.then(o, o)
            },
            a = (f, p, ...y) => {
              u < i ? l(f, p, ...y) : s.push(l.bind(null, f, p, ...y))
            },
            c = (f, ...p) => new Promise((y) => a(f, y, ...p))
          return (
            Object.defineProperties(c, {
              activeCount: { get: () => u },
              pendingCount: { get: () => s.length },
              clearQueue: {
                value: () => {
                  s.length = 0
                }
              }
            }),
            c
          )
        }
      ;(r.exports = n), (r.exports.default = n)
    }
  }),
  dU = te({
    'node_modules/p-settle/index.js'(e, r) {
      V(), F()
      var t = uU(),
        n = fU()
      r.exports = async (i, s = {}) => {
        let { concurrency: u = 1 / 0 } = s,
          o = n(u)
        return Promise.all(
          i.map((l) =>
            l && typeof l.then == 'function' ? t(l) : typeof l == 'function' ? t(o(() => l())) : t(Promise.resolve(l))
          )
        )
      }
    }
  }),
  hU = te({
    'node_modules/libp2p/src/record/envelope/envelope.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-envelope'] || (t.roots['libp2p-envelope'] = {})
      ;(u.Envelope = (function () {
        function o(l) {
          if (l) for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
        }
        return (
          (o.prototype.publicKey = s.newBuffer([])),
          (o.prototype.payloadType = s.newBuffer([])),
          (o.prototype.payload = s.newBuffer([])),
          (o.prototype.signature = s.newBuffer([])),
          (o.encode = function (a, c) {
            return (
              c || (c = i.create()),
              a.publicKey != null && Object.hasOwnProperty.call(a, 'publicKey') && c.uint32(10).bytes(a.publicKey),
              a.payloadType != null &&
                Object.hasOwnProperty.call(a, 'payloadType') &&
                c.uint32(18).bytes(a.payloadType),
              a.payload != null && Object.hasOwnProperty.call(a, 'payload') && c.uint32(26).bytes(a.payload),
              a.signature != null && Object.hasOwnProperty.call(a, 'signature') && c.uint32(42).bytes(a.signature),
              c
            )
          }),
          (o.decode = function (a, c) {
            a instanceof n || (a = n.create(a))
            for (var f = c === void 0 ? a.len : a.pos + c, p = new u.Envelope(); a.pos < f; ) {
              var y = a.uint32()
              switch (y >>> 3) {
                case 1:
                  p.publicKey = a.bytes()
                  break
                case 2:
                  p.payloadType = a.bytes()
                  break
                case 3:
                  p.payload = a.bytes()
                  break
                case 5:
                  p.signature = a.bytes()
                  break
                default:
                  a.skipType(y & 7)
                  break
              }
            }
            return p
          }),
          (o.fromObject = function (a) {
            if (a instanceof u.Envelope) return a
            var c = new u.Envelope()
            return (
              a.publicKey != null &&
                (typeof a.publicKey == 'string'
                  ? s.base64.decode(a.publicKey, (c.publicKey = s.newBuffer(s.base64.length(a.publicKey))), 0)
                  : a.publicKey.length && (c.publicKey = a.publicKey)),
              a.payloadType != null &&
                (typeof a.payloadType == 'string'
                  ? s.base64.decode(a.payloadType, (c.payloadType = s.newBuffer(s.base64.length(a.payloadType))), 0)
                  : a.payloadType.length && (c.payloadType = a.payloadType)),
              a.payload != null &&
                (typeof a.payload == 'string'
                  ? s.base64.decode(a.payload, (c.payload = s.newBuffer(s.base64.length(a.payload))), 0)
                  : a.payload.length && (c.payload = a.payload)),
              a.signature != null &&
                (typeof a.signature == 'string'
                  ? s.base64.decode(a.signature, (c.signature = s.newBuffer(s.base64.length(a.signature))), 0)
                  : a.signature.length && (c.signature = a.signature)),
              c
            )
          }),
          (o.toObject = function (a, c) {
            c || (c = {})
            var f = {}
            return (
              c.defaults &&
                (c.bytes === String
                  ? (f.publicKey = '')
                  : ((f.publicKey = []), c.bytes !== Array && (f.publicKey = s.newBuffer(f.publicKey))),
                c.bytes === String
                  ? (f.payloadType = '')
                  : ((f.payloadType = []), c.bytes !== Array && (f.payloadType = s.newBuffer(f.payloadType))),
                c.bytes === String
                  ? (f.payload = '')
                  : ((f.payload = []), c.bytes !== Array && (f.payload = s.newBuffer(f.payload))),
                c.bytes === String
                  ? (f.signature = '')
                  : ((f.signature = []), c.bytes !== Array && (f.signature = s.newBuffer(f.signature)))),
              a.publicKey != null &&
                a.hasOwnProperty('publicKey') &&
                (f.publicKey =
                  c.bytes === String
                    ? s.base64.encode(a.publicKey, 0, a.publicKey.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.publicKey)
                    : a.publicKey),
              a.payloadType != null &&
                a.hasOwnProperty('payloadType') &&
                (f.payloadType =
                  c.bytes === String
                    ? s.base64.encode(a.payloadType, 0, a.payloadType.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.payloadType)
                    : a.payloadType),
              a.payload != null &&
                a.hasOwnProperty('payload') &&
                (f.payload =
                  c.bytes === String
                    ? s.base64.encode(a.payload, 0, a.payload.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.payload)
                    : a.payload),
              a.signature != null &&
                a.hasOwnProperty('signature') &&
                (f.signature =
                  c.bytes === String
                    ? s.base64.encode(a.signature, 0, a.signature.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.signature)
                    : a.signature),
              f
            )
          }),
          (o.prototype.toJSON = function () {
            return this.constructor.toObject(this, t.util.toJSONOptions)
          }),
          o
        )
      })()),
        (r.exports = u)
    }
  }),
  m2 = te({
    'node_modules/libp2p/src/record/envelope/index.js'(e, r) {
      V(), F()
      var t = pt(),
        n = f2(),
        i = xs(),
        s = g1(),
        u = er(),
        o = $t(),
        l = vf(),
        { codes: a } = or(),
        { Envelope: c } = hU(),
        f = class {
          constructor({ peerId: y, payloadType: d, payload: h, signature: m }) {
            ;(this.peerId = y),
              (this.payloadType = d),
              (this.payload = h),
              (this.signature = m),
              (this._marshal = void 0)
          }
          marshal() {
            if (this._marshal) return this._marshal
            let y = s.marshalPublicKey(this.peerId.pubKey)
            return (
              (this._marshal = c
                .encode({
                  publicKey: y,
                  payloadType: this.payloadType,
                  payload: this.payload,
                  signature: this.signature
                })
                .finish()),
              this._marshal
            )
          }
          equals(y) {
            return (
              l(this.peerId.pubKey.bytes, y.peerId.pubKey.bytes) &&
              l(this.payloadType, y.payloadType) &&
              l(this.payload, y.payload) &&
              l(this.signature, y.signature)
            )
          }
          validate(y) {
            let d = p(y, this.payloadType, this.payload)
            return this.peerId.pubKey.verify(d, this.signature)
          }
        },
        p = (y, d, h) => {
          let m = i(y),
            _ = o.encode(m.byteLength),
            A = o.encode(d.length),
            T = o.encode(h.length)
          return n([new Uint8Array(_), m, new Uint8Array(A), d, new Uint8Array(T), h])
        }
      ;(f.createFromProtobuf = async (y) => {
        let d = c.decode(y),
          h = await u.createFromPubKey(d.publicKey)
        return new f({ peerId: h, payloadType: d.payloadType, payload: d.payload, signature: d.signature })
      }),
        (f.seal = async (y, d) => {
          let h = y.domain,
            m = y.codec,
            _ = y.marshal(),
            A = p(h, m, _),
            T = await d.privKey.sign(A)
          return new f({ peerId: d, payloadType: m, payload: _, signature: T })
        }),
        (f.openAndCertify = async (y, d) => {
          let h = await f.createFromProtobuf(y)
          if (!(await h.validate(d)))
            throw t(new Error('envelope signature is not valid for the given domain'), a.ERR_SIGNATURE_NOT_VALID)
          return h
        }),
        (r.exports = f)
    }
  }),
  pU = te({
    'node_modules/libp2p-utils/src/array-equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        return n.length === i.length && i.sort() && n.sort().every((s, u) => i[u].equals(s))
      }
      r.exports = t
    }
  }),
  mU = te({
    'node_modules/libp2p/src/record/peer-record/peer-record.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-peer-record'] || (t.roots['libp2p-peer-record'] = {})
      ;(u.PeerRecord = (function () {
        function o(l) {
          if (((this.addresses = []), l))
            for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
        }
        return (
          (o.prototype.peerId = s.newBuffer([])),
          (o.prototype.seq = s.Long ? s.Long.fromBits(0, 0, !0) : 0),
          (o.prototype.addresses = s.emptyArray),
          (o.encode = function (a, c) {
            if (
              (c || (c = i.create()),
              a.peerId != null && Object.hasOwnProperty.call(a, 'peerId') && c.uint32(10).bytes(a.peerId),
              a.seq != null && Object.hasOwnProperty.call(a, 'seq') && c.uint32(16).uint64(a.seq),
              a.addresses != null && a.addresses.length)
            )
              for (var f = 0; f < a.addresses.length; ++f)
                u.PeerRecord.AddressInfo.encode(a.addresses[f], c.uint32(26).fork()).ldelim()
            return c
          }),
          (o.decode = function (a, c) {
            a instanceof n || (a = n.create(a))
            for (var f = c === void 0 ? a.len : a.pos + c, p = new u.PeerRecord(); a.pos < f; ) {
              var y = a.uint32()
              switch (y >>> 3) {
                case 1:
                  p.peerId = a.bytes()
                  break
                case 2:
                  p.seq = a.uint64()
                  break
                case 3:
                  ;(p.addresses && p.addresses.length) || (p.addresses = []),
                    p.addresses.push(u.PeerRecord.AddressInfo.decode(a, a.uint32()))
                  break
                default:
                  a.skipType(y & 7)
                  break
              }
            }
            return p
          }),
          (o.fromObject = function (a) {
            if (a instanceof u.PeerRecord) return a
            var c = new u.PeerRecord()
            if (
              (a.peerId != null &&
                (typeof a.peerId == 'string'
                  ? s.base64.decode(a.peerId, (c.peerId = s.newBuffer(s.base64.length(a.peerId))), 0)
                  : a.peerId.length && (c.peerId = a.peerId)),
              a.seq != null &&
                (s.Long
                  ? ((c.seq = s.Long.fromValue(a.seq)).unsigned = !0)
                  : typeof a.seq == 'string'
                  ? (c.seq = parseInt(a.seq, 10))
                  : typeof a.seq == 'number'
                  ? (c.seq = a.seq)
                  : typeof a.seq == 'object' &&
                    (c.seq = new s.LongBits(a.seq.low >>> 0, a.seq.high >>> 0).toNumber(!0))),
              a.addresses)
            ) {
              if (!Array.isArray(a.addresses)) throw TypeError('.PeerRecord.addresses: array expected')
              c.addresses = []
              for (var f = 0; f < a.addresses.length; ++f) {
                if (typeof a.addresses[f] != 'object') throw TypeError('.PeerRecord.addresses: object expected')
                c.addresses[f] = u.PeerRecord.AddressInfo.fromObject(a.addresses[f])
              }
            }
            return c
          }),
          (o.toObject = function (a, c) {
            c || (c = {})
            var f = {}
            if (((c.arrays || c.defaults) && (f.addresses = []), c.defaults))
              if (
                (c.bytes === String
                  ? (f.peerId = '')
                  : ((f.peerId = []), c.bytes !== Array && (f.peerId = s.newBuffer(f.peerId))),
                s.Long)
              ) {
                var p = new s.Long(0, 0, !0)
                f.seq = c.longs === String ? p.toString() : c.longs === Number ? p.toNumber() : p
              } else f.seq = c.longs === String ? '0' : 0
            if (
              (a.peerId != null &&
                a.hasOwnProperty('peerId') &&
                (f.peerId =
                  c.bytes === String
                    ? s.base64.encode(a.peerId, 0, a.peerId.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.peerId)
                    : a.peerId),
              a.seq != null &&
                a.hasOwnProperty('seq') &&
                (typeof a.seq == 'number'
                  ? (f.seq = c.longs === String ? String(a.seq) : a.seq)
                  : (f.seq =
                      c.longs === String
                        ? s.Long.prototype.toString.call(a.seq)
                        : c.longs === Number
                        ? new s.LongBits(a.seq.low >>> 0, a.seq.high >>> 0).toNumber(!0)
                        : a.seq)),
              a.addresses && a.addresses.length)
            ) {
              f.addresses = []
              for (var y = 0; y < a.addresses.length; ++y)
                f.addresses[y] = u.PeerRecord.AddressInfo.toObject(a.addresses[y], c)
            }
            return f
          }),
          (o.prototype.toJSON = function () {
            return this.constructor.toObject(this, t.util.toJSONOptions)
          }),
          (o.AddressInfo = (function () {
            function l(a) {
              if (a) for (var c = Object.keys(a), f = 0; f < c.length; ++f) a[c[f]] != null && (this[c[f]] = a[c[f]])
            }
            return (
              (l.prototype.multiaddr = s.newBuffer([])),
              (l.encode = function (c, f) {
                return (
                  f || (f = i.create()),
                  c.multiaddr != null && Object.hasOwnProperty.call(c, 'multiaddr') && f.uint32(10).bytes(c.multiaddr),
                  f
                )
              }),
              (l.decode = function (c, f) {
                c instanceof n || (c = n.create(c))
                for (var p = f === void 0 ? c.len : c.pos + f, y = new u.PeerRecord.AddressInfo(); c.pos < p; ) {
                  var d = c.uint32()
                  switch (d >>> 3) {
                    case 1:
                      y.multiaddr = c.bytes()
                      break
                    default:
                      c.skipType(d & 7)
                      break
                  }
                }
                return y
              }),
              (l.fromObject = function (c) {
                if (c instanceof u.PeerRecord.AddressInfo) return c
                var f = new u.PeerRecord.AddressInfo()
                return (
                  c.multiaddr != null &&
                    (typeof c.multiaddr == 'string'
                      ? s.base64.decode(c.multiaddr, (f.multiaddr = s.newBuffer(s.base64.length(c.multiaddr))), 0)
                      : c.multiaddr.length && (f.multiaddr = c.multiaddr)),
                  f
                )
              }),
              (l.toObject = function (c, f) {
                f || (f = {})
                var p = {}
                return (
                  f.defaults &&
                    (f.bytes === String
                      ? (p.multiaddr = '')
                      : ((p.multiaddr = []), f.bytes !== Array && (p.multiaddr = s.newBuffer(p.multiaddr)))),
                  c.multiaddr != null &&
                    c.hasOwnProperty('multiaddr') &&
                    (p.multiaddr =
                      f.bytes === String
                        ? s.base64.encode(c.multiaddr, 0, c.multiaddr.length)
                        : f.bytes === Array
                        ? Array.prototype.slice.call(c.multiaddr)
                        : c.multiaddr),
                  p
                )
              }),
              (l.prototype.toJSON = function () {
                return this.constructor.toObject(this, t.util.toJSONOptions)
              }),
              l
            )
          })()),
          o
        )
      })()),
        (r.exports = u)
    }
  }),
  bU = te({
    'node_modules/libp2p/src/record/peer-record/consts.js'(e, r) {
      V(), F()
      var t = h3(),
        n = t.getName(t.LIBP2P_PEER_RECORD) || 'libp2p-peer-record',
        i = Uint8Array.from([3, 1])
      r.exports = { ENVELOPE_DOMAIN_PEER_RECORD: n, ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: i }
    }
  }),
  b2 = te({
    'node_modules/libp2p/src/record/peer-record/index.js'(e, r) {
      V(), F()
      var { Multiaddr: t } = Zr(),
        n = er(),
        i = pU(),
        { PeerRecord: s } = mU(),
        { ENVELOPE_DOMAIN_PEER_RECORD: u, ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: o } = bU(),
        l = class {
          constructor({ peerId: a, multiaddrs: c = [], seqNumber: f = Date.now() }) {
            ;(this.domain = u),
              (this.codec = o),
              (this.peerId = a),
              (this.multiaddrs = c),
              (this.seqNumber = f),
              (this._marshal = void 0)
          }
          marshal() {
            return this._marshal
              ? this._marshal
              : ((this._marshal = s
                  .encode({
                    peerId: this.peerId.toBytes(),
                    seq: this.seqNumber,
                    addresses: this.multiaddrs.map((a) => ({ multiaddr: a.bytes }))
                  })
                  .finish()),
                this._marshal)
          }
          equals(a) {
            return !(
              !(a instanceof l) ||
              !this.peerId.equals(a.peerId) ||
              this.seqNumber !== a.seqNumber ||
              !i(this.multiaddrs, a.multiaddrs)
            )
          }
        }
      ;(l.createFromProtobuf = (a) => {
        let c = s.decode(a),
          f = n.createFromBytes(c.peerId),
          p = (c.addresses || []).map((d) => new t(d.multiaddr)),
          y = Number(c.seq)
        return new l({ peerId: f, multiaddrs: p, seqNumber: y })
      }),
        (l.DOMAIN = u),
        (r.exports = l)
    }
  }),
  hT = te({
    'node_modules/libp2p/src/record/utils.js'(e, r) {
      V(), F()
      var t = m2(),
        n = b2()
      async function i(s) {
        let u = new n({ peerId: s.peerId, multiaddrs: s.multiaddrs }),
          o = await t.seal(u, s.peerId)
        s.peerStore.addressBook.consumePeerRecord(o)
      }
      r.exports.updateSelfPeerRecord = i
    }
  }),
  pT = te({
    'node_modules/libp2p/src/transport-manager.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:transports'), { error: t('libp2p:transports:err') }),
        i = dU(),
        { codes: s } = or(),
        u = pt(),
        { updateSelfPeerRecord: o } = hT(),
        l = class {
          constructor({ libp2p: c, upgrader: f, faultTolerance: p = a.FATAL_ALL }) {
            ;(this.libp2p = c),
              (this.upgrader = f),
              (this._transports = new Map()),
              (this._listeners = new Map()),
              (this._listenerOptions = new Map()),
              (this.faultTolerance = p)
          }
          add(c, f, p = {}) {
            if ((n('adding %s', c), !c))
              throw u(new Error(`Transport must have a valid key, was given '${c}'`), s.ERR_INVALID_KEY)
            if (this._transports.has(c))
              throw u(new Error('There is already a transport with this key'), s.ERR_DUPLICATE_TRANSPORT)
            let y = new f({ ...p, libp2p: this.libp2p, upgrader: this.upgrader })
            this._transports.set(c, y),
              this._listenerOptions.set(c, p.listenerOptions || {}),
              this._listeners.has(c) || this._listeners.set(c, [])
          }
          async close() {
            let c = []
            for (let [f, p] of this._listeners)
              for (n('closing listeners for %s', f); p.length; ) {
                let y = p.pop()
                y.removeAllListeners('listening'), y.removeAllListeners('close'), c.push(y.close())
              }
            await Promise.all(c), n('all listeners closed')
            for (let f of this._listeners.keys()) this._listeners.set(f, [])
          }
          async dial(c, f) {
            let p = this.transportForMultiaddr(c)
            if (!p) throw u(new Error(`No transport available for address ${String(c)}`), s.ERR_TRANSPORT_UNAVAILABLE)
            try {
              return await p.dial(c, f)
            } catch (y) {
              throw (y.code || (y.code = s.ERR_TRANSPORT_DIAL_FAILED), y)
            }
          }
          getAddrs() {
            let c = []
            for (let f of this._listeners.values()) for (let p of f) c = [...c, ...p.getAddrs()]
            return c
          }
          getTransports() {
            return this._transports.values()
          }
          transportForMultiaddr(c) {
            for (let f of this._transports.values()) if (f.filter([c]).length) return f
            return null
          }
          async listen(c) {
            if (!c || c.length === 0) {
              n('no addresses were provided for listening, this node is dial only')
              return
            }
            let f = []
            for (let [p, y] of this._transports.entries()) {
              let d = y.filter(c),
                h = []
              for (let A of d) {
                n('creating listener for %s on %s', p, A)
                let T = y.createListener(this._listenerOptions.get(p))
                this._listeners.get(p).push(T),
                  T.on('listening', () => o(this.libp2p)),
                  T.on('close', () => o(this.libp2p)),
                  h.push(T.listen(A))
              }
              if (h.length === 0) {
                f.push(p)
                continue
              }
              if (!(await i(h)).find((A) => A.isFulfilled === !0) && this.faultTolerance !== a.NO_FATAL)
                throw u(
                  new Error(`Transport (${p}) could not listen on any available address`),
                  s.ERR_NO_VALID_ADDRESSES
                )
            }
            if (f.length === this._transports.size) {
              let p = `no valid addresses were provided for transports [${f}]`
              if (this.faultTolerance === a.FATAL_ALL) throw u(new Error(p), s.ERR_NO_VALID_ADDRESSES)
              n(`libp2p in dial mode only: ${p}`)
            }
          }
          async remove(c) {
            if ((n('removing %s', c), this._listeners.has(c)))
              for (let f of this._listeners.get(c))
                f.removeAllListeners('listening'), f.removeAllListeners('close'), await f.close()
            this._transports.delete(c), this._listeners.delete(c)
          }
          async removeAll() {
            let c = []
            for (let f of this._transports.keys()) c.push(this.remove(f))
            await Promise.all(c)
          }
        },
        a = { FATAL_ALL: 0, NO_FATAL: 1 }
      ;(l.FaultTolerance = a), (r.exports = l)
    }
  }),
  yU = te({
    'node_modules/libp2p/src/config.js'(e, r) {
      V(), F()
      var t = gf(),
        { dnsaddrResolver: n } = sU(),
        i = h2(),
        { AGENT_VERSION: s } = lT(),
        u = p2(),
        { publicAddressesFirst: o } = dT(),
        { FaultTolerance: l } = pT(),
        a = {
          addresses: { listen: [], announce: [], noAnnounce: [], announceFilter: (c) => c },
          connectionManager: { minConnections: 25 },
          transportManager: { faultTolerance: l.FATAL_ALL },
          dialer: {
            maxParallelDials: i.MAX_PARALLEL_DIALS,
            maxDialsPerPeer: i.MAX_PER_PEER_DIALS,
            dialTimeout: i.DIAL_TIMEOUT,
            resolvers: { dnsaddr: n },
            addressSorter: o
          },
          host: { agentVersion: s },
          metrics: { enabled: !1 },
          peerStore: { persistence: !1, threshold: 5 },
          peerRouting: { refreshManager: { enabled: !0, interval: 6e5, bootDelay: 1e4 } },
          config: {
            dht: {
              enabled: !1,
              kBucketSize: 20,
              randomWalk: { enabled: !1, queriesPerPeriod: 1, interval: 3e5, timeout: 1e4 }
            },
            nat: { enabled: !0, ttl: 7200, keepAlive: !0, gateway: null, externalIp: null, pmp: { enabled: !1 } },
            peerDiscovery: { autoDial: !0 },
            pubsub: { enabled: !0 },
            relay: {
              enabled: !0,
              advertise: { bootDelay: u.ADVERTISE_BOOT_DELAY, enabled: !1, ttl: u.ADVERTISE_TTL },
              hop: { enabled: !1, active: !1 },
              autoRelay: { enabled: !1, maxListeners: 2 }
            },
            transport: {}
          }
        }
      r.exports.validate = (c) => {
        let f = t(a, c)
        if (f.modules.transport.length < 1)
          throw new Error("'options.modules.transport' must contain at least 1 transport")
        return f
      }
    }
  }),
  vU = te({
    'node_modules/libp2p/src/address-manager/index.js'(e, r) {
      V(), F()
      var { EventEmitter: t } = ln(),
        { Multiaddr: n } = Zr(),
        i = er(),
        s = class extends t {
          constructor(u, { listen: o = [], announce: l = [] } = {}) {
            super()
            ;(this.peerId = u),
              (this.listen = new Set(o.map((a) => a.toString()))),
              (this.announce = new Set(l.map((a) => a.toString()))),
              (this.observed = new Set())
          }
          getListenAddrs() {
            return Array.from(this.listen).map((u) => new n(u))
          }
          getAnnounceAddrs() {
            return Array.from(this.announce).map((u) => new n(u))
          }
          getObservedAddrs() {
            return Array.from(this.observed).map((u) => new n(u))
          }
          addObservedAddr(u) {
            let o = new n(u),
              l = o.getPeerId()
            l && i.createFromB58String(l).equals(this.peerId) && (o = o.decapsulate(new n(`/p2p/${this.peerId}`)))
            let a = o.toString()
            this.observed.has(a) || (this.observed.add(a), this.emit('change:addresses'))
          }
        }
      r.exports = s
    }
  }),
  gU = te({
    'node_modules/libp2p/src/connection-manager/visibility-change-emitter.js'(e, r) {
      V(), F()
      var { EventEmitter: t } = ln(),
        n = mt()('latency-monitor:VisibilityChangeEmitter'),
        i = class extends t {
          constructor() {
            super()
            if (typeof document == 'undefined') {
              n('This is not a browser, no "document" found. Stopping.')
              return
            }
            this._initializeVisibilityVarNames(), this._addVisibilityChangeListener()
          }
          _initializeVisibilityVarNames() {
            let s, u
            typeof document.hidden != 'undefined'
              ? ((s = 'hidden'), (u = 'visibilitychange'))
              : typeof document.mozHidden != 'undefined'
              ? ((s = 'mozHidden'), (u = 'mozvisibilitychange'))
              : typeof document.msHidden != 'undefined'
              ? ((s = 'msHidden'), (u = 'msvisibilitychange'))
              : typeof document.webkitHidden != 'undefined' && ((s = 'webkitHidden'), (u = 'webkitvisibilitychange')),
              (this._hidden = s),
              (this._visibilityChange = u)
          }
          _addVisibilityChangeListener() {
            typeof document.addEventListener == 'undefined' || typeof document[this._hidden] == 'undefined'
              ? n('Checking page visibility requires a browser that supports the Page Visibility API.')
              : document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), !1)
          }
          isVisible() {
            if (!(this._hidden === void 0 || document[this._hidden] === void 0)) return !document[this._hidden]
          }
          _handleVisibilityChange() {
            let s = !document[this._hidden]
            n(s ? 'Page Visible' : 'Page Hidden'), this.emit('visibilityChange', s)
          }
        }
      r.exports = i
    }
  }),
  wU = te({
    'node_modules/libp2p/src/connection-manager/latency-monitor.js'(e, r) {
      V(), F()
      var { EventEmitter: t } = ln(),
        n = gU(),
        i = mt()('latency-monitor:LatencyMonitor'),
        s = class extends t {
          constructor({
            latencyCheckIntervalMs: o,
            dataEmitIntervalMs: l,
            asyncTestFn: a,
            latencyRandomPercentage: c
          } = {}) {
            super()
            let f = this
            ;(f.latencyCheckIntervalMs = o || 500),
              (f.latencyRandomPercentage = c || 10),
              (f._latecyCheckMultiply = 2 * (f.latencyRandomPercentage / 100) * f.latencyCheckIntervalMs),
              (f._latecyCheckSubtract = f._latecyCheckMultiply / 2),
              (f.dataEmitIntervalMs = l === null || l === 0 ? void 0 : l || 5 * 1e3),
              i('latencyCheckIntervalMs: %s dataEmitIntervalMs: %s', f.latencyCheckIntervalMs, f.dataEmitIntervalMs),
              f.dataEmitIntervalMs
                ? i('Expecting ~%s events per summary', f.latencyCheckIntervalMs / f.dataEmitIntervalMs)
                : i('Not emitting summaries'),
              (f.asyncTestFn = a)
          }
          start() {
            globalThis.process && globalThis.process.hrtime
              ? (i('Using process.hrtime for timing'),
                (this.now = globalThis.process.hrtime),
                (this.getDeltaMS = (o) => {
                  let l = this.now(o)
                  return l[0] * 1e3 + l[1] / 1e6
                }))
              : typeof window != 'undefined' && window.performance && window.performance.now
              ? (i('Using performance.now for timing'),
                (this.now = window.performance.now.bind(window.performance)),
                (this.getDeltaMS = (o) => Math.round(this.now() - o)))
              : (i('Using Date.now for timing'), (this.now = Date.now), (this.getDeltaMS = (o) => this.now() - o)),
              (this._latencyData = this._initLatencyData()),
              u() &&
                ((this._visibilityChangeEmitter = new n()),
                this._visibilityChangeEmitter.on('visibilityChange', (o) => {
                  o ? this._startTimers() : (this._emitSummary(), this._stopTimers())
                })),
              (!this._visibilityChangeEmitter || this._visibilityChangeEmitter.isVisible()) && this._startTimers()
          }
          stop() {
            this._stopTimers()
          }
          _startTimers() {
            this._checkLatencyID ||
              (this._checkLatency(),
              this.dataEmitIntervalMs &&
                ((this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs)),
                typeof this._emitIntervalID.unref == 'function' && this._emitIntervalID.unref()))
          }
          _stopTimers() {
            this._checkLatencyID && (clearTimeout(this._checkLatencyID), (this._checkLatencyID = void 0)),
              this._emitIntervalID && (clearInterval(this._emitIntervalID), (this._emitIntervalID = void 0))
          }
          _emitSummary() {
            let o = this.getSummary()
            o.events > 0 && this.emit('data', o)
          }
          getSummary() {
            let o = {
              events: this._latencyData.events,
              minMs: this._latencyData.minMs,
              maxMs: this._latencyData.maxMs,
              avgMs: this._latencyData.events
                ? this._latencyData.totalMs / this._latencyData.events
                : Number.POSITIVE_INFINITY,
              lengthMs: this.getDeltaMS(this._latencyData.startTime)
            }
            return (this._latencyData = this._initLatencyData()), i('Summary: %O', o), o
          }
          _checkLatency() {
            let o = this,
              l = Math.random() * o._latecyCheckMultiply - o._latecyCheckSubtract,
              a = { deltaOffset: Math.ceil(o.latencyCheckIntervalMs + l), startTime: o.now() },
              c = () => {
                if (!this._checkLatencyID) return
                let f = o.getDeltaMS(a.startTime) - a.deltaOffset
                o._checkLatency(),
                  o._latencyData.events++,
                  (o._latencyData.minMs = Math.min(o._latencyData.minMs, f)),
                  (o._latencyData.maxMs = Math.max(o._latencyData.maxMs, f)),
                  (o._latencyData.totalMs += f),
                  i('MS: %s Data: %O', f, o._latencyData)
              }
            i('localData: %O', a),
              (this._checkLatencyID = setTimeout(() => {
                o.asyncTestFn
                  ? ((a.deltaOffset = 0), (a.startTime = o.now()), o.asyncTestFn(c))
                  : ((a.deltaOffset -= 1), c())
              }, a.deltaOffset)),
              typeof this._checkLatencyID.unref == 'function' && this._checkLatencyID.unref()
          }
          _initLatencyData() {
            return {
              startTime: this.now(),
              minMs: Number.POSITIVE_INFINITY,
              maxMs: Number.NEGATIVE_INFINITY,
              events: 0,
              totalMs: 0
            }
          }
        }
      function u() {
        return typeof window != 'undefined'
      }
      r.exports = s
    }
  }),
  _U = te({
    'node_modules/retimer/time-browser.js'(e, r) {
      V(),
        F(),
        (r.exports = function () {
          return Date.now()
        })
    }
  }),
  mT = te({
    'node_modules/retimer/retimer.js'(e, r) {
      V(), F()
      var t = _U(),
        n = class {
          constructor(s, u, o) {
            let l = this
            ;(this._started = t()),
              (this._rescheduled = 0),
              (this._scheduled = u),
              (this._args = o),
              (this._triggered = !1),
              (this._timerWrapper = () => {
                l._rescheduled > 0
                  ? ((l._scheduled = l._rescheduled - (t() - l._started)), l._schedule(l._scheduled))
                  : ((l._triggered = !0), s.apply(null, l._args))
              }),
              (this._timer = setTimeout(this._timerWrapper, u))
          }
          reschedule(s) {
            s || (s = this._scheduled)
            let u = t()
            u + s - (this._started + this._scheduled) < 0
              ? (clearTimeout(this._timer), this._schedule(s))
              : this._triggered
              ? this._schedule(s)
              : ((this._started = u), (this._rescheduled = s))
          }
          _schedule(s) {
            ;(this._triggered = !1),
              (this._started = t()),
              (this._rescheduled = 0),
              (this._scheduled = s),
              (this._timer = setTimeout(this._timerWrapper, s))
          }
          clear() {
            clearTimeout(this._timer)
          }
        }
      function i() {
        if (typeof arguments[0] != 'function') throw new Error('callback needed')
        if (typeof arguments[1] != 'number') throw new Error('timeout needed')
        let s
        if (arguments.length > 0) {
          s = new Array(arguments.length - 2)
          for (var u = 0; u < s.length; u++) s[u] = arguments[u + 2]
        }
        return new n(arguments[0], arguments[1], s)
      }
      r.exports = i
    }
  }),
  EU = te({
    'node_modules/libp2p/src/connection-manager/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:connection-manager'), { error: t('libp2p:connection-manager:err') }),
        i = pt(),
        s = gf(),
        u = wU(),
        o = mT(),
        { EventEmitter: l } = ln(),
        a = er(),
        {
          codes: { ERR_INVALID_PARAMETERS: c }
        } = or(),
        f = {
          maxConnections: 1 / 0,
          minConnections: 0,
          maxData: 1 / 0,
          maxSentData: 1 / 0,
          maxReceivedData: 1 / 0,
          maxEventLoopDelay: 1 / 0,
          pollInterval: 2e3,
          autoDialInterval: 1e4,
          movingAverageInterval: 6e4,
          defaultPeerValue: 1
        },
        p = class extends l {
          constructor(y, d = {}) {
            super()
            if (
              ((this._libp2p = y),
              (this._peerId = y.peerId.toB58String()),
              (this._options = s.call({ ignoreUndefined: !0 }, f, d)),
              this._options.maxConnections < this._options.minConnections)
            )
              throw i(new Error('Connection Manager maxConnections must be greater than minConnections'), c)
            n('options: %j', this._options),
              (this._peerValues = new Map()),
              (this.connections = new Map()),
              (this._started = !1),
              (this._timer = null),
              (this._autoDialTimeout = null),
              (this._checkMetrics = this._checkMetrics.bind(this)),
              (this._autoDial = this._autoDial.bind(this)),
              (this._latencyMonitor = new u({
                latencyCheckIntervalMs: this._options.pollInterval,
                dataEmitIntervalMs: this._options.pollInterval
              }))
          }
          get size() {
            return Array.from(this.connections.values()).reduce((y, d) => y + d.length, 0)
          }
          start() {
            this._libp2p.metrics && (this._timer = this._timer || o(this._checkMetrics, this._options.pollInterval)),
              this._latencyMonitor.start(),
              (this._onLatencyMeasure = this._onLatencyMeasure.bind(this)),
              this._latencyMonitor.on('data', this._onLatencyMeasure),
              (this._started = !0),
              n('started'),
              this._options.autoDial && this._autoDial()
          }
          async stop() {
            this._autoDialTimeout && this._autoDialTimeout.clear(),
              this._timer && this._timer.clear(),
              this._latencyMonitor.removeListener('data', this._onLatencyMeasure),
              this._latencyMonitor.stop(),
              (this._started = !1),
              await this._close(),
              n('stopped')
          }
          async _close() {
            let y = []
            for (let d of this.connections.values()) for (let h of d) y.push(h.close())
            await Promise.all(y), this.connections.clear()
          }
          setPeerValue(y, d) {
            if (d < 0 || d > 1) throw new Error('value should be a number between 0 and 1')
            this._peerValues.set(y.toB58String(), d)
          }
          _checkMetrics() {
            if (this._libp2p.metrics) {
              let y = this._libp2p.metrics.global.movingAverages,
                d = y.dataReceived[this._options.movingAverageInterval].movingAverage()
              this._checkMaxLimit('maxReceivedData', d)
              let h = y.dataSent[this._options.movingAverageInterval].movingAverage()
              this._checkMaxLimit('maxSentData', h)
              let m = d + h
              this._checkMaxLimit('maxData', m),
                n('metrics update', m),
                (this._timer = o(this._checkMetrics, this._options.pollInterval))
            }
          }
          onConnect(y) {
            let d = y.remotePeer,
              h = d.toB58String(),
              m = this.connections.get(h)
            this.emit('peer:connect', y),
              m ? m.push(y) : this.connections.set(h, [y]),
              this._libp2p.peerStore.keyBook.set(d, d.pubKey),
              this._peerValues.has(h) || this._peerValues.set(h, this._options.defaultPeerValue),
              this._checkMaxLimit('maxConnections', this.size)
          }
          onDisconnect(y) {
            let d = y.remotePeer.toB58String(),
              h = this.connections.get(d)
            h && h.length > 1
              ? ((h = h.filter((m) => m.id !== y.id)), this.connections.set(d, h))
              : h &&
                (this.connections.delete(d),
                this._peerValues.delete(y.remotePeer.toB58String()),
                this.emit('peer:disconnect', y))
          }
          get(y) {
            let d = this.getAll(y)
            return d.length ? d[0] : null
          }
          getAll(y) {
            if (!a.isPeerId(y)) throw i(new Error('peerId must be an instance of peer-id'), c)
            let d = y.toB58String(),
              h = this.connections.get(d)
            return h ? h.filter((m) => m.stat.status === 'open') : []
          }
          _onLatencyMeasure(y) {
            this._checkMaxLimit('maxEventLoopDelay', y.avgMs)
          }
          _checkMaxLimit(y, d) {
            let h = this._options[y]
            n('checking limit of %s. current value: %d of %d', y, d, h),
              d > h && (n('%s: limit exceeded: %s, %d', this._peerId, y, d), this._maybeDisconnectOne())
          }
          async _autoDial() {
            let y = this._options.minConnections
            if (this.size >= y) {
              this._autoDialTimeout = o(this._autoDial, this._options.autoDialInterval)
              return
            }
            let d = Array.from(this._libp2p.peerStore.peers.values()).sort((h, m) =>
              (m.protocols && m.protocols.length && (!h.protocols || !h.protocols.length)) ||
              (m.id.pubKey && !h.id.pubKey)
                ? 1
                : -1
            )
            for (let h = 0; h < d.length && this.size < y; h++)
              if (!this.get(d[h].id)) {
                n('connecting to a peerStore stored peer %s', d[h].id.toB58String())
                try {
                  if ((await this._libp2p.dialer.connectToPeer(d[h].id), !this._started)) return
                } catch (m) {
                  n.error('could not connect to peerStore stored peer', m)
                }
              }
            this._autoDialTimeout = o(this._autoDial, this._options.autoDialInterval)
          }
          _maybeDisconnectOne() {
            if (this._options.minConnections < this.connections.size) {
              let y = Array.from(new Map([...this._peerValues.entries()].sort((h, m) => h[1] - m[1])))
              n('%s: sorted peer values: %j', this._peerId, y)
              let d = y[0]
              if (d) {
                let h = d[0]
                n('%s: lowest value peer is %s', this._peerId, h), n('%s: closing a connection to %j', this._peerId, h)
                for (let m of this.connections.values())
                  if (m[0].remotePeer.toB58String() === h) {
                    m[0].close()
                    break
                  }
              }
            }
          }
        }
      r.exports = p
    }
  }),
  ou = te({
    'node_modules/libp2p/src/circuit/protocol/index.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-circuit'] || (t.roots['libp2p-circuit'] = {})
      ;(u.CircuitRelay = (function () {
        function o(l) {
          if (l) for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
        }
        return (
          (o.prototype.type = 1),
          (o.prototype.srcPeer = null),
          (o.prototype.dstPeer = null),
          (o.prototype.code = 100),
          (o.encode = function (a, c) {
            return (
              c || (c = i.create()),
              a.type != null && Object.hasOwnProperty.call(a, 'type') && c.uint32(8).int32(a.type),
              a.srcPeer != null &&
                Object.hasOwnProperty.call(a, 'srcPeer') &&
                u.CircuitRelay.Peer.encode(a.srcPeer, c.uint32(18).fork()).ldelim(),
              a.dstPeer != null &&
                Object.hasOwnProperty.call(a, 'dstPeer') &&
                u.CircuitRelay.Peer.encode(a.dstPeer, c.uint32(26).fork()).ldelim(),
              a.code != null && Object.hasOwnProperty.call(a, 'code') && c.uint32(32).int32(a.code),
              c
            )
          }),
          (o.decode = function (a, c) {
            a instanceof n || (a = n.create(a))
            for (var f = c === void 0 ? a.len : a.pos + c, p = new u.CircuitRelay(); a.pos < f; ) {
              var y = a.uint32()
              switch (y >>> 3) {
                case 1:
                  p.type = a.int32()
                  break
                case 2:
                  p.srcPeer = u.CircuitRelay.Peer.decode(a, a.uint32())
                  break
                case 3:
                  p.dstPeer = u.CircuitRelay.Peer.decode(a, a.uint32())
                  break
                case 4:
                  p.code = a.int32()
                  break
                default:
                  a.skipType(y & 7)
                  break
              }
            }
            return p
          }),
          (o.fromObject = function (a) {
            if (a instanceof u.CircuitRelay) return a
            var c = new u.CircuitRelay()
            switch (a.type) {
              case 'HOP':
              case 1:
                c.type = 1
                break
              case 'STOP':
              case 2:
                c.type = 2
                break
              case 'STATUS':
              case 3:
                c.type = 3
                break
              case 'CAN_HOP':
              case 4:
                c.type = 4
                break
            }
            if (a.srcPeer != null) {
              if (typeof a.srcPeer != 'object') throw TypeError('.CircuitRelay.srcPeer: object expected')
              c.srcPeer = u.CircuitRelay.Peer.fromObject(a.srcPeer)
            }
            if (a.dstPeer != null) {
              if (typeof a.dstPeer != 'object') throw TypeError('.CircuitRelay.dstPeer: object expected')
              c.dstPeer = u.CircuitRelay.Peer.fromObject(a.dstPeer)
            }
            switch (a.code) {
              case 'SUCCESS':
              case 100:
                c.code = 100
                break
              case 'HOP_SRC_ADDR_TOO_LONG':
              case 220:
                c.code = 220
                break
              case 'HOP_DST_ADDR_TOO_LONG':
              case 221:
                c.code = 221
                break
              case 'HOP_SRC_MULTIADDR_INVALID':
              case 250:
                c.code = 250
                break
              case 'HOP_DST_MULTIADDR_INVALID':
              case 251:
                c.code = 251
                break
              case 'HOP_NO_CONN_TO_DST':
              case 260:
                c.code = 260
                break
              case 'HOP_CANT_DIAL_DST':
              case 261:
                c.code = 261
                break
              case 'HOP_CANT_OPEN_DST_STREAM':
              case 262:
                c.code = 262
                break
              case 'HOP_CANT_SPEAK_RELAY':
              case 270:
                c.code = 270
                break
              case 'HOP_CANT_RELAY_TO_SELF':
              case 280:
                c.code = 280
                break
              case 'STOP_SRC_ADDR_TOO_LONG':
              case 320:
                c.code = 320
                break
              case 'STOP_DST_ADDR_TOO_LONG':
              case 321:
                c.code = 321
                break
              case 'STOP_SRC_MULTIADDR_INVALID':
              case 350:
                c.code = 350
                break
              case 'STOP_DST_MULTIADDR_INVALID':
              case 351:
                c.code = 351
                break
              case 'STOP_RELAY_REFUSED':
              case 390:
                c.code = 390
                break
              case 'MALFORMED_MESSAGE':
              case 400:
                c.code = 400
                break
            }
            return c
          }),
          (o.toObject = function (a, c) {
            c || (c = {})
            var f = {}
            return (
              c.defaults &&
                ((f.type = c.enums === String ? 'HOP' : 1),
                (f.srcPeer = null),
                (f.dstPeer = null),
                (f.code = c.enums === String ? 'SUCCESS' : 100)),
              a.type != null &&
                a.hasOwnProperty('type') &&
                (f.type = c.enums === String ? u.CircuitRelay.Type[a.type] : a.type),
              a.srcPeer != null &&
                a.hasOwnProperty('srcPeer') &&
                (f.srcPeer = u.CircuitRelay.Peer.toObject(a.srcPeer, c)),
              a.dstPeer != null &&
                a.hasOwnProperty('dstPeer') &&
                (f.dstPeer = u.CircuitRelay.Peer.toObject(a.dstPeer, c)),
              a.code != null &&
                a.hasOwnProperty('code') &&
                (f.code = c.enums === String ? u.CircuitRelay.Status[a.code] : a.code),
              f
            )
          }),
          (o.prototype.toJSON = function () {
            return this.constructor.toObject(this, t.util.toJSONOptions)
          }),
          (o.Status = (function () {
            var l = {},
              a = Object.create(l)
            return (
              (a[(l[100] = 'SUCCESS')] = 100),
              (a[(l[220] = 'HOP_SRC_ADDR_TOO_LONG')] = 220),
              (a[(l[221] = 'HOP_DST_ADDR_TOO_LONG')] = 221),
              (a[(l[250] = 'HOP_SRC_MULTIADDR_INVALID')] = 250),
              (a[(l[251] = 'HOP_DST_MULTIADDR_INVALID')] = 251),
              (a[(l[260] = 'HOP_NO_CONN_TO_DST')] = 260),
              (a[(l[261] = 'HOP_CANT_DIAL_DST')] = 261),
              (a[(l[262] = 'HOP_CANT_OPEN_DST_STREAM')] = 262),
              (a[(l[270] = 'HOP_CANT_SPEAK_RELAY')] = 270),
              (a[(l[280] = 'HOP_CANT_RELAY_TO_SELF')] = 280),
              (a[(l[320] = 'STOP_SRC_ADDR_TOO_LONG')] = 320),
              (a[(l[321] = 'STOP_DST_ADDR_TOO_LONG')] = 321),
              (a[(l[350] = 'STOP_SRC_MULTIADDR_INVALID')] = 350),
              (a[(l[351] = 'STOP_DST_MULTIADDR_INVALID')] = 351),
              (a[(l[390] = 'STOP_RELAY_REFUSED')] = 390),
              (a[(l[400] = 'MALFORMED_MESSAGE')] = 400),
              a
            )
          })()),
          (o.Type = (function () {
            var l = {},
              a = Object.create(l)
            return (
              (a[(l[1] = 'HOP')] = 1),
              (a[(l[2] = 'STOP')] = 2),
              (a[(l[3] = 'STATUS')] = 3),
              (a[(l[4] = 'CAN_HOP')] = 4),
              a
            )
          })()),
          (o.Peer = (function () {
            function l(a) {
              if (((this.addrs = []), a))
                for (var c = Object.keys(a), f = 0; f < c.length; ++f) a[c[f]] != null && (this[c[f]] = a[c[f]])
            }
            return (
              (l.prototype.id = s.newBuffer([])),
              (l.prototype.addrs = s.emptyArray),
              (l.encode = function (c, f) {
                if ((f || (f = i.create()), f.uint32(10).bytes(c.id), c.addrs != null && c.addrs.length))
                  for (var p = 0; p < c.addrs.length; ++p) f.uint32(18).bytes(c.addrs[p])
                return f
              }),
              (l.decode = function (c, f) {
                c instanceof n || (c = n.create(c))
                for (var p = f === void 0 ? c.len : c.pos + f, y = new u.CircuitRelay.Peer(); c.pos < p; ) {
                  var d = c.uint32()
                  switch (d >>> 3) {
                    case 1:
                      y.id = c.bytes()
                      break
                    case 2:
                      ;(y.addrs && y.addrs.length) || (y.addrs = []), y.addrs.push(c.bytes())
                      break
                    default:
                      c.skipType(d & 7)
                      break
                  }
                }
                if (!y.hasOwnProperty('id')) throw s.ProtocolError("missing required 'id'", { instance: y })
                return y
              }),
              (l.fromObject = function (c) {
                if (c instanceof u.CircuitRelay.Peer) return c
                var f = new u.CircuitRelay.Peer()
                if (
                  (c.id != null &&
                    (typeof c.id == 'string'
                      ? s.base64.decode(c.id, (f.id = s.newBuffer(s.base64.length(c.id))), 0)
                      : c.id.length && (f.id = c.id)),
                  c.addrs)
                ) {
                  if (!Array.isArray(c.addrs)) throw TypeError('.CircuitRelay.Peer.addrs: array expected')
                  f.addrs = []
                  for (var p = 0; p < c.addrs.length; ++p)
                    typeof c.addrs[p] == 'string'
                      ? s.base64.decode(c.addrs[p], (f.addrs[p] = s.newBuffer(s.base64.length(c.addrs[p]))), 0)
                      : c.addrs[p].length && (f.addrs[p] = c.addrs[p])
                }
                return f
              }),
              (l.toObject = function (c, f) {
                f || (f = {})
                var p = {}
                if (
                  ((f.arrays || f.defaults) && (p.addrs = []),
                  f.defaults &&
                    (f.bytes === String ? (p.id = '') : ((p.id = []), f.bytes !== Array && (p.id = s.newBuffer(p.id)))),
                  c.id != null &&
                    c.hasOwnProperty('id') &&
                    (p.id =
                      f.bytes === String
                        ? s.base64.encode(c.id, 0, c.id.length)
                        : f.bytes === Array
                        ? Array.prototype.slice.call(c.id)
                        : c.id),
                  c.addrs && c.addrs.length)
                ) {
                  p.addrs = []
                  for (var y = 0; y < c.addrs.length; ++y)
                    p.addrs[y] =
                      f.bytes === String
                        ? s.base64.encode(c.addrs[y], 0, c.addrs[y].length)
                        : f.bytes === Array
                        ? Array.prototype.slice.call(c.addrs[y])
                        : c.addrs[y]
                }
                return p
              }),
              (l.prototype.toJSON = function () {
                return this.constructor.toObject(this, t.util.toJSONOptions)
              }),
              l
            )
          })()),
          o
        )
      })()),
        (r.exports = u)
    }
  }),
  SU = te({
    'node_modules/libp2p-utils/src/stream-to-ma-conn.js'(e, r) {
      V(), F()
      var { source: t } = Ui(),
        n = mt(),
        i = n('libp2p:stream:converter')
      function s({ stream: u, remoteAddr: o, localAddr: l }, a = {}) {
        let { sink: c, source: f } = u,
          p = {
            async sink(d) {
              a.signal && (d = t(d, a.signal))
              try {
                await c(d)
              } catch (h) {
                h.type !== 'aborted' && i(h)
              }
              y()
            },
            source: a.signal ? t(f, a.signal) : f,
            conn: u,
            localAddr: l,
            remoteAddr: o,
            timeline: { open: Date.now(), close: void 0 },
            close() {
              return c(new Uint8Array(0)), y()
            }
          }
        function y() {
          return p.timeline.close || (p.timeline.close = Date.now()), Promise.resolve()
        }
        return p
      }
      r.exports = s
    }
  }),
  _f = te({
    'node_modules/libp2p/src/circuit/multicodec.js'(e, r) {
      V(), F(), (r.exports = { relay: '/libp2p/circuit/relay/0.1.0' })
    }
  }),
  AU = te({
    'node_modules/libp2p/src/circuit/listener.js'(e, r) {
      V(), F()
      var { EventEmitter: t } = ln(),
        { Multiaddr: n } = Zr()
      r.exports = (i) => {
        let s = new Map()
        async function u(a) {
          let c = String(a)
              .split('/p2p-circuit')
              .find((y) => y !== ''),
            f = await i.dial(new n(c)),
            p = f.remoteAddr.encapsulate('/p2p-circuit')
          s.set(f.remotePeer.toB58String(), p), l.emit('listening')
        }
        function o() {
          let a = []
          for (let c of s.values()) a.push(c)
          return a
        }
        let l = Object.assign(new t(), { close: () => Promise.resolve(), listen: u, getAddrs: o })
        return (
          i.connectionManager.on('peer:disconnect', (a) => {
            s.delete(a.remotePeer.toB58String()) && l.emit('close')
          }),
          l
        )
      }
    }
  }),
  bT = te({
    'node_modules/libp2p/src/circuit/circuit/utils.js'(e, r) {
      V(), F()
      var { Multiaddr: t } = Zr(),
        { CircuitRelay: n } = ou()
      function i(u, o) {
        u.write({ type: n.Type.STATUS, code: o })
      }
      function s(u, o) {
        try {
          u.dstPeer && u.dstPeer.addrs && u.dstPeer.addrs.forEach((l) => new t(l))
        } catch (l) {
          throw (
            (i(o, u.type === n.Type.HOP ? n.Status.HOP_DST_MULTIADDR_INVALID : n.Status.STOP_DST_MULTIADDR_INVALID), l)
          )
        }
        try {
          u.srcPeer && u.srcPeer.addrs && u.srcPeer.addrs.forEach((l) => new t(l))
        } catch (l) {
          throw (
            (i(o, u.type === n.Type.HOP ? n.Status.HOP_SRC_MULTIADDR_INVALID : n.Status.STOP_SRC_MULTIADDR_INVALID), l)
          )
        }
      }
      r.exports = { validateAddrs: s }
    }
  }),
  y2 = te({
    'node_modules/libp2p/src/circuit/circuit/stream-handler.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:circuit:stream-handler'), { error: t('libp2p:circuit:stream-handler:err') }),
        i = Zc(),
        s = Yc(),
        { CircuitRelay: u } = ou(),
        o = class {
          constructor({ stream: l, maxLength: a = 4096 }) {
            ;(this.stream = l),
              (this.shake = s(this.stream)),
              (this.decoder = i.decode.fromReader(this.shake.reader, { maxDataLength: a }))
          }
          async read() {
            let l = await this.decoder.next()
            if (l.value) {
              let a = u.decode(l.value.slice())
              return n('read message type', a.type), a
            }
            n('read received no value, closing stream'), this.close()
          }
          write(l) {
            n('write message type %s', l.type), this.shake.write(i.encode.single(u.encode(l).finish()))
          }
          rest() {
            return this.shake.rest(), this.shake.stream
          }
          end(l) {
            this.write(l), this.close()
          }
          close() {
            n('closing the stream'), this.rest().sink([])
          }
        }
      r.exports = o
    }
  }),
  yT = te({
    'node_modules/libp2p/src/circuit/circuit/stop.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:circuit:stop'), { error: t('libp2p:circuit:stop:err') }),
        { CircuitRelay: i } = ou(),
        s = _f(),
        u = y2(),
        { validateAddrs: o } = bT()
      ;(r.exports.handleStop = function ({ connection: a, request: c, streamHandler: f }) {
        try {
          o(c, f)
        } catch (p) {
          return n.error('invalid stop request via peer %s', a.remotePeer.toB58String(), p)
        }
        return n('stop request is valid'), f.write({ type: i.Type.STATUS, code: i.Status.SUCCESS }), f.rest()
      }),
        (r.exports.stop = async function ({ connection: a, request: c }) {
          let { stream: f } = await a.newStream([s.relay])
          n('starting stop request to %s', a.remotePeer.toB58String())
          let p = new u({ stream: f })
          p.write(c)
          let y = await p.read()
          if (!y) return p.close()
          if (y.code === i.Status.SUCCESS)
            return n('stop request to %s was successful', a.remotePeer.toB58String()), p.rest()
          n('stop request failed with code %d', y.code), p.close()
        })
    }
  }),
  vT = te({
    'node_modules/libp2p/src/circuit/circuit/hop.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:circuit:hop'), { error: t('libp2p:circuit:hop:err') }),
        i = pt(),
        s = er(),
        { validateAddrs: u } = bT(),
        o = y2(),
        { CircuitRelay: l } = ou(),
        { pipe: a } = wn(),
        { codes: c } = or(),
        { stop: f } = yT(),
        p = _f()
      async function y({ connection: _, request: A, streamHandler: T, circuit: E }) {
        if (!E._options.hop.enabled)
          return (
            n('HOP request received but we are not acting as a relay'),
            T.end({ type: l.Type.STATUS, code: l.Status.HOP_CANT_SPEAK_RELAY })
          )
        try {
          u(A, T)
        } catch (q) {
          return n.error('invalid hop request via peer %s', _.remotePeer.toB58String(), q)
        }
        if (!A.dstPeer) {
          n('HOP request received but we do not receive a dstPeer')
          return
        }
        let k = new s(A.dstPeer.id),
          w = E._connectionManager.get(k)
        if (!w && !E._options.hop.active)
          return (
            n('HOP request received but we are not connected to the destination peer'),
            T.end({ type: l.Type.STATUS, code: l.Status.HOP_NO_CONN_TO_DST })
          )
        if (!w) return
        let v = { type: l.Type.STOP, dstPeer: A.dstPeer, srcPeer: A.srcPeer },
          I
        try {
          I = await f({ connection: w, request: v })
        } catch (q) {
          return n.error(q)
        }
        n('hop request from %s is valid', _.remotePeer.toB58String()),
          T.write({ type: l.Type.STATUS, code: l.Status.SUCCESS })
        let M = T.rest()
        return a(M, I, M)
      }
      async function d({ connection: _, request: A }) {
        let { stream: T } = await _.newStream([p.relay]),
          E = new o({ stream: T })
        E.write(A)
        let k = await E.read()
        if (!k) throw i(new Error('HOP request had no response'), c.ERR_HOP_REQUEST_FAILED)
        if (k.code === l.Status.SUCCESS) return n('hop request was successful'), E.rest()
        throw (
          (n('hop request failed with code %d, closing stream', k.code),
          E.close(),
          i(new Error(`HOP request failed with code ${k.code}`), c.ERR_HOP_REQUEST_FAILED))
        )
      }
      async function h({ connection: _ }) {
        let { stream: A } = await _.newStream([p.relay]),
          T = new o({ stream: A })
        T.write({ type: l.Type.CAN_HOP })
        let E = await T.read()
        return await T.close(), !(!E || E.code !== l.Status.SUCCESS)
      }
      function m({ connection: _, streamHandler: A, circuit: T }) {
        let E = T._options.hop.enabled
        n('can hop (%s) request from %s', E, _.remotePeer.toB58String()),
          A.end({ type: l.Type.STATUS, code: E ? l.Status.SUCCESS : l.Status.HOP_CANT_SPEAK_RELAY })
      }
      r.exports = { handleHop: y, hop: d, canHop: h, handleCanHop: m }
    }
  }),
  IU = te({
    'node_modules/libp2p/src/circuit/transport.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:circuit'), { error: t('libp2p:circuit:err') }),
        i = pt(),
        s = xp(),
        { Multiaddr: u } = Zr(),
        o = er(),
        { CircuitRelay: l } = ou(),
        { codes: a } = or(),
        c = SU(),
        { relay: f } = _f(),
        p = AU(),
        { handleCanHop: y, handleHop: d, hop: h } = vT(),
        { handleStop: m } = yT(),
        _ = y2(),
        A = Symbol.for('@libp2p/js-libp2p-circuit/circuit'),
        T = class {
          constructor({ libp2p: E, upgrader: k }) {
            ;(this._dialer = E.dialer),
              (this._registrar = E.registrar),
              (this._connectionManager = E.connectionManager),
              (this._upgrader = k),
              (this._options = E._config.relay),
              (this._libp2p = E),
              (this.peerId = E.peerId),
              this._registrar.handle(f, this._onProtocol.bind(this))
          }
          async _onProtocol({ connection: E, stream: k }) {
            let w = new _({ stream: k }),
              v = await w.read()
            if (!v) return
            let I = this,
              M
            switch (v.type) {
              case l.Type.CAN_HOP: {
                n('received CAN_HOP request from %s', E.remotePeer.toB58String()),
                  await y({ circuit: I, connection: E, streamHandler: w })
                break
              }
              case l.Type.HOP: {
                n('received HOP request from %s', E.remotePeer.toB58String()),
                  (M = await d({ connection: E, request: v, streamHandler: w, circuit: I }))
                break
              }
              case l.Type.STOP: {
                n('received STOP request from %s', E.remotePeer.toB58String()),
                  (M = await m({ connection: E, request: v, streamHandler: w }))
                break
              }
              default:
                n('Request of type %s not supported', v.type)
            }
            if (M) {
              let q = new u(v.dstPeer.addrs[0]),
                G = new u(v.srcPeer.addrs[0]),
                O = c({ stream: M, remoteAddr: q, localAddr: G }),
                x = v.type === l.Type.HOP ? 'relay' : 'inbound'
              n('new %s connection %s', x, O.remoteAddr)
              let L = await this._upgrader.upgradeInbound(O)
              n('%s connection %s upgraded', x, O.remoteAddr), this.handler && this.handler(L)
            }
          }
          async dial(E, k) {
            let w = E.toString().split('/p2p-circuit'),
              v = new u(w[0]),
              I = new u(w[w.length - 1]),
              M = v.getPeerId(),
              q = I.getPeerId()
            if (!M || !q) {
              let K = 'Circuit relay dial failed as addresses did not have peer id'
              throw (n.error(K), i(new Error(K), a.ERR_RELAYED_DIAL))
            }
            let G = o.createFromCID(M),
              O = o.createFromCID(q),
              x = !1,
              L = this._connectionManager.get(G)
            L || ((L = await this._dialer.connectToPeer(v, k)), (x = !0))
            try {
              let K = await h({
                  connection: L,
                  request: {
                    type: l.Type.HOP,
                    srcPeer: { id: this.peerId.toBytes(), addrs: this._libp2p.multiaddrs.map((Q) => Q.bytes) },
                    dstPeer: { id: O.toBytes(), addrs: [new u(I).bytes] }
                  }
                }),
                J = v.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`),
                Z = c({ stream: K, remoteAddr: E, localAddr: J })
              return n('new outbound connection %s', Z.remoteAddr), this._upgrader.upgradeOutbound(Z)
            } catch (K) {
              throw (n.error('Circuit relay dial failed', K), x && (await L.close()), K)
            }
          }
          createListener(E, k) {
            return typeof E == 'function' && ((k = E), (E = {})), (this.handler = k), p(this._libp2p)
          }
          filter(E) {
            return (E = Array.isArray(E) ? E : [E]), E.filter((k) => s.Circuit.matches(k))
          }
          get [Symbol.toStringTag]() {
            return 'Circuit'
          }
          static isTransport(E) {
            return Boolean(E && E[A])
          }
        }
      r.exports = T
    }
  }),
  TU = te({
    'node_modules/js-sha3/src/sha3.js'(e, r) {
      V(),
        F(),
        (function () {
          'use strict'
          var t = 'input is invalid type',
            n = 'finalize already called',
            i = typeof window == 'object',
            s = i ? window : {}
          s.JS_SHA3_NO_WINDOW && (i = !1)
          var u = !i && typeof self == 'object',
            o = !s.JS_SHA3_NO_NODE_JS && typeof lt == 'object' && lt.versions && lt.versions.node
          o ? (s = globalThis) : u && (s = self)
          var l = !s.JS_SHA3_NO_COMMON_JS && typeof r == 'object' && r.exports,
            a = typeof define == 'function' && define.amd,
            c = !s.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer != 'undefined',
            f = '0123456789abcdef'.split(''),
            p = [31, 7936, 2031616, 520093696],
            y = [4, 1024, 262144, 67108864],
            d = [1, 256, 65536, 16777216],
            h = [6, 1536, 393216, 100663296],
            m = [0, 8, 16, 24],
            _ = [
              1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545,
              2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139,
              2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0,
              2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648
            ],
            A = [224, 256, 384, 512],
            T = [128, 256],
            E = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'],
            k = { 128: 168, 256: 136 }
          ;(s.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
            (Array.isArray = function (oe) {
              return Object.prototype.toString.call(oe) === '[object Array]'
            }),
            c &&
              (s.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
              (ArrayBuffer.isView = function (oe) {
                return typeof oe == 'object' && oe.buffer && oe.buffer.constructor === ArrayBuffer
              })
          for (
            var w = function (oe, be, ge) {
                return function (re) {
                  return new _e(oe, be, oe).update(re)[ge]()
                }
              },
              v = function (oe, be, ge) {
                return function (re, j) {
                  return new _e(oe, be, j).update(re)[ge]()
                }
              },
              I = function (oe, be, ge) {
                return function (re, j, b, C) {
                  return J['cshake' + oe].update(re, j, b, C)[ge]()
                }
              },
              M = function (oe, be, ge) {
                return function (re, j, b, C) {
                  return J['kmac' + oe].update(re, j, b, C)[ge]()
                }
              },
              q = function (oe, be, ge, re) {
                for (var j = 0; j < E.length; ++j) {
                  var b = E[j]
                  oe[b] = be(ge, re, b)
                }
                return oe
              },
              G = function (oe, be) {
                var ge = w(oe, be, 'hex')
                return (
                  (ge.create = function () {
                    return new _e(oe, be, oe)
                  }),
                  (ge.update = function (re) {
                    return ge.create().update(re)
                  }),
                  q(ge, w, oe, be)
                )
              },
              O = function (oe, be) {
                var ge = v(oe, be, 'hex')
                return (
                  (ge.create = function (re) {
                    return new _e(oe, be, re)
                  }),
                  (ge.update = function (re, j) {
                    return ge.create(j).update(re)
                  }),
                  q(ge, v, oe, be)
                )
              },
              x = function (oe, be) {
                var ge = k[oe],
                  re = I(oe, be, 'hex')
                return (
                  (re.create = function (j, b, C) {
                    return !b && !C ? J['shake' + oe].create(j) : new _e(oe, be, j).bytepad([b, C], ge)
                  }),
                  (re.update = function (j, b, C, S) {
                    return re.create(b, C, S).update(j)
                  }),
                  q(re, I, oe, be)
                )
              },
              L = function (oe, be) {
                var ge = k[oe],
                  re = M(oe, be, 'hex')
                return (
                  (re.create = function (j, b, C) {
                    return new Ne(oe, be, b).bytepad(['KMAC', C], ge).bytepad([j], ge)
                  }),
                  (re.update = function (j, b, C, S) {
                    return re.create(j, C, S).update(b)
                  }),
                  q(re, M, oe, be)
                )
              },
              K = [
                { name: 'keccak', padding: d, bits: A, createMethod: G },
                { name: 'sha3', padding: h, bits: A, createMethod: G },
                { name: 'shake', padding: p, bits: T, createMethod: O },
                { name: 'cshake', padding: y, bits: T, createMethod: x },
                { name: 'kmac', padding: y, bits: T, createMethod: L }
              ],
              J = {},
              Z = [],
              Q = 0;
            Q < K.length;
            ++Q
          )
            for (var fe = K[Q], ie = fe.bits, W = 0; W < ie.length; ++W) {
              var le = fe.name + '_' + ie[W]
              if ((Z.push(le), (J[le] = fe.createMethod(ie[W], fe.padding)), fe.name !== 'sha3')) {
                var xe = fe.name + ie[W]
                Z.push(xe), (J[xe] = J[le])
              }
            }
          function _e(oe, be, ge) {
            ;(this.blocks = []),
              (this.s = []),
              (this.padding = be),
              (this.outputBits = ge),
              (this.reset = !0),
              (this.finalized = !1),
              (this.block = 0),
              (this.start = 0),
              (this.blockCount = (1600 - (oe << 1)) >> 5),
              (this.byteCount = this.blockCount << 2),
              (this.outputBlocks = ge >> 5),
              (this.extraBytes = (ge & 31) >> 3)
            for (var re = 0; re < 50; ++re) this.s[re] = 0
          }
          ;(_e.prototype.update = function (oe) {
            if (this.finalized) throw new Error(n)
            var be,
              ge = typeof oe
            if (ge !== 'string') {
              if (ge === 'object') {
                if (oe === null) throw new Error(t)
                if (c && oe.constructor === ArrayBuffer) oe = new Uint8Array(oe)
                else if (!Array.isArray(oe) && (!c || !ArrayBuffer.isView(oe))) throw new Error(t)
              } else throw new Error(t)
              be = !0
            }
            for (
              var re = this.blocks, j = this.byteCount, b = oe.length, C = this.blockCount, S = 0, R = this.s, P, B;
              S < b;

            ) {
              if (this.reset) for (this.reset = !1, re[0] = this.block, P = 1; P < C + 1; ++P) re[P] = 0
              if (be) for (P = this.start; S < b && P < j; ++S) re[P >> 2] |= oe[S] << m[P++ & 3]
              else
                for (P = this.start; S < b && P < j; ++S)
                  (B = oe.charCodeAt(S)),
                    B < 128
                      ? (re[P >> 2] |= B << m[P++ & 3])
                      : B < 2048
                      ? ((re[P >> 2] |= (192 | (B >> 6)) << m[P++ & 3]), (re[P >> 2] |= (128 | (B & 63)) << m[P++ & 3]))
                      : B < 55296 || B >= 57344
                      ? ((re[P >> 2] |= (224 | (B >> 12)) << m[P++ & 3]),
                        (re[P >> 2] |= (128 | ((B >> 6) & 63)) << m[P++ & 3]),
                        (re[P >> 2] |= (128 | (B & 63)) << m[P++ & 3]))
                      : ((B = 65536 + (((B & 1023) << 10) | (oe.charCodeAt(++S) & 1023))),
                        (re[P >> 2] |= (240 | (B >> 18)) << m[P++ & 3]),
                        (re[P >> 2] |= (128 | ((B >> 12) & 63)) << m[P++ & 3]),
                        (re[P >> 2] |= (128 | ((B >> 6) & 63)) << m[P++ & 3]),
                        (re[P >> 2] |= (128 | (B & 63)) << m[P++ & 3]))
              if (((this.lastByteIndex = P), P >= j)) {
                for (this.start = P - j, this.block = re[C], P = 0; P < C; ++P) R[P] ^= re[P]
                ke(R), (this.reset = !0)
              } else this.start = P
            }
            return this
          }),
            (_e.prototype.encode = function (oe, be) {
              var ge = oe & 255,
                re = 1,
                j = [ge]
              for (oe = oe >> 8, ge = oe & 255; ge > 0; ) j.unshift(ge), (oe = oe >> 8), (ge = oe & 255), ++re
              return be ? j.push(re) : j.unshift(re), this.update(j), j.length
            }),
            (_e.prototype.encodeString = function (oe) {
              var be,
                ge = typeof oe
              if (ge !== 'string') {
                if (ge === 'object') {
                  if (oe === null) throw new Error(t)
                  if (c && oe.constructor === ArrayBuffer) oe = new Uint8Array(oe)
                  else if (!Array.isArray(oe) && (!c || !ArrayBuffer.isView(oe))) throw new Error(t)
                } else throw new Error(t)
                be = !0
              }
              var re = 0,
                j = oe.length
              if (be) re = j
              else
                for (var b = 0; b < oe.length; ++b) {
                  var C = oe.charCodeAt(b)
                  C < 128
                    ? (re += 1)
                    : C < 2048
                    ? (re += 2)
                    : C < 55296 || C >= 57344
                    ? (re += 3)
                    : ((C = 65536 + (((C & 1023) << 10) | (oe.charCodeAt(++b) & 1023))), (re += 4))
                }
              return (re += this.encode(re * 8)), this.update(oe), re
            }),
            (_e.prototype.bytepad = function (oe, be) {
              for (var ge = this.encode(be), re = 0; re < oe.length; ++re) ge += this.encodeString(oe[re])
              var j = be - (ge % be),
                b = []
              return (b.length = j), this.update(b), this
            }),
            (_e.prototype.finalize = function () {
              if (!this.finalized) {
                this.finalized = !0
                var oe = this.blocks,
                  be = this.lastByteIndex,
                  ge = this.blockCount,
                  re = this.s
                if (((oe[be >> 2] |= this.padding[be & 3]), this.lastByteIndex === this.byteCount))
                  for (oe[0] = oe[ge], be = 1; be < ge + 1; ++be) oe[be] = 0
                for (oe[ge - 1] |= 2147483648, be = 0; be < ge; ++be) re[be] ^= oe[be]
                ke(re)
              }
            }),
            (_e.prototype.toString = _e.prototype.hex =
              function () {
                this.finalize()
                for (
                  var oe = this.blockCount,
                    be = this.s,
                    ge = this.outputBlocks,
                    re = this.extraBytes,
                    j = 0,
                    b = 0,
                    C = '',
                    S;
                  b < ge;

                ) {
                  for (j = 0; j < oe && b < ge; ++j, ++b)
                    (S = be[j]),
                      (C +=
                        f[(S >> 4) & 15] +
                        f[S & 15] +
                        f[(S >> 12) & 15] +
                        f[(S >> 8) & 15] +
                        f[(S >> 20) & 15] +
                        f[(S >> 16) & 15] +
                        f[(S >> 28) & 15] +
                        f[(S >> 24) & 15])
                  b % oe == 0 && (ke(be), (j = 0))
                }
                return (
                  re &&
                    ((S = be[j]),
                    (C += f[(S >> 4) & 15] + f[S & 15]),
                    re > 1 && (C += f[(S >> 12) & 15] + f[(S >> 8) & 15]),
                    re > 2 && (C += f[(S >> 20) & 15] + f[(S >> 16) & 15])),
                  C
                )
              }),
            (_e.prototype.arrayBuffer = function () {
              this.finalize()
              var oe = this.blockCount,
                be = this.s,
                ge = this.outputBlocks,
                re = this.extraBytes,
                j = 0,
                b = 0,
                C = this.outputBits >> 3,
                S
              re ? (S = new ArrayBuffer((ge + 1) << 2)) : (S = new ArrayBuffer(C))
              for (var R = new Uint32Array(S); b < ge; ) {
                for (j = 0; j < oe && b < ge; ++j, ++b) R[b] = be[j]
                b % oe == 0 && ke(be)
              }
              return re && ((R[j] = be[j]), (S = S.slice(0, C))), S
            }),
            (_e.prototype.buffer = _e.prototype.arrayBuffer),
            (_e.prototype.digest = _e.prototype.array =
              function () {
                this.finalize()
                for (
                  var oe = this.blockCount,
                    be = this.s,
                    ge = this.outputBlocks,
                    re = this.extraBytes,
                    j = 0,
                    b = 0,
                    C = [],
                    S,
                    R;
                  b < ge;

                ) {
                  for (j = 0; j < oe && b < ge; ++j, ++b)
                    (S = b << 2),
                      (R = be[j]),
                      (C[S] = R & 255),
                      (C[S + 1] = (R >> 8) & 255),
                      (C[S + 2] = (R >> 16) & 255),
                      (C[S + 3] = (R >> 24) & 255)
                  b % oe == 0 && ke(be)
                }
                return (
                  re &&
                    ((S = b << 2),
                    (R = be[j]),
                    (C[S] = R & 255),
                    re > 1 && (C[S + 1] = (R >> 8) & 255),
                    re > 2 && (C[S + 2] = (R >> 16) & 255)),
                  C
                )
              })
          function Ne(oe, be, ge) {
            _e.call(this, oe, be, ge)
          }
          ;(Ne.prototype = new _e()),
            (Ne.prototype.finalize = function () {
              return this.encode(this.outputBits, !0), _e.prototype.finalize.call(this)
            })
          var ke = function (oe) {
            var be,
              ge,
              re,
              j,
              b,
              C,
              S,
              R,
              P,
              B,
              D,
              $,
              g,
              N,
              U,
              X,
              ne,
              ee,
              ae,
              Y,
              z,
              H,
              se,
              me,
              we,
              Ee,
              Me,
              Be,
              je,
              Pe,
              Oe,
              ht,
              Qe,
              et,
              Mt,
              ut,
              at,
              Pt,
              ft,
              We,
              gt,
              Ge,
              He,
              wt,
              tt,
              Xe,
              _t,
              nt,
              it,
              xt,
              st,
              ot,
              Rt,
              Ze,
              Ye,
              Er,
              Et,
              St,
              Dr,
              At,
              vt,
              Yt,
              It
            for (re = 0; re < 48; re += 2)
              (j = oe[0] ^ oe[10] ^ oe[20] ^ oe[30] ^ oe[40]),
                (b = oe[1] ^ oe[11] ^ oe[21] ^ oe[31] ^ oe[41]),
                (C = oe[2] ^ oe[12] ^ oe[22] ^ oe[32] ^ oe[42]),
                (S = oe[3] ^ oe[13] ^ oe[23] ^ oe[33] ^ oe[43]),
                (R = oe[4] ^ oe[14] ^ oe[24] ^ oe[34] ^ oe[44]),
                (P = oe[5] ^ oe[15] ^ oe[25] ^ oe[35] ^ oe[45]),
                (B = oe[6] ^ oe[16] ^ oe[26] ^ oe[36] ^ oe[46]),
                (D = oe[7] ^ oe[17] ^ oe[27] ^ oe[37] ^ oe[47]),
                ($ = oe[8] ^ oe[18] ^ oe[28] ^ oe[38] ^ oe[48]),
                (g = oe[9] ^ oe[19] ^ oe[29] ^ oe[39] ^ oe[49]),
                (be = $ ^ ((C << 1) | (S >>> 31))),
                (ge = g ^ ((S << 1) | (C >>> 31))),
                (oe[0] ^= be),
                (oe[1] ^= ge),
                (oe[10] ^= be),
                (oe[11] ^= ge),
                (oe[20] ^= be),
                (oe[21] ^= ge),
                (oe[30] ^= be),
                (oe[31] ^= ge),
                (oe[40] ^= be),
                (oe[41] ^= ge),
                (be = j ^ ((R << 1) | (P >>> 31))),
                (ge = b ^ ((P << 1) | (R >>> 31))),
                (oe[2] ^= be),
                (oe[3] ^= ge),
                (oe[12] ^= be),
                (oe[13] ^= ge),
                (oe[22] ^= be),
                (oe[23] ^= ge),
                (oe[32] ^= be),
                (oe[33] ^= ge),
                (oe[42] ^= be),
                (oe[43] ^= ge),
                (be = C ^ ((B << 1) | (D >>> 31))),
                (ge = S ^ ((D << 1) | (B >>> 31))),
                (oe[4] ^= be),
                (oe[5] ^= ge),
                (oe[14] ^= be),
                (oe[15] ^= ge),
                (oe[24] ^= be),
                (oe[25] ^= ge),
                (oe[34] ^= be),
                (oe[35] ^= ge),
                (oe[44] ^= be),
                (oe[45] ^= ge),
                (be = R ^ (($ << 1) | (g >>> 31))),
                (ge = P ^ ((g << 1) | ($ >>> 31))),
                (oe[6] ^= be),
                (oe[7] ^= ge),
                (oe[16] ^= be),
                (oe[17] ^= ge),
                (oe[26] ^= be),
                (oe[27] ^= ge),
                (oe[36] ^= be),
                (oe[37] ^= ge),
                (oe[46] ^= be),
                (oe[47] ^= ge),
                (be = B ^ ((j << 1) | (b >>> 31))),
                (ge = D ^ ((b << 1) | (j >>> 31))),
                (oe[8] ^= be),
                (oe[9] ^= ge),
                (oe[18] ^= be),
                (oe[19] ^= ge),
                (oe[28] ^= be),
                (oe[29] ^= ge),
                (oe[38] ^= be),
                (oe[39] ^= ge),
                (oe[48] ^= be),
                (oe[49] ^= ge),
                (N = oe[0]),
                (U = oe[1]),
                (Xe = (oe[11] << 4) | (oe[10] >>> 28)),
                (_t = (oe[10] << 4) | (oe[11] >>> 28)),
                (Be = (oe[20] << 3) | (oe[21] >>> 29)),
                (je = (oe[21] << 3) | (oe[20] >>> 29)),
                (At = (oe[31] << 9) | (oe[30] >>> 23)),
                (vt = (oe[30] << 9) | (oe[31] >>> 23)),
                (Ge = (oe[40] << 18) | (oe[41] >>> 14)),
                (He = (oe[41] << 18) | (oe[40] >>> 14)),
                (et = (oe[2] << 1) | (oe[3] >>> 31)),
                (Mt = (oe[3] << 1) | (oe[2] >>> 31)),
                (X = (oe[13] << 12) | (oe[12] >>> 20)),
                (ne = (oe[12] << 12) | (oe[13] >>> 20)),
                (nt = (oe[22] << 10) | (oe[23] >>> 22)),
                (it = (oe[23] << 10) | (oe[22] >>> 22)),
                (Pe = (oe[33] << 13) | (oe[32] >>> 19)),
                (Oe = (oe[32] << 13) | (oe[33] >>> 19)),
                (Yt = (oe[42] << 2) | (oe[43] >>> 30)),
                (It = (oe[43] << 2) | (oe[42] >>> 30)),
                (Ze = (oe[5] << 30) | (oe[4] >>> 2)),
                (Ye = (oe[4] << 30) | (oe[5] >>> 2)),
                (ut = (oe[14] << 6) | (oe[15] >>> 26)),
                (at = (oe[15] << 6) | (oe[14] >>> 26)),
                (ee = (oe[25] << 11) | (oe[24] >>> 21)),
                (ae = (oe[24] << 11) | (oe[25] >>> 21)),
                (xt = (oe[34] << 15) | (oe[35] >>> 17)),
                (st = (oe[35] << 15) | (oe[34] >>> 17)),
                (ht = (oe[45] << 29) | (oe[44] >>> 3)),
                (Qe = (oe[44] << 29) | (oe[45] >>> 3)),
                (me = (oe[6] << 28) | (oe[7] >>> 4)),
                (we = (oe[7] << 28) | (oe[6] >>> 4)),
                (Er = (oe[17] << 23) | (oe[16] >>> 9)),
                (Et = (oe[16] << 23) | (oe[17] >>> 9)),
                (Pt = (oe[26] << 25) | (oe[27] >>> 7)),
                (ft = (oe[27] << 25) | (oe[26] >>> 7)),
                (Y = (oe[36] << 21) | (oe[37] >>> 11)),
                (z = (oe[37] << 21) | (oe[36] >>> 11)),
                (ot = (oe[47] << 24) | (oe[46] >>> 8)),
                (Rt = (oe[46] << 24) | (oe[47] >>> 8)),
                (wt = (oe[8] << 27) | (oe[9] >>> 5)),
                (tt = (oe[9] << 27) | (oe[8] >>> 5)),
                (Ee = (oe[18] << 20) | (oe[19] >>> 12)),
                (Me = (oe[19] << 20) | (oe[18] >>> 12)),
                (St = (oe[29] << 7) | (oe[28] >>> 25)),
                (Dr = (oe[28] << 7) | (oe[29] >>> 25)),
                (We = (oe[38] << 8) | (oe[39] >>> 24)),
                (gt = (oe[39] << 8) | (oe[38] >>> 24)),
                (H = (oe[48] << 14) | (oe[49] >>> 18)),
                (se = (oe[49] << 14) | (oe[48] >>> 18)),
                (oe[0] = N ^ (~X & ee)),
                (oe[1] = U ^ (~ne & ae)),
                (oe[10] = me ^ (~Ee & Be)),
                (oe[11] = we ^ (~Me & je)),
                (oe[20] = et ^ (~ut & Pt)),
                (oe[21] = Mt ^ (~at & ft)),
                (oe[30] = wt ^ (~Xe & nt)),
                (oe[31] = tt ^ (~_t & it)),
                (oe[40] = Ze ^ (~Er & St)),
                (oe[41] = Ye ^ (~Et & Dr)),
                (oe[2] = X ^ (~ee & Y)),
                (oe[3] = ne ^ (~ae & z)),
                (oe[12] = Ee ^ (~Be & Pe)),
                (oe[13] = Me ^ (~je & Oe)),
                (oe[22] = ut ^ (~Pt & We)),
                (oe[23] = at ^ (~ft & gt)),
                (oe[32] = Xe ^ (~nt & xt)),
                (oe[33] = _t ^ (~it & st)),
                (oe[42] = Er ^ (~St & At)),
                (oe[43] = Et ^ (~Dr & vt)),
                (oe[4] = ee ^ (~Y & H)),
                (oe[5] = ae ^ (~z & se)),
                (oe[14] = Be ^ (~Pe & ht)),
                (oe[15] = je ^ (~Oe & Qe)),
                (oe[24] = Pt ^ (~We & Ge)),
                (oe[25] = ft ^ (~gt & He)),
                (oe[34] = nt ^ (~xt & ot)),
                (oe[35] = it ^ (~st & Rt)),
                (oe[44] = St ^ (~At & Yt)),
                (oe[45] = Dr ^ (~vt & It)),
                (oe[6] = Y ^ (~H & N)),
                (oe[7] = z ^ (~se & U)),
                (oe[16] = Pe ^ (~ht & me)),
                (oe[17] = Oe ^ (~Qe & we)),
                (oe[26] = We ^ (~Ge & et)),
                (oe[27] = gt ^ (~He & Mt)),
                (oe[36] = xt ^ (~ot & wt)),
                (oe[37] = st ^ (~Rt & tt)),
                (oe[46] = At ^ (~Yt & Ze)),
                (oe[47] = vt ^ (~It & Ye)),
                (oe[8] = H ^ (~N & X)),
                (oe[9] = se ^ (~U & ne)),
                (oe[18] = ht ^ (~me & Ee)),
                (oe[19] = Qe ^ (~we & Me)),
                (oe[28] = Ge ^ (~et & ut)),
                (oe[29] = He ^ (~Mt & at)),
                (oe[38] = ot ^ (~wt & Xe)),
                (oe[39] = Rt ^ (~tt & _t)),
                (oe[48] = Yt ^ (~Ze & Er)),
                (oe[49] = It ^ (~Ye & Et)),
                (oe[0] ^= _[re]),
                (oe[1] ^= _[re + 1])
          }
          if (l) r.exports = J
          else {
            for (Q = 0; Q < Z.length; ++Q) s[Z[Q]] = J[Z[Q]]
            a &&
              define(function () {
                return J
              })
          }
        })()
    }
  }),
  CU = te({
    'node_modules/murmurhash3js-revisited/lib/murmurHash3js.js'(e, r) {
      V(),
        F(),
        (function (t, n) {
          'use strict'
          var i = { version: '3.0.0', x86: {}, x64: {}, inputValidation: !0 }
          function s(h) {
            if (!Array.isArray(h) && !ArrayBuffer.isView(h)) return !1
            for (var m = 0; m < h.length; m++) if (!Number.isInteger(h[m]) || h[m] < 0 || h[m] > 255) return !1
            return !0
          }
          function u(h, m) {
            return (h & 65535) * m + ((((h >>> 16) * m) & 65535) << 16)
          }
          function o(h, m) {
            return (h << m) | (h >>> (32 - m))
          }
          function l(h) {
            return (h ^= h >>> 16), (h = u(h, 2246822507)), (h ^= h >>> 13), (h = u(h, 3266489909)), (h ^= h >>> 16), h
          }
          function a(h, m) {
            ;(h = [h[0] >>> 16, h[0] & 65535, h[1] >>> 16, h[1] & 65535]),
              (m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535])
            var _ = [0, 0, 0, 0]
            return (
              (_[3] += h[3] + m[3]),
              (_[2] += _[3] >>> 16),
              (_[3] &= 65535),
              (_[2] += h[2] + m[2]),
              (_[1] += _[2] >>> 16),
              (_[2] &= 65535),
              (_[1] += h[1] + m[1]),
              (_[0] += _[1] >>> 16),
              (_[1] &= 65535),
              (_[0] += h[0] + m[0]),
              (_[0] &= 65535),
              [(_[0] << 16) | _[1], (_[2] << 16) | _[3]]
            )
          }
          function c(h, m) {
            ;(h = [h[0] >>> 16, h[0] & 65535, h[1] >>> 16, h[1] & 65535]),
              (m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535])
            var _ = [0, 0, 0, 0]
            return (
              (_[3] += h[3] * m[3]),
              (_[2] += _[3] >>> 16),
              (_[3] &= 65535),
              (_[2] += h[2] * m[3]),
              (_[1] += _[2] >>> 16),
              (_[2] &= 65535),
              (_[2] += h[3] * m[2]),
              (_[1] += _[2] >>> 16),
              (_[2] &= 65535),
              (_[1] += h[1] * m[3]),
              (_[0] += _[1] >>> 16),
              (_[1] &= 65535),
              (_[1] += h[2] * m[2]),
              (_[0] += _[1] >>> 16),
              (_[1] &= 65535),
              (_[1] += h[3] * m[1]),
              (_[0] += _[1] >>> 16),
              (_[1] &= 65535),
              (_[0] += h[0] * m[3] + h[1] * m[2] + h[2] * m[1] + h[3] * m[0]),
              (_[0] &= 65535),
              [(_[0] << 16) | _[1], (_[2] << 16) | _[3]]
            )
          }
          function f(h, m) {
            return (
              (m %= 64),
              m === 32
                ? [h[1], h[0]]
                : m < 32
                ? [(h[0] << m) | (h[1] >>> (32 - m)), (h[1] << m) | (h[0] >>> (32 - m))]
                : ((m -= 32), [(h[1] << m) | (h[0] >>> (32 - m)), (h[0] << m) | (h[1] >>> (32 - m))])
            )
          }
          function p(h, m) {
            return (
              (m %= 64), m === 0 ? h : m < 32 ? [(h[0] << m) | (h[1] >>> (32 - m)), h[1] << m] : [h[1] << (m - 32), 0]
            )
          }
          function y(h, m) {
            return [h[0] ^ m[0], h[1] ^ m[1]]
          }
          function d(h) {
            return (
              (h = y(h, [0, h[0] >>> 1])),
              (h = c(h, [4283543511, 3981806797])),
              (h = y(h, [0, h[0] >>> 1])),
              (h = c(h, [3301882366, 444984403])),
              (h = y(h, [0, h[0] >>> 1])),
              h
            )
          }
          ;(i.x86.hash32 = function (h, m) {
            if (i.inputValidation && !s(h)) return n
            m = m || 0
            for (
              var _ = h.length % 4, A = h.length - _, T = m, E = 0, k = 3432918353, w = 461845907, v = 0;
              v < A;
              v = v + 4
            )
              (E = h[v] | (h[v + 1] << 8) | (h[v + 2] << 16) | (h[v + 3] << 24)),
                (E = u(E, k)),
                (E = o(E, 15)),
                (E = u(E, w)),
                (T ^= E),
                (T = o(T, 13)),
                (T = u(T, 5) + 3864292196)
            switch (((E = 0), _)) {
              case 3:
                E ^= h[v + 2] << 16
              case 2:
                E ^= h[v + 1] << 8
              case 1:
                ;(E ^= h[v]), (E = u(E, k)), (E = o(E, 15)), (E = u(E, w)), (T ^= E)
            }
            return (T ^= h.length), (T = l(T)), T >>> 0
          }),
            (i.x86.hash128 = function (h, m) {
              if (i.inputValidation && !s(h)) return n
              m = m || 0
              for (
                var _ = h.length % 16,
                  A = h.length - _,
                  T = m,
                  E = m,
                  k = m,
                  w = m,
                  v = 0,
                  I = 0,
                  M = 0,
                  q = 0,
                  G = 597399067,
                  O = 2869860233,
                  x = 951274213,
                  L = 2716044179,
                  K = 0;
                K < A;
                K = K + 16
              )
                (v = h[K] | (h[K + 1] << 8) | (h[K + 2] << 16) | (h[K + 3] << 24)),
                  (I = h[K + 4] | (h[K + 5] << 8) | (h[K + 6] << 16) | (h[K + 7] << 24)),
                  (M = h[K + 8] | (h[K + 9] << 8) | (h[K + 10] << 16) | (h[K + 11] << 24)),
                  (q = h[K + 12] | (h[K + 13] << 8) | (h[K + 14] << 16) | (h[K + 15] << 24)),
                  (v = u(v, G)),
                  (v = o(v, 15)),
                  (v = u(v, O)),
                  (T ^= v),
                  (T = o(T, 19)),
                  (T += E),
                  (T = u(T, 5) + 1444728091),
                  (I = u(I, O)),
                  (I = o(I, 16)),
                  (I = u(I, x)),
                  (E ^= I),
                  (E = o(E, 17)),
                  (E += k),
                  (E = u(E, 5) + 197830471),
                  (M = u(M, x)),
                  (M = o(M, 17)),
                  (M = u(M, L)),
                  (k ^= M),
                  (k = o(k, 15)),
                  (k += w),
                  (k = u(k, 5) + 2530024501),
                  (q = u(q, L)),
                  (q = o(q, 18)),
                  (q = u(q, G)),
                  (w ^= q),
                  (w = o(w, 13)),
                  (w += T),
                  (w = u(w, 5) + 850148119)
              switch (((v = 0), (I = 0), (M = 0), (q = 0), _)) {
                case 15:
                  q ^= h[K + 14] << 16
                case 14:
                  q ^= h[K + 13] << 8
                case 13:
                  ;(q ^= h[K + 12]), (q = u(q, L)), (q = o(q, 18)), (q = u(q, G)), (w ^= q)
                case 12:
                  M ^= h[K + 11] << 24
                case 11:
                  M ^= h[K + 10] << 16
                case 10:
                  M ^= h[K + 9] << 8
                case 9:
                  ;(M ^= h[K + 8]), (M = u(M, x)), (M = o(M, 17)), (M = u(M, L)), (k ^= M)
                case 8:
                  I ^= h[K + 7] << 24
                case 7:
                  I ^= h[K + 6] << 16
                case 6:
                  I ^= h[K + 5] << 8
                case 5:
                  ;(I ^= h[K + 4]), (I = u(I, O)), (I = o(I, 16)), (I = u(I, x)), (E ^= I)
                case 4:
                  v ^= h[K + 3] << 24
                case 3:
                  v ^= h[K + 2] << 16
                case 2:
                  v ^= h[K + 1] << 8
                case 1:
                  ;(v ^= h[K]), (v = u(v, G)), (v = o(v, 15)), (v = u(v, O)), (T ^= v)
              }
              return (
                (T ^= h.length),
                (E ^= h.length),
                (k ^= h.length),
                (w ^= h.length),
                (T += E),
                (T += k),
                (T += w),
                (E += T),
                (k += T),
                (w += T),
                (T = l(T)),
                (E = l(E)),
                (k = l(k)),
                (w = l(w)),
                (T += E),
                (T += k),
                (T += w),
                (E += T),
                (k += T),
                (w += T),
                ('00000000' + (T >>> 0).toString(16)).slice(-8) +
                  ('00000000' + (E >>> 0).toString(16)).slice(-8) +
                  ('00000000' + (k >>> 0).toString(16)).slice(-8) +
                  ('00000000' + (w >>> 0).toString(16)).slice(-8)
              )
            }),
            (i.x64.hash128 = function (h, m) {
              if (i.inputValidation && !s(h)) return n
              m = m || 0
              for (
                var _ = h.length % 16,
                  A = h.length - _,
                  T = [0, m],
                  E = [0, m],
                  k = [0, 0],
                  w = [0, 0],
                  v = [2277735313, 289559509],
                  I = [1291169091, 658871167],
                  M = 0;
                M < A;
                M = M + 16
              )
                (k = [
                  h[M + 4] | (h[M + 5] << 8) | (h[M + 6] << 16) | (h[M + 7] << 24),
                  h[M] | (h[M + 1] << 8) | (h[M + 2] << 16) | (h[M + 3] << 24)
                ]),
                  (w = [
                    h[M + 12] | (h[M + 13] << 8) | (h[M + 14] << 16) | (h[M + 15] << 24),
                    h[M + 8] | (h[M + 9] << 8) | (h[M + 10] << 16) | (h[M + 11] << 24)
                  ]),
                  (k = c(k, v)),
                  (k = f(k, 31)),
                  (k = c(k, I)),
                  (T = y(T, k)),
                  (T = f(T, 27)),
                  (T = a(T, E)),
                  (T = a(c(T, [0, 5]), [0, 1390208809])),
                  (w = c(w, I)),
                  (w = f(w, 33)),
                  (w = c(w, v)),
                  (E = y(E, w)),
                  (E = f(E, 31)),
                  (E = a(E, T)),
                  (E = a(c(E, [0, 5]), [0, 944331445]))
              switch (((k = [0, 0]), (w = [0, 0]), _)) {
                case 15:
                  w = y(w, p([0, h[M + 14]], 48))
                case 14:
                  w = y(w, p([0, h[M + 13]], 40))
                case 13:
                  w = y(w, p([0, h[M + 12]], 32))
                case 12:
                  w = y(w, p([0, h[M + 11]], 24))
                case 11:
                  w = y(w, p([0, h[M + 10]], 16))
                case 10:
                  w = y(w, p([0, h[M + 9]], 8))
                case 9:
                  ;(w = y(w, [0, h[M + 8]])), (w = c(w, I)), (w = f(w, 33)), (w = c(w, v)), (E = y(E, w))
                case 8:
                  k = y(k, p([0, h[M + 7]], 56))
                case 7:
                  k = y(k, p([0, h[M + 6]], 48))
                case 6:
                  k = y(k, p([0, h[M + 5]], 40))
                case 5:
                  k = y(k, p([0, h[M + 4]], 32))
                case 4:
                  k = y(k, p([0, h[M + 3]], 24))
                case 3:
                  k = y(k, p([0, h[M + 2]], 16))
                case 2:
                  k = y(k, p([0, h[M + 1]], 8))
                case 1:
                  ;(k = y(k, [0, h[M]])), (k = c(k, v)), (k = f(k, 31)), (k = c(k, I)), (T = y(T, k))
              }
              return (
                (T = y(T, [0, h.length])),
                (E = y(E, [0, h.length])),
                (T = a(T, E)),
                (E = a(E, T)),
                (T = d(T)),
                (E = d(E)),
                (T = a(T, E)),
                (E = a(E, T)),
                ('00000000' + (T[0] >>> 0).toString(16)).slice(-8) +
                  ('00000000' + (T[1] >>> 0).toString(16)).slice(-8) +
                  ('00000000' + (E[0] >>> 0).toString(16)).slice(-8) +
                  ('00000000' + (E[1] >>> 0).toString(16)).slice(-8)
              )
            }),
            typeof e != 'undefined'
              ? (typeof r != 'undefined' && r.exports && (e = r.exports = i), (e.murmurHash3 = i))
              : typeof define == 'function' && define.amd
              ? define([], function () {
                  return i
                })
              : ((i._murmurHash3 = t.murmurHash3),
                (i.noConflict = function () {
                  return (t.murmurHash3 = i._murmurHash3), (i._murmurHash3 = n), (i.noConflict = n), i
                }),
                (t.murmurHash3 = i))
        })(e)
    }
  }),
  kU = te({
    'node_modules/murmurhash3js-revisited/index.js'(e, r) {
      V(), F(), (r.exports = CU())
    }
  }),
  MU = te({
    'node_modules/multihashing-async/src/sha.browser.js'(e, r) {
      V(), F()
      var t = gc(),
        n = self.crypto || self.msCrypto,
        i = async (s, u) => {
          if (typeof self == 'undefined' || !n)
            throw new Error(
              'Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context'
            )
          switch (u) {
            case 'sha1':
              return new Uint8Array(await n.subtle.digest({ name: 'SHA-1' }, s))
            case 'sha2-256':
              return new Uint8Array(await n.subtle.digest({ name: 'SHA-256' }, s))
            case 'sha2-512':
              return new Uint8Array(await n.subtle.digest({ name: 'SHA-512' }, s))
            case 'dbl-sha2-256': {
              let o = await n.subtle.digest({ name: 'SHA-256' }, s)
              return new Uint8Array(await n.subtle.digest({ name: 'SHA-256' }, o))
            }
            default:
              throw new Error(`${u} is not a supported algorithm`)
          }
        }
      r.exports = {
        factory: (s) => async (u) => i(u, s),
        digest: i,
        multihashing: async (s, u, o) => {
          let l = await i(s, u)
          return t.encode(l, u, o)
        }
      }
    }
  }),
  xU = te({
    'node_modules/multihashing-async/src/utils.js'(e, r) {
      V(), F()
      var t = (n) => {
        let i = new Uint8Array(4)
        for (let s = 0; s < 4; s++) (i[s] = n & 255), (n = n >> 8)
        return i
      }
      r.exports = { fromNumberTo32BitBuf: t }
    }
  }),
  gT = te({
    'node_modules/blakejs/util.js'(e, r) {
      V(), F()
      var t = 'Input must be an string, Buffer or Uint8Array'
      function n(l) {
        let a
        if (l instanceof Uint8Array) a = l
        else if (l instanceof Ve.Buffer) a = new Uint8Array(l)
        else if (typeof l == 'string') a = new Uint8Array(Ve.Buffer.from(l, 'utf8'))
        else throw new Error(t)
        return a
      }
      function i(l) {
        return Array.prototype.map
          .call(l, function (a) {
            return (a < 16 ? '0' : '') + a.toString(16)
          })
          .join('')
      }
      function s(l) {
        return (4294967296 + l).toString(16).substring(1)
      }
      function u(l, a, c) {
        let f =
          `
` +
          l +
          ' = '
        for (let p = 0; p < a.length; p += 2) {
          if (c === 32) (f += s(a[p]).toUpperCase()), (f += ' '), (f += s(a[p + 1]).toUpperCase())
          else if (c === 64) (f += s(a[p + 1]).toUpperCase()), (f += s(a[p]).toUpperCase())
          else throw new Error('Invalid size ' + c)
          p % 6 == 4
            ? (f +=
                `
` + new Array(l.length + 4).join(' '))
            : p < a.length - 2 && (f += ' ')
        }
        console.log(f)
      }
      function o(l, a, c) {
        let f = new Date().getTime(),
          p = new Uint8Array(a)
        for (let d = 0; d < a; d++) p[d] = d % 256
        let y = new Date().getTime()
        console.log('Generated random input in ' + (y - f) + 'ms'), (f = y)
        for (let d = 0; d < c; d++) {
          let h = l(p),
            m = new Date().getTime(),
            _ = m - f
          ;(f = m),
            console.log('Hashed in ' + _ + 'ms: ' + h.substring(0, 20) + '...'),
            console.log(Math.round((a / (1 << 20) / (_ / 1e3)) * 100) / 100 + ' MB PER SECOND')
        }
      }
      r.exports = { normalizeInput: n, toHex: i, debugPrint: u, testSpeed: o }
    }
  }),
  RU = te({
    'node_modules/blakejs/blake2b.js'(e, r) {
      V(), F()
      var t = gT()
      function n(A, T, E) {
        let k = A[T] + A[E],
          w = A[T + 1] + A[E + 1]
        k >= 4294967296 && w++, (A[T] = k), (A[T + 1] = w)
      }
      function i(A, T, E, k) {
        let w = A[T] + E
        E < 0 && (w += 4294967296)
        let v = A[T + 1] + k
        w >= 4294967296 && v++, (A[T] = w), (A[T + 1] = v)
      }
      function s(A, T) {
        return A[T] ^ (A[T + 1] << 8) ^ (A[T + 2] << 16) ^ (A[T + 3] << 24)
      }
      function u(A, T, E, k, w, v) {
        let I = f[w],
          M = f[w + 1],
          q = f[v],
          G = f[v + 1]
        n(c, A, T), i(c, A, I, M)
        let O = c[k] ^ c[A],
          x = c[k + 1] ^ c[A + 1]
        ;(c[k] = x),
          (c[k + 1] = O),
          n(c, E, k),
          (O = c[T] ^ c[E]),
          (x = c[T + 1] ^ c[E + 1]),
          (c[T] = (O >>> 24) ^ (x << 8)),
          (c[T + 1] = (x >>> 24) ^ (O << 8)),
          n(c, A, T),
          i(c, A, q, G),
          (O = c[k] ^ c[A]),
          (x = c[k + 1] ^ c[A + 1]),
          (c[k] = (O >>> 16) ^ (x << 16)),
          (c[k + 1] = (x >>> 16) ^ (O << 16)),
          n(c, E, k),
          (O = c[T] ^ c[E]),
          (x = c[T + 1] ^ c[E + 1]),
          (c[T] = (x >>> 31) ^ (O << 1)),
          (c[T + 1] = (O >>> 31) ^ (x << 1))
      }
      var o = new Uint32Array([
          4089235720, 1779033703, 2227873595, 3144134277, 4271175723, 1013904242, 1595750129, 2773480762, 2917565137,
          1359893119, 725511199, 2600822924, 4215389547, 528734635, 327033209, 1541459225
        ]),
        l = [
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
          11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9,
          0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12,
          5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15,
          14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2,
          3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3
        ],
        a = new Uint8Array(
          l.map(function (A) {
            return A * 2
          })
        ),
        c = new Uint32Array(32),
        f = new Uint32Array(32)
      function p(A, T) {
        let E = 0
        for (E = 0; E < 16; E++) (c[E] = A.h[E]), (c[E + 16] = o[E])
        for (
          c[24] = c[24] ^ A.t, c[25] = c[25] ^ (A.t / 4294967296), T && ((c[28] = ~c[28]), (c[29] = ~c[29])), E = 0;
          E < 32;
          E++
        )
          f[E] = s(A.b, 4 * E)
        for (E = 0; E < 12; E++)
          u(0, 8, 16, 24, a[E * 16 + 0], a[E * 16 + 1]),
            u(2, 10, 18, 26, a[E * 16 + 2], a[E * 16 + 3]),
            u(4, 12, 20, 28, a[E * 16 + 4], a[E * 16 + 5]),
            u(6, 14, 22, 30, a[E * 16 + 6], a[E * 16 + 7]),
            u(0, 10, 20, 30, a[E * 16 + 8], a[E * 16 + 9]),
            u(2, 12, 22, 24, a[E * 16 + 10], a[E * 16 + 11]),
            u(4, 14, 16, 26, a[E * 16 + 12], a[E * 16 + 13]),
            u(6, 8, 18, 28, a[E * 16 + 14], a[E * 16 + 15])
        for (E = 0; E < 16; E++) A.h[E] = A.h[E] ^ c[E] ^ c[E + 16]
      }
      function y(A, T) {
        if (A === 0 || A > 64) throw new Error('Illegal output length, expected 0 < length <= 64')
        if (T && T.length > 64) throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
        let E = { b: new Uint8Array(128), h: new Uint32Array(16), t: 0, c: 0, outlen: A }
        for (let w = 0; w < 16; w++) E.h[w] = o[w]
        let k = T ? T.length : 0
        return (E.h[0] ^= 16842752 ^ (k << 8) ^ A), T && (d(E, T), (E.c = 128)), E
      }
      function d(A, T) {
        for (let E = 0; E < T.length; E++) A.c === 128 && ((A.t += A.c), p(A, !1), (A.c = 0)), (A.b[A.c++] = T[E])
      }
      function h(A) {
        for (A.t += A.c; A.c < 128; ) A.b[A.c++] = 0
        p(A, !0)
        let T = new Uint8Array(A.outlen)
        for (let E = 0; E < A.outlen; E++) T[E] = A.h[E >> 2] >> (8 * (E & 3))
        return T
      }
      function m(A, T, E) {
        ;(E = E || 64), (A = t.normalizeInput(A))
        let k = y(E, T)
        return d(k, A), h(k)
      }
      function _(A, T, E) {
        let k = m(A, T, E)
        return t.toHex(k)
      }
      r.exports = { blake2b: m, blake2bHex: _, blake2bInit: y, blake2bUpdate: d, blake2bFinal: h }
    }
  }),
  BU = te({
    'node_modules/blakejs/blake2s.js'(e, r) {
      V(), F()
      var t = gT()
      function n(m, _) {
        return m[_] ^ (m[_ + 1] << 8) ^ (m[_ + 2] << 16) ^ (m[_ + 3] << 24)
      }
      function i(m, _, A, T, E, k) {
        ;(l[m] = l[m] + l[_] + E),
          (l[T] = s(l[T] ^ l[m], 16)),
          (l[A] = l[A] + l[T]),
          (l[_] = s(l[_] ^ l[A], 12)),
          (l[m] = l[m] + l[_] + k),
          (l[T] = s(l[T] ^ l[m], 8)),
          (l[A] = l[A] + l[T]),
          (l[_] = s(l[_] ^ l[A], 7))
      }
      function s(m, _) {
        return (m >>> _) ^ (m << (32 - _))
      }
      var u = new Uint32Array([
          1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225
        ]),
        o = new Uint8Array([
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3,
          11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9,
          0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12,
          5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15,
          14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0
        ]),
        l = new Uint32Array(16),
        a = new Uint32Array(16)
      function c(m, _) {
        let A = 0
        for (A = 0; A < 8; A++) (l[A] = m.h[A]), (l[A + 8] = u[A])
        for (l[12] ^= m.t, l[13] ^= m.t / 4294967296, _ && (l[14] = ~l[14]), A = 0; A < 16; A++) a[A] = n(m.b, 4 * A)
        for (A = 0; A < 10; A++)
          i(0, 4, 8, 12, a[o[A * 16 + 0]], a[o[A * 16 + 1]]),
            i(1, 5, 9, 13, a[o[A * 16 + 2]], a[o[A * 16 + 3]]),
            i(2, 6, 10, 14, a[o[A * 16 + 4]], a[o[A * 16 + 5]]),
            i(3, 7, 11, 15, a[o[A * 16 + 6]], a[o[A * 16 + 7]]),
            i(0, 5, 10, 15, a[o[A * 16 + 8]], a[o[A * 16 + 9]]),
            i(1, 6, 11, 12, a[o[A * 16 + 10]], a[o[A * 16 + 11]]),
            i(2, 7, 8, 13, a[o[A * 16 + 12]], a[o[A * 16 + 13]]),
            i(3, 4, 9, 14, a[o[A * 16 + 14]], a[o[A * 16 + 15]])
        for (A = 0; A < 8; A++) m.h[A] ^= l[A] ^ l[A + 8]
      }
      function f(m, _) {
        if (!(m > 0 && m <= 32)) throw new Error('Incorrect output length, should be in [1, 32]')
        let A = _ ? _.length : 0
        if (_ && !(A > 0 && A <= 32)) throw new Error('Incorrect key length, should be in [1, 32]')
        let T = { h: new Uint32Array(u), b: new Uint8Array(64), c: 0, t: 0, outlen: m }
        return (T.h[0] ^= 16842752 ^ (A << 8) ^ m), A > 0 && (p(T, _), (T.c = 64)), T
      }
      function p(m, _) {
        for (let A = 0; A < _.length; A++) m.c === 64 && ((m.t += m.c), c(m, !1), (m.c = 0)), (m.b[m.c++] = _[A])
      }
      function y(m) {
        for (m.t += m.c; m.c < 64; ) m.b[m.c++] = 0
        c(m, !0)
        let _ = new Uint8Array(m.outlen)
        for (let A = 0; A < m.outlen; A++) _[A] = (m.h[A >> 2] >> (8 * (A & 3))) & 255
        return _
      }
      function d(m, _, A) {
        ;(A = A || 32), (m = t.normalizeInput(m))
        let T = f(A, _)
        return p(T, m), y(T)
      }
      function h(m, _, A) {
        let T = d(m, _, A)
        return t.toHex(T)
      }
      r.exports = { blake2s: d, blake2sHex: h, blake2sInit: f, blake2sUpdate: p, blake2sFinal: y }
    }
  }),
  NU = te({
    'node_modules/blakejs/index.js'(e, r) {
      V(), F()
      var t = RU(),
        n = BU()
      r.exports = {
        blake2b: t.blake2b,
        blake2bHex: t.blake2bHex,
        blake2bInit: t.blake2bInit,
        blake2bUpdate: t.blake2bUpdate,
        blake2bFinal: t.blake2bFinal,
        blake2s: n.blake2s,
        blake2sHex: n.blake2sHex,
        blake2sInit: n.blake2sInit,
        blake2sUpdate: n.blake2sUpdate,
        blake2sFinal: n.blake2sFinal
      }
    }
  }),
  PU = te({
    'node_modules/multihashing-async/src/blake.js'(e, r) {
      V(), F()
      var t = NU(),
        n = 45569,
        i = 45633,
        s = { init: t.blake2bInit, update: t.blake2bUpdate, digest: t.blake2bFinal },
        u = { init: t.blake2sInit, update: t.blake2sUpdate, digest: t.blake2sFinal },
        o = (l, a) => async (c) => {
          let f = a.init(l, null)
          return a.update(f, c), a.digest(f)
        }
      r.exports = (l) => {
        for (let a = 0; a < 64; a++) l[n + a] = o(a + 1, s)
        for (let a = 0; a < 32; a++) l[i + a] = o(a + 1, u)
      }
    }
  }),
  OU = te({
    'node_modules/multihashing-async/src/crypto.js'(e, r) {
      V(), F()
      var t = TU(),
        n = kU(),
        { factory: i } = MU(),
        { fromNumberTo32BitBuf: s } = xU(),
        { fromString: u } = (gn(), un),
        o = (a) => async (c) => {
          switch (a) {
            case 'sha3-224':
              return new Uint8Array(t.sha3_224.arrayBuffer(c))
            case 'sha3-256':
              return new Uint8Array(t.sha3_256.arrayBuffer(c))
            case 'sha3-384':
              return new Uint8Array(t.sha3_384.arrayBuffer(c))
            case 'sha3-512':
              return new Uint8Array(t.sha3_512.arrayBuffer(c))
            case 'shake-128':
              return new Uint8Array(t.shake128.create(128).update(c).arrayBuffer())
            case 'shake-256':
              return new Uint8Array(t.shake256.create(256).update(c).arrayBuffer())
            case 'keccak-224':
              return new Uint8Array(t.keccak224.arrayBuffer(c))
            case 'keccak-256':
              return new Uint8Array(t.keccak256.arrayBuffer(c))
            case 'keccak-384':
              return new Uint8Array(t.keccak384.arrayBuffer(c))
            case 'keccak-512':
              return new Uint8Array(t.keccak512.arrayBuffer(c))
            case 'murmur3-128':
              return u(n.x64.hash128(c), 'base16')
            case 'murmur3-32':
              return s(n.x86.hash32(c))
            default:
              throw new TypeError(`${a} is not a supported algorithm`)
          }
        },
        l = (a) => a
      r.exports = {
        identity: l,
        sha1: i('sha1'),
        sha2256: i('sha2-256'),
        sha2512: i('sha2-512'),
        dblSha2256: i('dbl-sha2-256'),
        sha3224: o('sha3-224'),
        sha3256: o('sha3-256'),
        sha3384: o('sha3-384'),
        sha3512: o('sha3-512'),
        shake128: o('shake-128'),
        shake256: o('shake-256'),
        keccak224: o('keccak-224'),
        keccak256: o('keccak-256'),
        keccak384: o('keccak-384'),
        keccak512: o('keccak-512'),
        murmur3128: o('murmur3-128'),
        murmur332: o('murmur3-32'),
        addBlake: PU()
      }
    }
  }),
  DU = te({
    'node_modules/multihashing-async/src/index.js'(e, r) {
      V(), F()
      var t = pt(),
        n = gc(),
        i = OU(),
        { equals: s } = (To(), ps)
      async function u(o, l, a) {
        let c = await u.digest(o, l, a)
        return n.encode(c, l, a)
      }
      ;(u.multihash = n),
        (u.digest = async (o, l, a) => {
          let f = await u.createHash(l)(o)
          return a ? f.slice(0, a) : f
        }),
        (u.createHash = function (o) {
          if (!o) throw t(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED')
          let l = n.coerceCode(o)
          if (!u.functions[l])
            throw t(new Error(`multihash function '${o}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED')
          return u.functions[l]
        }),
        (u.functions = {
          0: i.identity,
          17: i.sha1,
          18: i.sha2256,
          19: i.sha2512,
          20: i.sha3512,
          21: i.sha3384,
          22: i.sha3256,
          23: i.sha3224,
          24: i.shake128,
          25: i.shake256,
          26: i.keccak224,
          27: i.keccak256,
          28: i.keccak384,
          29: i.keccak512,
          34: i.murmur3128,
          35: i.murmur332,
          86: i.dblSha2256
        }),
        i.addBlake(u.functions),
        (u.validate = async (o, l) => {
          let a = await u(o, n.decode(l).name)
          return s(l, a)
        }),
        (r.exports = u)
    }
  }),
  wT = te({
    'node_modules/libp2p/src/circuit/utils.js'(e, r) {
      V(), F()
      var t = Gr(),
        n = DU()
      r.exports.namespaceToCid = async (i) => {
        let s = new TextEncoder().encode(i),
          u = await n(s, 'sha2-256')
        return new t(u)
      }
    }
  }),
  LU = te({
    'node_modules/libp2p/src/circuit/auto-relay.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:auto-relay'), { error: t('libp2p:auto-relay:err') }),
        i = xs(),
        s = zi(),
        { Multiaddr: u } = Zr(),
        o = er(),
        { relay: l } = _f(),
        { canHop: a } = vT(),
        { namespaceToCid: c } = wT(),
        { CIRCUIT_PROTO_CODE: f, HOP_METADATA_KEY: p, HOP_METADATA_VALUE: y, RELAY_RENDEZVOUS_NS: d } = p2(),
        h = class {
          constructor({ libp2p: m, maxListeners: _ = 1, onError: A }) {
            ;(this._libp2p = m),
              (this._peerId = m.peerId),
              (this._peerStore = m.peerStore),
              (this._connectionManager = m.connectionManager),
              (this._transportManager = m.transportManager),
              (this._addressSorter = m.dialer.addressSorter),
              (this.maxListeners = _),
              (this._listenRelays = new Set()),
              (this._onProtocolChange = this._onProtocolChange.bind(this)),
              (this._onPeerDisconnected = this._onPeerDisconnected.bind(this)),
              this._peerStore.on('change:protocols', this._onProtocolChange),
              this._connectionManager.on('peer:disconnect', this._onPeerDisconnected),
              (this._onError = (T, E) => {
                n.error(E || T), A && A(T, E)
              })
          }
          async _onProtocolChange({ peerId: m, protocols: _ }) {
            let A = m.toB58String(),
              T = _.find((E) => E === l)
            if (!T && this._listenRelays.has(A)) {
              this._removeListenRelay(A)
              return
            } else if (!T || this._listenRelays.has(A)) return
            try {
              let E = this._connectionManager.get(m)
              if (!E) return
              if (E.remoteAddr.protoCodes().includes(f)) {
                n(`relayed connection to ${A} will not be used to hop on`)
                return
              }
              ;(await a({ connection: E })) &&
                (this._peerStore.metadataBook.set(m, p, i(y)), await this._addListenRelay(E, A))
            } catch (E) {
              this._onError(E)
            }
          }
          _onPeerDisconnected(m) {
            let A = m.remotePeer.toB58String()
            !this._listenRelays.has(A) || this._removeListenRelay(A)
          }
          async _addListenRelay(m, _) {
            if (this._listenRelays.size >= this.maxListeners) return
            let A = this._peerStore.addressBook.getMultiaddrsForPeer(m.remotePeer, this._addressSorter)
            if (!A || !A.length) return
            let T = `${A[0].toString()}/p2p-circuit`
            this._listenRelays.add(_)
            try {
              await this._transportManager.listen([new u(T)])
            } catch (E) {
              this._onError(E), this._listenRelays.delete(_)
            }
          }
          _removeListenRelay(m) {
            this._listenRelays.delete(m) && this._listenOnAvailableHopRelays([m])
          }
          async _listenOnAvailableHopRelays(m = []) {
            if (this._listenRelays.size >= this.maxListeners) return
            let _ = []
            for (let [A, T] of this._peerStore.metadataBook.data.entries()) {
              if (this._listenRelays.has(A) || m.includes(A)) continue
              let E = T.get(p)
              if (!E || s(E) !== y) continue
              let k = o.createFromCID(A),
                w = this._connectionManager.get(k)
              if (!w) {
                _.push(k)
                continue
              }
              if ((await this._addListenRelay(w, A), this._listenRelays.size >= this.maxListeners)) return
            }
            for (let A of _)
              if ((await this._tryToListenOnRelay(A), this._listenRelays.size >= this.maxListeners)) return
            try {
              let A = await c(d)
              for await (let T of this._libp2p.contentRouting.findProviders(A)) {
                if (!T.multiaddrs.length) continue
                let E = T.id
                if (
                  (this._peerStore.addressBook.add(E, T.multiaddrs),
                  await this._tryToListenOnRelay(E),
                  this._listenRelays.size >= this.maxListeners)
                )
                  return
              }
            } catch (A) {
              this._onError(A)
            }
          }
          async _tryToListenOnRelay(m) {
            try {
              let _ = await this._libp2p.dial(m)
              await this._addListenRelay(_, m.toB58String())
            } catch (_) {
              this._onError(_, `could not connect and listen on known hop relay ${m.toB58String()}`)
            }
          }
        }
      r.exports = h
    }
  }),
  UU = te({
    'node_modules/libp2p/src/circuit/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:relay'), { error: t('libp2p:relay:err') }),
        { setDelayedInterval: i, clearDelayedInterval: s } = aT(),
        u = LU(),
        { namespaceToCid: o } = wT(),
        { RELAY_RENDEZVOUS_NS: l } = p2(),
        a = class {
          constructor(c) {
            ;(this._libp2p = c),
              (this._options = { ...c._config.relay }),
              (this._autoRelay = this._options.autoRelay.enabled && new u({ libp2p: c, ...this._options.autoRelay })),
              (this._advertiseService = this._advertiseService.bind(this))
          }
          start() {
            this._options.hop.enabled &&
              this._options.advertise.enabled &&
              (this._timeout = i(
                this._advertiseService,
                this._options.advertise.ttl,
                this._options.advertise.bootDelay
              ))
          }
          stop() {
            s(this._timeout)
          }
          async _advertiseService() {
            try {
              let c = await o(l)
              await this._libp2p.contentRouting.provide(c)
            } catch (c) {
              c.code === 'NO_ROUTERS_AVAILABLE'
                ? (n.error(
                    'a content router, such as a DHT, must be provided in order to advertise the relay service',
                    c
                  ),
                  this.stop())
                : n.error(c)
            }
          }
        }
      r.exports = a
    }
  }),
  qU = te({
    'node_modules/timeout-abort-controller/node_modules/retimer/time-browser.js'(e, r) {
      V(),
        F(),
        (r.exports = function () {
          return Date.now()
        })
    }
  }),
  jU = te({
    'node_modules/timeout-abort-controller/node_modules/retimer/retimer.js'(e, r) {
      V(), F()
      var t = qU()
      function n(s, u, o) {
        var l = this
        ;(this._started = t()),
          (this._rescheduled = 0),
          (this._scheduled = u),
          (this._args = o),
          (this._timer = setTimeout(a, u))
        function a() {
          l._rescheduled > 0
            ? ((l._scheduled = l._rescheduled - (t() - l._started)),
              (l._timer = setTimeout(a, l._scheduled)),
              (l._rescheduled = 0))
            : s.apply(null, l._args)
        }
      }
      ;(n.prototype.reschedule = function (s) {
        var u = t()
        return u + s - (this._started + this._scheduled) < 0 ? !1 : ((this._started = u), (this._rescheduled = s), !0)
      }),
        (n.prototype.clear = function () {
          clearTimeout(this._timer)
        })
      function i() {
        if (typeof arguments[0] != 'function') throw new Error('callback needed')
        if (typeof arguments[1] != 'number') throw new Error('timeout needed')
        var s
        if (arguments.length > 0) {
          s = new Array(arguments.length - 2)
          for (var u = 0; u < s.length; u++) s[u] = arguments[u + 2]
        }
        return new n(arguments[0], arguments[1], s)
      }
      r.exports = i
    }
  }),
  zU = te({
    'node_modules/timeout-abort-controller/index.js'(e, r) {
      V(), F()
      var { AbortController: t } = typeof self != 'undefined' ? self : typeof window != 'undefined' ? window : pf(),
        n = jU(),
        i = class extends t {
          constructor(s) {
            super()
            ;(this._ms = s), (this._timer = n(() => this.abort(), s)), Object.setPrototypeOf(this, i.prototype)
          }
          abort() {
            return this._timer.clear(), super.abort()
          }
          clear() {
            this._timer.clear()
          }
          reset() {
            this._timer.clear(), (this._timer = n(() => this.abort(), this._ms))
          }
        }
      ;(r.exports = i), (r.exports.TimeoutController = i)
    }
  }),
  KU = te({
    'node_modules/native-abort-controller/src/index.js'(e, r) {
      V(), F()
      var t
      globalThis.AbortController && globalThis.AbortSignal ? (t = globalThis) : (t = pf()),
        (r.exports = { AbortController: t.AbortController, AbortSignal: t.AbortSignal })
    }
  }),
  _T = te({
    'node_modules/any-signal/index.js'(e, r) {
      V(), F()
      var { AbortController: t } = KU()
      function n(i) {
        let s = new t()
        function u() {
          s.abort()
          for (let o of i) !o || !o.removeEventListener || o.removeEventListener('abort', u)
        }
        for (let o of i)
          if (!(!o || !o.addEventListener)) {
            if (o.aborted) {
              u()
              break
            }
            o.addEventListener('abort', u)
          }
        return s.signal
      }
      ;(r.exports = n), (r.exports.anySignal = n)
    }
  }),
  FU = te({
    'node_modules/p-fifo/index.js'(e, r) {
      V(), F()
      var t = sA(),
        n = Vl()
      r.exports = class {
        constructor() {
          ;(this._buffer = new t()), (this._waitingConsumers = new t())
        }
        push(s) {
          let { promise: u, resolve: o } = n()
          return this._buffer.push({ chunk: s, resolve: o }), this._consume(), u
        }
        _consume() {
          for (; !this._waitingConsumers.isEmpty() && !this._buffer.isEmpty(); ) {
            let s = this._waitingConsumers.shift(),
              u = this._buffer.shift()
            s.resolve(u.chunk), u.resolve()
          }
        }
        shift() {
          let { promise: s, resolve: u } = n()
          return this._waitingConsumers.push({ resolve: u }), this._consume(), s
        }
        isEmpty() {
          return this._buffer.isEmpty()
        }
      }
    }
  }),
  VU = te({
    'node_modules/indent-string/index.js'(e, r) {
      V(),
        F(),
        (r.exports = (t, n = 1, i) => {
          if (((i = { indent: ' ', includeEmptyLines: !1, ...i }), typeof t != 'string'))
            throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof t}\``)
          if (typeof n != 'number') throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof n}\``)
          if (typeof i.indent != 'string')
            throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof i.indent}\``)
          if (n === 0) return t
          let s = i.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm
          return t.replace(s, i.indent.repeat(n))
        })
    }
  }),
  HU = te({
    '(disabled):os'() {
      V(), F()
    }
  }),
  $U = te({
    'node_modules/clean-stack/index.js'(e, r) {
      V(), F()
      var t = HU(),
        n = /\s+at.*(?:\(|\s)(.*)\)?/,
        i =
          /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/,
        s = typeof t.homedir == 'undefined' ? '' : t.homedir()
      r.exports = (u, o) => (
        (o = Object.assign({ pretty: !1 }, o)),
        u
          .replace(/\\/g, '/')
          .split(
            `
`
          )
          .filter((l) => {
            let a = l.match(n)
            if (a === null || !a[1]) return !0
            let c = a[1]
            return c.includes('.app/Contents/Resources/electron.asar') ||
              c.includes('.app/Contents/Resources/default_app.asar')
              ? !1
              : !i.test(c)
          })
          .filter((l) => l.trim() !== '')
          .map((l) => (o.pretty ? l.replace(n, (a, c) => a.replace(c, c.replace(s, '~'))) : l)).join(`
`)
      )
    }
  }),
  GU = te({
    'node_modules/aggregate-error/index.js'(e, r) {
      V(), F()
      var t = VU(),
        n = $U(),
        i = (u) => u.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, ''),
        s = class extends Error {
          constructor(u) {
            if (!Array.isArray(u)) throw new TypeError(`Expected input to be an Array, got ${typeof u}`)
            u = [...u].map((l) =>
              l instanceof Error
                ? l
                : l !== null && typeof l == 'object'
                ? Object.assign(new Error(l.message), l)
                : new Error(l)
            )
            let o = u.map((l) => (typeof l.stack == 'string' ? i(n(l.stack)) : String(l))).join(`
`)
            o =
              `
` + t(o, 4)
            super(o)
            ;(this.name = 'AggregateError'), Object.defineProperty(this, '_errors', { value: u })
          }
          *[Symbol.iterator]() {
            for (let u of this._errors) yield u
          }
        }
      r.exports = s
    }
  }),
  ET = te({
    'node_modules/p-cancelable/index.js'(e, r) {
      V(), F()
      var t = class extends Error {
          constructor(i) {
            super(i || 'Promise was canceled')
            this.name = 'CancelError'
          }
          get isCanceled() {
            return !0
          }
        },
        n = class {
          static fn(i) {
            return (...s) =>
              new n((u, o, l) => {
                s.push(l), i(...s).then(u, o)
              })
          }
          constructor(i) {
            ;(this._cancelHandlers = []),
              (this._isPending = !0),
              (this._isCanceled = !1),
              (this._rejectOnCancel = !0),
              (this._promise = new Promise((s, u) => {
                this._reject = u
                let o = (c) => {
                    ;(!this._isCanceled || !a.shouldReject) && ((this._isPending = !1), s(c))
                  },
                  l = (c) => {
                    ;(this._isPending = !1), u(c)
                  },
                  a = (c) => {
                    if (!this._isPending)
                      throw new Error('The `onCancel` handler was attached after the promise settled.')
                    this._cancelHandlers.push(c)
                  }
                return (
                  Object.defineProperties(a, {
                    shouldReject: {
                      get: () => this._rejectOnCancel,
                      set: (c) => {
                        this._rejectOnCancel = c
                      }
                    }
                  }),
                  i(o, l, a)
                )
              }))
          }
          then(i, s) {
            return this._promise.then(i, s)
          }
          catch(i) {
            return this._promise.catch(i)
          }
          finally(i) {
            return this._promise.finally(i)
          }
          cancel(i) {
            if (!(!this._isPending || this._isCanceled)) {
              if (((this._isCanceled = !0), this._cancelHandlers.length > 0))
                try {
                  for (let s of this._cancelHandlers) s()
                } catch (s) {
                  this._reject(s)
                  return
                }
              this._rejectOnCancel && this._reject(new t(i))
            }
          }
          get isCanceled() {
            return this._isCanceled
          }
        }
      Object.setPrototypeOf(n.prototype, Promise.prototype), (r.exports = n), (r.exports.CancelError = t)
    }
  }),
  WU = te({
    'node_modules/p-some/index.js'(e, r) {
      V(), F()
      var t = GU(),
        n = ET(),
        i = class extends Error {},
        s = (u, o) =>
          new n((l, a, c) => {
            let { count: f, filter: p = () => !0 } = o
            if (!Number.isFinite(f)) {
              a(new TypeError(`Expected a finite number, got ${typeof o.count}`))
              return
            }
            let y = [],
              d = [],
              h = 0,
              m = !1,
              _ = new Set(),
              A = () => (y.length === f && (l(y), (m = !0)), h - d.length < f && (a(new t(d)), (m = !0)), m),
              T = () => {
                for (let E of u) !_.has(E) && typeof E.cancel == 'function' && E.cancel()
              }
            c(T)
            for (let E of u)
              h++,
                (async () => {
                  try {
                    let k = await E
                    if (m) return
                    if (!p(k)) throw new i('Value does not satisfy filter')
                    y.push(k)
                  } catch (k) {
                    d.push(k)
                  } finally {
                    _.add(E), !m && A() && T()
                  }
                })()
            f > h &&
              (a(new RangeError(`Expected input to contain at least ${o.count} items, but contains ${h} items`)), T())
          })
      ;(r.exports = s), (r.exports.AggregateError = t), (r.exports.FilterError = i)
    }
  }),
  JU = te({
    'node_modules/p-any/index.js'(e, r) {
      V(), F()
      var t = WU(),
        n = ET()
      ;(r.exports = (i, s) => {
        let u = t(i, { ...s, count: 1 })
        return n.fn(async (o) => {
          o(() => {
            u.cancel()
          })
          let [l] = await u
          return l
        })()
      }),
        (r.exports.AggregateError = t.AggregateError)
    }
  }),
  XU = te({
    'node_modules/libp2p/src/dialer/dial-request.js'(e, r) {
      V(), F()
      var t = pt(),
        n = pf().default,
        { anySignal: i } = _T(),
        s = FU(),
        u = JU(),
        o = class {
          constructor({ addrs: l, dialAction: a, dialer: c }) {
            ;(this.addrs = l), (this.dialer = c), (this.dialAction = a)
          }
          async run(l = {}) {
            let a = this.dialer.getTokens(this.addrs.length)
            if (a.length < 1) throw t(new Error('No dial tokens available'), 'ERR_NO_DIAL_TOKENS')
            let c = new s()
            a.forEach((y) => c.push(y))
            let f = this.addrs.map(() => new n()),
              p = 0
            try {
              return await u(
                this.addrs.map(async (y, d) => {
                  let h = await c.shift(),
                    m
                  try {
                    let _ = f[d].signal
                    ;(m = await this.dialAction(y, { ...l, signal: l.signal ? i([_, l.signal]) : _ })), f.splice(d, 1)
                  } finally {
                    p++,
                      this.addrs.length - p >= a.length
                        ? c.push(h)
                        : this.dialer.releaseToken(a.splice(a.indexOf(h), 1)[0])
                  }
                  return m
                })
              )
            } finally {
              f.map((y) => y.abort()), a.forEach((y) => this.dialer.releaseToken(y))
            }
          }
        }
      r.exports = o
    }
  }),
  YU = te({
    'node_modules/libp2p/src/dialer/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:dialer'), { error: t('libp2p:dialer:err') }),
        i = pt(),
        { Multiaddr: s } = Zr(),
        u = zU(),
        { AbortError: o } = Ui(),
        { anySignal: l } = _T(),
        a = XU(),
        { publicAddressesFirst: c } = dT(),
        f = cT(),
        { codes: p } = or(),
        { DIAL_TIMEOUT: y, MAX_PARALLEL_DIALS: d, MAX_PER_PEER_DIALS: h } = h2(),
        m = class {
          constructor({
            transportManager: _,
            peerStore: A,
            addressSorter: T = c,
            maxParallelDials: E = d,
            dialTimeout: k = y,
            maxDialsPerPeer: w = h,
            resolvers: v = {}
          }) {
            ;(this.transportManager = _),
              (this.peerStore = A),
              (this.addressSorter = T),
              (this.maxParallelDials = E),
              (this.timeout = k),
              (this.maxDialsPerPeer = w),
              (this.tokens = [...new Array(E)].map((I, M) => M)),
              (this._pendingDials = new Map()),
              (this._pendingDialTargets = new Map())
            for (let [I, M] of Object.entries(v)) s.resolvers.set(I, M)
          }
          destroy() {
            for (let _ of this._pendingDials.values())
              try {
                _.controller.abort()
              } catch (A) {
                n.error(A)
              }
            this._pendingDials.clear()
            for (let _ of this._pendingDialTargets.values()) _.reject(new o('Dialer was destroyed'))
            this._pendingDialTargets.clear()
          }
          async connectToPeer(_, A = {}) {
            let T = await this._createCancellableDialTarget(_)
            if (!T.addrs.length) throw i(new Error('The dial request has no valid addresses'), p.ERR_NO_VALID_ADDRESSES)
            let E = this._pendingDials.get(T.id) || this._createPendingDial(T, A)
            try {
              let k = await E.promise
              return n('dial succeeded to %s', T.id), k
            } catch (k) {
              throw (E.controller.signal.aborted && (k.code = p.ERR_TIMEOUT), n.error(k), k)
            } finally {
              E.destroy()
            }
          }
          async _createCancellableDialTarget(_) {
            let A = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`,
              T = new Promise((k, w) => {
                this._pendingDialTargets.set(A, { resolve: k, reject: w })
              }),
              E = await Promise.race([this._createDialTarget(_), T])
            return this._pendingDialTargets.delete(A), E
          }
          async _createDialTarget(_) {
            let { id: A, multiaddrs: T } = f(_)
            T && this.peerStore.addressBook.add(A, T)
            let E = this.peerStore.addressBook.getMultiaddrsForPeer(A, this.addressSorter) || []
            s.isMultiaddr(_) && ((E = E.filter((v) => !_.equals(v))), E.unshift(_))
            let k = []
            for (let v of E) (await this._resolve(v)).forEach((M) => k.push(M))
            let w = k.filter((v) => this.transportManager.transportForMultiaddr(v))
            return { id: A.toB58String(), addrs: w }
          }
          _createPendingDial(_, A = {}) {
            let T = (M, q) => {
                if (q.signal.aborted) throw i(new Error('already aborted'), p.ERR_ALREADY_ABORTED)
                return this.transportManager.dial(M, q)
              },
              E = new a({ addrs: _.addrs, dialAction: T, dialer: this }),
              k = new u(this.timeout),
              w = [k.signal]
            A.signal && w.push(A.signal)
            let v = l(w),
              I = {
                dialRequest: E,
                controller: k,
                promise: E.run({ ...A, signal: v }),
                destroy: () => {
                  k.clear(), this._pendingDials.delete(_.id)
                }
              }
            return this._pendingDials.set(_.id, I), I
          }
          getTokens(_) {
            let A = Math.min(_, this.maxDialsPerPeer, this.tokens.length),
              T = this.tokens.splice(0, A)
            return n('%d tokens request, returning %d, %d remaining', _, A, this.tokens.length), T
          }
          releaseToken(_) {
            this.tokens.indexOf(_) > -1 || (n('token %d released', _), this.tokens.push(_))
          }
          async _resolve(_) {
            if (!_.protoNames().includes('dnsaddr')) return [_]
            let T = await this._resolveRecord(_)
            return (await Promise.all(T.map((w) => this._resolve(w))))
              .flat()
              .reduce((w, v) => (w.find((I) => I.equals(v)) || w.push(v), w), [])
          }
          async _resolveRecord(_) {
            try {
              return (_ = new s(_.toString())), await _.resolve()
            } catch (A) {
              return n.error(`multiaddr ${_} could not be resolved`), []
            }
          }
        }
      r.exports = m
    }
  }),
  ZU = te({
    'node_modules/truncate-utf8-bytes/lib/truncate.js'(e, r) {
      V(), F()
      function t(i) {
        return i >= 55296 && i <= 56319
      }
      function n(i) {
        return i >= 56320 && i <= 57343
      }
      r.exports = function (s, u, o) {
        if (typeof u != 'string') throw new Error('Input must be string')
        for (var l = u.length, a = 0, c, f, p = 0; p < l; p += 1) {
          if (
            ((c = u.charCodeAt(p)),
            (f = u[p]),
            t(c) && n(u.charCodeAt(p + 1)) && ((p += 1), (f += u[p])),
            (a += s(f)),
            a === o)
          )
            return u.slice(0, p + 1)
          if (a > o) return u.slice(0, p - f.length + 1)
        }
        return u
      }
    }
  }),
  QU = te({
    'node_modules/utf8-byte-length/browser.js'(e, r) {
      V(), F()
      function t(i) {
        return i >= 55296 && i <= 56319
      }
      function n(i) {
        return i >= 56320 && i <= 57343
      }
      r.exports = function (s) {
        if (typeof s != 'string') throw new Error('Input must be string')
        for (var u = s.length, o = 0, l = null, a = null, c = 0; c < u; c++)
          (l = s.charCodeAt(c)),
            n(l)
              ? a != null && t(a)
                ? (o += 1)
                : (o += 3)
              : l <= 127
              ? (o += 1)
              : l >= 128 && l <= 2047
              ? (o += 2)
              : l >= 2048 && l <= 65535 && (o += 3),
            (a = l)
        return o
      }
    }
  }),
  eq = te({
    'node_modules/truncate-utf8-bytes/browser.js'(e, r) {
      V(), F()
      var t = ZU(),
        n = QU()
      r.exports = t.bind(null, n)
    }
  }),
  tq = te({
    'node_modules/sanitize-filename/index.js'(e, r) {
      V(), F()
      var t = eq(),
        n = /[\/\?<>\\:\*\|"]/g,
        i = /[\x00-\x1f\x80-\x9f]/g,
        s = /^\.+$/,
        u = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,
        o = /[\. ]+$/
      function l(a, c) {
        if (typeof a != 'string') throw new Error('Input must be string')
        var f = a.replace(n, c).replace(i, c).replace(s, c).replace(u, c).replace(o, c)
        return t(f, 255)
      }
      r.exports = function (a, c) {
        var f = (c && c.replacement) || '',
          p = l(a, f)
        return f === '' ? p : l(p, '')
      }
    }
  }),
  ST,
  rq = Ie({
    'node_modules/nanoid/url-alphabet/index.js'() {
      V(), F(), (ST = 'ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW')
    }
  }),
  v2 = {}
Re(v2, { customAlphabet: () => AT, customRandom: () => w2, nanoid: () => IT, random: () => g2, urlAlphabet: () => ST })
var g2,
  w2,
  AT,
  IT,
  TT = Ie({
    'node_modules/nanoid/index.prod.js'() {
      V(),
        F(),
        rq(),
        (g2 = (e) => crypto.getRandomValues(new Uint8Array(e))),
        (w2 = (e, r, t) => {
          let n = (2 << (Math.log(e.length - 1) / Math.LN2)) - 1,
            i = -~((1.6 * n * r) / e.length)
          return () => {
            let s = ''
            for (;;) {
              let u = t(i),
                o = i
              for (; o--; ) if (((s += e[u[o] & n] || ''), s.length === r)) return s
            }
          }
        }),
        (AT = (e, r) => w2(e, r, g2)),
        (IT = (e = 21) => {
          let r = '',
            t = crypto.getRandomValues(new Uint8Array(e))
          for (; e--; ) {
            let n = t[e] & 63
            n < 36
              ? (r += n.toString(36))
              : n < 62
              ? (r += (n - 26).toString(36).toUpperCase())
              : n < 63
              ? (r += '_')
              : (r += '-')
          }
          return r
        })
    }
  }),
  CT = te({
    'node_modules/libp2p/node_modules/interface-datastore/src/key.js'(e, r) {
      V(), F()
      var { nanoid: t } = (TT(), v2),
        n = zi(),
        i = xs(),
        s = Symbol.for('@ipfs/interface-datastore/key'),
        u = '/',
        o = new TextEncoder().encode(u),
        l = o[0],
        a = class {
          constructor(y, d) {
            if (typeof y == 'string') this._buf = i(y)
            else if (y instanceof Uint8Array) this._buf = y
            else throw new Error('Invalid key, should be String of Uint8Array')
            if ((d == null && (d = !0), d && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== l))
              throw new Error('Invalid key')
          }
          toString(y = 'utf8') {
            return n(this._buf, y)
          }
          uint8Array() {
            return this._buf
          }
          get [s]() {
            return !0
          }
          get [Symbol.toStringTag]() {
            return `Key(${this.toString()})`
          }
          static withNamespaces(y) {
            return new a(y.join(u))
          }
          static random() {
            return new a(t().replace(/-/g, ''))
          }
          clean() {
            if (((!this._buf || this._buf.byteLength === 0) && (this._buf = o), this._buf[0] !== l)) {
              let y = new Uint8Array(this._buf.byteLength + 1)
              y.fill(l, 0, 1), y.set(this._buf, 1), (this._buf = y)
            }
            for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === l; )
              this._buf = this._buf.subarray(0, -1)
          }
          less(y) {
            let d = this.list(),
              h = y.list()
            for (let m = 0; m < d.length; m++) {
              if (h.length < m + 1) return !1
              let _ = d[m],
                A = h[m]
              if (_ < A) return !0
              if (_ > A) return !1
            }
            return d.length < h.length
          }
          reverse() {
            return a.withNamespaces(this.list().slice().reverse())
          }
          namespaces() {
            return this.list()
          }
          baseNamespace() {
            let y = this.namespaces()
            return y[y.length - 1]
          }
          list() {
            return this.toString().split(u).slice(1)
          }
          type() {
            return c(this.baseNamespace())
          }
          name() {
            return f(this.baseNamespace())
          }
          instance(y) {
            return new a(this.toString() + ':' + y)
          }
          path() {
            let y = this.parent().toString()
            return y.endsWith(u) || (y += u), (y += this.type()), new a(y)
          }
          parent() {
            let y = this.list()
            return y.length === 1 ? new a(u) : new a(y.slice(0, -1).join(u))
          }
          child(y) {
            return this.toString() === u ? y : y.toString() === u ? this : new a(this.toString() + y.toString(), !1)
          }
          isAncestorOf(y) {
            return y.toString() === this.toString() ? !1 : y.toString().startsWith(this.toString())
          }
          isDecendantOf(y) {
            return y.toString() === this.toString() ? !1 : this.toString().startsWith(y.toString())
          }
          isTopLevel() {
            return this.list().length === 1
          }
          concat(...y) {
            return a.withNamespaces([...this.namespaces(), ...p(y.map((d) => d.namespaces()))])
          }
          static isKey(y) {
            return y instanceof a || Boolean(y && y[s])
          }
        }
      function c(y) {
        let d = y.split(':')
        return d.length < 2 ? '' : d.slice(0, -1).join(':')
      }
      function f(y) {
        let d = y.split(':')
        return d[d.length - 1]
      }
      function p(y) {
        return [].concat(...y)
      }
      r.exports = a
    }
  }),
  nq = te({
    'node_modules/ipfs-utils/src/temp-dir.browser.js'(e, r) {
      V(), F()
      var { nanoid: t } = (TT(), v2),
        n = (i = (s) => s) => i(t())
      r.exports = n
    }
  }),
  iq = te({
    'node_modules/it-all/index.js'(e, r) {
      V(), F()
      var t = async (n) => {
        let i = []
        for await (let s of n) i.push(s)
        return i
      }
      r.exports = t
    }
  }),
  kT = te({
    'node_modules/libp2p/node_modules/interface-datastore/src/utils.js'(e, r) {
      V(), F()
      var t = nq(),
        n = iq(),
        i = (u, o) =>
          (async function* () {
            yield* (await n(u)).sort(o)
          })(),
        s = (u, o) => {
          let l = new RegExp('^' + o)
          return u.replace(l, '')
        }
      r.exports = { sortAll: i, tmpdir: t, replaceStartWith: s }
    }
  }),
  sq = te({
    'node_modules/libp2p/node_modules/interface-datastore/node_modules/it-take/index.js'(e, r) {
      V(), F()
      var t = async function* (n, i) {
        let s = 0
        if (!(i < 1)) {
          for await (let u of n) if ((yield u, s++, s === i)) return
        }
      }
      r.exports = t
    }
  }),
  MT = te({
    'node_modules/libp2p/node_modules/interface-datastore/src/adapter.js'(e, r) {
      V(), F()
      var { sortAll: t } = kT(),
        n = oT(),
        i = d2(),
        s = sq(),
        u = class {
          open() {
            return Promise.reject(new Error('.open is not implemented'))
          }
          close() {
            return Promise.reject(new Error('.close is not implemented'))
          }
          put(o, l, a) {
            return Promise.reject(new Error('.put is not implemented'))
          }
          get(o, l) {
            return Promise.reject(new Error('.get is not implemented'))
          }
          has(o, l) {
            return Promise.reject(new Error('.has is not implemented'))
          }
          delete(o, l) {
            return Promise.reject(new Error('.delete is not implemented'))
          }
          async *putMany(o, l = {}) {
            for await (let { key: a, value: c } of o) await this.put(a, c, l), yield { key: a, value: c }
          }
          async *getMany(o, l = {}) {
            for await (let a of o) yield this.get(a, l)
          }
          async *deleteMany(o, l = {}) {
            for await (let a of o) await this.delete(a, l), yield a
          }
          batch() {
            let o = [],
              l = []
            return {
              put(a, c) {
                o.push({ key: a, value: c })
              },
              delete(a) {
                l.push(a)
              },
              commit: async (a) => {
                await n(this.putMany(o, a)), (o = []), await n(this.deleteMany(l, a)), (l = [])
              }
            }
          }
          async *_all(o, l) {
            throw new Error('._all is not implemented')
          }
          async *_allKeys(o, l) {
            throw new Error('._allKeys is not implemented')
          }
          query(o, l) {
            let a = this._all(o, l)
            if (
              (o.prefix != null && (a = i(a, (c) => c.key.toString().startsWith(o.prefix))),
              Array.isArray(o.filters) && (a = o.filters.reduce((c, f) => i(c, f), a)),
              Array.isArray(o.orders) && (a = o.orders.reduce((c, f) => t(c, f), a)),
              o.offset != null)
            ) {
              let c = 0
              a = i(a, () => c++ >= o.offset)
            }
            return o.limit != null && (a = s(a, o.limit)), a
          }
          queryKeys(o, l) {
            let a = this._allKeys(o, l)
            if (
              (o.prefix != null && (a = i(a, (c) => c.toString().startsWith(o.prefix))),
              Array.isArray(o.filters) && (a = o.filters.reduce((c, f) => i(c, f), a)),
              Array.isArray(o.orders) && (a = o.orders.reduce((c, f) => t(c, f), a)),
              o.offset != null)
            ) {
              let c = 0
              a = i(a, () => c++ >= o.offset)
            }
            return o.limit != null && (a = s(a, o.limit)), a
          }
        }
      r.exports = u
    }
  }),
  xT = te({
    'node_modules/libp2p/node_modules/interface-datastore/src/errors.js'(e, r) {
      V(), F()
      var t = pt()
      function n(l) {
        return (l = l || new Error('Cannot open database')), t(l, 'ERR_DB_OPEN_FAILED')
      }
      function i(l) {
        return (l = l || new Error('Delete failed')), t(l, 'ERR_DB_DELETE_FAILED')
      }
      function s(l) {
        return (l = l || new Error('Write failed')), t(l, 'ERR_DB_WRITE_FAILED')
      }
      function u(l) {
        return (l = l || new Error('Not Found')), t(l, 'ERR_NOT_FOUND')
      }
      function o(l) {
        return (l = l || new Error('Aborted')), t(l, 'ERR_ABORTED')
      }
      r.exports = {
        dbOpenFailedError: n,
        dbDeleteFailedError: i,
        dbWriteFailedError: s,
        notFoundError: u,
        abortedError: o
      }
    }
  }),
  oq = te({
    'node_modules/libp2p/node_modules/interface-datastore/src/memory.js'(e, r) {
      V(), F()
      var t = CT(),
        n = MT(),
        i = xT(),
        s = class extends n {
          constructor() {
            super()
            this.data = {}
          }
          open() {
            return Promise.resolve()
          }
          close() {
            return Promise.resolve()
          }
          async put(u, o) {
            this.data[u.toString()] = o
          }
          async get(u) {
            if (!(await this.has(u))) throw i.notFoundError()
            return this.data[u.toString()]
          }
          async has(u) {
            return this.data[u.toString()] !== void 0
          }
          async delete(u) {
            delete this.data[u.toString()]
          }
          async *_all() {
            yield* Object.entries(this.data).map(([u, o]) => ({ key: new t(u), value: o }))
          }
          async *_allKeys() {
            yield* Object.entries(this.data).map(([u]) => new t(u))
          }
        }
      r.exports = s
    }
  }),
  RT = te({
    'node_modules/libp2p/node_modules/interface-datastore/src/index.js'(e, r) {
      V(), F()
      var t = CT(),
        n = oq(),
        i = kT(),
        s = xT(),
        u = MT()
      r.exports = { Key: t, MemoryDatastore: n, utils: i, Errors: s, Adapter: u }
    }
  }),
  aq = te({
    'node_modules/node-forge/lib/pkcs7asn1.js'(e, r) {
      V(), F()
      var t = yt()
      qi(), zt()
      var n = t.asn1,
        i = (r.exports = t.pkcs7asn1 = t.pkcs7asn1 || {})
      ;(t.pkcs7 = t.pkcs7 || {}), (t.pkcs7.asn1 = i)
      var s = {
        name: 'ContentInfo',
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'ContentInfo.ContentType',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.OID,
            constructed: !1,
            capture: 'contentType'
          },
          {
            name: 'ContentInfo.content',
            tagClass: n.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: !0,
            optional: !0,
            captureAsn1: 'content'
          }
        ]
      }
      i.contentInfoValidator = s
      var u = {
        name: 'EncryptedContentInfo',
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'EncryptedContentInfo.contentType',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.OID,
            constructed: !1,
            capture: 'contentType'
          },
          {
            name: 'EncryptedContentInfo.contentEncryptionAlgorithm',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.SEQUENCE,
            constructed: !0,
            value: [
              {
                name: 'EncryptedContentInfo.contentEncryptionAlgorithm.algorithm',
                tagClass: n.Class.UNIVERSAL,
                type: n.Type.OID,
                constructed: !1,
                capture: 'encAlgorithm'
              },
              {
                name: 'EncryptedContentInfo.contentEncryptionAlgorithm.parameter',
                tagClass: n.Class.UNIVERSAL,
                captureAsn1: 'encParameter'
              }
            ]
          },
          {
            name: 'EncryptedContentInfo.encryptedContent',
            tagClass: n.Class.CONTEXT_SPECIFIC,
            type: 0,
            capture: 'encryptedContent',
            captureAsn1: 'encryptedContentAsn1'
          }
        ]
      }
      ;(i.envelopedDataValidator = {
        name: 'EnvelopedData',
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'EnvelopedData.Version',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.INTEGER,
            constructed: !1,
            capture: 'version'
          },
          {
            name: 'EnvelopedData.RecipientInfos',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.SET,
            constructed: !0,
            captureAsn1: 'recipientInfos'
          }
        ].concat(u)
      }),
        (i.encryptedDataValidator = {
          name: 'EncryptedData',
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'EncryptedData.Version',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.INTEGER,
              constructed: !1,
              capture: 'version'
            }
          ].concat(u)
        })
      var o = {
        name: 'SignerInfo',
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [
          { name: 'SignerInfo.version', tagClass: n.Class.UNIVERSAL, type: n.Type.INTEGER, constructed: !1 },
          {
            name: 'SignerInfo.issuerAndSerialNumber',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.SEQUENCE,
            constructed: !0,
            value: [
              {
                name: 'SignerInfo.issuerAndSerialNumber.issuer',
                tagClass: n.Class.UNIVERSAL,
                type: n.Type.SEQUENCE,
                constructed: !0,
                captureAsn1: 'issuer'
              },
              {
                name: 'SignerInfo.issuerAndSerialNumber.serialNumber',
                tagClass: n.Class.UNIVERSAL,
                type: n.Type.INTEGER,
                constructed: !1,
                capture: 'serial'
              }
            ]
          },
          {
            name: 'SignerInfo.digestAlgorithm',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.SEQUENCE,
            constructed: !0,
            value: [
              {
                name: 'SignerInfo.digestAlgorithm.algorithm',
                tagClass: n.Class.UNIVERSAL,
                type: n.Type.OID,
                constructed: !1,
                capture: 'digestAlgorithm'
              },
              {
                name: 'SignerInfo.digestAlgorithm.parameter',
                tagClass: n.Class.UNIVERSAL,
                constructed: !1,
                captureAsn1: 'digestParameter',
                optional: !0
              }
            ]
          },
          {
            name: 'SignerInfo.authenticatedAttributes',
            tagClass: n.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: !0,
            optional: !0,
            capture: 'authenticatedAttributes'
          },
          {
            name: 'SignerInfo.digestEncryptionAlgorithm',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.SEQUENCE,
            constructed: !0,
            capture: 'signatureAlgorithm'
          },
          {
            name: 'SignerInfo.encryptedDigest',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.OCTETSTRING,
            constructed: !1,
            capture: 'signature'
          },
          {
            name: 'SignerInfo.unauthenticatedAttributes',
            tagClass: n.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: !0,
            optional: !0,
            capture: 'unauthenticatedAttributes'
          }
        ]
      }
      ;(i.signedDataValidator = {
        name: 'SignedData',
        tagClass: n.Class.UNIVERSAL,
        type: n.Type.SEQUENCE,
        constructed: !0,
        value: [
          {
            name: 'SignedData.Version',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.INTEGER,
            constructed: !1,
            capture: 'version'
          },
          {
            name: 'SignedData.DigestAlgorithms',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.SET,
            constructed: !0,
            captureAsn1: 'digestAlgorithms'
          },
          s,
          {
            name: 'SignedData.Certificates',
            tagClass: n.Class.CONTEXT_SPECIFIC,
            type: 0,
            optional: !0,
            captureAsn1: 'certificates'
          },
          {
            name: 'SignedData.CertificateRevocationLists',
            tagClass: n.Class.CONTEXT_SPECIFIC,
            type: 1,
            optional: !0,
            captureAsn1: 'crls'
          },
          {
            name: 'SignedData.SignerInfos',
            tagClass: n.Class.UNIVERSAL,
            type: n.Type.SET,
            capture: 'signerInfos',
            optional: !0,
            value: [o]
          }
        ]
      }),
        (i.recipientInfoValidator = {
          name: 'RecipientInfo',
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'RecipientInfo.version',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.INTEGER,
              constructed: !1,
              capture: 'version'
            },
            {
              name: 'RecipientInfo.issuerAndSerial',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'RecipientInfo.issuerAndSerial.issuer',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.SEQUENCE,
                  constructed: !0,
                  captureAsn1: 'issuer'
                },
                {
                  name: 'RecipientInfo.issuerAndSerial.serialNumber',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.INTEGER,
                  constructed: !1,
                  capture: 'serial'
                }
              ]
            },
            {
              name: 'RecipientInfo.keyEncryptionAlgorithm',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'RecipientInfo.keyEncryptionAlgorithm.algorithm',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.OID,
                  constructed: !1,
                  capture: 'encAlgorithm'
                },
                {
                  name: 'RecipientInfo.keyEncryptionAlgorithm.parameter',
                  tagClass: n.Class.UNIVERSAL,
                  constructed: !1,
                  captureAsn1: 'encParameter'
                }
              ]
            },
            {
              name: 'RecipientInfo.encryptedKey',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.OCTETSTRING,
              constructed: !1,
              capture: 'encKey'
            }
          ]
        })
    }
  }),
  cq = te({
    'node_modules/node-forge/lib/mgf1.js'(e, r) {
      V(), F()
      var t = yt()
      zt(), (t.mgf = t.mgf || {})
      var n = (r.exports = t.mgf.mgf1 = t.mgf1 = t.mgf1 || {})
      n.create = function (i) {
        var s = {
          generate: function (u, o) {
            for (var l = new t.util.ByteBuffer(), a = Math.ceil(o / i.digestLength), c = 0; c < a; c++) {
              var f = new t.util.ByteBuffer()
              f.putInt32(c), i.start(), i.update(u + f.getBytes()), l.putBuffer(i.digest())
            }
            return l.truncate(l.length() - o), l.getBytes()
          }
        }
        return s
      }
    }
  }),
  uq = te({
    'node_modules/node-forge/lib/mgf.js'(e, r) {
      V(), F()
      var t = yt()
      cq(), (r.exports = t.mgf = t.mgf || {}), (t.mgf.mgf1 = t.mgf1)
    }
  }),
  lq = te({
    'node_modules/node-forge/lib/pss.js'(e, r) {
      V(), F()
      var t = yt()
      Ss(), zt()
      var n = (r.exports = t.pss = t.pss || {})
      n.create = function (i) {
        arguments.length === 3 && (i = { md: arguments[0], mgf: arguments[1], saltLength: arguments[2] })
        var s = i.md,
          u = i.mgf,
          o = s.digestLength,
          l = i.salt || null
        typeof l == 'string' && (l = t.util.createBuffer(l))
        var a
        if ('saltLength' in i) a = i.saltLength
        else if (l !== null) a = l.length()
        else throw new Error('Salt length not specified or specific salt not given.')
        if (l !== null && l.length() !== a) throw new Error('Given salt length does not match length of given salt.')
        var c = i.prng || t.random,
          f = {}
        return (
          (f.encode = function (p, y) {
            var d,
              h = y - 1,
              m = Math.ceil(h / 8),
              _ = p.digest().getBytes()
            if (m < o + a + 2) throw new Error('Message is too long to encrypt.')
            var A
            l === null ? (A = c.getBytesSync(a)) : (A = l.bytes())
            var T = new t.util.ByteBuffer()
            T.fillWithByte(0, 8), T.putBytes(_), T.putBytes(A), s.start(), s.update(T.getBytes())
            var E = s.digest().getBytes(),
              k = new t.util.ByteBuffer()
            k.fillWithByte(0, m - a - o - 2), k.putByte(1), k.putBytes(A)
            var w = k.getBytes(),
              v = m - o - 1,
              I = u.generate(E, v),
              M = ''
            for (d = 0; d < v; d++) M += String.fromCharCode(w.charCodeAt(d) ^ I.charCodeAt(d))
            var q = (65280 >> (8 * m - h)) & 255
            return (M = String.fromCharCode(M.charCodeAt(0) & ~q) + M.substr(1)), M + E + String.fromCharCode(188)
          }),
          (f.verify = function (p, y, d) {
            var h,
              m = d - 1,
              _ = Math.ceil(m / 8)
            if (((y = y.substr(-_)), _ < o + a + 2))
              throw new Error('Inconsistent parameters to PSS signature verification.')
            if (y.charCodeAt(_ - 1) !== 188) throw new Error('Encoded message does not end in 0xBC.')
            var A = _ - o - 1,
              T = y.substr(0, A),
              E = y.substr(A, o),
              k = (65280 >> (8 * _ - m)) & 255
            if ((T.charCodeAt(0) & k) != 0) throw new Error('Bits beyond keysize not zero as expected.')
            var w = u.generate(E, A),
              v = ''
            for (h = 0; h < A; h++) v += String.fromCharCode(T.charCodeAt(h) ^ w.charCodeAt(h))
            v = String.fromCharCode(v.charCodeAt(0) & ~k) + v.substr(1)
            var I = _ - o - a - 2
            for (h = 0; h < I; h++) if (v.charCodeAt(h) !== 0) throw new Error('Leftmost octets not zero as expected')
            if (v.charCodeAt(I) !== 1) throw new Error('Inconsistent PSS signature, 0x01 marker not found')
            var M = v.substr(-a),
              q = new t.util.ByteBuffer()
            q.fillWithByte(0, 8), q.putBytes(p), q.putBytes(M), s.start(), s.update(q.getBytes())
            var G = s.digest().getBytes()
            return E === G
          }),
          f
        )
      }
    }
  }),
  BT = te({
    'node_modules/node-forge/lib/x509.js'(e, r) {
      V(), F()
      var t = yt()
      qc(), qi(), Zp(), Es(), uq(), Uc(), Qp(), lq(), nf(), zt()
      var n = t.asn1,
        i = (r.exports = t.pki = t.pki || {}),
        s = i.oids,
        u = {}
      ;(u.CN = s.commonName),
        (u.commonName = 'CN'),
        (u.C = s.countryName),
        (u.countryName = 'C'),
        (u.L = s.localityName),
        (u.localityName = 'L'),
        (u.ST = s.stateOrProvinceName),
        (u.stateOrProvinceName = 'ST'),
        (u.O = s.organizationName),
        (u.organizationName = 'O'),
        (u.OU = s.organizationalUnitName),
        (u.organizationalUnitName = 'OU'),
        (u.E = s.emailAddress),
        (u.emailAddress = 'E')
      var o = t.pki.rsa.publicKeyValidator,
        l = {
          name: 'Certificate',
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'Certificate.TBSCertificate',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: 'tbsCertificate',
              value: [
                {
                  name: 'Certificate.TBSCertificate.version',
                  tagClass: n.Class.CONTEXT_SPECIFIC,
                  type: 0,
                  constructed: !0,
                  optional: !0,
                  value: [
                    {
                      name: 'Certificate.TBSCertificate.version.integer',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.INTEGER,
                      constructed: !1,
                      capture: 'certVersion'
                    }
                  ]
                },
                {
                  name: 'Certificate.TBSCertificate.serialNumber',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.INTEGER,
                  constructed: !1,
                  capture: 'certSerialNumber'
                },
                {
                  name: 'Certificate.TBSCertificate.signature',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.SEQUENCE,
                  constructed: !0,
                  value: [
                    {
                      name: 'Certificate.TBSCertificate.signature.algorithm',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.OID,
                      constructed: !1,
                      capture: 'certinfoSignatureOid'
                    },
                    {
                      name: 'Certificate.TBSCertificate.signature.parameters',
                      tagClass: n.Class.UNIVERSAL,
                      optional: !0,
                      captureAsn1: 'certinfoSignatureParams'
                    }
                  ]
                },
                {
                  name: 'Certificate.TBSCertificate.issuer',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.SEQUENCE,
                  constructed: !0,
                  captureAsn1: 'certIssuer'
                },
                {
                  name: 'Certificate.TBSCertificate.validity',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.SEQUENCE,
                  constructed: !0,
                  value: [
                    {
                      name: 'Certificate.TBSCertificate.validity.notBefore (utc)',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.UTCTIME,
                      constructed: !1,
                      optional: !0,
                      capture: 'certValidity1UTCTime'
                    },
                    {
                      name: 'Certificate.TBSCertificate.validity.notBefore (generalized)',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.GENERALIZEDTIME,
                      constructed: !1,
                      optional: !0,
                      capture: 'certValidity2GeneralizedTime'
                    },
                    {
                      name: 'Certificate.TBSCertificate.validity.notAfter (utc)',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.UTCTIME,
                      constructed: !1,
                      optional: !0,
                      capture: 'certValidity3UTCTime'
                    },
                    {
                      name: 'Certificate.TBSCertificate.validity.notAfter (generalized)',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.GENERALIZEDTIME,
                      constructed: !1,
                      optional: !0,
                      capture: 'certValidity4GeneralizedTime'
                    }
                  ]
                },
                {
                  name: 'Certificate.TBSCertificate.subject',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.SEQUENCE,
                  constructed: !0,
                  captureAsn1: 'certSubject'
                },
                o,
                {
                  name: 'Certificate.TBSCertificate.issuerUniqueID',
                  tagClass: n.Class.CONTEXT_SPECIFIC,
                  type: 1,
                  constructed: !0,
                  optional: !0,
                  value: [
                    {
                      name: 'Certificate.TBSCertificate.issuerUniqueID.id',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.BITSTRING,
                      constructed: !1,
                      captureBitStringValue: 'certIssuerUniqueId'
                    }
                  ]
                },
                {
                  name: 'Certificate.TBSCertificate.subjectUniqueID',
                  tagClass: n.Class.CONTEXT_SPECIFIC,
                  type: 2,
                  constructed: !0,
                  optional: !0,
                  value: [
                    {
                      name: 'Certificate.TBSCertificate.subjectUniqueID.id',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.BITSTRING,
                      constructed: !1,
                      captureBitStringValue: 'certSubjectUniqueId'
                    }
                  ]
                },
                {
                  name: 'Certificate.TBSCertificate.extensions',
                  tagClass: n.Class.CONTEXT_SPECIFIC,
                  type: 3,
                  constructed: !0,
                  captureAsn1: 'certExtensions',
                  optional: !0
                }
              ]
            },
            {
              name: 'Certificate.signatureAlgorithm',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'Certificate.signatureAlgorithm.algorithm',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.OID,
                  constructed: !1,
                  capture: 'certSignatureOid'
                },
                {
                  name: 'Certificate.TBSCertificate.signature.parameters',
                  tagClass: n.Class.UNIVERSAL,
                  optional: !0,
                  captureAsn1: 'certSignatureParams'
                }
              ]
            },
            {
              name: 'Certificate.signatureValue',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.BITSTRING,
              constructed: !1,
              captureBitStringValue: 'certSignature'
            }
          ]
        },
        a = {
          name: 'rsapss',
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          value: [
            {
              name: 'rsapss.hashAlgorithm',
              tagClass: n.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: !0,
              value: [
                {
                  name: 'rsapss.hashAlgorithm.AlgorithmIdentifier',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Class.SEQUENCE,
                  constructed: !0,
                  optional: !0,
                  value: [
                    {
                      name: 'rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.OID,
                      constructed: !1,
                      capture: 'hashOid'
                    }
                  ]
                }
              ]
            },
            {
              name: 'rsapss.maskGenAlgorithm',
              tagClass: n.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: !0,
              value: [
                {
                  name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Class.SEQUENCE,
                  constructed: !0,
                  optional: !0,
                  value: [
                    {
                      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.OID,
                      constructed: !1,
                      capture: 'maskGenOid'
                    },
                    {
                      name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SEQUENCE,
                      constructed: !0,
                      value: [
                        {
                          name: 'rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm',
                          tagClass: n.Class.UNIVERSAL,
                          type: n.Type.OID,
                          constructed: !1,
                          capture: 'maskGenHashOid'
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              name: 'rsapss.saltLength',
              tagClass: n.Class.CONTEXT_SPECIFIC,
              type: 2,
              optional: !0,
              value: [
                {
                  name: 'rsapss.saltLength.saltLength',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Class.INTEGER,
                  constructed: !1,
                  capture: 'saltLength'
                }
              ]
            },
            {
              name: 'rsapss.trailerField',
              tagClass: n.Class.CONTEXT_SPECIFIC,
              type: 3,
              optional: !0,
              value: [
                {
                  name: 'rsapss.trailer.trailer',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Class.INTEGER,
                  constructed: !1,
                  capture: 'trailer'
                }
              ]
            }
          ]
        },
        c = {
          name: 'CertificationRequestInfo',
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: 'certificationRequestInfo',
          value: [
            {
              name: 'CertificationRequestInfo.integer',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.INTEGER,
              constructed: !1,
              capture: 'certificationRequestInfoVersion'
            },
            {
              name: 'CertificationRequestInfo.subject',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.SEQUENCE,
              constructed: !0,
              captureAsn1: 'certificationRequestInfoSubject'
            },
            o,
            {
              name: 'CertificationRequestInfo.attributes',
              tagClass: n.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: !0,
              optional: !0,
              capture: 'certificationRequestInfoAttributes',
              value: [
                {
                  name: 'CertificationRequestInfo.attributes',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.SEQUENCE,
                  constructed: !0,
                  value: [
                    {
                      name: 'CertificationRequestInfo.attributes.type',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.OID,
                      constructed: !1
                    },
                    {
                      name: 'CertificationRequestInfo.attributes.value',
                      tagClass: n.Class.UNIVERSAL,
                      type: n.Type.SET,
                      constructed: !0
                    }
                  ]
                }
              ]
            }
          ]
        },
        f = {
          name: 'CertificationRequest',
          tagClass: n.Class.UNIVERSAL,
          type: n.Type.SEQUENCE,
          constructed: !0,
          captureAsn1: 'csr',
          value: [
            c,
            {
              name: 'CertificationRequest.signatureAlgorithm',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.SEQUENCE,
              constructed: !0,
              value: [
                {
                  name: 'CertificationRequest.signatureAlgorithm.algorithm',
                  tagClass: n.Class.UNIVERSAL,
                  type: n.Type.OID,
                  constructed: !1,
                  capture: 'csrSignatureOid'
                },
                {
                  name: 'CertificationRequest.signatureAlgorithm.parameters',
                  tagClass: n.Class.UNIVERSAL,
                  optional: !0,
                  captureAsn1: 'csrSignatureParams'
                }
              ]
            },
            {
              name: 'CertificationRequest.signature',
              tagClass: n.Class.UNIVERSAL,
              type: n.Type.BITSTRING,
              constructed: !1,
              captureBitStringValue: 'csrSignature'
            }
          ]
        }
      ;(i.RDNAttributesAsArray = function (w, v) {
        for (var I = [], M, q, G, O = 0; O < w.value.length; ++O) {
          M = w.value[O]
          for (var x = 0; x < M.value.length; ++x)
            (G = {}),
              (q = M.value[x]),
              (G.type = n.derToOid(q.value[0].value)),
              (G.value = q.value[1].value),
              (G.valueTagClass = q.value[1].type),
              G.type in s && ((G.name = s[G.type]), G.name in u && (G.shortName = u[G.name])),
              v && (v.update(G.type), v.update(G.value)),
              I.push(G)
        }
        return I
      }),
        (i.CRIAttributesAsArray = function (w) {
          for (var v = [], I = 0; I < w.length; ++I)
            for (var M = w[I], q = n.derToOid(M.value[0].value), G = M.value[1].value, O = 0; O < G.length; ++O) {
              var x = {}
              if (
                ((x.type = q),
                (x.value = G[O].value),
                (x.valueTagClass = G[O].type),
                x.type in s && ((x.name = s[x.type]), x.name in u && (x.shortName = u[x.name])),
                x.type === s.extensionRequest)
              ) {
                x.extensions = []
                for (var L = 0; L < x.value.length; ++L) x.extensions.push(i.certificateExtensionFromAsn1(x.value[L]))
              }
              v.push(x)
            }
          return v
        })
      function p(w, v) {
        typeof v == 'string' && (v = { shortName: v })
        for (var I = null, M, q = 0; I === null && q < w.attributes.length; ++q)
          (M = w.attributes[q]),
            ((v.type && v.type === M.type) ||
              (v.name && v.name === M.name) ||
              (v.shortName && v.shortName === M.shortName)) &&
              (I = M)
        return I
      }
      var y = function (w, v, I) {
        var M = {}
        if (w !== s['RSASSA-PSS']) return M
        I &&
          (M = {
            hash: { algorithmOid: s.sha1 },
            mgf: { algorithmOid: s.mgf1, hash: { algorithmOid: s.sha1 } },
            saltLength: 20
          })
        var q = {},
          G = []
        if (!n.validate(v, a, q, G)) {
          var O = new Error('Cannot read RSASSA-PSS parameter block.')
          throw ((O.errors = G), O)
        }
        return (
          q.hashOid !== void 0 && ((M.hash = M.hash || {}), (M.hash.algorithmOid = n.derToOid(q.hashOid))),
          q.maskGenOid !== void 0 &&
            ((M.mgf = M.mgf || {}),
            (M.mgf.algorithmOid = n.derToOid(q.maskGenOid)),
            (M.mgf.hash = M.mgf.hash || {}),
            (M.mgf.hash.algorithmOid = n.derToOid(q.maskGenHashOid))),
          q.saltLength !== void 0 && (M.saltLength = q.saltLength.charCodeAt(0)),
          M
        )
      }
      ;(i.certificateFromPem = function (w, v, I) {
        var M = t.pem.decode(w)[0]
        if (M.type !== 'CERTIFICATE' && M.type !== 'X509 CERTIFICATE' && M.type !== 'TRUSTED CERTIFICATE') {
          var q = new Error(
            'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
          )
          throw ((q.headerType = M.type), q)
        }
        if (M.procType && M.procType.type === 'ENCRYPTED')
          throw new Error('Could not convert certificate from PEM; PEM is encrypted.')
        var G = n.fromDer(M.body, I)
        return i.certificateFromAsn1(G, v)
      }),
        (i.certificateToPem = function (w, v) {
          var I = { type: 'CERTIFICATE', body: n.toDer(i.certificateToAsn1(w)).getBytes() }
          return t.pem.encode(I, { maxline: v })
        }),
        (i.publicKeyFromPem = function (w) {
          var v = t.pem.decode(w)[0]
          if (v.type !== 'PUBLIC KEY' && v.type !== 'RSA PUBLIC KEY') {
            var I = new Error(
              'Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".'
            )
            throw ((I.headerType = v.type), I)
          }
          if (v.procType && v.procType.type === 'ENCRYPTED')
            throw new Error('Could not convert public key from PEM; PEM is encrypted.')
          var M = n.fromDer(v.body)
          return i.publicKeyFromAsn1(M)
        }),
        (i.publicKeyToPem = function (w, v) {
          var I = { type: 'PUBLIC KEY', body: n.toDer(i.publicKeyToAsn1(w)).getBytes() }
          return t.pem.encode(I, { maxline: v })
        }),
        (i.publicKeyToRSAPublicKeyPem = function (w, v) {
          var I = { type: 'RSA PUBLIC KEY', body: n.toDer(i.publicKeyToRSAPublicKey(w)).getBytes() }
          return t.pem.encode(I, { maxline: v })
        }),
        (i.getPublicKeyFingerprint = function (w, v) {
          v = v || {}
          var I = v.md || t.md.sha1.create(),
            M = v.type || 'RSAPublicKey',
            q
          switch (M) {
            case 'RSAPublicKey':
              q = n.toDer(i.publicKeyToRSAPublicKey(w)).getBytes()
              break
            case 'SubjectPublicKeyInfo':
              q = n.toDer(i.publicKeyToAsn1(w)).getBytes()
              break
            default:
              throw new Error('Unknown fingerprint type "' + v.type + '".')
          }
          I.start(), I.update(q)
          var G = I.digest()
          if (v.encoding === 'hex') {
            var O = G.toHex()
            return v.delimiter ? O.match(/.{2}/g).join(v.delimiter) : O
          } else {
            if (v.encoding === 'binary') return G.getBytes()
            if (v.encoding) throw new Error('Unknown encoding "' + v.encoding + '".')
          }
          return G
        }),
        (i.certificationRequestFromPem = function (w, v, I) {
          var M = t.pem.decode(w)[0]
          if (M.type !== 'CERTIFICATE REQUEST') {
            var q = new Error(
              'Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".'
            )
            throw ((q.headerType = M.type), q)
          }
          if (M.procType && M.procType.type === 'ENCRYPTED')
            throw new Error('Could not convert certification request from PEM; PEM is encrypted.')
          var G = n.fromDer(M.body, I)
          return i.certificationRequestFromAsn1(G, v)
        }),
        (i.certificationRequestToPem = function (w, v) {
          var I = { type: 'CERTIFICATE REQUEST', body: n.toDer(i.certificationRequestToAsn1(w)).getBytes() }
          return t.pem.encode(I, { maxline: v })
        }),
        (i.createCertificate = function () {
          var w = {}
          return (
            (w.version = 2),
            (w.serialNumber = '00'),
            (w.signatureOid = null),
            (w.signature = null),
            (w.siginfo = {}),
            (w.siginfo.algorithmOid = null),
            (w.validity = {}),
            (w.validity.notBefore = new Date()),
            (w.validity.notAfter = new Date()),
            (w.issuer = {}),
            (w.issuer.getField = function (v) {
              return p(w.issuer, v)
            }),
            (w.issuer.addField = function (v) {
              h([v]), w.issuer.attributes.push(v)
            }),
            (w.issuer.attributes = []),
            (w.issuer.hash = null),
            (w.subject = {}),
            (w.subject.getField = function (v) {
              return p(w.subject, v)
            }),
            (w.subject.addField = function (v) {
              h([v]), w.subject.attributes.push(v)
            }),
            (w.subject.attributes = []),
            (w.subject.hash = null),
            (w.extensions = []),
            (w.publicKey = null),
            (w.md = null),
            (w.setSubject = function (v, I) {
              h(v),
                (w.subject.attributes = v),
                delete w.subject.uniqueId,
                I && (w.subject.uniqueId = I),
                (w.subject.hash = null)
            }),
            (w.setIssuer = function (v, I) {
              h(v),
                (w.issuer.attributes = v),
                delete w.issuer.uniqueId,
                I && (w.issuer.uniqueId = I),
                (w.issuer.hash = null)
            }),
            (w.setExtensions = function (v) {
              for (var I = 0; I < v.length; ++I) m(v[I], { cert: w })
              w.extensions = v
            }),
            (w.getExtension = function (v) {
              typeof v == 'string' && (v = { name: v })
              for (var I = null, M, q = 0; I === null && q < w.extensions.length; ++q)
                (M = w.extensions[q]), ((v.id && M.id === v.id) || (v.name && M.name === v.name)) && (I = M)
              return I
            }),
            (w.sign = function (v, I) {
              w.md = I || t.md.sha1.create()
              var M = s[w.md.algorithm + 'WithRSAEncryption']
              if (!M) {
                var q = new Error('Could not compute certificate digest. Unknown message digest algorithm OID.')
                throw ((q.algorithm = w.md.algorithm), q)
              }
              ;(w.signatureOid = w.siginfo.algorithmOid = M), (w.tbsCertificate = i.getTBSCertificate(w))
              var G = n.toDer(w.tbsCertificate)
              w.md.update(G.getBytes()), (w.signature = v.sign(w.md))
            }),
            (w.verify = function (v) {
              var I = !1
              if (!w.issued(v)) {
                var M = v.issuer,
                  q = w.subject,
                  G = new Error(
                    "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
                  )
                throw ((G.expectedIssuer = M.attributes), (G.actualIssuer = q.attributes), G)
              }
              var O = v.md
              if (O === null) {
                if (v.signatureOid in s) {
                  var x = s[v.signatureOid]
                  switch (x) {
                    case 'sha1WithRSAEncryption':
                      O = t.md.sha1.create()
                      break
                    case 'md5WithRSAEncryption':
                      O = t.md.md5.create()
                      break
                    case 'sha256WithRSAEncryption':
                      O = t.md.sha256.create()
                      break
                    case 'sha384WithRSAEncryption':
                      O = t.md.sha384.create()
                      break
                    case 'sha512WithRSAEncryption':
                      O = t.md.sha512.create()
                      break
                    case 'RSASSA-PSS':
                      O = t.md.sha256.create()
                      break
                  }
                }
                if (O === null) {
                  var G = new Error('Could not compute certificate digest. Unknown signature OID.')
                  throw ((G.signatureOid = v.signatureOid), G)
                }
                var L = v.tbsCertificate || i.getTBSCertificate(v),
                  K = n.toDer(L)
                O.update(K.getBytes())
              }
              if (O !== null) {
                var J
                switch (v.signatureOid) {
                  case s.sha1WithRSAEncryption:
                    J = void 0
                    break
                  case s['RSASSA-PSS']:
                    var Z, Q
                    if (((Z = s[v.signatureParameters.mgf.hash.algorithmOid]), Z === void 0 || t.md[Z] === void 0)) {
                      var G = new Error('Unsupported MGF hash function.')
                      throw ((G.oid = v.signatureParameters.mgf.hash.algorithmOid), (G.name = Z), G)
                    }
                    if (((Q = s[v.signatureParameters.mgf.algorithmOid]), Q === void 0 || t.mgf[Q] === void 0)) {
                      var G = new Error('Unsupported MGF function.')
                      throw ((G.oid = v.signatureParameters.mgf.algorithmOid), (G.name = Q), G)
                    }
                    if (
                      ((Q = t.mgf[Q].create(t.md[Z].create())),
                      (Z = s[v.signatureParameters.hash.algorithmOid]),
                      Z === void 0 || t.md[Z] === void 0)
                    )
                      throw {
                        message: 'Unsupported RSASSA-PSS hash function.',
                        oid: v.signatureParameters.hash.algorithmOid,
                        name: Z
                      }
                    J = t.pss.create(t.md[Z].create(), Q, v.signatureParameters.saltLength)
                    break
                }
                I = w.publicKey.verify(O.digest().getBytes(), v.signature, J)
              }
              return I
            }),
            (w.isIssuer = function (v) {
              var I = !1,
                M = w.issuer,
                q = v.subject
              if (M.hash && q.hash) I = M.hash === q.hash
              else if (M.attributes.length === q.attributes.length) {
                I = !0
                for (var G, O, x = 0; I && x < M.attributes.length; ++x)
                  (G = M.attributes[x]), (O = q.attributes[x]), (G.type !== O.type || G.value !== O.value) && (I = !1)
              }
              return I
            }),
            (w.issued = function (v) {
              return v.isIssuer(w)
            }),
            (w.generateSubjectKeyIdentifier = function () {
              return i.getPublicKeyFingerprint(w.publicKey, { type: 'RSAPublicKey' })
            }),
            (w.verifySubjectKeyIdentifier = function () {
              for (var v = s.subjectKeyIdentifier, I = 0; I < w.extensions.length; ++I) {
                var M = w.extensions[I]
                if (M.id === v) {
                  var q = w.generateSubjectKeyIdentifier().getBytes()
                  return t.util.hexToBytes(M.subjectKeyIdentifier) === q
                }
              }
              return !1
            }),
            w
          )
        }),
        (i.certificateFromAsn1 = function (w, v) {
          var I = {},
            M = []
          if (!n.validate(w, l, I, M)) {
            var q = new Error('Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.')
            throw ((q.errors = M), q)
          }
          var G = n.derToOid(I.publicKeyOid)
          if (G !== i.oids.rsaEncryption) throw new Error('Cannot read public key. OID is not RSA.')
          var O = i.createCertificate()
          O.version = I.certVersion ? I.certVersion.charCodeAt(0) : 0
          var x = t.util.createBuffer(I.certSerialNumber)
          ;(O.serialNumber = x.toHex()),
            (O.signatureOid = t.asn1.derToOid(I.certSignatureOid)),
            (O.signatureParameters = y(O.signatureOid, I.certSignatureParams, !0)),
            (O.siginfo.algorithmOid = t.asn1.derToOid(I.certinfoSignatureOid)),
            (O.siginfo.parameters = y(O.siginfo.algorithmOid, I.certinfoSignatureParams, !1)),
            (O.signature = I.certSignature)
          var L = []
          if (
            (I.certValidity1UTCTime !== void 0 && L.push(n.utcTimeToDate(I.certValidity1UTCTime)),
            I.certValidity2GeneralizedTime !== void 0 &&
              L.push(n.generalizedTimeToDate(I.certValidity2GeneralizedTime)),
            I.certValidity3UTCTime !== void 0 && L.push(n.utcTimeToDate(I.certValidity3UTCTime)),
            I.certValidity4GeneralizedTime !== void 0 &&
              L.push(n.generalizedTimeToDate(I.certValidity4GeneralizedTime)),
            L.length > 2)
          )
            throw new Error(
              'Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.'
            )
          if (L.length < 2)
            throw new Error(
              'Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.'
            )
          if (((O.validity.notBefore = L[0]), (O.validity.notAfter = L[1]), (O.tbsCertificate = I.tbsCertificate), v)) {
            if (((O.md = null), O.signatureOid in s)) {
              var G = s[O.signatureOid]
              switch (G) {
                case 'sha1WithRSAEncryption':
                  O.md = t.md.sha1.create()
                  break
                case 'md5WithRSAEncryption':
                  O.md = t.md.md5.create()
                  break
                case 'sha256WithRSAEncryption':
                  O.md = t.md.sha256.create()
                  break
                case 'sha384WithRSAEncryption':
                  O.md = t.md.sha384.create()
                  break
                case 'sha512WithRSAEncryption':
                  O.md = t.md.sha512.create()
                  break
                case 'RSASSA-PSS':
                  O.md = t.md.sha256.create()
                  break
              }
            }
            if (O.md === null) {
              var q = new Error('Could not compute certificate digest. Unknown signature OID.')
              throw ((q.signatureOid = O.signatureOid), q)
            }
            var K = n.toDer(O.tbsCertificate)
            O.md.update(K.getBytes())
          }
          var J = t.md.sha1.create()
          ;(O.issuer.getField = function (Q) {
            return p(O.issuer, Q)
          }),
            (O.issuer.addField = function (Q) {
              h([Q]), O.issuer.attributes.push(Q)
            }),
            (O.issuer.attributes = i.RDNAttributesAsArray(I.certIssuer, J)),
            I.certIssuerUniqueId && (O.issuer.uniqueId = I.certIssuerUniqueId),
            (O.issuer.hash = J.digest().toHex())
          var Z = t.md.sha1.create()
          return (
            (O.subject.getField = function (Q) {
              return p(O.subject, Q)
            }),
            (O.subject.addField = function (Q) {
              h([Q]), O.subject.attributes.push(Q)
            }),
            (O.subject.attributes = i.RDNAttributesAsArray(I.certSubject, Z)),
            I.certSubjectUniqueId && (O.subject.uniqueId = I.certSubjectUniqueId),
            (O.subject.hash = Z.digest().toHex()),
            I.certExtensions ? (O.extensions = i.certificateExtensionsFromAsn1(I.certExtensions)) : (O.extensions = []),
            (O.publicKey = i.publicKeyFromAsn1(I.subjectPublicKeyInfo)),
            O
          )
        }),
        (i.certificateExtensionsFromAsn1 = function (w) {
          for (var v = [], I = 0; I < w.value.length; ++I)
            for (var M = w.value[I], q = 0; q < M.value.length; ++q) v.push(i.certificateExtensionFromAsn1(M.value[q]))
          return v
        }),
        (i.certificateExtensionFromAsn1 = function (w) {
          var v = {}
          if (
            ((v.id = n.derToOid(w.value[0].value)),
            (v.critical = !1),
            w.value[1].type === n.Type.BOOLEAN
              ? ((v.critical = w.value[1].value.charCodeAt(0) !== 0), (v.value = w.value[2].value))
              : (v.value = w.value[1].value),
            v.id in s)
          ) {
            if (((v.name = s[v.id]), v.name === 'keyUsage')) {
              var I = n.fromDer(v.value),
                M = 0,
                q = 0
              I.value.length > 1 && ((M = I.value.charCodeAt(1)), (q = I.value.length > 2 ? I.value.charCodeAt(2) : 0)),
                (v.digitalSignature = (M & 128) == 128),
                (v.nonRepudiation = (M & 64) == 64),
                (v.keyEncipherment = (M & 32) == 32),
                (v.dataEncipherment = (M & 16) == 16),
                (v.keyAgreement = (M & 8) == 8),
                (v.keyCertSign = (M & 4) == 4),
                (v.cRLSign = (M & 2) == 2),
                (v.encipherOnly = (M & 1) == 1),
                (v.decipherOnly = (q & 128) == 128)
            } else if (v.name === 'basicConstraints') {
              var I = n.fromDer(v.value)
              I.value.length > 0 && I.value[0].type === n.Type.BOOLEAN
                ? (v.cA = I.value[0].value.charCodeAt(0) !== 0)
                : (v.cA = !1)
              var G = null
              I.value.length > 0 && I.value[0].type === n.Type.INTEGER
                ? (G = I.value[0].value)
                : I.value.length > 1 && (G = I.value[1].value),
                G !== null && (v.pathLenConstraint = n.derToInteger(G))
            } else if (v.name === 'extKeyUsage')
              for (var I = n.fromDer(v.value), O = 0; O < I.value.length; ++O) {
                var x = n.derToOid(I.value[O].value)
                x in s ? (v[s[x]] = !0) : (v[x] = !0)
              }
            else if (v.name === 'nsCertType') {
              var I = n.fromDer(v.value),
                M = 0
              I.value.length > 1 && (M = I.value.charCodeAt(1)),
                (v.client = (M & 128) == 128),
                (v.server = (M & 64) == 64),
                (v.email = (M & 32) == 32),
                (v.objsign = (M & 16) == 16),
                (v.reserved = (M & 8) == 8),
                (v.sslCA = (M & 4) == 4),
                (v.emailCA = (M & 2) == 2),
                (v.objCA = (M & 1) == 1)
            } else if (v.name === 'subjectAltName' || v.name === 'issuerAltName') {
              v.altNames = []
              for (var L, I = n.fromDer(v.value), K = 0; K < I.value.length; ++K) {
                L = I.value[K]
                var J = { type: L.type, value: L.value }
                switch ((v.altNames.push(J), L.type)) {
                  case 1:
                  case 2:
                  case 6:
                    break
                  case 7:
                    J.ip = t.util.bytesToIP(L.value)
                    break
                  case 8:
                    J.oid = n.derToOid(L.value)
                    break
                  default:
                }
              }
            } else if (v.name === 'subjectKeyIdentifier') {
              var I = n.fromDer(v.value)
              v.subjectKeyIdentifier = t.util.bytesToHex(I.value)
            }
          }
          return v
        }),
        (i.certificationRequestFromAsn1 = function (w, v) {
          var I = {},
            M = []
          if (!n.validate(w, f, I, M)) {
            var q = new Error(
              'Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.'
            )
            throw ((q.errors = M), q)
          }
          var G = n.derToOid(I.publicKeyOid)
          if (G !== i.oids.rsaEncryption) throw new Error('Cannot read public key. OID is not RSA.')
          var O = i.createCertificationRequest()
          if (
            ((O.version = I.csrVersion ? I.csrVersion.charCodeAt(0) : 0),
            (O.signatureOid = t.asn1.derToOid(I.csrSignatureOid)),
            (O.signatureParameters = y(O.signatureOid, I.csrSignatureParams, !0)),
            (O.siginfo.algorithmOid = t.asn1.derToOid(I.csrSignatureOid)),
            (O.siginfo.parameters = y(O.siginfo.algorithmOid, I.csrSignatureParams, !1)),
            (O.signature = I.csrSignature),
            (O.certificationRequestInfo = I.certificationRequestInfo),
            v)
          ) {
            if (((O.md = null), O.signatureOid in s)) {
              var G = s[O.signatureOid]
              switch (G) {
                case 'sha1WithRSAEncryption':
                  O.md = t.md.sha1.create()
                  break
                case 'md5WithRSAEncryption':
                  O.md = t.md.md5.create()
                  break
                case 'sha256WithRSAEncryption':
                  O.md = t.md.sha256.create()
                  break
                case 'sha384WithRSAEncryption':
                  O.md = t.md.sha384.create()
                  break
                case 'sha512WithRSAEncryption':
                  O.md = t.md.sha512.create()
                  break
                case 'RSASSA-PSS':
                  O.md = t.md.sha256.create()
                  break
              }
            }
            if (O.md === null) {
              var q = new Error('Could not compute certification request digest. Unknown signature OID.')
              throw ((q.signatureOid = O.signatureOid), q)
            }
            var x = n.toDer(O.certificationRequestInfo)
            O.md.update(x.getBytes())
          }
          var L = t.md.sha1.create()
          return (
            (O.subject.getField = function (K) {
              return p(O.subject, K)
            }),
            (O.subject.addField = function (K) {
              h([K]), O.subject.attributes.push(K)
            }),
            (O.subject.attributes = i.RDNAttributesAsArray(I.certificationRequestInfoSubject, L)),
            (O.subject.hash = L.digest().toHex()),
            (O.publicKey = i.publicKeyFromAsn1(I.subjectPublicKeyInfo)),
            (O.getAttribute = function (K) {
              return p(O, K)
            }),
            (O.addAttribute = function (K) {
              h([K]), O.attributes.push(K)
            }),
            (O.attributes = i.CRIAttributesAsArray(I.certificationRequestInfoAttributes || [])),
            O
          )
        }),
        (i.createCertificationRequest = function () {
          var w = {}
          return (
            (w.version = 0),
            (w.signatureOid = null),
            (w.signature = null),
            (w.siginfo = {}),
            (w.siginfo.algorithmOid = null),
            (w.subject = {}),
            (w.subject.getField = function (v) {
              return p(w.subject, v)
            }),
            (w.subject.addField = function (v) {
              h([v]), w.subject.attributes.push(v)
            }),
            (w.subject.attributes = []),
            (w.subject.hash = null),
            (w.publicKey = null),
            (w.attributes = []),
            (w.getAttribute = function (v) {
              return p(w, v)
            }),
            (w.addAttribute = function (v) {
              h([v]), w.attributes.push(v)
            }),
            (w.md = null),
            (w.setSubject = function (v) {
              h(v), (w.subject.attributes = v), (w.subject.hash = null)
            }),
            (w.setAttributes = function (v) {
              h(v), (w.attributes = v)
            }),
            (w.sign = function (v, I) {
              w.md = I || t.md.sha1.create()
              var M = s[w.md.algorithm + 'WithRSAEncryption']
              if (!M) {
                var q = new Error(
                  'Could not compute certification request digest. Unknown message digest algorithm OID.'
                )
                throw ((q.algorithm = w.md.algorithm), q)
              }
              ;(w.signatureOid = w.siginfo.algorithmOid = M),
                (w.certificationRequestInfo = i.getCertificationRequestInfo(w))
              var G = n.toDer(w.certificationRequestInfo)
              w.md.update(G.getBytes()), (w.signature = v.sign(w.md))
            }),
            (w.verify = function () {
              var v = !1,
                I = w.md
              if (I === null) {
                if (w.signatureOid in s) {
                  var M = s[w.signatureOid]
                  switch (M) {
                    case 'sha1WithRSAEncryption':
                      I = t.md.sha1.create()
                      break
                    case 'md5WithRSAEncryption':
                      I = t.md.md5.create()
                      break
                    case 'sha256WithRSAEncryption':
                      I = t.md.sha256.create()
                      break
                    case 'sha384WithRSAEncryption':
                      I = t.md.sha384.create()
                      break
                    case 'sha512WithRSAEncryption':
                      I = t.md.sha512.create()
                      break
                    case 'RSASSA-PSS':
                      I = t.md.sha256.create()
                      break
                  }
                }
                if (I === null) {
                  var q = new Error('Could not compute certification request digest. Unknown signature OID.')
                  throw ((q.signatureOid = w.signatureOid), q)
                }
                var G = w.certificationRequestInfo || i.getCertificationRequestInfo(w),
                  O = n.toDer(G)
                I.update(O.getBytes())
              }
              if (I !== null) {
                var x
                switch (w.signatureOid) {
                  case s.sha1WithRSAEncryption:
                    break
                  case s['RSASSA-PSS']:
                    var L, K
                    if (((L = s[w.signatureParameters.mgf.hash.algorithmOid]), L === void 0 || t.md[L] === void 0)) {
                      var q = new Error('Unsupported MGF hash function.')
                      throw ((q.oid = w.signatureParameters.mgf.hash.algorithmOid), (q.name = L), q)
                    }
                    if (((K = s[w.signatureParameters.mgf.algorithmOid]), K === void 0 || t.mgf[K] === void 0)) {
                      var q = new Error('Unsupported MGF function.')
                      throw ((q.oid = w.signatureParameters.mgf.algorithmOid), (q.name = K), q)
                    }
                    if (
                      ((K = t.mgf[K].create(t.md[L].create())),
                      (L = s[w.signatureParameters.hash.algorithmOid]),
                      L === void 0 || t.md[L] === void 0)
                    ) {
                      var q = new Error('Unsupported RSASSA-PSS hash function.')
                      throw ((q.oid = w.signatureParameters.hash.algorithmOid), (q.name = L), q)
                    }
                    x = t.pss.create(t.md[L].create(), K, w.signatureParameters.saltLength)
                    break
                }
                v = w.publicKey.verify(I.digest().getBytes(), w.signature, x)
              }
              return v
            }),
            w
          )
        })
      function d(w) {
        for (
          var v = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, []), I, M, q = w.attributes, G = 0;
          G < q.length;
          ++G
        ) {
          I = q[G]
          var O = I.value,
            x = n.Type.PRINTABLESTRING
          'valueTagClass' in I && ((x = I.valueTagClass), x === n.Type.UTF8 && (O = t.util.encodeUtf8(O))),
            (M = n.create(n.Class.UNIVERSAL, n.Type.SET, !0, [
              n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(I.type).getBytes()),
                n.create(n.Class.UNIVERSAL, x, !1, O)
              ])
            ])),
            v.value.push(M)
        }
        return v
      }
      function h(w) {
        for (var v, I = 0; I < w.length; ++I) {
          if (
            ((v = w[I]),
            typeof v.name == 'undefined' &&
              (v.type && v.type in i.oids
                ? (v.name = i.oids[v.type])
                : v.shortName && v.shortName in u && (v.name = i.oids[u[v.shortName]])),
            typeof v.type == 'undefined')
          )
            if (v.name && v.name in i.oids) v.type = i.oids[v.name]
            else {
              var M = new Error('Attribute type not specified.')
              throw ((M.attribute = v), M)
            }
          if (
            (typeof v.shortName == 'undefined' && v.name && v.name in u && (v.shortName = u[v.name]),
            v.type === s.extensionRequest &&
              ((v.valueConstructed = !0), (v.valueTagClass = n.Type.SEQUENCE), !v.value && v.extensions))
          ) {
            v.value = []
            for (var q = 0; q < v.extensions.length; ++q) v.value.push(i.certificateExtensionToAsn1(m(v.extensions[q])))
          }
          if (typeof v.value == 'undefined') {
            var M = new Error('Attribute value not specified.')
            throw ((M.attribute = v), M)
          }
        }
      }
      function m(w, v) {
        if (
          ((v = v || {}),
          typeof w.name == 'undefined' && w.id && w.id in i.oids && (w.name = i.oids[w.id]),
          typeof w.id == 'undefined')
        )
          if (w.name && w.name in i.oids) w.id = i.oids[w.name]
          else {
            var I = new Error('Extension ID not specified.')
            throw ((I.extension = w), I)
          }
        if (typeof w.value != 'undefined') return w
        if (w.name === 'keyUsage') {
          var M = 0,
            q = 0,
            G = 0
          w.digitalSignature && ((q |= 128), (M = 7)),
            w.nonRepudiation && ((q |= 64), (M = 6)),
            w.keyEncipherment && ((q |= 32), (M = 5)),
            w.dataEncipherment && ((q |= 16), (M = 4)),
            w.keyAgreement && ((q |= 8), (M = 3)),
            w.keyCertSign && ((q |= 4), (M = 2)),
            w.cRLSign && ((q |= 2), (M = 1)),
            w.encipherOnly && ((q |= 1), (M = 0)),
            w.decipherOnly && ((G |= 128), (M = 7))
          var O = String.fromCharCode(M)
          G !== 0 ? (O += String.fromCharCode(q) + String.fromCharCode(G)) : q !== 0 && (O += String.fromCharCode(q)),
            (w.value = n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, O))
        } else if (w.name === 'basicConstraints')
          (w.value = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [])),
            w.cA && w.value.value.push(n.create(n.Class.UNIVERSAL, n.Type.BOOLEAN, !1, String.fromCharCode(255))),
            'pathLenConstraint' in w &&
              w.value.value.push(
                n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(w.pathLenConstraint).getBytes())
              )
        else if (w.name === 'extKeyUsage') {
          w.value = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [])
          var x = w.value.value
          for (var L in w)
            w[L] === !0 &&
              (L in s
                ? x.push(n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(s[L]).getBytes()))
                : L.indexOf('.') !== -1 &&
                  x.push(n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(L).getBytes())))
        } else if (w.name === 'nsCertType') {
          var M = 0,
            q = 0
          w.client && ((q |= 128), (M = 7)),
            w.server && ((q |= 64), (M = 6)),
            w.email && ((q |= 32), (M = 5)),
            w.objsign && ((q |= 16), (M = 4)),
            w.reserved && ((q |= 8), (M = 3)),
            w.sslCA && ((q |= 4), (M = 2)),
            w.emailCA && ((q |= 2), (M = 1)),
            w.objCA && ((q |= 1), (M = 0))
          var O = String.fromCharCode(M)
          q !== 0 && (O += String.fromCharCode(q)), (w.value = n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, O))
        } else if (w.name === 'subjectAltName' || w.name === 'issuerAltName') {
          w.value = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [])
          for (var K, J = 0; J < w.altNames.length; ++J) {
            K = w.altNames[J]
            var O = K.value
            if (K.type === 7 && K.ip) {
              if (((O = t.util.bytesFromIP(K.ip)), O === null)) {
                var I = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')
                throw ((I.extension = w), I)
              }
            } else K.type === 8 && (K.oid ? (O = n.oidToDer(n.oidToDer(K.oid))) : (O = n.oidToDer(O)))
            w.value.value.push(n.create(n.Class.CONTEXT_SPECIFIC, K.type, !1, O))
          }
        } else if (w.name === 'nsComment' && v.cert) {
          if (!/^[\x00-\x7F]*$/.test(w.comment) || w.comment.length < 1 || w.comment.length > 128)
            throw new Error('Invalid "nsComment" content.')
          w.value = n.create(n.Class.UNIVERSAL, n.Type.IA5STRING, !1, w.comment)
        } else if (w.name === 'subjectKeyIdentifier' && v.cert) {
          var Z = v.cert.generateSubjectKeyIdentifier()
          ;(w.subjectKeyIdentifier = Z.toHex()),
            (w.value = n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, Z.getBytes()))
        } else if (w.name === 'authorityKeyIdentifier' && v.cert) {
          w.value = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [])
          var x = w.value.value
          if (w.keyIdentifier) {
            var Q = w.keyIdentifier === !0 ? v.cert.generateSubjectKeyIdentifier().getBytes() : w.keyIdentifier
            x.push(n.create(n.Class.CONTEXT_SPECIFIC, 0, !1, Q))
          }
          if (w.authorityCertIssuer) {
            var fe = [
              n.create(n.Class.CONTEXT_SPECIFIC, 4, !0, [
                d(w.authorityCertIssuer === !0 ? v.cert.issuer : w.authorityCertIssuer)
              ])
            ]
            x.push(n.create(n.Class.CONTEXT_SPECIFIC, 1, !0, fe))
          }
          if (w.serialNumber) {
            var ie = t.util.hexToBytes(w.serialNumber === !0 ? v.cert.serialNumber : w.serialNumber)
            x.push(n.create(n.Class.CONTEXT_SPECIFIC, 2, !1, ie))
          }
        } else if (w.name === 'cRLDistributionPoints') {
          w.value = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [])
          for (
            var x = w.value.value,
              W = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, []),
              le = n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, []),
              K,
              J = 0;
            J < w.altNames.length;
            ++J
          ) {
            K = w.altNames[J]
            var O = K.value
            if (K.type === 7 && K.ip) {
              if (((O = t.util.bytesFromIP(K.ip)), O === null)) {
                var I = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.')
                throw ((I.extension = w), I)
              }
            } else K.type === 8 && (K.oid ? (O = n.oidToDer(n.oidToDer(K.oid))) : (O = n.oidToDer(O)))
            le.value.push(n.create(n.Class.CONTEXT_SPECIFIC, K.type, !1, O))
          }
          W.value.push(n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [le])), x.push(W)
        }
        if (typeof w.value == 'undefined') {
          var I = new Error('Extension value not specified.')
          throw ((I.extension = w), I)
        }
        return w
      }
      function _(w, v) {
        switch (w) {
          case s['RSASSA-PSS']:
            var I = []
            return (
              v.hash.algorithmOid !== void 0 &&
                I.push(
                  n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [
                    n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                      n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(v.hash.algorithmOid).getBytes()),
                      n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, '')
                    ])
                  ])
                ),
              v.mgf.algorithmOid !== void 0 &&
                I.push(
                  n.create(n.Class.CONTEXT_SPECIFIC, 1, !0, [
                    n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                      n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(v.mgf.algorithmOid).getBytes()),
                      n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                        n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(v.mgf.hash.algorithmOid).getBytes()),
                        n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, '')
                      ])
                    ])
                  ])
                ),
              v.saltLength !== void 0 &&
                I.push(
                  n.create(n.Class.CONTEXT_SPECIFIC, 2, !0, [
                    n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(v.saltLength).getBytes())
                  ])
                ),
              n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, I)
            )
          default:
            return n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, '')
        }
      }
      function A(w) {
        var v = n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [])
        if (w.attributes.length === 0) return v
        for (var I = w.attributes, M = 0; M < I.length; ++M) {
          var q = I[M],
            G = q.value,
            O = n.Type.UTF8
          'valueTagClass' in q && (O = q.valueTagClass), O === n.Type.UTF8 && (G = t.util.encodeUtf8(G))
          var x = !1
          'valueConstructed' in q && (x = q.valueConstructed)
          var L = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(q.type).getBytes()),
            n.create(n.Class.UNIVERSAL, n.Type.SET, !0, [n.create(n.Class.UNIVERSAL, O, x, G)])
          ])
          v.value.push(L)
        }
        return v
      }
      var T = new Date('1950-01-01T00:00:00Z'),
        E = new Date('2050-01-01T00:00:00Z')
      function k(w) {
        return w >= T && w < E
          ? n.create(n.Class.UNIVERSAL, n.Type.UTCTIME, !1, n.dateToUtcTime(w))
          : n.create(n.Class.UNIVERSAL, n.Type.GENERALIZEDTIME, !1, n.dateToGeneralizedTime(w))
      }
      ;(i.getTBSCertificate = function (w) {
        var v = k(w.validity.notBefore),
          I = k(w.validity.notAfter),
          M = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [
              n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(w.version).getBytes())
            ]),
            n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, t.util.hexToBytes(w.serialNumber)),
            n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
              n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(w.siginfo.algorithmOid).getBytes()),
              _(w.siginfo.algorithmOid, w.siginfo.parameters)
            ]),
            d(w.issuer),
            n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [v, I]),
            d(w.subject),
            i.publicKeyToAsn1(w.publicKey)
          ])
        return (
          w.issuer.uniqueId &&
            M.value.push(
              n.create(n.Class.CONTEXT_SPECIFIC, 1, !0, [
                n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, String.fromCharCode(0) + w.issuer.uniqueId)
              ])
            ),
          w.subject.uniqueId &&
            M.value.push(
              n.create(n.Class.CONTEXT_SPECIFIC, 2, !0, [
                n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, String.fromCharCode(0) + w.subject.uniqueId)
              ])
            ),
          w.extensions.length > 0 && M.value.push(i.certificateExtensionsToAsn1(w.extensions)),
          M
        )
      }),
        (i.getCertificationRequestInfo = function (w) {
          var v = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(w.version).getBytes()),
            d(w.subject),
            i.publicKeyToAsn1(w.publicKey),
            A(w)
          ])
          return v
        }),
        (i.distinguishedNameToAsn1 = function (w) {
          return d(w)
        }),
        (i.certificateToAsn1 = function (w) {
          var v = w.tbsCertificate || i.getTBSCertificate(w)
          return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            v,
            n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
              n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(w.signatureOid).getBytes()),
              _(w.signatureOid, w.signatureParameters)
            ]),
            n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, String.fromCharCode(0) + w.signature)
          ])
        }),
        (i.certificateExtensionsToAsn1 = function (w) {
          var v = n.create(n.Class.CONTEXT_SPECIFIC, 3, !0, []),
            I = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [])
          v.value.push(I)
          for (var M = 0; M < w.length; ++M) I.value.push(i.certificateExtensionToAsn1(w[M]))
          return v
        }),
        (i.certificateExtensionToAsn1 = function (w) {
          var v = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [])
          v.value.push(n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(w.id).getBytes())),
            w.critical && v.value.push(n.create(n.Class.UNIVERSAL, n.Type.BOOLEAN, !1, String.fromCharCode(255)))
          var I = w.value
          return (
            typeof w.value != 'string' && (I = n.toDer(I).getBytes()),
            v.value.push(n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, I)),
            v
          )
        }),
        (i.certificationRequestToAsn1 = function (w) {
          var v = w.certificationRequestInfo || i.getCertificationRequestInfo(w)
          return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            v,
            n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
              n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(w.signatureOid).getBytes()),
              _(w.signatureOid, w.signatureParameters)
            ]),
            n.create(n.Class.UNIVERSAL, n.Type.BITSTRING, !1, String.fromCharCode(0) + w.signature)
          ])
        }),
        (i.createCaStore = function (w) {
          var v = { certs: {} }
          ;(v.getIssuer = function (O) {
            var x = I(O.issuer)
            return x
          }),
            (v.addCertificate = function (O) {
              if ((typeof O == 'string' && (O = t.pki.certificateFromPem(O)), M(O.subject), !v.hasCertificate(O)))
                if (O.subject.hash in v.certs) {
                  var x = v.certs[O.subject.hash]
                  t.util.isArray(x) || (x = [x]), x.push(O), (v.certs[O.subject.hash] = x)
                } else v.certs[O.subject.hash] = O
            }),
            (v.hasCertificate = function (O) {
              typeof O == 'string' && (O = t.pki.certificateFromPem(O))
              var x = I(O.subject)
              if (!x) return !1
              t.util.isArray(x) || (x = [x])
              for (var L = n.toDer(i.certificateToAsn1(O)).getBytes(), K = 0; K < x.length; ++K) {
                var J = n.toDer(i.certificateToAsn1(x[K])).getBytes()
                if (L === J) return !0
              }
              return !1
            }),
            (v.listAllCertificates = function () {
              var O = []
              for (var x in v.certs)
                if (v.certs.hasOwnProperty(x)) {
                  var L = v.certs[x]
                  if (!t.util.isArray(L)) O.push(L)
                  else for (var K = 0; K < L.length; ++K) O.push(L[K])
                }
              return O
            }),
            (v.removeCertificate = function (O) {
              var x
              if ((typeof O == 'string' && (O = t.pki.certificateFromPem(O)), M(O.subject), !v.hasCertificate(O)))
                return null
              var L = I(O.subject)
              if (!t.util.isArray(L)) return (x = v.certs[O.subject.hash]), delete v.certs[O.subject.hash], x
              for (var K = n.toDer(i.certificateToAsn1(O)).getBytes(), J = 0; J < L.length; ++J) {
                var Z = n.toDer(i.certificateToAsn1(L[J])).getBytes()
                K === Z && ((x = L[J]), L.splice(J, 1))
              }
              return L.length === 0 && delete v.certs[O.subject.hash], x
            })
          function I(O) {
            return M(O), v.certs[O.hash] || null
          }
          function M(O) {
            if (!O.hash) {
              var x = t.md.sha1.create()
              ;(O.attributes = i.RDNAttributesAsArray(d(O), x)), (O.hash = x.digest().toHex())
            }
          }
          if (w)
            for (var q = 0; q < w.length; ++q) {
              var G = w[q]
              v.addCertificate(G)
            }
          return v
        }),
        (i.certificateError = {
          bad_certificate: 'forge.pki.BadCertificate',
          unsupported_certificate: 'forge.pki.UnsupportedCertificate',
          certificate_revoked: 'forge.pki.CertificateRevoked',
          certificate_expired: 'forge.pki.CertificateExpired',
          certificate_unknown: 'forge.pki.CertificateUnknown',
          unknown_ca: 'forge.pki.UnknownCertificateAuthority'
        }),
        (i.verifyCertificateChain = function (w, v, I) {
          typeof I == 'function' && (I = { verify: I }), (I = I || {}), (v = v.slice(0))
          var M = v.slice(0),
            q = I.validityCheckDate
          typeof q == 'undefined' && (q = new Date())
          var G = !0,
            O = null,
            x = 0
          do {
            var L = v.shift(),
              K = null,
              J = !1
            if (
              (q &&
                (q < L.validity.notBefore || q > L.validity.notAfter) &&
                (O = {
                  message: 'Certificate is not valid yet or has expired.',
                  error: i.certificateError.certificate_expired,
                  notBefore: L.validity.notBefore,
                  notAfter: L.validity.notAfter,
                  now: q
                }),
              O === null)
            ) {
              if (((K = v[0] || w.getIssuer(L)), K === null && L.isIssuer(L) && ((J = !0), (K = L)), K)) {
                var Z = K
                t.util.isArray(Z) || (Z = [Z])
                for (var Q = !1; !Q && Z.length > 0; ) {
                  K = Z.shift()
                  try {
                    Q = K.verify(L)
                  } catch (oe) {}
                }
                Q || (O = { message: 'Certificate signature is invalid.', error: i.certificateError.bad_certificate })
              }
              O === null &&
                (!K || J) &&
                !w.hasCertificate(L) &&
                (O = { message: 'Certificate is not trusted.', error: i.certificateError.unknown_ca })
            }
            if (
              (O === null &&
                K &&
                !L.isIssuer(K) &&
                (O = { message: 'Certificate issuer is invalid.', error: i.certificateError.bad_certificate }),
              O === null)
            )
              for (
                var fe = { keyUsage: !0, basicConstraints: !0 }, ie = 0;
                O === null && ie < L.extensions.length;
                ++ie
              ) {
                var W = L.extensions[ie]
                W.critical &&
                  !(W.name in fe) &&
                  (O = {
                    message: 'Certificate has an unsupported critical extension.',
                    error: i.certificateError.unsupported_certificate
                  })
              }
            if (O === null && (!G || (v.length === 0 && (!K || J)))) {
              var le = L.getExtension('basicConstraints'),
                xe = L.getExtension('keyUsage')
              if (
                (xe !== null &&
                  (!xe.keyCertSign || le === null) &&
                  (O = {
                    message:
                      "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                    error: i.certificateError.bad_certificate
                  }),
                O === null &&
                  le !== null &&
                  !le.cA &&
                  (O = {
                    message: 'Certificate basicConstraints indicates the certificate is not a CA.',
                    error: i.certificateError.bad_certificate
                  }),
                O === null && xe !== null && 'pathLenConstraint' in le)
              ) {
                var _e = x - 1
                _e > le.pathLenConstraint &&
                  (O = {
                    message: 'Certificate basicConstraints pathLenConstraint violated.',
                    error: i.certificateError.bad_certificate
                  })
              }
            }
            var Ne = O === null ? !0 : O.error,
              ke = I.verify ? I.verify(Ne, x, M) : Ne
            if (ke === !0) O = null
            else
              throw (
                (Ne === !0 &&
                  (O = {
                    message: 'The application rejected the certificate.',
                    error: i.certificateError.bad_certificate
                  }),
                (ke || ke === 0) &&
                  (typeof ke == 'object' && !t.util.isArray(ke)
                    ? (ke.message && (O.message = ke.message), ke.error && (O.error = ke.error))
                    : typeof ke == 'string' && (O.error = ke)),
                O)
              )
            ;(G = !1), ++x
          } while (v.length > 0)
          return !0
        })
    }
  }),
  fq = te({
    'node_modules/node-forge/lib/pkcs7.js'(e, r) {
      V(), F()
      var t = yt()
      qc(), qi(), Zp(), Uc(), Qp(), aq(), Ss(), zt(), BT()
      var n = t.asn1,
        i = (r.exports = t.pkcs7 = t.pkcs7 || {})
      ;(i.messageFromPem = function (h) {
        var m = t.pem.decode(h)[0]
        if (m.type !== 'PKCS7') {
          var _ = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".')
          throw ((_.headerType = m.type), _)
        }
        if (m.procType && m.procType.type === 'ENCRYPTED')
          throw new Error('Could not convert PKCS#7 message from PEM; PEM is encrypted.')
        var A = n.fromDer(m.body)
        return i.messageFromAsn1(A)
      }),
        (i.messageToPem = function (h, m) {
          var _ = { type: 'PKCS7', body: n.toDer(h.toAsn1()).getBytes() }
          return t.pem.encode(_, { maxline: m })
        }),
        (i.messageFromAsn1 = function (h) {
          var m = {},
            _ = []
          if (!n.validate(h, i.asn1.contentInfoValidator, m, _)) {
            var A = new Error('Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.')
            throw ((A.errors = _), A)
          }
          var T = n.derToOid(m.contentType),
            E
          switch (T) {
            case t.pki.oids.envelopedData:
              E = i.createEnvelopedData()
              break
            case t.pki.oids.encryptedData:
              E = i.createEncryptedData()
              break
            case t.pki.oids.signedData:
              E = i.createSignedData()
              break
            default:
              throw new Error('Cannot read PKCS#7 message. ContentType with OID ' + T + ' is not (yet) supported.')
          }
          return E.fromAsn1(m.content.value[0]), E
        }),
        (i.createSignedData = function () {
          var h = null
          return (
            (h = {
              type: t.pki.oids.signedData,
              version: 1,
              certificates: [],
              crls: [],
              signers: [],
              digestAlgorithmIdentifiers: [],
              contentInfo: null,
              signerInfos: [],
              fromAsn1: function (A) {
                if (
                  (y(h, A, i.asn1.signedDataValidator),
                  (h.certificates = []),
                  (h.crls = []),
                  (h.digestAlgorithmIdentifiers = []),
                  (h.contentInfo = null),
                  (h.signerInfos = []),
                  h.rawCapture.certificates)
                )
                  for (var T = h.rawCapture.certificates.value, E = 0; E < T.length; ++E)
                    h.certificates.push(t.pki.certificateFromAsn1(T[E]))
              },
              toAsn1: function () {
                h.contentInfo || h.sign()
                for (var A = [], T = 0; T < h.certificates.length; ++T)
                  A.push(t.pki.certificateToAsn1(h.certificates[T]))
                var E = [],
                  k = n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [
                    n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                      n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(h.version).getBytes()),
                      n.create(n.Class.UNIVERSAL, n.Type.SET, !0, h.digestAlgorithmIdentifiers),
                      h.contentInfo
                    ])
                  ])
                return (
                  A.length > 0 && k.value[0].value.push(n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, A)),
                  E.length > 0 && k.value[0].value.push(n.create(n.Class.CONTEXT_SPECIFIC, 1, !0, E)),
                  k.value[0].value.push(n.create(n.Class.UNIVERSAL, n.Type.SET, !0, h.signerInfos)),
                  n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                    n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.type).getBytes()),
                    k
                  ])
                )
              },
              addSigner: function (A) {
                var T = A.issuer,
                  E = A.serialNumber
                if (A.certificate) {
                  var k = A.certificate
                  typeof k == 'string' && (k = t.pki.certificateFromPem(k)),
                    (T = k.issuer.attributes),
                    (E = k.serialNumber)
                }
                var w = A.key
                if (!w) throw new Error('Could not add PKCS#7 signer; no private key specified.')
                typeof w == 'string' && (w = t.pki.privateKeyFromPem(w))
                var v = A.digestAlgorithm || t.pki.oids.sha1
                switch (v) {
                  case t.pki.oids.sha1:
                  case t.pki.oids.sha256:
                  case t.pki.oids.sha384:
                  case t.pki.oids.sha512:
                  case t.pki.oids.md5:
                    break
                  default:
                    throw new Error('Could not add PKCS#7 signer; unknown message digest algorithm: ' + v)
                }
                var I = A.authenticatedAttributes || []
                if (I.length > 0) {
                  for (var M = !1, q = !1, G = 0; G < I.length; ++G) {
                    var O = I[G]
                    if (!M && O.type === t.pki.oids.contentType) {
                      if (((M = !0), q)) break
                      continue
                    }
                    if (!q && O.type === t.pki.oids.messageDigest) {
                      if (((q = !0), M)) break
                      continue
                    }
                  }
                  if (!M || !q)
                    throw new Error(
                      'Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.'
                    )
                }
                h.signers.push({
                  key: w,
                  version: 1,
                  issuer: T,
                  serialNumber: E,
                  digestAlgorithm: v,
                  signatureAlgorithm: t.pki.oids.rsaEncryption,
                  signature: null,
                  authenticatedAttributes: I,
                  unauthenticatedAttributes: []
                })
              },
              sign: function (A) {
                if (
                  ((A = A || {}),
                  (typeof h.content != 'object' || h.contentInfo === null) &&
                    ((h.contentInfo = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                      n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(t.pki.oids.data).getBytes())
                    ])),
                    'content' in h))
                ) {
                  var T
                  h.content instanceof t.util.ByteBuffer
                    ? (T = h.content.bytes())
                    : typeof h.content == 'string' && (T = t.util.encodeUtf8(h.content)),
                    A.detached
                      ? (h.detachedContent = n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, T))
                      : h.contentInfo.value.push(
                          n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [
                            n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, T)
                          ])
                        )
                }
                if (h.signers.length !== 0) {
                  var E = m()
                  _(E)
                }
              },
              verify: function () {
                throw new Error('PKCS#7 signature verification not yet implemented.')
              },
              addCertificate: function (A) {
                typeof A == 'string' && (A = t.pki.certificateFromPem(A)), h.certificates.push(A)
              },
              addCertificateRevokationList: function (A) {
                throw new Error('PKCS#7 CRL support not yet implemented.')
              }
            }),
            h
          )
          function m() {
            for (var A = {}, T = 0; T < h.signers.length; ++T) {
              var E = h.signers[T],
                k = E.digestAlgorithm
              k in A || (A[k] = t.md[t.pki.oids[k]].create()),
                E.authenticatedAttributes.length === 0 ? (E.md = A[k]) : (E.md = t.md[t.pki.oids[k]].create())
            }
            h.digestAlgorithmIdentifiers = []
            for (var k in A)
              h.digestAlgorithmIdentifiers.push(
                n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                  n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(k).getBytes()),
                  n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, '')
                ])
              )
            return A
          }
          function _(A) {
            var T
            if ((h.detachedContent ? (T = h.detachedContent) : ((T = h.contentInfo.value[1]), (T = T.value[0])), !T))
              throw new Error('Could not sign PKCS#7 message; there is no content to sign.')
            var E = n.derToOid(h.contentInfo.value[0].value),
              k = n.toDer(T)
            k.getByte(), n.getBerValueLength(k), (k = k.getBytes())
            for (var w in A) A[w].start().update(k)
            for (var v = new Date(), I = 0; I < h.signers.length; ++I) {
              var M = h.signers[I]
              if (M.authenticatedAttributes.length === 0) {
                if (E !== t.pki.oids.data)
                  throw new Error(
                    'Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.'
                  )
              } else {
                M.authenticatedAttributesAsn1 = n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [])
                for (
                  var q = n.create(n.Class.UNIVERSAL, n.Type.SET, !0, []), G = 0;
                  G < M.authenticatedAttributes.length;
                  ++G
                ) {
                  var O = M.authenticatedAttributes[G]
                  O.type === t.pki.oids.messageDigest
                    ? (O.value = A[M.digestAlgorithm].digest())
                    : O.type === t.pki.oids.signingTime && (O.value || (O.value = v)),
                    q.value.push(f(O)),
                    M.authenticatedAttributesAsn1.value.push(f(O))
                }
                ;(k = n.toDer(q).getBytes()), M.md.start().update(k)
              }
              M.signature = M.key.sign(M.md, 'RSASSA-PKCS1-V1_5')
            }
            h.signerInfos = c(h.signers)
          }
        }),
        (i.createEncryptedData = function () {
          var h = null
          return (
            (h = {
              type: t.pki.oids.encryptedData,
              version: 0,
              encryptedContent: { algorithm: t.pki.oids['aes256-CBC'] },
              fromAsn1: function (m) {
                y(h, m, i.asn1.encryptedDataValidator)
              },
              decrypt: function (m) {
                m !== void 0 && (h.encryptedContent.key = m), d(h)
              }
            }),
            h
          )
        }),
        (i.createEnvelopedData = function () {
          var h = null
          return (
            (h = {
              type: t.pki.oids.envelopedData,
              version: 0,
              recipients: [],
              encryptedContent: { algorithm: t.pki.oids['aes256-CBC'] },
              fromAsn1: function (m) {
                var _ = y(h, m, i.asn1.envelopedDataValidator)
                h.recipients = o(_.recipientInfos.value)
              },
              toAsn1: function () {
                return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                  n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.type).getBytes()),
                  n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [
                    n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
                      n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(h.version).getBytes()),
                      n.create(n.Class.UNIVERSAL, n.Type.SET, !0, l(h.recipients)),
                      n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, p(h.encryptedContent))
                    ])
                  ])
                ])
              },
              findRecipient: function (m) {
                for (var _ = m.issuer.attributes, A = 0; A < h.recipients.length; ++A) {
                  var T = h.recipients[A],
                    E = T.issuer
                  if (T.serialNumber === m.serialNumber && E.length === _.length) {
                    for (var k = !0, w = 0; w < _.length; ++w)
                      if (E[w].type !== _[w].type || E[w].value !== _[w].value) {
                        k = !1
                        break
                      }
                    if (k) return T
                  }
                }
                return null
              },
              decrypt: function (m, _) {
                if (h.encryptedContent.key === void 0 && m !== void 0 && _ !== void 0)
                  switch (m.encryptedContent.algorithm) {
                    case t.pki.oids.rsaEncryption:
                    case t.pki.oids.desCBC:
                      var A = _.decrypt(m.encryptedContent.content)
                      h.encryptedContent.key = t.util.createBuffer(A)
                      break
                    default:
                      throw new Error('Unsupported asymmetric cipher, OID ' + m.encryptedContent.algorithm)
                  }
                d(h)
              },
              addRecipient: function (m) {
                h.recipients.push({
                  version: 0,
                  issuer: m.issuer.attributes,
                  serialNumber: m.serialNumber,
                  encryptedContent: { algorithm: t.pki.oids.rsaEncryption, key: m.publicKey }
                })
              },
              encrypt: function (m, _) {
                if (h.encryptedContent.content === void 0) {
                  ;(_ = _ || h.encryptedContent.algorithm), (m = m || h.encryptedContent.key)
                  var A, T, E
                  switch (_) {
                    case t.pki.oids['aes128-CBC']:
                      ;(A = 16), (T = 16), (E = t.aes.createEncryptionCipher)
                      break
                    case t.pki.oids['aes192-CBC']:
                      ;(A = 24), (T = 16), (E = t.aes.createEncryptionCipher)
                      break
                    case t.pki.oids['aes256-CBC']:
                      ;(A = 32), (T = 16), (E = t.aes.createEncryptionCipher)
                      break
                    case t.pki.oids['des-EDE3-CBC']:
                      ;(A = 24), (T = 8), (E = t.des.createEncryptionCipher)
                      break
                    default:
                      throw new Error('Unsupported symmetric cipher, OID ' + _)
                  }
                  if (m === void 0) m = t.util.createBuffer(t.random.getBytes(A))
                  else if (m.length() != A)
                    throw new Error('Symmetric key has wrong length; got ' + m.length() + ' bytes, expected ' + A + '.')
                  ;(h.encryptedContent.algorithm = _),
                    (h.encryptedContent.key = m),
                    (h.encryptedContent.parameter = t.util.createBuffer(t.random.getBytes(T)))
                  var k = E(m)
                  if ((k.start(h.encryptedContent.parameter.copy()), k.update(h.content), !k.finish()))
                    throw new Error('Symmetric encryption failed.')
                  h.encryptedContent.content = k.output
                }
                for (var w = 0; w < h.recipients.length; ++w) {
                  var v = h.recipients[w]
                  if (v.encryptedContent.content === void 0)
                    switch (v.encryptedContent.algorithm) {
                      case t.pki.oids.rsaEncryption:
                        v.encryptedContent.content = v.encryptedContent.key.encrypt(h.encryptedContent.key.data)
                        break
                      default:
                        throw new Error('Unsupported asymmetric cipher, OID ' + v.encryptedContent.algorithm)
                    }
                }
              }
            }),
            h
          )
        })
      function s(h) {
        var m = {},
          _ = []
        if (!n.validate(h, i.asn1.recipientInfoValidator, m, _)) {
          var A = new Error('Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.')
          throw ((A.errors = _), A)
        }
        return {
          version: m.version.charCodeAt(0),
          issuer: t.pki.RDNAttributesAsArray(m.issuer),
          serialNumber: t.util.createBuffer(m.serial).toHex(),
          encryptedContent: {
            algorithm: n.derToOid(m.encAlgorithm),
            parameter: m.encParameter.value,
            content: m.encKey
          }
        }
      }
      function u(h) {
        return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
          n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(h.version).getBytes()),
          n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            t.pki.distinguishedNameToAsn1({ attributes: h.issuer }),
            n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, t.util.hexToBytes(h.serialNumber))
          ]),
          n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.encryptedContent.algorithm).getBytes()),
            n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, '')
          ]),
          n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, h.encryptedContent.content)
        ])
      }
      function o(h) {
        for (var m = [], _ = 0; _ < h.length; ++_) m.push(s(h[_]))
        return m
      }
      function l(h) {
        for (var m = [], _ = 0; _ < h.length; ++_) m.push(u(h[_]))
        return m
      }
      function a(h) {
        var m = n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
          n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, n.integerToDer(h.version).getBytes()),
          n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            t.pki.distinguishedNameToAsn1({ attributes: h.issuer }),
            n.create(n.Class.UNIVERSAL, n.Type.INTEGER, !1, t.util.hexToBytes(h.serialNumber))
          ]),
          n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.digestAlgorithm).getBytes()),
            n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, '')
          ])
        ])
        if (
          (h.authenticatedAttributesAsn1 && m.value.push(h.authenticatedAttributesAsn1),
          m.value.push(
            n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
              n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.signatureAlgorithm).getBytes()),
              n.create(n.Class.UNIVERSAL, n.Type.NULL, !1, '')
            ])
          ),
          m.value.push(n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, h.signature)),
          h.unauthenticatedAttributes.length > 0)
        ) {
          for (
            var _ = n.create(n.Class.CONTEXT_SPECIFIC, 1, !0, []), A = 0;
            A < h.unauthenticatedAttributes.length;
            ++A
          ) {
            var T = h.unauthenticatedAttributes[A]
            _.values.push(f(T))
          }
          m.value.push(_)
        }
        return m
      }
      function c(h) {
        for (var m = [], _ = 0; _ < h.length; ++_) m.push(a(h[_]))
        return m
      }
      function f(h) {
        var m
        if (h.type === t.pki.oids.contentType)
          m = n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.value).getBytes())
        else if (h.type === t.pki.oids.messageDigest)
          m = n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, h.value.bytes())
        else if (h.type === t.pki.oids.signingTime) {
          var _ = new Date('1950-01-01T00:00:00Z'),
            A = new Date('2050-01-01T00:00:00Z'),
            T = h.value
          if (typeof T == 'string') {
            var E = Date.parse(T)
            isNaN(E)
              ? T.length === 13
                ? (T = n.utcTimeToDate(T))
                : (T = n.generalizedTimeToDate(T))
              : (T = new Date(E))
          }
          T >= _ && T < A
            ? (m = n.create(n.Class.UNIVERSAL, n.Type.UTCTIME, !1, n.dateToUtcTime(T)))
            : (m = n.create(n.Class.UNIVERSAL, n.Type.GENERALIZEDTIME, !1, n.dateToGeneralizedTime(T)))
        }
        return n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
          n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.type).getBytes()),
          n.create(n.Class.UNIVERSAL, n.Type.SET, !0, [m])
        ])
      }
      function p(h) {
        return [
          n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(t.pki.oids.data).getBytes()),
          n.create(n.Class.UNIVERSAL, n.Type.SEQUENCE, !0, [
            n.create(n.Class.UNIVERSAL, n.Type.OID, !1, n.oidToDer(h.algorithm).getBytes()),
            n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, h.parameter.getBytes())
          ]),
          n.create(n.Class.CONTEXT_SPECIFIC, 0, !0, [
            n.create(n.Class.UNIVERSAL, n.Type.OCTETSTRING, !1, h.content.getBytes())
          ])
        ]
      }
      function y(h, m, _) {
        var A = {},
          T = []
        if (!n.validate(m, _, A, T)) {
          var E = new Error('Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.')
          throw ((E.errors = E), E)
        }
        var k = n.derToOid(A.contentType)
        if (k !== t.pki.oids.data)
          throw new Error('Unsupported PKCS#7 message. Only wrapped ContentType Data supported.')
        if (A.encryptedContent) {
          var w = ''
          if (t.util.isArray(A.encryptedContent))
            for (var v = 0; v < A.encryptedContent.length; ++v) {
              if (A.encryptedContent[v].type !== n.Type.OCTETSTRING)
                throw new Error(
                  'Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.'
                )
              w += A.encryptedContent[v].value
            }
          else w = A.encryptedContent
          h.encryptedContent = {
            algorithm: n.derToOid(A.encAlgorithm),
            parameter: t.util.createBuffer(A.encParameter.value),
            content: t.util.createBuffer(w)
          }
        }
        if (A.content) {
          var w = ''
          if (t.util.isArray(A.content))
            for (var v = 0; v < A.content.length; ++v) {
              if (A.content[v].type !== n.Type.OCTETSTRING)
                throw new Error('Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.')
              w += A.content[v].value
            }
          else w = A.content
          h.content = t.util.createBuffer(w)
        }
        return (h.version = A.version.charCodeAt(0)), (h.rawCapture = A), A
      }
      function d(h) {
        if (h.encryptedContent.key === void 0) throw new Error('Symmetric key not available.')
        if (h.content === void 0) {
          var m
          switch (h.encryptedContent.algorithm) {
            case t.pki.oids['aes128-CBC']:
            case t.pki.oids['aes192-CBC']:
            case t.pki.oids['aes256-CBC']:
              m = t.aes.createDecryptionCipher(h.encryptedContent.key)
              break
            case t.pki.oids.desCBC:
            case t.pki.oids['des-EDE3-CBC']:
              m = t.des.createDecryptionCipher(h.encryptedContent.key)
              break
            default:
              throw new Error('Unsupported symmetric cipher, OID ' + h.encryptedContent.algorithm)
          }
          if ((m.start(h.encryptedContent.parameter), m.update(h.encryptedContent.content), !m.finish()))
            throw new Error('Symmetric decryption failed.')
          h.content = m.output
        }
      }
    }
  }),
  dq = te({
    'node_modules/libp2p/src/keychain/util.js'(e, r) {
      V(), F(), BT()
      var t = yt(),
        n = t.pki,
        i = (u, o) => {
          let l = n.setRsaPublicKey(o.n, o.e),
            a = n.createCertificate()
          ;(a.publicKey = l),
            (a.serialNumber = '01'),
            (a.validity.notBefore = new Date()),
            (a.validity.notAfter = new Date()),
            a.validity.notAfter.setFullYear(a.validity.notBefore.getFullYear() + 10)
          let c = [
            { name: 'organizationName', value: 'ipfs' },
            { shortName: 'OU', value: 'keystore' },
            { name: 'commonName', value: u.id }
          ]
          return (
            a.setSubject(c),
            a.setIssuer(c),
            a.setExtensions([
              { name: 'basicConstraints', cA: !0 },
              {
                name: 'keyUsage',
                keyCertSign: !0,
                digitalSignature: !0,
                nonRepudiation: !0,
                keyEncipherment: !0,
                dataEncipherment: !0
              },
              {
                name: 'extKeyUsage',
                serverAuth: !0,
                clientAuth: !0,
                codeSigning: !0,
                emailProtection: !0,
                timeStamping: !0
              },
              { name: 'nsCertType', client: !0, server: !0, email: !0, objsign: !0, sslCA: !0, emailCA: !0, objCA: !0 }
            ]),
            a.sign(o),
            a
          )
        }
      async function s(u, o) {
        let l = u.map(o),
          c = (await Promise.all(l)).findIndex((f) => f)
        return u[c]
      }
      r.exports = { certificateForKey: i, findAsync: s }
    }
  }),
  hq = te({
    'node_modules/libp2p/src/keychain/cms.js'(e, r) {
      V(), F(), fq(), t9()
      var t = yt(),
        { certificateForKey: n, findAsync: i } = dq(),
        s = pt(),
        u = xs(),
        o = zi(),
        l = new WeakMap(),
        a = class {
          constructor(c, f) {
            if (!c) throw s(new Error('keychain is required'), 'ERR_KEYCHAIN_REQUIRED')
            ;(this.keychain = c), l.set(this, { dek: f })
          }
          async encrypt(c, f) {
            if (!(f instanceof Uint8Array)) throw s(new Error('Plain data must be a Uint8Array'), 'ERR_INVALID_PARAMS')
            let p = await this.keychain.findKeyByName(c),
              y = await this.keychain._getPrivateKey(c),
              d = l.get(this).dek,
              h = t.pki.decryptRsaPrivateKey(y, d),
              m = await n(p, h),
              _ = t.pkcs7.createEnvelopedData()
            _.addRecipient(m), (_.content = t.util.createBuffer(f)), _.encrypt()
            let A = t.asn1.toDer(_.toAsn1()).getBytes()
            return u(A, 'ascii')
          }
          async decrypt(c) {
            if (!(c instanceof Uint8Array)) throw s(new Error('CMS data is required'), 'ERR_INVALID_PARAMS')
            let f
            try {
              let A = t.util.createBuffer(o(c, 'ascii')),
                T = t.asn1.fromDer(A)
              f = t.pkcs7.messageFromAsn1(T)
            } catch (A) {
              throw s(new Error('Invalid CMS: ' + A.message), 'ERR_INVALID_CMS')
            }
            let p = f.recipients
                .filter((A) => A.issuer.find((T) => T.shortName === 'O' && T.value === 'ipfs'))
                .filter((A) => A.issuer.find((T) => T.shortName === 'CN'))
                .map((A) => ({ recipient: A, keyId: A.issuer.find((T) => T.shortName === 'CN').value })),
              y = await i(p, async (A) => {
                try {
                  if (await this.keychain.findKeyById(A.keyId)) return !0
                } catch (T) {
                  return !1
                }
                return !1
              })
            if (!y) {
              let A = p.map((T) => T.keyId)
              throw s(new Error('Decryption needs one of the key(s): ' + A.join(', ')), 'ERR_MISSING_KEYS', {
                missingKeys: A
              })
            }
            let d = await this.keychain.findKeyById(y.keyId)
            if (!d) throw s(new Error('No key available to decrypto'), 'ERR_NO_KEY')
            let h = await this.keychain._getPrivateKey(d.name),
              m = l.get(this).dek,
              _ = t.pki.decryptRsaPrivateKey(h, m)
            return f.decrypt(y.recipient, _), u(f.content.getBytes(), 'ascii')
          }
        }
      r.exports = a
    }
  }),
  pq = te({
    'node_modules/libp2p/src/keychain/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:keychain'), { error: t('libp2p:keychain:err') }),
        i = tq(),
        s = gf(),
        u = H1(),
        { Key: o } = RT(),
        l = hq(),
        a = pt(),
        c = zi(),
        f = xs()
      h1()
      var p = '/pkcs8/',
        y = '/info/',
        d = new WeakMap(),
        h = { minKeyLength: 112 / 8, minSaltLength: 128 / 8, minIterationCount: 1e3 },
        m = {
          dek: {
            keyLength: 512 / 8,
            iterationCount: 1e4,
            salt: 'you should override this value with a crypto secure random number',
            hash: 'sha2-512'
          }
        }
      function _(w) {
        return !w || typeof w != 'string' ? !1 : w === i(w.trim())
      }
      async function A(w) {
        let v = 200,
          I = 1e3,
          M = Math.random() * (I - v) + v
        throw (await new Promise((q) => setTimeout(q, M)), w)
      }
      function T(w) {
        return new o(p + w)
      }
      function E(w) {
        return new o(y + w)
      }
      var k = class {
        constructor(w, v) {
          if (!w) throw new Error('store is required')
          if (((this.store = w), (this.opts = s(m, v)), this.opts.pass && this.opts.pass.length < 20))
            throw new Error('pass must be least 20 characters')
          if (this.opts.dek.keyLength < h.minKeyLength)
            throw new Error(`dek.keyLength must be least ${h.minKeyLength} bytes`)
          if (this.opts.dek.salt.length < h.minSaltLength)
            throw new Error(`dek.saltLength must be least ${h.minSaltLength} bytes`)
          if (this.opts.dek.iterationCount < h.minIterationCount)
            throw new Error(`dek.iterationCount must be least ${h.minIterationCount}`)
          let I = this.opts.pass
            ? u.pbkdf2(
                this.opts.pass,
                this.opts.dek.salt,
                this.opts.dek.iterationCount,
                this.opts.dek.keyLength,
                this.opts.dek.hash
              )
            : ''
          d.set(this, { dek: I })
        }
        get cms() {
          return new l(this, d.get(this).dek)
        }
        static generateOptions() {
          let w = Object.assign({}, m),
            v = Math.ceil(h.minSaltLength / 3) * 3
          return (w.dek.salt = c(u.randomBytes(v), 'base64')), w
        }
        static get options() {
          return m
        }
        async createKey(w, v, I = 2048) {
          let M = this
          if (!_(w) || w === 'self') return A(a(new Error(`Invalid key name '${w}'`), 'ERR_INVALID_KEY_NAME'))
          if (typeof v != 'string') return A(a(new Error(`Invalid key type '${v}'`), 'ERR_INVALID_KEY_TYPE'))
          let q = T(w)
          if (await M.store.has(q)) return A(a(new Error(`Key '${w}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))
          switch (v.toLowerCase()) {
            case 'rsa':
              if (!Number.isSafeInteger(I) || I < 2048)
                return A(a(new Error(`Invalid RSA key size ${I}`), 'ERR_INVALID_KEY_SIZE'))
              break
            default:
              break
          }
          let O
          try {
            let x = await u.keys.generateKeyPair(v, I),
              L = await x.id(),
              K = d.get(this).dek,
              J = await x.export(K)
            O = { name: w, id: L }
            let Z = M.store.batch()
            Z.put(q, f(J)), Z.put(E(w), f(JSON.stringify(O))), await Z.commit()
          } catch (x) {
            return A(x)
          }
          return O
        }
        async listKeys() {
          let w = this,
            v = { prefix: y },
            I = []
          for await (let M of w.store.query(v)) I.push(JSON.parse(c(M.value)))
          return I
        }
        async findKeyById(w) {
          try {
            return (await this.listKeys()).find((I) => I.id === w)
          } catch (v) {
            return A(v)
          }
        }
        async findKeyByName(w) {
          if (!_(w)) return A(a(new Error(`Invalid key name '${w}'`), 'ERR_INVALID_KEY_NAME'))
          let v = E(w)
          try {
            let I = await this.store.get(v)
            return JSON.parse(c(I))
          } catch (I) {
            return A(a(new Error(`Key '${w}' does not exist. ${I.message}`), 'ERR_KEY_NOT_FOUND'))
          }
        }
        async removeKey(w) {
          let v = this
          if (!_(w) || w === 'self') return A(a(new Error(`Invalid key name '${w}'`), 'ERR_INVALID_KEY_NAME'))
          let I = T(w),
            M = await v.findKeyByName(w),
            q = v.store.batch()
          return q.delete(I), q.delete(E(w)), await q.commit(), M
        }
        async renameKey(w, v) {
          let I = this
          if (!_(w) || w === 'self') return A(a(new Error(`Invalid old key name '${w}'`), 'ERR_OLD_KEY_NAME_INVALID'))
          if (!_(v) || v === 'self') return A(a(new Error(`Invalid new key name '${v}'`), 'ERR_NEW_KEY_NAME_INVALID'))
          let M = T(w),
            q = T(v),
            G = E(w),
            O = E(v)
          if (await I.store.has(q)) return A(a(new Error(`Key '${v}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))
          try {
            let L = await I.store.get(M),
              K = await I.store.get(G),
              J = JSON.parse(c(K))
            J.name = v
            let Z = I.store.batch()
            return Z.put(q, L), Z.put(O, f(JSON.stringify(J))), Z.delete(M), Z.delete(G), await Z.commit(), J
          } catch (L) {
            return A(L)
          }
        }
        async exportKey(w, v) {
          if (!_(w)) return A(a(new Error(`Invalid key name '${w}'`), 'ERR_INVALID_KEY_NAME'))
          if (!v) return A(a(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'))
          let I = T(w)
          try {
            let M = await this.store.get(I),
              q = c(M),
              G = d.get(this).dek
            return (await u.keys.import(q, G)).export(v)
          } catch (M) {
            return A(M)
          }
        }
        async importKey(w, v, I) {
          let M = this
          if (!_(w) || w === 'self') return A(a(new Error(`Invalid key name '${w}'`), 'ERR_INVALID_KEY_NAME'))
          if (!v) return A(a(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'))
          let q = T(w)
          if (await M.store.has(q)) return A(a(new Error(`Key '${w}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))
          let O
          try {
            O = await u.keys.import(v, I)
          } catch (J) {
            return A(a(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'))
          }
          let x
          try {
            x = await O.id()
            let J = d.get(this).dek
            v = await O.export(J)
          } catch (J) {
            return A(J)
          }
          let L = { name: w, id: x },
            K = M.store.batch()
          return K.put(q, f(v)), K.put(E(w), f(JSON.stringify(L))), await K.commit(), L
        }
        async importPeer(w, v) {
          let I = this
          if (!_(w)) return A(a(new Error(`Invalid key name '${w}'`), 'ERR_INVALID_KEY_NAME'))
          if (!v || !v.privKey) return A(a(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'))
          let M = v.privKey,
            q = T(w)
          if (await I.store.has(q)) return A(a(new Error(`Key '${w}' already exists`), 'ERR_KEY_ALREADY_EXISTS'))
          try {
            let O = await M.id(),
              x = d.get(this).dek,
              L = await M.export(x),
              K = { name: w, id: O },
              J = I.store.batch()
            return J.put(q, f(L)), J.put(E(w), f(JSON.stringify(K))), await J.commit(), K
          } catch (O) {
            return A(O)
          }
        }
        async _getPrivateKey(w) {
          if (!_(w)) return A(a(new Error(`Invalid key name '${w}'`), 'ERR_INVALID_KEY_NAME'))
          try {
            let v = T(w),
              I = await this.store.get(v)
            return c(I)
          } catch (v) {
            return A(a(new Error(`Key '${w}' does not exist. ${v.message}`), 'ERR_KEY_NOT_FOUND'))
          }
        }
        async rotateKeychainPass(w, v) {
          if (typeof w != 'string')
            return A(a(new Error(`Invalid old pass type '${typeof w}'`), 'ERR_INVALID_OLD_PASS_TYPE'))
          if (typeof v != 'string')
            return A(a(new Error(`Invalid new pass type '${typeof v}'`), 'ERR_INVALID_NEW_PASS_TYPE'))
          if (v.length < 20) return A(a(new Error(`Invalid pass length ${v.length}`), 'ERR_INVALID_PASS_LENGTH'))
          n('recreating keychain')
          let I = d.get(this).dek
          this.opts.pass = v
          let M = v
            ? u.pbkdf2(v, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash)
            : ''
          d.set(this, { dek: M })
          let q = await this.listKeys()
          for (let G of q) {
            let O = await this.store.get(T(G.name)),
              x = c(O),
              L = await u.keys.import(x, I),
              K = M.toString(),
              J = await L.export(K),
              Z = this.store.batch(),
              Q = { name: G.name, id: G.id }
            Z.put(T(G.name), f(J)), Z.put(E(G.name), f(JSON.stringify(Q))), await Z.commit()
          }
          n('keychain reconstructed')
        }
      }
      r.exports = k
    }
  }),
  _2 = te({
    'node_modules/streaming-iterables/dist/index.js'(e, r) {
      V(),
        F(),
        (function (t, n) {
          typeof e == 'object' && typeof r != 'undefined'
            ? n(e)
            : typeof define == 'function' && define.amd
            ? define(['exports'], n)
            : ((t = typeof globalThis != 'undefined' ? globalThis : t || self), n((t.streamingIterables = {})))
        })(e, function (t) {
          'use strict'
          async function* n(S, R) {
            let P = []
            for await (let B of R) P.push(B), P.length === S && (yield P, (P = []))
            P.length > 0 && (yield P)
          }
          function* i(S, R) {
            let P = []
            for (let B of R) P.push(B), P.length === S && (yield P, (P = []))
            P.length > 0 && (yield P)
          }
          function s(S, R) {
            return R === void 0 ? (P) => s(S, P) : R[Symbol.asyncIterator] ? n(S, R) : i(S, R)
          }
          function u(S) {
            if (typeof S.next == 'function') return S
            if (typeof S[Symbol.iterator] == 'function') return S[Symbol.iterator]()
            if (typeof S[Symbol.asyncIterator] == 'function') return S[Symbol.asyncIterator]()
            throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols')
          }
          function o() {
            let S, R
            return {
              promise: new Promise((B, D) => {
                ;(R = B), (S = D)
              }),
              reject: S,
              resolve: R
            }
          }
          function l(S, R) {
            let P = u(R),
              B = [],
              D = [],
              $ = !1,
              g = !1
            function N() {
              for (; D.length > 0 && B.length > 0; ) {
                let ee = D.shift(),
                  { error: ae, value: Y } = B.shift()
                ae ? ee.reject(ae) : ee.resolve({ done: !1, value: Y })
              }
              for (; D.length > 0 && g; ) {
                let { resolve: ee } = D.shift()
                ee({ done: !0, value: void 0 })
              }
            }
            async function U() {
              if (!g && !$ && !(B.length >= S)) {
                $ = !0
                try {
                  let { done: ee, value: ae } = await P.next()
                  ee ? (g = !0) : B.push({ value: ae })
                } catch (ee) {
                  ;(g = !0), B.push({ error: ee })
                }
                N(), ($ = !1), U()
              }
            }
            async function X() {
              if (B.length > 0) {
                let { error: ae, value: Y } = B.shift()
                if (ae) throw ae
                return U(), { done: !1, value: Y }
              }
              if (g) return { done: !0, value: void 0 }
              let ee = o()
              return D.push(ee), U(), ee.promise
            }
            let ne = { next: X, [Symbol.asyncIterator]: () => ne }
            return ne
          }
          function* a(S, R) {
            let P = [],
              B
            try {
              for (let D of R) P.push(D), !(P.length <= S) && (yield P.shift())
            } catch (D) {
              B = D
            }
            for (let D of P) yield D
            if (B) throw B
          }
          function c(S, R) {
            return R === void 0 ? (P) => c(S, P) : S === 0 ? R : R[Symbol.asyncIterator] ? l(S, R) : a(S, R)
          }
          async function f(S) {
            let R = []
            for await (let P of S) R.push(P)
            return R
          }
          function p(S) {
            return S[Symbol.asyncIterator] ? f(S) : Array.from(S)
          }
          async function* y(S) {
            for await (let R of S) yield* R
          }
          function* d(S) {
            for (let R of S) yield* R
          }
          function h(...S) {
            return S.find((P) => P[Symbol.asyncIterator] !== void 0) ? y(S) : d(S)
          }
          async function m(S) {
            for await (let R of S);
          }
          function _(S) {
            if (S[Symbol.asyncIterator]) return m(S)
            for (let R of S);
          }
          async function* A(S, R) {
            for await (let P of R) (await S(P)) && (yield P)
          }
          function T(S, R) {
            return R === void 0 ? (P) => A(S, P) : A(S, R)
          }
          async function* E(S) {
            for await (let R of S)
              R && typeof R != 'string' && (R[Symbol.iterator] || R[Symbol.asyncIterator]) ? yield* E(R) : yield R
          }
          async function* k(S, R) {
            for await (let P of R) yield await S(P)
          }
          function w(S, R) {
            return R === void 0 ? (P) => k(S, P) : k(S, R)
          }
          function v(S, R) {
            return R === void 0 ? (P) => v(S, P) : T((P) => P != null, E(w(S, R)))
          }
          function I(S, R, P) {
            let B = u(P),
              D = [],
              $ = [],
              g = !1,
              N = !1,
              U = 0,
              X = null
            function ne() {
              for (; $.length > 0 && D.length > 0; ) {
                let { resolve: H } = $.shift(),
                  se = D.shift()
                H({ done: !1, value: se })
              }
              for (; $.length > 0 && U === 0 && g; ) {
                let { resolve: H, reject: se } = $.shift()
                X ? (se(X), (X = null)) : H({ done: !0, value: void 0 })
              }
            }
            async function ee() {
              if (g) {
                ne()
                return
              }
              if (!N && !(U + D.length >= S)) {
                ;(N = !0), U++
                try {
                  let { done: H, value: se } = await B.next()
                  H ? ((g = !0), U--, ne()) : ae(se)
                } catch (H) {
                  ;(g = !0), U--, (X = H), ne()
                }
                ;(N = !1), ee()
              }
            }
            async function ae(H) {
              try {
                let se = await R(H)
                if (se && se[Symbol.asyncIterator]) for await (let me of se) D.push(me)
                else D.push(se)
              } catch (se) {
                ;(g = !0), (X = se)
              }
              U--, ne(), ee()
            }
            async function Y() {
              if (D.length === 0) {
                let se = o()
                return $.push(se), ee(), se.promise
              }
              let H = D.shift()
              return ee(), { done: !1, value: H }
            }
            let z = { next: Y, [Symbol.asyncIterator]: () => z }
            return z
          }
          function M(S, R, P) {
            return R === void 0
              ? (B, D) => (D ? M(S, B, D) : M(S, B))
              : P === void 0
              ? (B) => M(S, R, B)
              : T((B) => B != null, E(I(S, R, P)))
          }
          async function q(S) {
            return new Promise((R) => {
              S.once('readable', () => {
                R()
              })
            })
          }
          async function* G(S) {
            for (;;) {
              let R = S.read()
              if (R !== null) {
                yield R
                continue
              }
              if (S._readableState.ended) break
              await q(S)
            }
          }
          function O(S) {
            return typeof S[Symbol.asyncIterator] == 'function' ? S : G(S)
          }
          async function* x(...S) {
            let R = new Set(S.map(u))
            for (; R.size > 0; )
              for (let P of R) {
                let B = await P.next()
                B.done ? R.delete(P) : yield B.value
              }
          }
          function L(S, ...R) {
            let P = S()
            for (let B of R) P = B(P)
            return P
          }
          async function* K(S, R, P) {
            let B = null,
              D = (U) => ({ value: R(U) }),
              $ = async function* (U) {
                for await (let X of U) {
                  if (B) return
                  yield X
                }
              },
              g = L(() => P, c(1), $, w(D), c(S - 1)),
              N = u(g)
            for (;;) {
              let { value: U, done: X } = await N.next()
              if (X) break
              try {
                let ne = await U.value
                B || (yield ne)
              } catch (ne) {
                B = ne
              }
            }
            if (B) throw B
          }
          function J(S, R, P) {
            return R === void 0
              ? (B, D) => J(S, B, D)
              : P === void 0
              ? (B) => J(S, R, B)
              : S === 1
              ? w(R, P)
              : K(S, R, P)
          }
          function Z(S, R, P) {
            return R === void 0
              ? (B, D) => (D ? Z(S, B, D) : Z(S, B))
              : P === void 0
              ? (B) => Z(S, R, B)
              : T((B) => B != null, E(J(S, R, P)))
          }
          async function* Q(...S) {
            let R = S.map(u),
              P = new Set(),
              B = new Map(),
              D = null,
              $ = null,
              g = null,
              N = (ee) => {
                ;(D = ee), $ && $(ee)
              },
              U = (ee) => {
                g && g(ee)
              },
              X = () =>
                new Promise((ee, ae) => {
                  if ((D && ae(D), B.size > 0)) return ee()
                  ;(g = ee), ($ = ae)
                }),
              ne = (ee) => {
                let ae = Promise.resolve(ee.next()).then(async ({ done: Y, value: z }) => {
                  Y || B.set(ee, z), P.delete(ae)
                })
                P.add(ae), ae.then(U, N)
              }
            for (let ee of R) ne(ee)
            for (;;) {
              if (P.size === 0 && B.size === 0) return
              await X()
              for (let [ee, ae] of B) B.delete(ee), yield ae, ne(ee)
            }
          }
          async function fe(S, R, P) {
            let B = R
            for await (let D of P) B = await S(B, D)
            return B
          }
          function ie(S, R, P) {
            return R === void 0
              ? (B, D) => (D ? fe(S, B, D) : ie(S, B))
              : P === void 0
              ? (B) => ie(S, R, B)
              : fe(S, R, P)
          }
          async function* W(S, R) {
            let P = 0
            for await (let B of R) if ((yield await B, P++, P >= S)) break
          }
          function* le(S, R) {
            let P = 0
            for (let B of R) if ((yield B, P++, P >= S)) break
          }
          function xe(S, R) {
            return R === void 0 ? (P) => xe(S, P) : R[Symbol.asyncIterator] ? W(S, R) : le(S, R)
          }
          async function* _e(S, R) {
            for await (let P of R) await S(P), yield P
          }
          function Ne(S, R) {
            return R === void 0 ? (P) => _e(S, P) : _e(S, R)
          }
          function ke(S, R) {
            let P = S[0] + R[0],
              B = S[1] + R[1]
            if (B >= 1e9) {
              let D = B % 1e9
              ;(P += (B - D) / 1e9), (B = D)
            }
            return [P, B]
          }
          async function* oe(S, R) {
            let P = R[Symbol.asyncIterator](),
              B = [0, 0]
            for (;;) {
              let D = lt.hrtime(),
                { value: $, done: g } = await P.next(),
                N = lt.hrtime(D)
              if (((B = ke(B, N)), S.progress && S.progress(N, B), g)) return S.total && S.total(B), $
              yield $
            }
          }
          function* be(S, R) {
            let P = R[Symbol.iterator](),
              B = [0, 0]
            for (;;) {
              let D = lt.hrtime(),
                { value: $, done: g } = P.next(),
                N = lt.hrtime(D)
              if (((B = ke(B, N)), S.progress && S.progress(N, B), g)) return S.total && S.total(B), $
              yield $
            }
          }
          function ge(S = {}, R) {
            return R === void 0 ? (P) => ge(S, P) : R[Symbol.asyncIterator] !== void 0 ? oe(S, R) : be(S, R)
          }
          function re(S, R, P) {
            let B = u(P),
              D = [],
              $ = [],
              g = !1,
              N = !1,
              U = 0,
              X = null
            function ne() {
              for (; $.length > 0 && D.length > 0; ) {
                let { resolve: H } = $.shift(),
                  se = D.shift()
                H({ done: !1, value: se })
              }
              for (; $.length > 0 && U === 0 && g; ) {
                let { resolve: H, reject: se } = $.shift()
                X ? (se(X), (X = null)) : H({ done: !0, value: void 0 })
              }
            }
            async function ee() {
              if (g) {
                ne()
                return
              }
              if (!N && !(U + D.length >= S)) {
                ;(N = !0), U++
                try {
                  let { done: H, value: se } = await B.next()
                  H ? ((g = !0), U--, ne()) : ae(se)
                } catch (H) {
                  ;(g = !0), U--, (X = H), ne()
                }
                ;(N = !1), ee()
              }
            }
            async function ae(H) {
              try {
                let se = await R(H)
                D.push(se)
              } catch (se) {
                ;(g = !0), (X = se)
              }
              U--, ne(), ee()
            }
            async function Y() {
              if (D.length === 0) {
                let se = o()
                return $.push(se), ee(), se.promise
              }
              let H = D.shift()
              return ee(), { done: !1, value: H }
            }
            let z = { next: Y, [Symbol.asyncIterator]: () => z }
            return z
          }
          function j(S, R, P) {
            return R === void 0 ? (B, D) => (D ? j(S, B, D) : j(S, B)) : P === void 0 ? (B) => j(S, R, B) : re(S, R, P)
          }
          async function b(S, R) {
            let P = null,
              B = null,
              D = null,
              $ = (X) => {
                ;(P = X), B && B(X)
              },
              g = () => {
                D && D()
              },
              N = () => {
                S.removeListener('error', $), S.removeListener('drain', g)
              }
            S.once('error', $)
            let U = () =>
              new Promise((X, ne) => {
                if (P) return ne(P)
                S.once('drain', g), (D = X), (B = ne)
              })
            for await (let X of R) if ((S.write(X) === !1 && (await U()), P)) break
            if ((N(), P)) throw P
          }
          function C(S, R) {
            return R === void 0 ? (P) => b(S, P) : b(S, R)
          }
          ;(t.batch = s),
            (t.buffer = c),
            (t.collect = p),
            (t.concat = h),
            (t.consume = _),
            (t.filter = T),
            (t.flatMap = v),
            (t.flatTransform = M),
            (t.flatten = E),
            (t.fromStream = O),
            (t.getIterator = u),
            (t.map = w),
            (t.merge = x),
            (t.parallelFlatMap = Z),
            (t.parallelMap = J),
            (t.parallelMerge = Q),
            (t.pipeline = L),
            (t.reduce = ie),
            (t.take = xe),
            (t.tap = Ne),
            (t.time = ge),
            (t.transform = j),
            (t.writeToStream = C),
            Object.defineProperty(t, '__esModule', { value: !0 })
        })
    }
  }),
  mq = te({
    'node_modules/hashlru/index.js'(e, r) {
      V(),
        F(),
        (r.exports = function (t) {
          if (!t) throw Error('hashlru must have a max value, of type number, greater than 0')
          var n = 0,
            i = Object.create(null),
            s = Object.create(null)
          function u(o, l) {
            ;(i[o] = l), n++, n >= t && ((n = 0), (s = i), (i = Object.create(null)))
          }
          return {
            has: function (o) {
              return i[o] !== void 0 || s[o] !== void 0
            },
            remove: function (o) {
              i[o] !== void 0 && (i[o] = void 0), s[o] !== void 0 && (s[o] = void 0)
            },
            get: function (o) {
              var l = i[o]
              if (l !== void 0) return l
              if ((l = s[o]) !== void 0) return u(o, l), l
            },
            set: function (o, l) {
              i[o] !== void 0 ? (i[o] = l) : u(o, l)
            },
            clear: function () {
              ;(i = Object.create(null)), (s = Object.create(null))
            }
          }
        })
    }
  }),
  bq = te({
    'node_modules/libp2p/src/metrics/old-peers.js'(e, r) {
      V(), F()
      var t = mq()
      r.exports = (n) => {
        let i = t(n)
        return (i.delete = i.remove), i
      }
    }
  }),
  yq = te({
    'node_modules/bignumber.js/bignumber.js'(e, r) {
      V(),
        F(),
        (function (t) {
          'use strict'
          var n,
            i = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
            s = Math.ceil,
            u = Math.floor,
            o = '[BigNumber Error] ',
            l = o + 'Number primitive has more than 15 significant digits: ',
            a = 1e14,
            c = 14,
            f = 9007199254740991,
            p = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
            y = 1e7,
            d = 1e9
          function h(v) {
            var I,
              M,
              q,
              G = (_e.prototype = { constructor: _e, toString: null, valueOf: null }),
              O = new _e(1),
              x = 20,
              L = 4,
              K = -7,
              J = 21,
              Z = -1e7,
              Q = 1e7,
              fe = !1,
              ie = 1,
              W = 0,
              le = {
                prefix: '',
                groupSize: 3,
                secondaryGroupSize: 0,
                groupSeparator: ',',
                decimalSeparator: '.',
                fractionGroupSize: 0,
                fractionGroupSeparator: '\xA0',
                suffix: ''
              },
              xe = '0123456789abcdefghijklmnopqrstuvwxyz'
            function _e(re, j) {
              var b,
                C,
                S,
                R,
                P,
                B,
                D,
                $,
                g = this
              if (!(g instanceof _e)) return new _e(re, j)
              if (j == null) {
                if (re && re._isBigNumber === !0) {
                  ;(g.s = re.s),
                    !re.c || re.e > Q
                      ? (g.c = g.e = null)
                      : re.e < Z
                      ? (g.c = [(g.e = 0)])
                      : ((g.e = re.e), (g.c = re.c.slice()))
                  return
                }
                if ((B = typeof re == 'number') && re * 0 == 0) {
                  if (((g.s = 1 / re < 0 ? ((re = -re), -1) : 1), re === ~~re)) {
                    for (R = 0, P = re; P >= 10; P /= 10, R++);
                    R > Q ? (g.c = g.e = null) : ((g.e = R), (g.c = [re]))
                    return
                  }
                  $ = String(re)
                } else {
                  if (!i.test(($ = String(re)))) return q(g, $, B)
                  g.s = $.charCodeAt(0) == 45 ? (($ = $.slice(1)), -1) : 1
                }
                ;(R = $.indexOf('.')) > -1 && ($ = $.replace('.', '')),
                  (P = $.search(/e/i)) > 0
                    ? (R < 0 && (R = P), (R += +$.slice(P + 1)), ($ = $.substring(0, P)))
                    : R < 0 && (R = $.length)
              } else {
                if ((T(j, 2, xe.length, 'Base'), j == 10)) return (g = new _e(re)), be(g, x + g.e + 1, L)
                if ((($ = String(re)), (B = typeof re == 'number'))) {
                  if (re * 0 != 0) return q(g, $, B, j)
                  if (
                    ((g.s = 1 / re < 0 ? (($ = $.slice(1)), -1) : 1),
                    _e.DEBUG && $.replace(/^0\.0*|\./, '').length > 15)
                  )
                    throw Error(l + re)
                } else g.s = $.charCodeAt(0) === 45 ? (($ = $.slice(1)), -1) : 1
                for (b = xe.slice(0, j), R = P = 0, D = $.length; P < D; P++)
                  if (b.indexOf((C = $.charAt(P))) < 0) {
                    if (C == '.') {
                      if (P > R) {
                        R = D
                        continue
                      }
                    } else if (
                      !S &&
                      (($ == $.toUpperCase() && ($ = $.toLowerCase())) ||
                        ($ == $.toLowerCase() && ($ = $.toUpperCase())))
                    ) {
                      ;(S = !0), (P = -1), (R = 0)
                      continue
                    }
                    return q(g, String(re), B, j)
                  }
                ;(B = !1), ($ = M($, j, 10, g.s)), (R = $.indexOf('.')) > -1 ? ($ = $.replace('.', '')) : (R = $.length)
              }
              for (P = 0; $.charCodeAt(P) === 48; P++);
              for (D = $.length; $.charCodeAt(--D) === 48; );
              if (($ = $.slice(P, ++D))) {
                if (((D -= P), B && _e.DEBUG && D > 15 && (re > f || re !== u(re)))) throw Error(l + g.s * re)
                if ((R = R - P - 1) > Q) g.c = g.e = null
                else if (R < Z) g.c = [(g.e = 0)]
                else {
                  if (((g.e = R), (g.c = []), (P = (R + 1) % c), R < 0 && (P += c), P < D)) {
                    for (P && g.c.push(+$.slice(0, P)), D -= c; P < D; ) g.c.push(+$.slice(P, (P += c)))
                    P = c - ($ = $.slice(P)).length
                  } else P -= D
                  for (; P--; $ += '0');
                  g.c.push(+$)
                }
              } else g.c = [(g.e = 0)]
            }
            ;(_e.clone = h),
              (_e.ROUND_UP = 0),
              (_e.ROUND_DOWN = 1),
              (_e.ROUND_CEIL = 2),
              (_e.ROUND_FLOOR = 3),
              (_e.ROUND_HALF_UP = 4),
              (_e.ROUND_HALF_DOWN = 5),
              (_e.ROUND_HALF_EVEN = 6),
              (_e.ROUND_HALF_CEIL = 7),
              (_e.ROUND_HALF_FLOOR = 8),
              (_e.EUCLID = 9),
              (_e.config = _e.set =
                function (re) {
                  var j, b
                  if (re != null)
                    if (typeof re == 'object') {
                      if (
                        (re.hasOwnProperty((j = 'DECIMAL_PLACES')) && ((b = re[j]), T(b, 0, d, j), (x = b)),
                        re.hasOwnProperty((j = 'ROUNDING_MODE')) && ((b = re[j]), T(b, 0, 8, j), (L = b)),
                        re.hasOwnProperty((j = 'EXPONENTIAL_AT')) &&
                          ((b = re[j]),
                          b && b.pop
                            ? (T(b[0], -d, 0, j), T(b[1], 0, d, j), (K = b[0]), (J = b[1]))
                            : (T(b, -d, d, j), (K = -(J = b < 0 ? -b : b)))),
                        re.hasOwnProperty((j = 'RANGE')))
                      )
                        if (((b = re[j]), b && b.pop)) T(b[0], -d, -1, j), T(b[1], 1, d, j), (Z = b[0]), (Q = b[1])
                        else if ((T(b, -d, d, j), b)) Z = -(Q = b < 0 ? -b : b)
                        else throw Error(o + j + ' cannot be zero: ' + b)
                      if (re.hasOwnProperty((j = 'CRYPTO')))
                        if (((b = re[j]), b === !!b))
                          if (b)
                            if (
                              typeof crypto != 'undefined' &&
                              crypto &&
                              (crypto.getRandomValues || crypto.randomBytes)
                            )
                              fe = b
                            else throw ((fe = !b), Error(o + 'crypto unavailable'))
                          else fe = b
                        else throw Error(o + j + ' not true or false: ' + b)
                      if (
                        (re.hasOwnProperty((j = 'MODULO_MODE')) && ((b = re[j]), T(b, 0, 9, j), (ie = b)),
                        re.hasOwnProperty((j = 'POW_PRECISION')) && ((b = re[j]), T(b, 0, d, j), (W = b)),
                        re.hasOwnProperty((j = 'FORMAT')))
                      )
                        if (((b = re[j]), typeof b == 'object')) le = b
                        else throw Error(o + j + ' not an object: ' + b)
                      if (re.hasOwnProperty((j = 'ALPHABET')))
                        if (((b = re[j]), typeof b == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(b))) xe = b
                        else throw Error(o + j + ' invalid: ' + b)
                    } else throw Error(o + 'Object expected: ' + re)
                  return {
                    DECIMAL_PLACES: x,
                    ROUNDING_MODE: L,
                    EXPONENTIAL_AT: [K, J],
                    RANGE: [Z, Q],
                    CRYPTO: fe,
                    MODULO_MODE: ie,
                    POW_PRECISION: W,
                    FORMAT: le,
                    ALPHABET: xe
                  }
                }),
              (_e.isBigNumber = function (re) {
                if (!re || re._isBigNumber !== !0) return !1
                if (!_e.DEBUG) return !0
                var j,
                  b,
                  C = re.c,
                  S = re.e,
                  R = re.s
                e: if ({}.toString.call(C) == '[object Array]') {
                  if ((R === 1 || R === -1) && S >= -d && S <= d && S === u(S)) {
                    if (C[0] === 0) {
                      if (S === 0 && C.length === 1) return !0
                      break e
                    }
                    if (((j = (S + 1) % c), j < 1 && (j += c), String(C[0]).length == j)) {
                      for (j = 0; j < C.length; j++) if (((b = C[j]), b < 0 || b >= a || b !== u(b))) break e
                      if (b !== 0) return !0
                    }
                  }
                } else if (C === null && S === null && (R === null || R === 1 || R === -1)) return !0
                throw Error(o + 'Invalid BigNumber: ' + re)
              }),
              (_e.maximum = _e.max =
                function () {
                  return ke(arguments, G.lt)
                }),
              (_e.minimum = _e.min =
                function () {
                  return ke(arguments, G.gt)
                }),
              (_e.random = (function () {
                var re = 9007199254740992,
                  j =
                    (Math.random() * re) & 2097151
                      ? function () {
                          return u(Math.random() * re)
                        }
                      : function () {
                          return ((Math.random() * 1073741824) | 0) * 8388608 + ((Math.random() * 8388608) | 0)
                        }
                return function (b) {
                  var C,
                    S,
                    R,
                    P,
                    B,
                    D = 0,
                    $ = [],
                    g = new _e(O)
                  if ((b == null ? (b = x) : T(b, 0, d), (P = s(b / c)), fe))
                    if (crypto.getRandomValues) {
                      for (C = crypto.getRandomValues(new Uint32Array((P *= 2))); D < P; )
                        (B = C[D] * 131072 + (C[D + 1] >>> 11)),
                          B >= 9e15
                            ? ((S = crypto.getRandomValues(new Uint32Array(2))), (C[D] = S[0]), (C[D + 1] = S[1]))
                            : ($.push(B % 1e14), (D += 2))
                      D = P / 2
                    } else if (crypto.randomBytes) {
                      for (C = crypto.randomBytes((P *= 7)); D < P; )
                        (B =
                          (C[D] & 31) * 281474976710656 +
                          C[D + 1] * 1099511627776 +
                          C[D + 2] * 4294967296 +
                          C[D + 3] * 16777216 +
                          (C[D + 4] << 16) +
                          (C[D + 5] << 8) +
                          C[D + 6]),
                          B >= 9e15 ? crypto.randomBytes(7).copy(C, D) : ($.push(B % 1e14), (D += 7))
                      D = P / 7
                    } else throw ((fe = !1), Error(o + 'crypto unavailable'))
                  if (!fe) for (; D < P; ) (B = j()), B < 9e15 && ($[D++] = B % 1e14)
                  for (P = $[--D], b %= c, P && b && ((B = p[c - b]), ($[D] = u(P / B) * B)); $[D] === 0; $.pop(), D--);
                  if (D < 0) $ = [(R = 0)]
                  else {
                    for (R = -1; $[0] === 0; $.splice(0, 1), R -= c);
                    for (D = 1, B = $[0]; B >= 10; B /= 10, D++);
                    D < c && (R -= c - D)
                  }
                  return (g.e = R), (g.c = $), g
                }
              })()),
              (_e.sum = function () {
                for (var re = 1, j = arguments, b = new _e(j[0]); re < j.length; ) b = b.plus(j[re++])
                return b
              }),
              (M = (function () {
                var re = '0123456789'
                function j(b, C, S, R) {
                  for (var P, B = [0], D, $ = 0, g = b.length; $ < g; ) {
                    for (D = B.length; D--; B[D] *= C);
                    for (B[0] += R.indexOf(b.charAt($++)), P = 0; P < B.length; P++)
                      B[P] > S - 1 && (B[P + 1] == null && (B[P + 1] = 0), (B[P + 1] += (B[P] / S) | 0), (B[P] %= S))
                  }
                  return B.reverse()
                }
                return function (b, C, S, R, P) {
                  var B,
                    D,
                    $,
                    g,
                    N,
                    U,
                    X,
                    ne,
                    ee = b.indexOf('.'),
                    ae = x,
                    Y = L
                  for (
                    ee >= 0 &&
                      ((g = W),
                      (W = 0),
                      (b = b.replace('.', '')),
                      (ne = new _e(C)),
                      (U = ne.pow(b.length - ee)),
                      (W = g),
                      (ne.c = j(w(_(U.c), U.e, '0'), 10, S, re)),
                      (ne.e = ne.c.length)),
                      X = j(b, C, S, P ? ((B = xe), re) : ((B = re), xe)),
                      $ = g = X.length;
                    X[--g] == 0;
                    X.pop()
                  );
                  if (!X[0]) return B.charAt(0)
                  if (
                    (ee < 0
                      ? --$
                      : ((U.c = X), (U.e = $), (U.s = R), (U = I(U, ne, ae, Y, S)), (X = U.c), (N = U.r), ($ = U.e)),
                    (D = $ + ae + 1),
                    (ee = X[D]),
                    (g = S / 2),
                    (N = N || D < 0 || X[D + 1] != null),
                    (N =
                      Y < 4
                        ? (ee != null || N) && (Y == 0 || Y == (U.s < 0 ? 3 : 2))
                        : ee > g || (ee == g && (Y == 4 || N || (Y == 6 && X[D - 1] & 1) || Y == (U.s < 0 ? 8 : 7)))),
                    D < 1 || !X[0])
                  )
                    b = N ? w(B.charAt(1), -ae, B.charAt(0)) : B.charAt(0)
                  else {
                    if (((X.length = D), N)) for (--S; ++X[--D] > S; ) (X[D] = 0), D || (++$, (X = [1].concat(X)))
                    for (g = X.length; !X[--g]; );
                    for (ee = 0, b = ''; ee <= g; b += B.charAt(X[ee++]));
                    b = w(b, $, B.charAt(0))
                  }
                  return b
                }
              })()),
              (I = (function () {
                function re(C, S, R) {
                  var P,
                    B,
                    D,
                    $,
                    g = 0,
                    N = C.length,
                    U = S % y,
                    X = (S / y) | 0
                  for (C = C.slice(); N--; )
                    (D = C[N] % y),
                      ($ = (C[N] / y) | 0),
                      (P = X * D + $ * U),
                      (B = U * D + (P % y) * y + g),
                      (g = ((B / R) | 0) + ((P / y) | 0) + X * $),
                      (C[N] = B % R)
                  return g && (C = [g].concat(C)), C
                }
                function j(C, S, R, P) {
                  var B, D
                  if (R != P) D = R > P ? 1 : -1
                  else
                    for (B = D = 0; B < R; B++)
                      if (C[B] != S[B]) {
                        D = C[B] > S[B] ? 1 : -1
                        break
                      }
                  return D
                }
                function b(C, S, R, P) {
                  for (var B = 0; R--; ) (C[R] -= B), (B = C[R] < S[R] ? 1 : 0), (C[R] = B * P + C[R] - S[R])
                  for (; !C[0] && C.length > 1; C.splice(0, 1));
                }
                return function (C, S, R, P, B) {
                  var D,
                    $,
                    g,
                    N,
                    U,
                    X,
                    ne,
                    ee,
                    ae,
                    Y,
                    z,
                    H,
                    se,
                    me,
                    we,
                    Ee,
                    Me,
                    Be = C.s == S.s ? 1 : -1,
                    je = C.c,
                    Pe = S.c
                  if (!je || !je[0] || !Pe || !Pe[0])
                    return new _e(
                      !C.s || !S.s || (je ? Pe && je[0] == Pe[0] : !Pe)
                        ? NaN
                        : (je && je[0] == 0) || !Pe
                        ? Be * 0
                        : Be / 0
                    )
                  for (
                    ee = new _e(Be),
                      ae = ee.c = [],
                      $ = C.e - S.e,
                      Be = R + $ + 1,
                      B || ((B = a), ($ = m(C.e / c) - m(S.e / c)), (Be = (Be / c) | 0)),
                      g = 0;
                    Pe[g] == (je[g] || 0);
                    g++
                  );
                  if ((Pe[g] > (je[g] || 0) && $--, Be < 0)) ae.push(1), (N = !0)
                  else {
                    for (
                      me = je.length,
                        Ee = Pe.length,
                        g = 0,
                        Be += 2,
                        U = u(B / (Pe[0] + 1)),
                        U > 1 && ((Pe = re(Pe, U, B)), (je = re(je, U, B)), (Ee = Pe.length), (me = je.length)),
                        se = Ee,
                        Y = je.slice(0, Ee),
                        z = Y.length;
                      z < Ee;
                      Y[z++] = 0
                    );
                    ;(Me = Pe.slice()), (Me = [0].concat(Me)), (we = Pe[0]), Pe[1] >= B / 2 && we++
                    do {
                      if (((U = 0), (D = j(Pe, Y, Ee, z)), D < 0)) {
                        if (((H = Y[0]), Ee != z && (H = H * B + (Y[1] || 0)), (U = u(H / we)), U > 1))
                          for (
                            U >= B && (U = B - 1), X = re(Pe, U, B), ne = X.length, z = Y.length;
                            j(X, Y, ne, z) == 1;

                          )
                            U--, b(X, Ee < ne ? Me : Pe, ne, B), (ne = X.length), (D = 1)
                        else U == 0 && (D = U = 1), (X = Pe.slice()), (ne = X.length)
                        if ((ne < z && (X = [0].concat(X)), b(Y, X, z, B), (z = Y.length), D == -1))
                          for (; j(Pe, Y, Ee, z) < 1; ) U++, b(Y, Ee < z ? Me : Pe, z, B), (z = Y.length)
                      } else D === 0 && (U++, (Y = [0]))
                      ;(ae[g++] = U), Y[0] ? (Y[z++] = je[se] || 0) : ((Y = [je[se]]), (z = 1))
                    } while ((se++ < me || Y[0] != null) && Be--)
                    ;(N = Y[0] != null), ae[0] || ae.splice(0, 1)
                  }
                  if (B == a) {
                    for (g = 1, Be = ae[0]; Be >= 10; Be /= 10, g++);
                    be(ee, R + (ee.e = g + $ * c - 1) + 1, P, N)
                  } else (ee.e = $), (ee.r = +N)
                  return ee
                }
              })())
            function Ne(re, j, b, C) {
              var S, R, P, B, D
              if ((b == null ? (b = L) : T(b, 0, 8), !re.c)) return re.toString()
              if (((S = re.c[0]), (P = re.e), j == null))
                (D = _(re.c)), (D = C == 1 || (C == 2 && (P <= K || P >= J)) ? k(D, P) : w(D, P, '0'))
              else if (
                ((re = be(new _e(re), j, b)),
                (R = re.e),
                (D = _(re.c)),
                (B = D.length),
                C == 1 || (C == 2 && (j <= R || R <= K)))
              ) {
                for (; B < j; D += '0', B++);
                D = k(D, R)
              } else if (((j -= P), (D = w(D, R, '0')), R + 1 > B)) {
                if (--j > 0) for (D += '.'; j--; D += '0');
              } else if (((j += R - B), j > 0)) for (R + 1 == B && (D += '.'); j--; D += '0');
              return re.s < 0 && S ? '-' + D : D
            }
            function ke(re, j) {
              for (var b, C = 1, S = new _e(re[0]); C < re.length; C++)
                if (((b = new _e(re[C])), b.s)) j.call(S, b) && (S = b)
                else {
                  S = b
                  break
                }
              return S
            }
            function oe(re, j, b) {
              for (var C = 1, S = j.length; !j[--S]; j.pop());
              for (S = j[0]; S >= 10; S /= 10, C++);
              return (
                (b = C + b * c - 1) > Q
                  ? (re.c = re.e = null)
                  : b < Z
                  ? (re.c = [(re.e = 0)])
                  : ((re.e = b), (re.c = j)),
                re
              )
            }
            q = (function () {
              var re = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
                j = /^([^.]+)\.$/,
                b = /^\.([^.]+)$/,
                C = /^-?(Infinity|NaN)$/,
                S = /^\s*\+(?=[\w.])|^\s+|\s+$/g
              return function (R, P, B, D) {
                var $,
                  g = B ? P : P.replace(S, '')
                if (C.test(g)) R.s = isNaN(g) ? null : g < 0 ? -1 : 1
                else {
                  if (
                    !B &&
                    ((g = g.replace(re, function (N, U, X) {
                      return ($ = (X = X.toLowerCase()) == 'x' ? 16 : X == 'b' ? 2 : 8), !D || D == $ ? U : N
                    })),
                    D && (($ = D), (g = g.replace(j, '$1').replace(b, '0.$1'))),
                    P != g)
                  )
                    return new _e(g, $)
                  if (_e.DEBUG) throw Error(o + 'Not a' + (D ? ' base ' + D : '') + ' number: ' + P)
                  R.s = null
                }
                R.c = R.e = null
              }
            })()
            function be(re, j, b, C) {
              var S,
                R,
                P,
                B,
                D,
                $,
                g,
                N = re.c,
                U = p
              if (N) {
                e: {
                  for (S = 1, B = N[0]; B >= 10; B /= 10, S++);
                  if (((R = j - S), R < 0)) (R += c), (P = j), (D = N[($ = 0)]), (g = (D / U[S - P - 1]) % 10 | 0)
                  else if ((($ = s((R + 1) / c)), $ >= N.length))
                    if (C) {
                      for (; N.length <= $; N.push(0));
                      ;(D = g = 0), (S = 1), (R %= c), (P = R - c + 1)
                    } else break e
                  else {
                    for (D = B = N[$], S = 1; B >= 10; B /= 10, S++);
                    ;(R %= c), (P = R - c + S), (g = P < 0 ? 0 : (D / U[S - P - 1]) % 10 | 0)
                  }
                  if (
                    ((C = C || j < 0 || N[$ + 1] != null || (P < 0 ? D : D % U[S - P - 1])),
                    (C =
                      b < 4
                        ? (g || C) && (b == 0 || b == (re.s < 0 ? 3 : 2))
                        : g > 5 ||
                          (g == 5 &&
                            (b == 4 ||
                              C ||
                              (b == 6 && (R > 0 ? (P > 0 ? D / U[S - P] : 0) : N[$ - 1]) % 10 & 1) ||
                              b == (re.s < 0 ? 8 : 7)))),
                    j < 1 || !N[0])
                  )
                    return (
                      (N.length = 0),
                      C ? ((j -= re.e + 1), (N[0] = U[(c - (j % c)) % c]), (re.e = -j || 0)) : (N[0] = re.e = 0),
                      re
                    )
                  if (
                    (R == 0
                      ? ((N.length = $), (B = 1), $--)
                      : ((N.length = $ + 1), (B = U[c - R]), (N[$] = P > 0 ? u((D / U[S - P]) % U[P]) * B : 0)),
                    C)
                  )
                    for (;;)
                      if ($ == 0) {
                        for (R = 1, P = N[0]; P >= 10; P /= 10, R++);
                        for (P = N[0] += B, B = 1; P >= 10; P /= 10, B++);
                        R != B && (re.e++, N[0] == a && (N[0] = 1))
                        break
                      } else {
                        if (((N[$] += B), N[$] != a)) break
                        ;(N[$--] = 0), (B = 1)
                      }
                  for (R = N.length; N[--R] === 0; N.pop());
                }
                re.e > Q ? (re.c = re.e = null) : re.e < Z && (re.c = [(re.e = 0)])
              }
              return re
            }
            function ge(re) {
              var j,
                b = re.e
              return b === null
                ? re.toString()
                : ((j = _(re.c)), (j = b <= K || b >= J ? k(j, b) : w(j, b, '0')), re.s < 0 ? '-' + j : j)
            }
            return (
              (G.absoluteValue = G.abs =
                function () {
                  var re = new _e(this)
                  return re.s < 0 && (re.s = 1), re
                }),
              (G.comparedTo = function (re, j) {
                return A(this, new _e(re, j))
              }),
              (G.decimalPlaces = G.dp =
                function (re, j) {
                  var b,
                    C,
                    S,
                    R = this
                  if (re != null) return T(re, 0, d), j == null ? (j = L) : T(j, 0, 8), be(new _e(R), re + R.e + 1, j)
                  if (!(b = R.c)) return null
                  if (((C = ((S = b.length - 1) - m(this.e / c)) * c), (S = b[S]))) for (; S % 10 == 0; S /= 10, C--);
                  return C < 0 && (C = 0), C
                }),
              (G.dividedBy = G.div =
                function (re, j) {
                  return I(this, new _e(re, j), x, L)
                }),
              (G.dividedToIntegerBy = G.idiv =
                function (re, j) {
                  return I(this, new _e(re, j), 0, 1)
                }),
              (G.exponentiatedBy = G.pow =
                function (re, j) {
                  var b,
                    C,
                    S,
                    R,
                    P,
                    B,
                    D,
                    $,
                    g,
                    N = this
                  if (((re = new _e(re)), re.c && !re.isInteger()))
                    throw Error(o + 'Exponent not an integer: ' + ge(re))
                  if (
                    (j != null && (j = new _e(j)),
                    (B = re.e > 14),
                    !N.c || !N.c[0] || (N.c[0] == 1 && !N.e && N.c.length == 1) || !re.c || !re.c[0])
                  )
                    return (g = new _e(Math.pow(+ge(N), B ? 2 - E(re) : +ge(re)))), j ? g.mod(j) : g
                  if (((D = re.s < 0), j)) {
                    if (j.c ? !j.c[0] : !j.s) return new _e(NaN)
                    ;(C = !D && N.isInteger() && j.isInteger()), C && (N = N.mod(j))
                  } else {
                    if (
                      re.e > 9 &&
                      (N.e > 0 ||
                        N.e < -1 ||
                        (N.e == 0 ? N.c[0] > 1 || (B && N.c[1] >= 24e7) : N.c[0] < 8e13 || (B && N.c[0] <= 9999975e7)))
                    )
                      return (R = N.s < 0 && E(re) ? -0 : 0), N.e > -1 && (R = 1 / R), new _e(D ? 1 / R : R)
                    W && (R = s(W / c + 2))
                  }
                  for (
                    B ? ((b = new _e(0.5)), D && (re.s = 1), ($ = E(re))) : ((S = Math.abs(+ge(re))), ($ = S % 2)),
                      g = new _e(O);
                    ;

                  ) {
                    if ($) {
                      if (((g = g.times(N)), !g.c)) break
                      R ? g.c.length > R && (g.c.length = R) : C && (g = g.mod(j))
                    }
                    if (S) {
                      if (((S = u(S / 2)), S === 0)) break
                      $ = S % 2
                    } else if (((re = re.times(b)), be(re, re.e + 1, 1), re.e > 14)) $ = E(re)
                    else {
                      if (((S = +ge(re)), S === 0)) break
                      $ = S % 2
                    }
                    ;(N = N.times(N)), R ? N.c && N.c.length > R && (N.c.length = R) : C && (N = N.mod(j))
                  }
                  return C ? g : (D && (g = O.div(g)), j ? g.mod(j) : R ? be(g, W, L, P) : g)
                }),
              (G.integerValue = function (re) {
                var j = new _e(this)
                return re == null ? (re = L) : T(re, 0, 8), be(j, j.e + 1, re)
              }),
              (G.isEqualTo = G.eq =
                function (re, j) {
                  return A(this, new _e(re, j)) === 0
                }),
              (G.isFinite = function () {
                return !!this.c
              }),
              (G.isGreaterThan = G.gt =
                function (re, j) {
                  return A(this, new _e(re, j)) > 0
                }),
              (G.isGreaterThanOrEqualTo = G.gte =
                function (re, j) {
                  return (j = A(this, new _e(re, j))) === 1 || j === 0
                }),
              (G.isInteger = function () {
                return !!this.c && m(this.e / c) > this.c.length - 2
              }),
              (G.isLessThan = G.lt =
                function (re, j) {
                  return A(this, new _e(re, j)) < 0
                }),
              (G.isLessThanOrEqualTo = G.lte =
                function (re, j) {
                  return (j = A(this, new _e(re, j))) === -1 || j === 0
                }),
              (G.isNaN = function () {
                return !this.s
              }),
              (G.isNegative = function () {
                return this.s < 0
              }),
              (G.isPositive = function () {
                return this.s > 0
              }),
              (G.isZero = function () {
                return !!this.c && this.c[0] == 0
              }),
              (G.minus = function (re, j) {
                var b,
                  C,
                  S,
                  R,
                  P = this,
                  B = P.s
                if (((re = new _e(re, j)), (j = re.s), !B || !j)) return new _e(NaN)
                if (B != j) return (re.s = -j), P.plus(re)
                var D = P.e / c,
                  $ = re.e / c,
                  g = P.c,
                  N = re.c
                if (!D || !$) {
                  if (!g || !N) return g ? ((re.s = -j), re) : new _e(N ? P : NaN)
                  if (!g[0] || !N[0]) return N[0] ? ((re.s = -j), re) : new _e(g[0] ? P : L == 3 ? -0 : 0)
                }
                if (((D = m(D)), ($ = m($)), (g = g.slice()), (B = D - $))) {
                  for ((R = B < 0) ? ((B = -B), (S = g)) : (($ = D), (S = N)), S.reverse(), j = B; j--; S.push(0));
                  S.reverse()
                } else
                  for (C = (R = (B = g.length) < (j = N.length)) ? B : j, B = j = 0; j < C; j++)
                    if (g[j] != N[j]) {
                      R = g[j] < N[j]
                      break
                    }
                if ((R && ((S = g), (g = N), (N = S), (re.s = -re.s)), (j = (C = N.length) - (b = g.length)), j > 0))
                  for (; j--; g[b++] = 0);
                for (j = a - 1; C > B; ) {
                  if (g[--C] < N[C]) {
                    for (b = C; b && !g[--b]; g[b] = j);
                    --g[b], (g[C] += a)
                  }
                  g[C] -= N[C]
                }
                for (; g[0] == 0; g.splice(0, 1), --$);
                return g[0] ? oe(re, g, $) : ((re.s = L == 3 ? -1 : 1), (re.c = [(re.e = 0)]), re)
              }),
              (G.modulo = G.mod =
                function (re, j) {
                  var b,
                    C,
                    S = this
                  return (
                    (re = new _e(re, j)),
                    !S.c || !re.s || (re.c && !re.c[0])
                      ? new _e(NaN)
                      : !re.c || (S.c && !S.c[0])
                      ? new _e(S)
                      : (ie == 9
                          ? ((C = re.s), (re.s = 1), (b = I(S, re, 0, 3)), (re.s = C), (b.s *= C))
                          : (b = I(S, re, 0, ie)),
                        (re = S.minus(b.times(re))),
                        !re.c[0] && ie == 1 && (re.s = S.s),
                        re)
                  )
                }),
              (G.multipliedBy = G.times =
                function (re, j) {
                  var b,
                    C,
                    S,
                    R,
                    P,
                    B,
                    D,
                    $,
                    g,
                    N,
                    U,
                    X,
                    ne,
                    ee,
                    ae,
                    Y = this,
                    z = Y.c,
                    H = (re = new _e(re, j)).c
                  if (!z || !H || !z[0] || !H[0])
                    return (
                      !Y.s || !re.s || (z && !z[0] && !H) || (H && !H[0] && !z)
                        ? (re.c = re.e = re.s = null)
                        : ((re.s *= Y.s), !z || !H ? (re.c = re.e = null) : ((re.c = [0]), (re.e = 0))),
                      re
                    )
                  for (
                    C = m(Y.e / c) + m(re.e / c),
                      re.s *= Y.s,
                      D = z.length,
                      N = H.length,
                      D < N && ((ne = z), (z = H), (H = ne), (S = D), (D = N), (N = S)),
                      S = D + N,
                      ne = [];
                    S--;
                    ne.push(0)
                  );
                  for (ee = a, ae = y, S = N; --S >= 0; ) {
                    for (b = 0, U = H[S] % ae, X = (H[S] / ae) | 0, P = D, R = S + P; R > S; )
                      ($ = z[--P] % ae),
                        (g = (z[P] / ae) | 0),
                        (B = X * $ + g * U),
                        ($ = U * $ + (B % ae) * ae + ne[R] + b),
                        (b = (($ / ee) | 0) + ((B / ae) | 0) + X * g),
                        (ne[R--] = $ % ee)
                    ne[R] = b
                  }
                  return b ? ++C : ne.splice(0, 1), oe(re, ne, C)
                }),
              (G.negated = function () {
                var re = new _e(this)
                return (re.s = -re.s || null), re
              }),
              (G.plus = function (re, j) {
                var b,
                  C = this,
                  S = C.s
                if (((re = new _e(re, j)), (j = re.s), !S || !j)) return new _e(NaN)
                if (S != j) return (re.s = -j), C.minus(re)
                var R = C.e / c,
                  P = re.e / c,
                  B = C.c,
                  D = re.c
                if (!R || !P) {
                  if (!B || !D) return new _e(S / 0)
                  if (!B[0] || !D[0]) return D[0] ? re : new _e(B[0] ? C : S * 0)
                }
                if (((R = m(R)), (P = m(P)), (B = B.slice()), (S = R - P))) {
                  for (S > 0 ? ((P = R), (b = D)) : ((S = -S), (b = B)), b.reverse(); S--; b.push(0));
                  b.reverse()
                }
                for (S = B.length, j = D.length, S - j < 0 && ((b = D), (D = B), (B = b), (j = S)), S = 0; j; )
                  (S = ((B[--j] = B[j] + D[j] + S) / a) | 0), (B[j] = a === B[j] ? 0 : B[j] % a)
                return S && ((B = [S].concat(B)), ++P), oe(re, B, P)
              }),
              (G.precision = G.sd =
                function (re, j) {
                  var b,
                    C,
                    S,
                    R = this
                  if (re != null && re !== !!re)
                    return T(re, 1, d), j == null ? (j = L) : T(j, 0, 8), be(new _e(R), re, j)
                  if (!(b = R.c)) return null
                  if (((S = b.length - 1), (C = S * c + 1), (S = b[S]))) {
                    for (; S % 10 == 0; S /= 10, C--);
                    for (S = b[0]; S >= 10; S /= 10, C++);
                  }
                  return re && R.e + 1 > C && (C = R.e + 1), C
                }),
              (G.shiftedBy = function (re) {
                return T(re, -f, f), this.times('1e' + re)
              }),
              (G.squareRoot = G.sqrt =
                function () {
                  var re,
                    j,
                    b,
                    C,
                    S,
                    R = this,
                    P = R.c,
                    B = R.s,
                    D = R.e,
                    $ = x + 4,
                    g = new _e('0.5')
                  if (B !== 1 || !P || !P[0]) return new _e(!B || (B < 0 && (!P || P[0])) ? NaN : P ? R : 1 / 0)
                  if (
                    ((B = Math.sqrt(+ge(R))),
                    B == 0 || B == 1 / 0
                      ? ((j = _(P)),
                        (j.length + D) % 2 == 0 && (j += '0'),
                        (B = Math.sqrt(+j)),
                        (D = m((D + 1) / 2) - (D < 0 || D % 2)),
                        B == 1 / 0
                          ? (j = '5e' + D)
                          : ((j = B.toExponential()), (j = j.slice(0, j.indexOf('e') + 1) + D)),
                        (b = new _e(j)))
                      : (b = new _e(B + '')),
                    b.c[0])
                  ) {
                    for (D = b.e, B = D + $, B < 3 && (B = 0); ; )
                      if (
                        ((S = b), (b = g.times(S.plus(I(R, S, $, 1)))), _(S.c).slice(0, B) === (j = _(b.c)).slice(0, B))
                      )
                        if ((b.e < D && --B, (j = j.slice(B - 3, B + 1)), j == '9999' || (!C && j == '4999'))) {
                          if (!C && (be(S, S.e + x + 2, 0), S.times(S).eq(R))) {
                            b = S
                            break
                          }
                          ;($ += 4), (B += 4), (C = 1)
                        } else {
                          ;(!+j || (!+j.slice(1) && j.charAt(0) == '5')) &&
                            (be(b, b.e + x + 2, 1), (re = !b.times(b).eq(R)))
                          break
                        }
                  }
                  return be(b, b.e + x + 1, L, re)
                }),
              (G.toExponential = function (re, j) {
                return re != null && (T(re, 0, d), re++), Ne(this, re, j, 1)
              }),
              (G.toFixed = function (re, j) {
                return re != null && (T(re, 0, d), (re = re + this.e + 1)), Ne(this, re, j)
              }),
              (G.toFormat = function (re, j, b) {
                var C,
                  S = this
                if (b == null)
                  re != null && j && typeof j == 'object'
                    ? ((b = j), (j = null))
                    : re && typeof re == 'object'
                    ? ((b = re), (re = j = null))
                    : (b = le)
                else if (typeof b != 'object') throw Error(o + 'Argument not an object: ' + b)
                if (((C = S.toFixed(re, j)), S.c)) {
                  var R,
                    P = C.split('.'),
                    B = +b.groupSize,
                    D = +b.secondaryGroupSize,
                    $ = b.groupSeparator || '',
                    g = P[0],
                    N = P[1],
                    U = S.s < 0,
                    X = U ? g.slice(1) : g,
                    ne = X.length
                  if ((D && ((R = B), (B = D), (D = R), (ne -= R)), B > 0 && ne > 0)) {
                    for (R = ne % B || B, g = X.substr(0, R); R < ne; R += B) g += $ + X.substr(R, B)
                    D > 0 && (g += $ + X.slice(R)), U && (g = '-' + g)
                  }
                  C = N
                    ? g +
                      (b.decimalSeparator || '') +
                      ((D = +b.fractionGroupSize)
                        ? N.replace(new RegExp('\\d{' + D + '}\\B', 'g'), '$&' + (b.fractionGroupSeparator || ''))
                        : N)
                    : g
                }
                return (b.prefix || '') + C + (b.suffix || '')
              }),
              (G.toFraction = function (re) {
                var j,
                  b,
                  C,
                  S,
                  R,
                  P,
                  B,
                  D,
                  $,
                  g,
                  N,
                  U,
                  X = this,
                  ne = X.c
                if (re != null && ((B = new _e(re)), (!B.isInteger() && (B.c || B.s !== 1)) || B.lt(O)))
                  throw Error(o + 'Argument ' + (B.isInteger() ? 'out of range: ' : 'not an integer: ') + ge(B))
                if (!ne) return new _e(X)
                for (
                  j = new _e(O),
                    $ = b = new _e(O),
                    C = D = new _e(O),
                    U = _(ne),
                    R = j.e = U.length - X.e - 1,
                    j.c[0] = p[(P = R % c) < 0 ? c + P : P],
                    re = !re || B.comparedTo(j) > 0 ? (R > 0 ? j : $) : B,
                    P = Q,
                    Q = 1 / 0,
                    B = new _e(U),
                    D.c[0] = 0;
                  (g = I(B, j, 0, 1)), (S = b.plus(g.times(C))), S.comparedTo(re) != 1;

                )
                  (b = C), (C = S), ($ = D.plus(g.times((S = $)))), (D = S), (j = B.minus(g.times((S = j)))), (B = S)
                return (
                  (S = I(re.minus(b), C, 0, 1)),
                  (D = D.plus(S.times($))),
                  (b = b.plus(S.times(C))),
                  (D.s = $.s = X.s),
                  (R = R * 2),
                  (N = I($, C, R, L).minus(X).abs().comparedTo(I(D, b, R, L).minus(X).abs()) < 1 ? [$, C] : [D, b]),
                  (Q = P),
                  N
                )
              }),
              (G.toNumber = function () {
                return +ge(this)
              }),
              (G.toPrecision = function (re, j) {
                return re != null && T(re, 1, d), Ne(this, re, j, 2)
              }),
              (G.toString = function (re) {
                var j,
                  b = this,
                  C = b.s,
                  S = b.e
                return (
                  S === null
                    ? C
                      ? ((j = 'Infinity'), C < 0 && (j = '-' + j))
                      : (j = 'NaN')
                    : (re == null
                        ? (j = S <= K || S >= J ? k(_(b.c), S) : w(_(b.c), S, '0'))
                        : re === 10
                        ? ((b = be(new _e(b), x + S + 1, L)), (j = w(_(b.c), b.e, '0')))
                        : (T(re, 2, xe.length, 'Base'), (j = M(w(_(b.c), S, '0'), 10, re, C, !0))),
                      C < 0 && b.c[0] && (j = '-' + j)),
                  j
                )
              }),
              (G.valueOf = G.toJSON =
                function () {
                  return ge(this)
                }),
              (G._isBigNumber = !0),
              v != null && _e.set(v),
              _e
            )
          }
          function m(v) {
            var I = v | 0
            return v > 0 || v === I ? I : I - 1
          }
          function _(v) {
            for (var I, M, q = 1, G = v.length, O = v[0] + ''; q < G; ) {
              for (I = v[q++] + '', M = c - I.length; M--; I = '0' + I);
              O += I
            }
            for (G = O.length; O.charCodeAt(--G) === 48; );
            return O.slice(0, G + 1 || 1)
          }
          function A(v, I) {
            var M,
              q,
              G = v.c,
              O = I.c,
              x = v.s,
              L = I.s,
              K = v.e,
              J = I.e
            if (!x || !L) return null
            if (((M = G && !G[0]), (q = O && !O[0]), M || q)) return M ? (q ? 0 : -L) : x
            if (x != L) return x
            if (((M = x < 0), (q = K == J), !G || !O)) return q ? 0 : !G ^ M ? 1 : -1
            if (!q) return (K > J) ^ M ? 1 : -1
            for (L = (K = G.length) < (J = O.length) ? K : J, x = 0; x < L; x++)
              if (G[x] != O[x]) return (G[x] > O[x]) ^ M ? 1 : -1
            return K == J ? 0 : (K > J) ^ M ? 1 : -1
          }
          function T(v, I, M, q) {
            if (v < I || v > M || v !== u(v))
              throw Error(
                o +
                  (q || 'Argument') +
                  (typeof v == 'number'
                    ? v < I || v > M
                      ? ' out of range: '
                      : ' not an integer: '
                    : ' not a primitive number: ') +
                  String(v)
              )
          }
          function E(v) {
            var I = v.c.length - 1
            return m(v.e / c) == I && v.c[I] % 2 != 0
          }
          function k(v, I) {
            return (v.length > 1 ? v.charAt(0) + '.' + v.slice(1) : v) + (I < 0 ? 'e' : 'e+') + I
          }
          function w(v, I, M) {
            var q, G
            if (I < 0) {
              for (G = M + '.'; ++I; G += M);
              v = G + v
            } else if (((q = v.length), ++I > q)) {
              for (G = M, I -= q; --I; G += M);
              v += G
            } else I < q && (v = v.slice(0, I) + '.' + v.slice(I))
            return v
          }
          ;(n = h()),
            (n.default = n.BigNumber = n),
            typeof define == 'function' && define.amd
              ? define(function () {
                  return n
                })
              : typeof r != 'undefined' && r.exports
              ? (r.exports = n)
              : (t || (t = typeof self != 'undefined' && self ? self : window), (t.BigNumber = n))
        })(e)
    }
  }),
  vq = te({
    'node_modules/@vascosantos/moving-average/index.js'(e, r) {
      V(), F()
      var t = Math.exp
      e = r.exports = function (i) {
        if (typeof i != 'number') throw new Error('must provide a timespan to the moving average constructor')
        if (i <= 0) throw new Error('must provide a timespan > 0 to the moving average constructor')
        let s,
          u = 0,
          o = 0,
          l = 0,
          a,
          c = {}
        function f(p, y) {
          return 1 - t(-(p - y) / i)
        }
        return (
          (c.push = function (y, d) {
            if (a) {
              let h = f(y, a),
                m = d - s,
                _ = h * m
              ;(s = h * d + (1 - h) * s), (u = (1 - h) * (u + m * _)), (o = Math.sqrt(u)), (l = s + h * m)
            } else s = d
            a = y
          }),
          (c.movingAverage = function () {
            return s
          }),
          (c.variance = function () {
            return u
          }),
          (c.deviation = function () {
            return o
          }),
          (c.forecast = function () {
            return l
          }),
          c
        )
      }
    }
  }),
  gq = te({
    'node_modules/libp2p/src/metrics/stats.js'(e, r) {
      V(), F()
      var { EventEmitter: t } = ln(),
        { BigNumber: n } = yq(),
        i = vq(),
        s = mT(),
        u = class extends t {
          constructor(o, l) {
            super()
            ;(this._options = l),
              (this._queue = []),
              (this._stats = { dataReceived: n(0), dataSent: n(0) }),
              (this._frequencyLastTime = Date.now()),
              (this._frequencyAccumulators = {}),
              (this._movingAverages = {}),
              (this._update = this._update.bind(this))
            let a = this._options.movingAverageIntervals
            for (let c = 0; c < o.length; c++) {
              let f = o[c]
              ;(this._stats[f] = n(0)), (this._movingAverages[f] = {})
              for (let p = 0; p < a.length; p++) {
                let y = a[p]
                ;(this._movingAverages[f][y] = i(y)).push(this._frequencyLastTime, 0)
              }
            }
          }
          start() {
            this._queue.length && this._resetComputeTimeout()
          }
          stop() {
            this._timeout && (this._timeout.clear(), (this._timeout = null))
          }
          get snapshot() {
            return Object.assign({}, this._stats)
          }
          get movingAverages() {
            return Object.assign({}, this._movingAverages)
          }
          toJSON() {
            let o = this.snapshot,
              l = this.movingAverages,
              a = { dataReceived: o.dataReceived.toString(), dataSent: o.dataSent.toString(), movingAverages: {} },
              c = Object.keys(l)
            for (let f of c) {
              a.movingAverages[f] = {}
              for (let p of Object.keys(l[f])) a.movingAverages[f][p] = l[f][p].movingAverage()
            }
            return a
          }
          push(o, l) {
            this._queue.push([o, l, Date.now()]), this._resetComputeTimeout()
          }
          _resetComputeTimeout() {
            this._timeout = s(this._update, this._nextTimeout())
          }
          _nextTimeout() {
            let o = this._queue.length / this._options.computeThrottleMaxQueueSize
            return Math.max(this._options.computeThrottleTimeout * (1 - o), 0)
          }
          _update() {
            if (((this._timeout = null), this._queue.length)) {
              let o
              for (o of this._queue) this._applyOp(o)
              ;(this._queue = []), this._updateFrequency(o[2]), this.emit('update', this._stats)
            }
          }
          _updateFrequency(o) {
            let l = o - this._frequencyLastTime
            Object.keys(this._stats).forEach((a) => {
              this._updateFrequencyFor(a, l, o)
            }),
              (this._frequencyLastTime = o)
          }
          _updateFrequencyFor(o, l, a) {
            let c = this._frequencyAccumulators[o] || 0
            this._frequencyAccumulators[o] = 0
            let p = (c / (l || 1)) * 1e3,
              y = this._movingAverages[o]
            y || (y = this._movingAverages[o] = {})
            let d = this._options.movingAverageIntervals
            for (let h = 0; h < d.length; h++) {
              let m = d[h],
                _ = y[m]
              _ || (_ = y[m] = i(m)), _.push(a, p)
            }
          }
          _applyOp(o) {
            let l = o[0],
              a = o[1]
            if (typeof a != 'number') throw new Error(`invalid increment number: ${a}`)
            let c
            Object.prototype.hasOwnProperty.call(this._stats, l) ? (c = this._stats[l]) : (c = this._stats[l] = n(0)),
              (this._stats[l] = c.plus(a)),
              this._frequencyAccumulators[l] || (this._frequencyAccumulators[l] = 0),
              (this._frequencyAccumulators[l] += a)
          }
        }
      r.exports = u
    }
  }),
  wq = te({
    'node_modules/libp2p/src/metrics/index.js'(e, r) {
      V(), F()
      var t = gf(),
        { pipe: n } = wn(),
        { tap: i } = _2(),
        s = bq(),
        { METRICS: u } = h2(),
        o = gq(),
        l = ['dataReceived', 'dataSent'],
        a = { in: 'dataReceived', out: 'dataSent' },
        c = class {
          constructor(f) {
            ;(this._options = t(u, f)),
              (this._globalStats = new o(l, this._options)),
              (this._peerStats = new Map()),
              (this._protocolStats = new Map()),
              (this._oldPeers = s(this._options.maxOldPeersRetention)),
              (this._running = !1),
              (this._onMessage = this._onMessage.bind(this)),
              (this._connectionManager = f.connectionManager),
              this._connectionManager.on('peer:disconnect', (p) => {
                this.onPeerDisconnected(p.remotePeer)
              })
          }
          start() {
            this._running = !0
          }
          stop() {
            ;(this._running = !1), this._globalStats.stop()
            for (let f of this._peerStats.values()) f.stop()
            for (let f of this._protocolStats.values()) f.stop()
          }
          get global() {
            return this._globalStats
          }
          get peers() {
            return Array.from(this._peerStats.keys())
          }
          forPeer(f) {
            let p = f.toB58String()
            return this._peerStats.get(p) || this._oldPeers.get(p)
          }
          get protocols() {
            return Array.from(this._protocolStats.keys())
          }
          forProtocol(f) {
            return this._protocolStats.get(f)
          }
          onPeerDisconnected(f) {
            let p = f.toB58String(),
              y = this._peerStats.get(p)
            y && (y.stop(), this._peerStats.delete(p), this._oldPeers.set(p, y))
          }
          _onMessage({ remotePeer: f, protocol: p, direction: y, dataLength: d }) {
            if (!this._running) return
            let h = a[y],
              m = this.forPeer(f)
            if (
              (m || ((m = new o(l, this._options)), this._peerStats.set(f.toB58String(), m)),
              m.push(h, d),
              this._globalStats.push(h, d),
              p)
            ) {
              let _ = this.forProtocol(p)
              _ || ((_ = new o(l, this._options)), this._protocolStats.set(p, _)), _.push(h, d)
            }
          }
          updatePlaceholder(f, p) {
            if (!this._running) return
            let y = this.forPeer(f),
              d = p.toB58String(),
              h = this.forPeer(p),
              m = y
            h && ((m = c.mergeStats(h, m)), this._oldPeers.delete(d)),
              this._peerStats.delete(f.toB58String()),
              this._peerStats.set(d, m),
              m.start()
          }
          trackStream({ stream: f, remotePeer: p, protocol: y }) {
            let d = this,
              h = f.source
            f.source = i((_) => d._onMessage({ remotePeer: p, protocol: y, direction: 'in', dataLength: _.length }))(h)
            let m = f.sink
            return (
              (f.sink = (_) =>
                n(
                  _,
                  i((A) => d._onMessage({ remotePeer: p, protocol: y, direction: 'out', dataLength: A.length })),
                  m
                )),
              f
            )
          }
          static mergeStats(f, p) {
            return f.stop(), p.stop(), (f._queue = [...f._queue, ...p._queue]), f
          }
        }
      r.exports = c
    }
  }),
  E2 = te({
    'node_modules/multistream-select/src/multistream.js'(e) {
      V(), F()
      var r = ui(),
        t = Zc(),
        n = wn(),
        i = pt(),
        { fromString: s } = (gn(), un),
        u = sT(),
        o = s(`
`)
      ;(e.encode = (l) => t.encode.single(new r([l, o]))),
        (e.write = (l, a) => l.push(e.encode(a))),
        (e.writeAll = (l, a) => {
          l.push(a.reduce((c, f) => c.append(e.encode(f)), new r()))
        }),
        (e.read = async (l) => {
          let a = 1,
            c = {
              [Symbol.asyncIterator]() {
                return this
              },
              next: () => l.next(a)
            },
            f = (y) => {
              a = y
            },
            p = await n(c, t.decode({ onLength: f }), u)
          if (p.get(p.length - 1) !== o[0])
            throw i(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE')
          return p.shallowSlice(0, -1)
        })
    }
  }),
  _q = te({
    'node_modules/multistream-select/src/select.js'(e, r) {
      V(), F()
      var t = mt()('mss:select'),
        n = pt(),
        i = E2(),
        s = Yc()
      r.exports = async (u, o, l) => {
        o = Array.isArray(o) ? [...o] : [o]
        let { reader: a, writer: c, rest: f, stream: p } = s(u),
          y = o.shift()
        l ? (t('select: write ["%s", "%s"]', l, y), i.writeAll(c, [l, y])) : (t('select: write "%s"', y), i.write(c, y))
        let d = (await i.read(a)).toString()
        if (
          (t('select: read "%s"', d),
          d === l && ((d = (await i.read(a)).toString()), t('select: read "%s"', d)),
          d === y)
        )
          return f(), { stream: p, protocol: y }
        for (let h of o) {
          t('select: write "%s"', h), i.write(c, h)
          let m = (await i.read(a)).toString()
          if ((t('select: read "%s" for "%s"', m, h), m === h)) return f(), { stream: p, protocol: h }
        }
        throw (f(), n(new Error('protocol selection failed'), 'ERR_UNSUPPORTED_PROTOCOL'))
      }
    }
  }),
  NT = te({
    'node_modules/multistream-select/src/constants.js'(e) {
      V(), F(), (e.PROTOCOL_ID = '/multistream/1.0.0')
    }
  }),
  Eq = te({
    'node_modules/multistream-select/src/handle.js'(e, r) {
      V(), F()
      var t = mt()('mss:handle'),
        n = ui(),
        i = E2(),
        s = Yc(),
        { PROTOCOL_ID: u } = NT()
      r.exports = async (o, l) => {
        l = Array.isArray(l) ? l : [l]
        let { writer: a, reader: c, rest: f, stream: p } = s(o)
        for (;;) {
          let y = (await i.read(c)).toString()
          if ((t('read "%s"', y), y === u)) {
            t('respond with "%s" for "%s"', u, y), i.write(a, u)
            continue
          }
          if (l.includes(y))
            return i.write(a, y), t('respond with "%s" for "%s"', y, y), f(), { stream: p, protocol: y }
          if (y === 'ls') {
            i.write(a, new n(l.map((d) => i.encode(d)))), t('respond with "%s" for %s', l, y)
            continue
          }
          i.write(a, 'na'), t('respond with "na" for "%s"', y)
        }
      }
    }
  }),
  Sq = te({
    'node_modules/multistream-select/src/ls.js'(e, r) {
      V(), F()
      var t = iA(),
        n = mt()('it-multistream-select:ls'),
        i = E2(),
        s = Yc(),
        u = Zc(),
        o = wn()
      r.exports = async (l) => {
        let { reader: a, writer: c, rest: f, stream: p } = s(l)
        n('write "ls"'), i.write(c, 'ls'), f()
        let y = await i.read(a),
          d = t([y]),
          h = []
        return (
          await o(d, u.decode(), async (m) => {
            for await (let _ of m) h.push(_.shallowSlice(0, -1).toString())
          }),
          { stream: p, protocols: h }
        )
      }
    }
  }),
  Aq = te({
    'node_modules/multistream-select/src/index.js'(e) {
      V(), F()
      var r = _q(),
        t = Eq(),
        n = Sq(),
        { PROTOCOL_ID: i } = NT()
      e.PROTOCOL_ID = i
      var s = class {
          constructor(l) {
            ;(this._stream = l), (this._shaken = !1)
          }
          async _handshake() {
            if (this._shaken) return
            let { stream: l } = await r(this._stream, i)
            ;(this._stream = l), (this._shaken = !0)
          }
        },
        u = class extends s {
          select(l) {
            return r(this._stream, l, this._shaken ? null : i)
          }
          async ls() {
            await this._handshake()
            let { stream: l, protocols: a } = await n(this._stream)
            return (this._stream = l), a
          }
        }
      e.Dialer = u
      var o = class extends s {
        handle(l) {
          return t(this._stream, l)
        }
      }
      e.Listener = o
    }
  })
function Iq(e, r) {
  if (e.length >= 255) throw new TypeError('Alphabet too long')
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++) t[n] = 255
  for (var i = 0; i < e.length; i++) {
    var s = e.charAt(i),
      u = s.charCodeAt(0)
    if (t[u] !== 255) throw new TypeError(s + ' is ambiguous')
    t[u] = i
  }
  var o = e.length,
    l = e.charAt(0),
    a = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o)
  function f(d) {
    if (
      (d instanceof Uint8Array ||
        (ArrayBuffer.isView(d)
          ? (d = new Uint8Array(d.buffer, d.byteOffset, d.byteLength))
          : Array.isArray(d) && (d = Uint8Array.from(d))),
      !(d instanceof Uint8Array))
    )
      throw new TypeError('Expected Uint8Array')
    if (d.length === 0) return ''
    for (var h = 0, m = 0, _ = 0, A = d.length; _ !== A && d[_] === 0; ) _++, h++
    for (var T = ((A - _) * c + 1) >>> 0, E = new Uint8Array(T); _ !== A; ) {
      for (var k = d[_], w = 0, v = T - 1; (k !== 0 || w < m) && v !== -1; v--, w++)
        (k += (256 * E[v]) >>> 0), (E[v] = k % o >>> 0), (k = (k / o) >>> 0)
      if (k !== 0) throw new Error('Non-zero carry')
      ;(m = w), _++
    }
    for (var I = T - m; I !== T && E[I] === 0; ) I++
    for (var M = l.repeat(h); I < T; ++I) M += e.charAt(E[I])
    return M
  }
  function p(d) {
    if (typeof d != 'string') throw new TypeError('Expected String')
    if (d.length === 0) return new Uint8Array()
    var h = 0
    if (d[h] !== ' ') {
      for (var m = 0, _ = 0; d[h] === l; ) m++, h++
      for (var A = ((d.length - h) * a + 1) >>> 0, T = new Uint8Array(A); d[h]; ) {
        var E = t[d.charCodeAt(h)]
        if (E === 255) return
        for (var k = 0, w = A - 1; (E !== 0 || k < _) && w !== -1; w--, k++)
          (E += (o * T[w]) >>> 0), (T[w] = E % 256 >>> 0), (E = (E / 256) >>> 0)
        if (E !== 0) throw new Error('Non-zero carry')
        ;(_ = k), h++
      }
      if (d[h] !== ' ') {
        for (var v = A - _; v !== A && T[v] === 0; ) v++
        for (var I = new Uint8Array(m + (A - v)), M = m; v !== A; ) I[M++] = T[v++]
        return I
      }
    }
  }
  function y(d) {
    var h = p(d)
    if (h) return h
    throw new Error(`Non-${r} character`)
  }
  return { encode: f, decodeUnsafe: p, decode: y }
}
var PT,
  OT,
  DT,
  Tq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/vendor/base-x.js'() {
      V(), F(), (PT = Iq), (OT = PT), (DT = OT)
    }
  }),
  LT = {}
Re(LT, {
  coerce: () => Rs,
  empty: () => S2,
  equals: () => A2,
  fromHex: () => qT,
  fromString: () => I2,
  isBinary: () => jT,
  toHex: () => UT,
  toString: () => T2
})
var S2,
  UT,
  qT,
  A2,
  Rs,
  jT,
  I2,
  T2,
  Bs = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bytes.js'() {
      V(),
        F(),
        (S2 = new Uint8Array(0)),
        (UT = (e) => e.reduce((r, t) => r + t.toString(16).padStart(2, '0'), '')),
        (qT = (e) => {
          let r = e.match(/../g)
          return r ? new Uint8Array(r.map((t) => parseInt(t, 16))) : S2
        }),
        (A2 = (e, r) => {
          if (e === r) return !0
          if (e.byteLength !== r.byteLength) return !1
          for (let t = 0; t < e.byteLength; t++) if (e[t] !== r[t]) return !1
          return !0
        }),
        (Rs = (e) => {
          if (e instanceof Uint8Array && e.constructor.name === 'Uint8Array') return e
          if (e instanceof ArrayBuffer) return new Uint8Array(e)
          if (ArrayBuffer.isView(e)) return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
          throw new Error('Unknown type, must be binary type')
        }),
        (jT = (e) => e instanceof ArrayBuffer || ArrayBuffer.isView(e)),
        (I2 = (e) => new TextEncoder().encode(e)),
        (T2 = (e) => new TextDecoder().decode(e))
    }
  }),
  zT,
  KT,
  C2,
  FT,
  Ef,
  ea,
  VT,
  HT,
  br,
  fi = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base.js'() {
      V(),
        F(),
        Tq(),
        Bs(),
        (zT = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseEncode = t)
          }
          encode(e) {
            if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`
            throw Error('Unknown type, must be binary type')
          }
        }),
        (KT = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.prefix = r), (this.baseDecode = t)
          }
          decode(e) {
            if (typeof e == 'string')
              switch (e[0]) {
                case this.prefix:
                  return this.baseDecode(e.slice(1))
                default:
                  throw Error(
                    `Unable to decode multibase string ${JSON.stringify(e)}, ${
                      this.name
                    } decoder only supports inputs prefixed with ${this.prefix}`
                  )
              }
            else throw Error('Can only multibase decode strings')
          }
          or(e) {
            let r = { [this.prefix]: this, ...(e.decoders || { [e.prefix]: e }) }
            return new C2(r)
          }
        }),
        (C2 = class {
          constructor(e) {
            this.decoders = e
          }
          or(e) {
            let r = e.decoders || { [e.prefix]: e }
            return new C2({ ...this.decoders, ...r })
          }
          decode(e) {
            let r = e[0],
              t = this.decoders[r]
            if (t) return t.decode(e)
            throw RangeError(
              `Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(
                this.decoders
              )} are supported`
            )
          }
        }),
        (FT = class {
          constructor(e, r, t, n) {
            ;(this.name = e),
              (this.prefix = r),
              (this.baseEncode = t),
              (this.baseDecode = n),
              (this.encoder = new zT(e, r, t)),
              (this.decoder = new KT(e, r, n))
          }
          encode(e) {
            return this.encoder.encode(e)
          }
          decode(e) {
            return this.decoder.decode(e)
          }
        }),
        (Ef = ({ name: e, prefix: r, encode: t, decode: n }) => new FT(e, r, t, n)),
        (ea = ({ prefix: e, name: r, alphabet: t }) => {
          let { encode: n, decode: i } = DT(t, r)
          return Ef({ prefix: e, name: r, encode: n, decode: (s) => Rs(i(s)) })
        }),
        (VT = (e, r, t, n) => {
          let i = {}
          for (let c = 0; c < r.length; ++c) i[r[c]] = c
          let s = e.length
          for (; e[s - 1] === '='; ) --s
          let u = new Uint8Array(((s * t) / 8) | 0),
            o = 0,
            l = 0,
            a = 0
          for (let c = 0; c < s; ++c) {
            let f = i[e[c]]
            if (f === void 0) throw new SyntaxError(`Non-${n} character`)
            ;(l = (l << t) | f), (o += t), o >= 8 && ((o -= 8), (u[a++] = 255 & (l >> o)))
          }
          if (o >= t || 255 & (l << (8 - o))) throw new SyntaxError('Unexpected end of data')
          return u
        }),
        (HT = (e, r, t) => {
          let n = r[r.length - 1] === '=',
            i = (1 << t) - 1,
            s = '',
            u = 0,
            o = 0
          for (let l = 0; l < e.length; ++l) for (o = (o << 8) | e[l], u += 8; u > t; ) (u -= t), (s += r[i & (o >> u)])
          if ((u && (s += r[i & (o << (t - u))]), n)) for (; (s.length * t) & 7; ) s += '='
          return s
        }),
        (br = ({ name: e, prefix: r, bitsPerChar: t, alphabet: n }) =>
          Ef({
            prefix: r,
            name: e,
            encode(i) {
              return HT(i, n, t)
            },
            decode(i) {
              return VT(i, n, t, e)
            }
          }))
    }
  }),
  $T = {}
Re($T, { identity: () => GT })
var GT,
  Cq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/identity.js'() {
      V(), F(), fi(), Bs(), (GT = Ef({ prefix: '\0', name: 'identity', encode: (e) => T2(e), decode: (e) => I2(e) }))
    }
  }),
  WT = {}
Re(WT, { base2: () => JT })
var JT,
  kq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base2.js'() {
      V(), F(), fi(), (JT = br({ prefix: '0', name: 'base2', alphabet: '01', bitsPerChar: 1 }))
    }
  }),
  XT = {}
Re(XT, { base8: () => YT })
var YT,
  Mq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base8.js'() {
      V(), F(), fi(), (YT = br({ prefix: '7', name: 'base8', alphabet: '01234567', bitsPerChar: 3 }))
    }
  }),
  ZT = {}
Re(ZT, { base10: () => QT })
var QT,
  xq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base10.js'() {
      V(), F(), fi(), (QT = ea({ prefix: '9', name: 'base10', alphabet: '0123456789' }))
    }
  }),
  eC = {}
Re(eC, { base16: () => tC, base16upper: () => rC })
var tC,
  rC,
  Rq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base16.js'() {
      V(),
        F(),
        fi(),
        (tC = br({ prefix: 'f', name: 'base16', alphabet: '0123456789abcdef', bitsPerChar: 4 })),
        (rC = br({ prefix: 'F', name: 'base16upper', alphabet: '0123456789ABCDEF', bitsPerChar: 4 }))
    }
  }),
  nC = {}
Re(nC, {
  base32: () => ta,
  base32hex: () => aC,
  base32hexpad: () => uC,
  base32hexpadupper: () => lC,
  base32hexupper: () => cC,
  base32pad: () => sC,
  base32padupper: () => oC,
  base32upper: () => iC,
  base32z: () => fC
})
var ta,
  iC,
  sC,
  oC,
  aC,
  cC,
  uC,
  lC,
  fC,
  dC = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base32.js'() {
      V(),
        F(),
        fi(),
        (ta = br({ prefix: 'b', name: 'base32', alphabet: 'abcdefghijklmnopqrstuvwxyz234567', bitsPerChar: 5 })),
        (iC = br({ prefix: 'B', name: 'base32upper', alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567', bitsPerChar: 5 })),
        (sC = br({ prefix: 'c', name: 'base32pad', alphabet: 'abcdefghijklmnopqrstuvwxyz234567=', bitsPerChar: 5 })),
        (oC = br({
          prefix: 'C',
          name: 'base32padupper',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
          bitsPerChar: 5
        })),
        (aC = br({ prefix: 'v', name: 'base32hex', alphabet: '0123456789abcdefghijklmnopqrstuv', bitsPerChar: 5 })),
        (cC = br({
          prefix: 'V',
          name: 'base32hexupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
          bitsPerChar: 5
        })),
        (uC = br({ prefix: 't', name: 'base32hexpad', alphabet: '0123456789abcdefghijklmnopqrstuv=', bitsPerChar: 5 })),
        (lC = br({
          prefix: 'T',
          name: 'base32hexpadupper',
          alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
          bitsPerChar: 5
        })),
        (fC = br({ prefix: 'h', name: 'base32z', alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769', bitsPerChar: 5 }))
    }
  }),
  hC = {}
Re(hC, { base36: () => pC, base36upper: () => mC })
var pC,
  mC,
  Bq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base36.js'() {
      V(),
        F(),
        fi(),
        (pC = ea({ prefix: 'k', name: 'base36', alphabet: '0123456789abcdefghijklmnopqrstuvwxyz' })),
        (mC = ea({ prefix: 'K', name: 'base36upper', alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' }))
    }
  }),
  bC = {}
Re(bC, { base58btc: () => Kn, base58flickr: () => yC })
var Kn,
  yC,
  vC = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base58.js'() {
      V(),
        F(),
        fi(),
        (Kn = ea({
          name: 'base58btc',
          prefix: 'z',
          alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
        })),
        (yC = ea({
          name: 'base58flickr',
          prefix: 'Z',
          alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
        }))
    }
  }),
  gC = {}
Re(gC, { base64: () => wC, base64pad: () => _C, base64url: () => EC, base64urlpad: () => SC })
var wC,
  _C,
  EC,
  SC,
  Nq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/bases/base64.js'() {
      V(),
        F(),
        fi(),
        (wC = br({
          prefix: 'm',
          name: 'base64',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
          bitsPerChar: 6
        })),
        (_C = br({
          prefix: 'M',
          name: 'base64pad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
          bitsPerChar: 6
        })),
        (EC = br({
          prefix: 'u',
          name: 'base64url',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
          bitsPerChar: 6
        })),
        (SC = br({
          prefix: 'U',
          name: 'base64urlpad',
          alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
          bitsPerChar: 6
        }))
    }
  })
function AC(e, r, t) {
  ;(r = r || []), (t = t || 0)
  for (var n = t; e >= kC; ) (r[t++] = (e & 255) | M2), (e /= 128)
  for (; e & CC; ) (r[t++] = (e & 255) | M2), (e >>>= 7)
  return (r[t] = e | 0), (AC.bytes = t - n + 1), r
}
function k2(e, r) {
  var t = 0,
    r = r || 0,
    n = 0,
    i = r,
    s,
    u = e.length
  do {
    if (i >= u) throw ((k2.bytes = 0), new RangeError('Could not decode varint'))
    ;(s = e[i++]), (t += n < 28 ? (s & x2) << n : (s & x2) * Math.pow(2, n)), (n += 7)
  } while (s >= xC)
  return (k2.bytes = i - r), t
}
var IC,
  M2,
  TC,
  CC,
  kC,
  MC,
  xC,
  x2,
  RC,
  BC,
  NC,
  PC,
  OC,
  DC,
  LC,
  UC,
  qC,
  jC,
  zC,
  KC,
  au,
  Pq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/vendor/varint.js'() {
      V(),
        F(),
        (IC = AC),
        (M2 = 128),
        (TC = 127),
        (CC = ~TC),
        (kC = Math.pow(2, 31)),
        (MC = k2),
        (xC = 128),
        (x2 = 127),
        (RC = Math.pow(2, 7)),
        (BC = Math.pow(2, 14)),
        (NC = Math.pow(2, 21)),
        (PC = Math.pow(2, 28)),
        (OC = Math.pow(2, 35)),
        (DC = Math.pow(2, 42)),
        (LC = Math.pow(2, 49)),
        (UC = Math.pow(2, 56)),
        (qC = Math.pow(2, 63)),
        (jC = function (e) {
          return e < RC
            ? 1
            : e < BC
            ? 2
            : e < NC
            ? 3
            : e < PC
            ? 4
            : e < OC
            ? 5
            : e < DC
            ? 6
            : e < LC
            ? 7
            : e < UC
            ? 8
            : e < qC
            ? 9
            : 10
        }),
        (zC = { encode: IC, decode: MC, encodingLength: jC }),
        (KC = zC),
        (au = KC)
    }
  }),
  FC = {}
Re(FC, { decode: () => cu, encodeTo: () => ra, encodingLength: () => na })
var cu,
  ra,
  na,
  R2 = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/varint.js'() {
      V(),
        F(),
        Pq(),
        (cu = (e) => [au.decode(e), au.decode.bytes]),
        (ra = (e, r, t = 0) => (au.encode(e, r, t), r)),
        (na = (e) => au.encodingLength(e))
    }
  }),
  VC = {}
Re(VC, { Digest: () => uu, create: () => Sf, decode: () => B2, equals: () => N2 })
var Sf,
  B2,
  N2,
  uu,
  P2 = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/hashes/digest.js'() {
      V(),
        F(),
        Bs(),
        R2(),
        (Sf = (e, r) => {
          let t = r.byteLength,
            n = na(e),
            i = n + na(t),
            s = new Uint8Array(i + t)
          return ra(e, s, 0), ra(t, s, n), s.set(r, i), new uu(e, t, r, s)
        }),
        (B2 = (e) => {
          let r = Rs(e),
            [t, n] = cu(r),
            [i, s] = cu(r.subarray(n)),
            u = r.subarray(n + s)
          if (u.byteLength !== i) throw new Error('Incorrect length')
          return new uu(t, i, u, r)
        }),
        (N2 = (e, r) => (e === r ? !0 : e.code === r.code && e.size === r.size && A2(e.bytes, r.bytes))),
        (uu = class {
          constructor(e, r, t, n) {
            ;(this.code = e), (this.size = r), (this.digest = t), (this.bytes = n)
          }
        })
    }
  }),
  HC = {}
Re(HC, { Hasher: () => O2, from: () => lu })
var lu,
  O2,
  D2 = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/hashes/hasher.js'() {
      V(),
        F(),
        P2(),
        (lu = ({ name: e, code: r, encode: t }) => new O2(e, r, t)),
        (O2 = class {
          constructor(e, r, t) {
            ;(this.name = e), (this.code = r), (this.encode = t)
          }
          async digest(e) {
            if (e instanceof Uint8Array) {
              let r = await this.encode(e)
              return Sf(this.code, r)
            } else throw Error('Unknown type, must be binary type')
          }
        })
    }
  }),
  $C = {}
Re($C, { sha256: () => GC, sha512: () => WC })
var L2,
  GC,
  WC,
  Oq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/hashes/sha2-browser.js'() {
      V(),
        F(),
        D2(),
        (L2 = (e) => async (r) => new Uint8Array(await crypto.subtle.digest(e, r))),
        (GC = lu({ name: 'sha2-256', code: 18, encode: L2('SHA-256') })),
        (WC = lu({ name: 'sha2-512', code: 19, encode: L2('SHA-512') }))
    }
  }),
  JC = {}
Re(JC, { identity: () => XC })
var XC,
  Dq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/hashes/identity.js'() {
      V(), F(), D2(), Bs(), (XC = lu({ name: 'identity', code: 0, encode: (e) => Rs(e) }))
    }
  }),
  YC = {}
Re(YC, { code: () => QC, decode: () => tk, encode: () => ek, name: () => ZC })
var U2,
  ZC,
  QC,
  ek,
  tk,
  Lq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/codecs/raw.js'() {
      V(),
        F(),
        Bs(),
        (U2 = (e) => Rs(e)),
        ({ name: ZC, code: QC, encode: ek, decode: tk } = { name: 'raw', code: 85, decode: U2, encode: U2 })
    }
  }),
  rk = {}
Re(rk, { code: () => ik, decode: () => ok, encode: () => sk, name: () => nk })
var nk,
  ik,
  sk,
  ok,
  Uq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/codecs/json.js'() {
      V(),
        F(),
        ({
          name: nk,
          code: ik,
          encode: sk,
          decode: ok
        } = {
          name: 'json',
          code: 512,
          encode: (e) => new TextEncoder().encode(JSON.stringify(e)),
          decode: (e) => JSON.parse(new TextDecoder().decode(e))
        })
    }
  }),
  Or,
  ak,
  ck,
  uk,
  ia,
  lk,
  q2,
  j2,
  fu,
  du,
  fk,
  dk,
  hk,
  qq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/cid.js'() {
      V(),
        F(),
        R2(),
        P2(),
        vC(),
        dC(),
        Bs(),
        (Or = class {
          constructor(e, r, t, n) {
            ;(this.code = r),
              (this.version = e),
              (this.multihash = t),
              (this.bytes = n),
              (this.byteOffset = n.byteOffset),
              (this.byteLength = n.byteLength),
              (this.asCID = this),
              (this._baseCache = new Map()),
              Object.defineProperties(this, {
                byteOffset: du,
                byteLength: du,
                code: fu,
                version: fu,
                multihash: fu,
                bytes: fu,
                _baseCache: du,
                asCID: du
              })
          }
          toV0() {
            switch (this.version) {
              case 0:
                return this
              default: {
                let { code: e, multihash: r } = this
                if (e !== ia) throw new Error('Cannot convert a non dag-pb CID to CIDv0')
                if (r.code !== lk) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')
                return Or.createV0(r)
              }
            }
          }
          toV1() {
            switch (this.version) {
              case 0: {
                let { code: e, digest: r } = this.multihash,
                  t = Sf(e, r)
                return Or.createV1(this.code, t)
              }
              case 1:
                return this
              default:
                throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)
            }
          }
          equals(e) {
            return e && this.code === e.code && this.version === e.version && N2(this.multihash, e.multihash)
          }
          toString(e) {
            let { bytes: r, version: t, _baseCache: n } = this
            switch (t) {
              case 0:
                return ck(r, n, e || Kn.encoder)
              default:
                return uk(r, n, e || ta.encoder)
            }
          }
          toJSON() {
            return { code: this.code, version: this.version, hash: this.multihash.bytes }
          }
          get [Symbol.toStringTag]() {
            return 'CID'
          }
          [Symbol.for('nodejs.util.inspect.custom')]() {
            return 'CID(' + this.toString() + ')'
          }
          static isCID(e) {
            return dk(/^0\.0/, hk), !!(e && (e[j2] || e.asCID === e))
          }
          get toBaseEncodedString() {
            throw new Error('Deprecated, use .toString()')
          }
          get codec() {
            throw new Error('"codec" property is deprecated, use integer "code" property instead')
          }
          get buffer() {
            throw new Error('Deprecated .buffer property, use .bytes to get Uint8Array instead')
          }
          get multibaseName() {
            throw new Error('"multibaseName" property is deprecated')
          }
          get prefix() {
            throw new Error('"prefix" property is deprecated')
          }
          static asCID(e) {
            if (e instanceof Or) return e
            if (e != null && e.asCID === e) {
              let { version: r, code: t, multihash: n, bytes: i } = e
              return new Or(r, t, n, i || q2(r, t, n.bytes))
            } else if (e != null && e[j2] === !0) {
              let { version: r, multihash: t, code: n } = e,
                i = B2(t)
              return Or.create(r, n, i)
            } else return null
          }
          static create(e, r, t) {
            if (typeof r != 'number') throw new Error('String codecs are no longer supported')
            switch (e) {
              case 0: {
                if (r !== ia) throw new Error(`Version 0 CID must use dag-pb (code: ${ia}) block encoding`)
                return new Or(e, r, t, t.bytes)
              }
              case 1: {
                let n = q2(e, r, t.bytes)
                return new Or(e, r, t, n)
              }
              default:
                throw new Error('Invalid version')
            }
          }
          static createV0(e) {
            return Or.create(0, ia, e)
          }
          static createV1(e, r) {
            return Or.create(1, e, r)
          }
          static decode(e) {
            let [r, t] = Or.decodeFirst(e)
            if (t.length) throw new Error('Incorrect length')
            return r
          }
          static decodeFirst(e) {
            let r = Or.inspectBytes(e),
              t = r.size - r.multihashSize,
              n = Rs(e.subarray(t, t + r.multihashSize))
            if (n.byteLength !== r.multihashSize) throw new Error('Incorrect length')
            let i = n.subarray(r.multihashSize - r.digestSize),
              s = new uu(r.multihashCode, r.digestSize, i, n)
            return [r.version === 0 ? Or.createV0(s) : Or.createV1(r.codec, s), e.subarray(r.size)]
          }
          static inspectBytes(e) {
            let r = 0,
              t = () => {
                let [c, f] = cu(e.subarray(r))
                return (r += f), c
              },
              n = t(),
              i = ia
            if ((n === 18 ? ((n = 0), (r = 0)) : n === 1 && (i = t()), n !== 0 && n !== 1))
              throw new RangeError(`Invalid CID version ${n}`)
            let s = r,
              u = t(),
              o = t(),
              l = r + o,
              a = l - s
            return { version: n, codec: i, multihashCode: u, digestSize: o, multihashSize: a, size: l }
          }
          static parse(e, r) {
            let [t, n] = ak(e, r),
              i = Or.decode(n)
            return i._baseCache.set(t, e), i
          }
        }),
        (ak = (e, r) => {
          switch (e[0]) {
            case 'Q': {
              let t = r || Kn
              return [Kn.prefix, t.decode(`${Kn.prefix}${e}`)]
            }
            case Kn.prefix: {
              let t = r || Kn
              return [Kn.prefix, t.decode(e)]
            }
            case ta.prefix: {
              let t = r || ta
              return [ta.prefix, t.decode(e)]
            }
            default: {
              if (r == null)
                throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided')
              return [e[0], r.decode(e)]
            }
          }
        }),
        (ck = (e, r, t) => {
          let { prefix: n } = t
          if (n !== Kn.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`)
          let i = r.get(n)
          if (i == null) {
            let s = t.encode(e).slice(1)
            return r.set(n, s), s
          } else return i
        }),
        (uk = (e, r, t) => {
          let { prefix: n } = t,
            i = r.get(n)
          if (i == null) {
            let s = t.encode(e)
            return r.set(n, s), s
          } else return i
        }),
        (ia = 112),
        (lk = 18),
        (q2 = (e, r, t) => {
          let n = na(e),
            i = n + na(r),
            s = new Uint8Array(i + t.byteLength)
          return ra(e, s, 0), ra(r, s, n), s.set(t, i), s
        }),
        (j2 = Symbol.for('@ipld/js-cid/CID')),
        (fu = { writable: !1, configurable: !1, enumerable: !0 }),
        (du = { writable: !1, enumerable: !1, configurable: !1 }),
        (fk = '0.0.0-dev'),
        (dk = (e, r) => {
          if (e.test(fk)) console.warn(r)
          else throw new Error(r)
        }),
        (hk = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`)
    }
  }),
  jq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/index.js'() {
      V(), F(), qq(), R2(), Bs(), D2(), P2()
    }
  }),
  pk = {}
Re(pk, {
  CID: () => Or,
  bases: () => mk,
  bytes: () => LT,
  codecs: () => yk,
  digest: () => VC,
  hasher: () => HC,
  hashes: () => bk,
  varint: () => FC
})
var mk,
  bk,
  yk,
  zq = Ie({
    'node_modules/libp2p-interfaces/node_modules/multiformats/esm/src/basics.js'() {
      V(),
        F(),
        Cq(),
        kq(),
        Mq(),
        xq(),
        Rq(),
        dC(),
        Bq(),
        vC(),
        Nq(),
        Oq(),
        Dq(),
        Lq(),
        Uq(),
        jq(),
        (mk = { ...$T, ...WT, ...XT, ...ZT, ...eC, ...nC, ...hC, ...bC, ...gC }),
        (bk = { ...$C, ...JC }),
        (yk = { raw: YC, json: rk })
    }
  }),
  vk = te({
    'node_modules/libp2p-interfaces/node_modules/uint8arrays/util/bases.js'(e, r) {
      V(), F()
      var { bases: t } = (zq(), pk)
      function n(o, l, a, c) {
        return { name: o, prefix: l, encoder: { name: o, prefix: l, encode: a }, decoder: { decode: c } }
      }
      var i = n(
          'utf8',
          'u',
          (o) => {
            let l = new TextDecoder('utf8')
            return 'u' + l.decode(o)
          },
          (o) => new TextEncoder().encode(o.substring(1))
        ),
        s = n(
          'ascii',
          'a',
          (o) => {
            let l = 'a'
            for (let a = 0; a < o.length; a++) l += String.fromCharCode(o[a])
            return l
          },
          (o) => {
            o = o.substring(1)
            let l = new Uint8Array(o.length)
            for (let a = 0; a < o.length; a++) l[a] = o.charCodeAt(a)
            return l
          }
        ),
        u = { utf8: i, 'utf-8': i, hex: t.base16, latin1: s, ascii: s, binary: s, ...t }
      r.exports = u
    }
  }),
  Af = te({
    'node_modules/libp2p-interfaces/node_modules/uint8arrays/to-string.js'(e, r) {
      V(), F()
      var t = vk()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.encoder.encode(i).substring(1)
      }
      r.exports = n
    }
  }),
  Kq = te({
    'node_modules/libp2p-interfaces/node_modules/multiaddr/src/ip.js'(e, r) {
      V(), F()
      var t = yo(),
        n = Af(),
        i = t,
        s = t.v4,
        u = t.v6,
        o = function (a, c, f) {
          f = ~~f
          let p
          if (s(a))
            (p = c || new Uint8Array(f + 4)),
              a.split(/\./g).map(function (d) {
                p[f++] = parseInt(d, 10) & 255
              })
          else if (u(a)) {
            let d = a.split(':', 8),
              h
            for (h = 0; h < d.length; h++) {
              let m = s(d[h])
              var y
              m && ((y = o(d[h])), (d[h] = n(y.slice(0, 2), 'base16'))),
                y && ++h < 8 && d.splice(h, 0, n(y.slice(2, 4), 'base16'))
            }
            if (d[0] === '') for (; d.length < 8; ) d.unshift('0')
            else if (d[d.length - 1] === '') for (; d.length < 8; ) d.push('0')
            else if (d.length < 8) {
              for (h = 0; h < d.length && d[h] !== ''; h++);
              let m = [h, '1']
              for (h = 9 - d.length; h > 0; h--) m.push('0')
              d.splice.apply(d, m)
            }
            for (p = c || new Uint8Array(f + 16), h = 0; h < d.length; h++) {
              let m = parseInt(d[h], 16)
              ;(p[f++] = (m >> 8) & 255), (p[f++] = m & 255)
            }
          }
          if (!p) throw Error('Invalid ip address: ' + a)
          return p
        },
        l = function (a, c, f) {
          ;(c = ~~c), (f = f || a.length - c)
          let p = [],
            y,
            d = new DataView(a.buffer)
          if (f === 4) {
            for (let h = 0; h < f; h++) p.push(a[c + h])
            y = p.join('.')
          } else if (f === 16) {
            for (let h = 0; h < f; h += 2) p.push(d.getUint16(c + h).toString(16))
            ;(y = p.join(':')), (y = y.replace(/(^|:)0(:0)*:0(:|$)/, '$1::$3')), (y = y.replace(/:{3,4}/, '::'))
          }
          return y
        }
      r.exports = { isIP: i, isV4: s, isV6: u, toBytes: o, toString: l }
    }
  }),
  z2 = te({
    'node_modules/libp2p-interfaces/node_modules/multiaddr/src/protocols-table.js'(e, r) {
      V(), F()
      function t(s) {
        if (typeof s == 'number') {
          if (t.codes[s]) return t.codes[s]
          throw new Error('no protocol with code: ' + s)
        } else if (typeof s == 'string') {
          if (t.names[s]) return t.names[s]
          throw new Error('no protocol with name: ' + s)
        }
        throw new Error('invalid protocol id type: ' + s)
      }
      var n = -1
      ;(t.lengthPrefixedVarSize = n),
        (t.V = n),
        (t.table = [
          [4, 32, 'ip4'],
          [6, 16, 'tcp'],
          [33, 16, 'dccp'],
          [41, 128, 'ip6'],
          [42, n, 'ip6zone'],
          [53, n, 'dns', 'resolvable'],
          [54, n, 'dns4', 'resolvable'],
          [55, n, 'dns6', 'resolvable'],
          [56, n, 'dnsaddr', 'resolvable'],
          [132, 16, 'sctp'],
          [273, 16, 'udp'],
          [275, 0, 'p2p-webrtc-star'],
          [276, 0, 'p2p-webrtc-direct'],
          [277, 0, 'p2p-stardust'],
          [290, 0, 'p2p-circuit'],
          [301, 0, 'udt'],
          [302, 0, 'utp'],
          [400, n, 'unix', !1, 'path'],
          [421, n, 'ipfs'],
          [421, n, 'p2p'],
          [443, 0, 'https'],
          [444, 96, 'onion'],
          [445, 296, 'onion3'],
          [446, n, 'garlic64'],
          [460, 0, 'quic'],
          [477, 0, 'ws'],
          [478, 0, 'wss'],
          [479, 0, 'p2p-websocket-star'],
          [480, 0, 'http'],
          [777, n, 'memory']
        ]),
        (t.names = {}),
        (t.codes = {}),
        t.table.map((s) => {
          let u = i.apply(null, s)
          return (t.codes[u.code] = u), (t.names[u.name] = u), null
        }),
        (t.object = i)
      function i(s, u, o, l, a) {
        return { code: s, size: u, name: o, resolvable: Boolean(l), path: Boolean(a) }
      }
      r.exports = t
    }
  }),
  Fq = te({
    'node_modules/libp2p-interfaces/node_modules/uint8arrays/from-string.js'(e, r) {
      V(), F()
      var t = vk()
      function n(i, s = 'utf8') {
        let u = t[s]
        if (!u) throw new Error(`Unsupported encoding "${s}"`)
        return u.decoder.decode(`${u.prefix}${i}`)
      }
      r.exports = n
    }
  }),
  gk = te({
    'node_modules/libp2p-interfaces/node_modules/uint8arrays/concat.js'(e, r) {
      V(), F()
      function t(n, i) {
        i || (i = n.reduce((o, l) => o + l.length, 0))
        let s = new Uint8Array(i),
          u = 0
        for (let o of n) s.set(o, u), (u += o.length)
        return s
      }
      r.exports = t
    }
  }),
  Vq = te({
    'node_modules/libp2p-interfaces/node_modules/multiaddr/src/convert.js'(e, r) {
      V(), F()
      var t = Kq(),
        n = z2(),
        i = Gr(),
        s = Di(),
        u = $t(),
        o = Af(),
        l = Fq(),
        a = gk()
      r.exports = c
      function c(w, v) {
        return v instanceof Uint8Array ? c.toString(w, v) : c.toBytes(w, v)
      }
      ;(c.toString = function (v, I) {
        switch (n(v).code) {
          case 4:
          case 41:
            return p(I)
          case 6:
          case 273:
          case 33:
          case 132:
            return d(I).toString()
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return m(I)
          case 421:
            return A(I)
          case 444:
            return k(I)
          case 445:
            return k(I)
          default:
            return o(I, 'base16')
        }
      }),
        (c.toBytes = function (v, I) {
          switch (n(v).code) {
            case 4:
              return f(I)
            case 41:
              return f(I)
            case 6:
            case 273:
            case 33:
            case 132:
              return y(parseInt(I, 10))
            case 53:
            case 54:
            case 55:
            case 56:
            case 400:
            case 777:
              return h(I)
            case 421:
              return _(I)
            case 444:
              return T(I)
            case 445:
              return E(I)
            default:
              return l(I, 'base16')
          }
        })
      function f(w) {
        if (!t.isIP(w)) throw new Error('invalid ip address')
        return t.toBytes(w)
      }
      function p(w) {
        let v = t.toString(w)
        if (!v || !t.isIP(v)) throw new Error('invalid ip address')
        return v
      }
      function y(w) {
        let v = new ArrayBuffer(2)
        return new DataView(v).setUint16(0, w), new Uint8Array(v)
      }
      function d(w) {
        return new DataView(w.buffer).getUint16(w.byteOffset)
      }
      function h(w) {
        let v = l(w),
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function m(w) {
        let v = u.decode(w)
        if (((w = w.slice(u.decode.bytes)), w.length !== v)) throw new Error('inconsistent lengths')
        return o(w)
      }
      function _(w) {
        let v = new i(w).multihash,
          I = Uint8Array.from(u.encode(v.length))
        return a([I, v], I.length + v.length)
      }
      function A(w) {
        let v = u.decode(w),
          I = w.slice(u.decode.bytes)
        if (I.length !== v) throw new Error('inconsistent lengths')
        return o(I, 'base58btc')
      }
      function T(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 16) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function E(w) {
        let v = w.split(':')
        if (v.length !== 2) throw new Error('failed to parse onion addr: ' + v + ' does not contain a port number')
        if (v[0].length !== 56) throw new Error('failed to parse onion addr: ' + v[0] + ' not a Tor onion3 address.')
        let I = s.decode('b' + v[0]),
          M = parseInt(v[1], 10)
        if (M < 1 || M > 65536) throw new Error('Port number is not in range(1, 65536)')
        let q = y(M)
        return a([I, q], I.length + q.length)
      }
      function k(w) {
        let v = w.slice(0, w.length - 2),
          I = w.slice(w.length - 2),
          M = o(v, 'base32'),
          q = d(I)
        return M + ':' + q
      }
    }
  }),
  Hq = te({
    'node_modules/libp2p-interfaces/node_modules/multiaddr/src/codec.js'(e, r) {
      V(), F()
      var t = Vq(),
        n = z2(),
        i = $t(),
        s = gk(),
        u = Af()
      r.exports = {
        stringToStringTuples: o,
        stringTuplesToString: l,
        tuplesToStringTuples: c,
        stringTuplesToTuples: a,
        bytesToTuples: y,
        tuplesToBytes: f,
        bytesToString: d,
        stringToBytes: h,
        fromString: m,
        fromBytes: _,
        validateBytes: A,
        isValidBytes: T,
        cleanPath: E,
        ParseError: k,
        protoFromTuple: w,
        sizeForAddr: p
      }
      function o(v) {
        let I = [],
          M = v.split('/').slice(1)
        if (M.length === 1 && M[0] === '') return []
        for (let q = 0; q < M.length; q++) {
          let G = M[q],
            O = n(G)
          if (O.size === 0) {
            I.push([G])
            continue
          }
          if ((q++, q >= M.length)) throw k('invalid address: ' + v)
          if (O.path) {
            I.push([G, E(M.slice(q).join('/'))])
            break
          }
          I.push([G, M[q]])
        }
        return I
      }
      function l(v) {
        let I = []
        return (
          v.map((M) => {
            let q = w(M)
            return I.push(q.name), M.length > 1 && I.push(M[1]), null
          }),
          E(I.join('/'))
        )
      }
      function a(v) {
        return v.map((I) => {
          Array.isArray(I) || (I = [I])
          let M = w(I)
          return I.length > 1 ? [M.code, t.toBytes(M.code, I[1])] : [M.code]
        })
      }
      function c(v) {
        return v.map((I) => {
          let M = w(I)
          return I[1] ? [M.code, t.toString(M.code, I[1])] : [M.code]
        })
      }
      function f(v) {
        return _(
          s(
            v.map((I) => {
              let M = w(I),
                q = Uint8Array.from(i.encode(M.code))
              return I.length > 1 && (q = s([q, I[1]])), q
            })
          )
        )
      }
      function p(v, I) {
        return v.size > 0 ? v.size / 8 : v.size === 0 ? 0 : i.decode(I) + i.decode.bytes
      }
      function y(v) {
        let I = [],
          M = 0
        for (; M < v.length; ) {
          let q = i.decode(v, M),
            G = i.decode.bytes,
            O = n(q),
            x = p(O, v.slice(M + G))
          if (x === 0) {
            I.push([q]), (M += G)
            continue
          }
          let L = v.slice(M + G, M + G + x)
          if (((M += x + G), M > v.length)) throw k('Invalid address Uint8Array: ' + u(v, 'base16'))
          I.push([q, L])
        }
        return I
      }
      function d(v) {
        let I = y(v),
          M = c(I)
        return l(M)
      }
      function h(v) {
        v = E(v)
        let I = o(v),
          M = a(I)
        return f(M)
      }
      function m(v) {
        return h(v)
      }
      function _(v) {
        let I = A(v)
        if (I) throw I
        return Uint8Array.from(v)
      }
      function A(v) {
        try {
          y(v)
        } catch (I) {
          return I
        }
      }
      function T(v) {
        return A(v) === void 0
      }
      function E(v) {
        return (
          '/' +
          v
            .trim()
            .split('/')
            .filter((I) => I)
            .join('/')
        )
      }
      function k(v) {
        return new Error('Error parsing address: ' + v)
      }
      function w(v) {
        return n(v[0])
      }
    }
  }),
  $q = te({
    'node_modules/libp2p-interfaces/node_modules/uint8arrays/equals.js'(e, r) {
      V(), F()
      function t(n, i) {
        if (n === i) return !0
        if (n.byteLength !== i.byteLength) return !1
        for (let s = 0; s < n.byteLength; s++) if (n[s] !== i[s]) return !1
        return !0
      }
      r.exports = t
    }
  }),
  Gq = te({
    'node_modules/libp2p-interfaces/node_modules/multiaddr/src/index.js'(e, r) {
      V(), F()
      var t = Hq(),
        n = z2(),
        i = $t(),
        s = Gr(),
        u = pt(),
        o = Symbol.for('nodejs.util.inspect.custom'),
        l = Af(),
        a = $q(),
        c = new Map(),
        f = Symbol.for('@multiformats/js-multiaddr/multiaddr'),
        p = class {
          constructor(d) {
            if ((d == null && (d = ''), Object.defineProperty(this, f, { value: !0 }), d instanceof Uint8Array))
              this.bytes = t.fromBytes(d)
            else if (typeof d == 'string') {
              if (d.length > 0 && d.charAt(0) !== '/') throw new Error(`multiaddr "${d}" must start with a "/"`)
              this.bytes = t.fromString(d)
            } else if (p.isMultiaddr(d)) this.bytes = t.fromBytes(d.bytes)
            else throw new Error('addr must be a string, Buffer, or another Multiaddr')
          }
          toString() {
            return t.bytesToString(this.bytes)
          }
          toJSON() {
            return this.toString()
          }
          toOptions() {
            let d = {},
              h = this.toString().split('/')
            return (
              (d.family = h[1] === 'ip4' ? 4 : 6), (d.host = h[2]), (d.transport = h[3]), (d.port = parseInt(h[4])), d
            )
          }
          protos() {
            return this.protoCodes().map((d) => Object.assign({}, n(d)))
          }
          protoCodes() {
            let d = [],
              h = this.bytes,
              m = 0
            for (; m < h.length; ) {
              let _ = i.decode(h, m),
                A = i.decode.bytes,
                T = n(_)
              ;(m += t.sizeForAddr(T, h.slice(m + A)) + A), d.push(_)
            }
            return d
          }
          protoNames() {
            return this.protos().map((d) => d.name)
          }
          tuples() {
            return t.bytesToTuples(this.bytes)
          }
          stringTuples() {
            let d = t.bytesToTuples(this.bytes)
            return t.tuplesToStringTuples(d)
          }
          encapsulate(d) {
            return (d = new p(d)), new p(this.toString() + d.toString())
          }
          decapsulate(d) {
            let h = d.toString(),
              m = this.toString(),
              _ = m.lastIndexOf(h)
            if (_ < 0) throw new Error('Address ' + this + ' does not contain subaddress: ' + d)
            return new p(m.slice(0, _))
          }
          decapsulateCode(d) {
            let h = this.tuples()
            for (let m = h.length - 1; m >= 0; m--) if (h[m][0] === d) return new p(t.tuplesToBytes(h.slice(0, m)))
            return this
          }
          getPeerId() {
            try {
              let h = this.stringTuples()
                .filter((m) => m[0] === n.names.ipfs.code)
                .pop()
              return h && h[1] ? l(new s(h[1]).multihash, 'base58btc') : null
            } catch (d) {
              return null
            }
          }
          getPath() {
            let d = null
            try {
              ;(d = this.stringTuples().filter((h) => !!n(h[0]).path)[0][1]), d || (d = null)
            } catch (h) {
              d = null
            }
            return d
          }
          equals(d) {
            return a(this.bytes, d.bytes)
          }
          async resolve() {
            let d = this.protos().find((_) => _.resolvable)
            if (!d) return [this]
            let h = c.get(d.name)
            if (!h) throw u(new Error(`no available resolver for ${d.name}`), 'ERR_NO_AVAILABLE_RESOLVER')
            return (await h(this)).map((_) => new p(_))
          }
          nodeAddress() {
            let d = this.protoCodes(),
              h = this.protoNames(),
              m = this.toString().split('/').slice(1)
            if (m.length < 4)
              throw new Error(
                'multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".'
              )
            if (d[0] !== 4 && d[0] !== 41 && d[0] !== 54 && d[0] !== 55)
              throw new Error(
                `no protocol with name: "'${h[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`
              )
            if (m[2] !== 'tcp' && m[2] !== 'udp')
              throw new Error(`no protocol with name: "'${h[1]}'". Must have a valid transport protocol: "{tcp, udp}".`)
            return { family: d[0] === 41 || d[0] === 55 ? 6 : 4, address: m[1], port: parseInt(m[3]) }
          }
          isThinWaistAddress(d) {
            let h = (d || this).protos()
            return !(h.length !== 2 || (h[0].code !== 4 && h[0].code !== 41) || (h[1].code !== 6 && h[1].code !== 273))
          }
          static fromNodeAddress(d, h) {
            if (!d) throw new Error('requires node address object')
            if (!h) throw new Error('requires transport protocol')
            let m
            switch (d.family) {
              case 4:
                m = 'ip4'
                break
              case 6:
                m = 'ip6'
                break
              default:
                throw Error(`Invalid addr family. Got '${d.family}' instead of 4 or 6`)
            }
            return new p('/' + [m, d.address, h, d.port].join('/'))
          }
          static isName(d) {
            return p.isMultiaddr(d) ? d.protos().some((h) => h.resolvable) : !1
          }
          static isMultiaddr(d) {
            return d instanceof p || Boolean(d && d[f])
          }
          [o]() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
          inspect() {
            return '<Multiaddr ' + l(this.bytes, 'base16') + ' - ' + t.bytesToString(this.bytes) + '>'
          }
        }
      ;(p.protocols = n), (p.resolvers = c)
      function y(d) {
        return new p(d)
      }
      r.exports = { Multiaddr: p, multiaddr: y, protocols: n, resolvers: c }
    }
  }),
  Wq = te({
    'node_modules/libp2p-interfaces/src/connection/status.js'(e, r) {
      V(), F()
      var t = { OPEN: 'open', CLOSING: 'closing', CLOSED: 'closed' }
      r.exports = t
    }
  }),
  Jq = te({
    'node_modules/libp2p-interfaces/src/connection/connection.js'(e, r) {
      V(), F()
      var t = er(),
        { Multiaddr: n } = Gq(),
        i = pt(),
        { OPEN: s, CLOSING: u, CLOSED: o } = Wq(),
        l = Symbol.for('@libp2p/interface-connection/connection'),
        a = class {
          constructor({
            localAddr: f,
            remoteAddr: p,
            localPeer: y,
            remotePeer: d,
            newStream: h,
            close: m,
            getStreams: _,
            stat: A
          }) {
            c(f, y, d, h, m, _, A),
              (this.id = parseInt(String(Math.random() * 1e9)).toString(36) + Date.now()),
              (this.localAddr = f),
              (this.remoteAddr = p),
              (this.localPeer = y),
              (this.remotePeer = d),
              (this._stat = { ...A, status: s }),
              (this._newStream = h),
              (this._close = m),
              (this._getStreams = _),
              (this.registry = new Map()),
              (this.tags = [])
          }
          get [Symbol.toStringTag]() {
            return 'Connection'
          }
          get [l]() {
            return !0
          }
          static isConnection(f) {
            return Boolean(f && f[l])
          }
          get stat() {
            return this._stat
          }
          get streams() {
            return this._getStreams()
          }
          async newStream(f) {
            if (this.stat.status === u)
              throw i(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED')
            if (this.stat.status === o) throw i(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED')
            Array.isArray(f) || (f = [f])
            let { stream: p, protocol: y } = await this._newStream(f)
            return this.addStream(p, { protocol: y }), { stream: p, protocol: y }
          }
          addStream(f, { protocol: p, metadata: y = {} }) {
            this.registry.set(f.id, { protocol: p, ...y })
          }
          removeStream(f) {
            this.registry.delete(f)
          }
          async close() {
            if (this.stat.status !== o) {
              if (this._closing) return this._closing
              ;(this.stat.status = u),
                (this._closing = await this._close()),
                (this._stat.timeline.close = Date.now()),
                (this.stat.status = o)
            }
          }
        }
      r.exports = a
      function c(f, p, y, d, h, m, _) {
        if (f && !n.isMultiaddr(f))
          throw i(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS')
        if (!t.isPeerId(p)) throw i(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')
        if (!t.isPeerId(y)) throw i(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS')
        if (typeof d != 'function') throw i(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS')
        if (typeof h != 'function') throw i(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS')
        if (typeof m != 'function') throw i(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS')
        if (!_) throw i(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS')
        if (_.direction !== 'inbound' && _.direction !== 'outbound')
          throw i(new Error('direction must be "inbound" or "outbound"'), 'ERR_INVALID_PARAMETERS')
        if (!_.timeline)
          throw i(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS')
        if (!_.timeline.open) throw i(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS')
        if (!_.timeline.upgraded)
          throw i(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS')
      }
    }
  }),
  Xq = te({
    'node_modules/libp2p-interfaces/src/connection/index.js'(e) {
      V(), F(), (e.Connection = Jq())
    }
  }),
  Yq = te({
    'node_modules/mutable-proxy/build/index.js'(e, r) {
      V(), F()
      function t(n) {
        if (Array.isArray(n)) {
          for (var i = 0, s = Array(n.length); i < n.length; i++) s[i] = n[i]
          return s
        } else return Array.from(n)
      }
      r.exports = function (i) {
        var s = void 0,
          u = void 0
        function o(c) {
          if (!(c instanceof Object)) throw new Error('Target "' + c + '" is not an object')
          u = c
        }
        function l(c) {
          Object.keys(c).forEach(function (f) {
            var p = c[f]
            if (typeof p != 'function') throw new Error('Trap "' + f + ': ' + p + '" is not a function')
            if (!Reflect[f]) throw new Error('Trap "' + f + ': ' + p + '" is not a valid trap')
          }),
            (s = c)
        }
        o(function () {}), i && o(i), l(Reflect)
        var a = new Proxy(
          {},
          {
            get: function (f, p) {
              return function () {
                for (var y = arguments.length, d = Array(y), h = 0; h < y; h++) d[h] = arguments[h]
                return s[p].apply(null, [u].concat(t(d.slice(1))))
              }
            }
          }
        )
        return {
          setTarget: o,
          setHandler: l,
          getTarget: function () {
            return u
          },
          getHandler: function () {
            return s
          },
          proxy: new Proxy(u, a)
        }
      }
    }
  }),
  Zq = te({
    'node_modules/libp2p/src/upgrader.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:upgrader'), { error: t('libp2p:upgrader:err') }),
        i = pt(),
        s = Aq(),
        { Connection: u } = Xq(),
        o = er(),
        { pipe: l } = wn(),
        a = Yq(),
        { codes: c } = or(),
        f = class {
          constructor({
            localPeer: p,
            metrics: y,
            cryptos: d = new Map(),
            muxers: h = new Map(),
            onConnectionEnd: m = () => {},
            onConnection: _ = () => {}
          }) {
            ;(this.localPeer = p),
              (this.metrics = y),
              (this.cryptos = d),
              (this.muxers = h),
              (this.protector = null),
              (this.protocols = new Map()),
              (this.onConnection = _),
              (this.onConnectionEnd = m)
          }
          async upgradeInbound(p) {
            let y, d, h, m, _, A, T
            if (this.metrics) {
              ;({ setTarget: A, proxy: T } = a())
              let k = (Math.random() * 1e9).toString(36) + Date.now()
              A({ toB58String: () => k }), (p = this.metrics.trackStream({ stream: p, remotePeer: T }))
            }
            n('Starting the inbound connection upgrade')
            let E = p
            this.protector && (E = await this.protector.protect(p))
            try {
              ;({ conn: y, remotePeer: d, protocol: _ } = await this._encryptInbound(this.localPeer, E, this.cryptos)),
                this.muxers.size ? ({ stream: h, Muxer: m } = await this._multiplexInbound(y, this.muxers)) : (h = y)
            } catch (k) {
              throw (n.error('Failed to upgrade inbound connection', k), await p.close(k), k)
            }
            return (
              this.metrics && (this.metrics.updatePlaceholder(T, d), A(d)),
              n('Successfully upgraded inbound connection'),
              this._createConnection({
                cryptoProtocol: _,
                direction: 'inbound',
                maConn: p,
                upgradedConn: h,
                Muxer: m,
                remotePeer: d
              })
            )
          }
          async upgradeOutbound(p) {
            let y = p.remoteAddr.getPeerId()
            if (!y) throw i(new Error('outbound connection must have a peer id'), c.ERR_INVALID_MULTIADDR)
            let d = o.createFromB58String(y),
              h,
              m,
              _,
              A,
              T,
              E,
              k
            if (this.metrics) {
              ;({ setTarget: E, proxy: k } = a())
              let v = (Math.random() * 1e9).toString(36) + Date.now()
              E({ toB58String: () => v }), (p = this.metrics.trackStream({ stream: p, remotePeer: k }))
            }
            n('Starting the outbound connection upgrade')
            let w = p
            this.protector && (w = await this.protector.protect(p))
            try {
              ;({
                conn: h,
                remotePeer: m,
                protocol: A
              } = await this._encryptOutbound(this.localPeer, w, d, this.cryptos)),
                this.muxers.size ? ({ stream: _, Muxer: T } = await this._multiplexOutbound(h, this.muxers)) : (_ = h)
            } catch (v) {
              throw (n.error('Failed to upgrade outbound connection', v), await p.close(v), v)
            }
            return (
              this.metrics && (this.metrics.updatePlaceholder(k, m), E(m)),
              n('Successfully upgraded outbound connection'),
              this._createConnection({
                cryptoProtocol: A,
                direction: 'outbound',
                maConn: p,
                upgradedConn: _,
                Muxer: T,
                remotePeer: m
              })
            )
          }
          _createConnection({ cryptoProtocol: p, direction: y, maConn: d, upgradedConn: h, Muxer: m, remotePeer: _ }) {
            let A, T, E
            m &&
              ((A = new m({
                onStream: async (v) => {
                  if (!E) return
                  let I = new s.Listener(v)
                  try {
                    let { stream: M, protocol: q } = await I.handle(Array.from(this.protocols.keys()))
                    n('%s: incoming stream opened on %s', y, q),
                      this.metrics && this.metrics.trackStream({ stream: M, remotePeer: _, protocol: q }),
                      E.addStream(v, { protocol: q }),
                      this._onStream({ connection: E, stream: { ...v, ...M }, protocol: q })
                  } catch (M) {
                    n.error(M)
                  }
                },
                onStreamEnd: (v) => {
                  E.removeStream(v.id)
                }
              })),
              (T = async (v) => {
                n('%s: starting new stream on %s', y, v)
                let I = A.newStream(),
                  M = new s.Dialer(I)
                try {
                  let { stream: q, protocol: G } = await M.select(v)
                  return (
                    this.metrics && this.metrics.trackStream({ stream: q, remotePeer: _, protocol: G }),
                    { stream: { ...I, ...q }, protocol: G }
                  )
                } catch (q) {
                  throw (n.error('could not create new stream', q), i(q, c.ERR_UNSUPPORTED_PROTOCOL))
                }
              }),
              l(h, A, h).catch(n.error))
            let k = d.timeline
            ;(d.timeline = new Proxy(k, {
              set: (...v) => (
                E &&
                  v[1] === 'close' &&
                  v[2] &&
                  !k.close &&
                  (async () => {
                    try {
                      E.stat.status === 'open' && (await E.close())
                    } catch (I) {
                      n.error(I)
                    } finally {
                      this.onConnectionEnd(E)
                    }
                  })(),
                Reflect.set(...v)
              )
            })),
              (d.timeline.upgraded = Date.now())
            let w = () => {
              throw i(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED')
            }
            return (
              (E = new u({
                localAddr: d.localAddr,
                remoteAddr: d.remoteAddr,
                localPeer: this.localPeer,
                remotePeer: _,
                stat: { direction: y, timeline: d.timeline, multiplexer: m && m.multicodec, encryption: p },
                newStream: T || w,
                getStreams: () => (A ? A.streams : w()),
                close: async () => {
                  await d.close(), A && A.streams.map((v) => v.abort())
                }
              })),
              this.onConnection(E),
              E
            )
          }
          _onStream({ connection: p, stream: y, protocol: d }) {
            this.protocols.get(d)({ connection: p, stream: y, protocol: d })
          }
          async _encryptInbound(p, y, d) {
            let h = new s.Listener(y),
              m = Array.from(d.keys())
            n('handling inbound crypto protocol selection', m)
            try {
              let { stream: _, protocol: A } = await h.handle(m),
                T = d.get(A)
              if ((n('encrypting inbound connection...'), !T)) throw new Error(`no crypto module found for ${A}`)
              return { ...(await T.secureInbound(p, _)), protocol: A }
            } catch (_) {
              throw i(_, c.ERR_ENCRYPTION_FAILED)
            }
          }
          async _encryptOutbound(p, y, d, h) {
            let m = new s.Dialer(y),
              _ = Array.from(h.keys())
            n('selecting outbound crypto protocol', _)
            try {
              let { stream: A, protocol: T } = await m.select(_),
                E = h.get(T)
              if ((n('encrypting outbound connection to %j', d), !E)) throw new Error(`no crypto module found for ${T}`)
              return { ...(await E.secureOutbound(p, A, d)), protocol: T }
            } catch (A) {
              throw i(A, c.ERR_ENCRYPTION_FAILED)
            }
          }
          async _multiplexOutbound(p, y) {
            let d = new s.Dialer(p),
              h = Array.from(y.keys())
            n('outbound selecting muxer %s', h)
            try {
              let { stream: m, protocol: _ } = await d.select(h)
              n('%s selected as muxer protocol', _)
              let A = y.get(_)
              return { stream: m, Muxer: A }
            } catch (m) {
              throw i(m, c.ERR_MUXER_UNAVAILABLE)
            }
          }
          async _multiplexInbound(p, y) {
            let d = new s.Listener(p),
              h = Array.from(y.keys())
            n('inbound handling muxers %s', h)
            try {
              let { stream: m, protocol: _ } = await d.handle(h),
                A = y.get(_)
              return { stream: m, Muxer: A }
            } catch (m) {
              throw i(m, c.ERR_MUXER_UNAVAILABLE)
            }
          }
        }
      r.exports = f
    }
  }),
  If = te({
    'node_modules/libp2p/src/peer-store/book.js'(e, r) {
      V(), F()
      var t = pt(),
        n = er(),
        {
          codes: { ERR_INVALID_PARAMETERS: i }
        } = or(),
        s = (o) => o,
        u = class {
          constructor({ peerStore: o, eventName: l, eventProperty: a, eventTransformer: c = s }) {
            ;(this._ps = o),
              (this.eventName = l),
              (this.eventProperty = a),
              (this.eventTransformer = c),
              (this.data = new Map())
          }
          set(o, l) {
            throw t(new Error('set must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED')
          }
          _setData(o, l, { emit: a = !0 } = {}) {
            let c = o.toB58String()
            this.data.set(c, l), a && this._emit(o, l)
          }
          _emit(o, l) {
            this._ps.emit(this.eventName, { peerId: o, [this.eventProperty]: this.eventTransformer(l) })
          }
          get(o) {
            if (!n.isPeerId(o)) throw t(new Error('peerId must be an instance of peer-id'), i)
            let l = this.data.get(o.toB58String())
            return l ? [...l] : void 0
          }
          delete(o) {
            if (!n.isPeerId(o)) throw t(new Error('peerId must be an instance of peer-id'), i)
            return this.data.delete(o.toB58String()) ? (this._emit(o, []), !0) : !1
          }
        }
      r.exports = u
    }
  }),
  Qq = te({
    'node_modules/libp2p/src/peer-store/address-book.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:peer-store:address-book'), { error: t('libp2p:peer-store:address-book:err') }),
        i = pt(),
        { Multiaddr: s } = Zr(),
        u = er(),
        o = If(),
        l = b2(),
        {
          codes: { ERR_INVALID_PARAMETERS: a }
        } = or(),
        c = m2(),
        f = class extends o {
          constructor(p) {
            super({
              peerStore: p,
              eventName: 'change:multiaddrs',
              eventProperty: 'multiaddrs',
              eventTransformer: (y) => (y.addresses ? y.addresses.map((d) => d.multiaddr) : [])
            })
            this.data = new Map()
          }
          consumePeerRecord(p) {
            let y
            try {
              y = l.createFromProtobuf(p.payload)
            } catch (T) {
              return n.error('invalid peer record received'), !1
            }
            if (!y.peerId.equals(p.peerId)) return n('signing key does not match PeerId in the PeerRecord'), !1
            if (!y.multiaddrs || !y.multiaddrs.length) return !1
            let d = y.peerId,
              h = d.toB58String(),
              _ = (this.data.get(h) || { record: void 0 }).record
            if (_ && _.seqNumber >= y.seqNumber) return !1
            let A = this._toAddresses(y.multiaddrs, !0)
            return (
              this._setData(d, { addresses: A, record: { raw: p.marshal(), seqNumber: y.seqNumber } }),
              n(`stored provided peer record for ${h}`),
              !0
            )
          }
          getRawEnvelope(p) {
            let y = this.data.get(p.toB58String())
            if (!(!y || !y.record || !y.record.raw)) return y.record.raw
          }
          getPeerRecord(p) {
            let y = this.getRawEnvelope(p)
            if (!!y) return c.createFromProtobuf(y)
          }
          set(p, y) {
            if (!u.isPeerId(p))
              throw (
                (n.error('peerId must be an instance of peer-id to store data'),
                i(new Error('peerId must be an instance of peer-id'), a))
              )
            let d = this._toAddresses(y)
            if (!d.length) return this
            let h = p.toB58String(),
              m = this.data.get(h)
            return m &&
              m.addresses &&
              m.addresses.length === d.length &&
              m.addresses.filter((A) => d.some((T) => A.multiaddr.equals(T.multiaddr))).length === m.addresses.length
              ? (n(`the addresses provided to store are equal to the already stored for ${h}`), this)
              : (this._setData(p, { addresses: d, record: m && m.record }),
                n(`stored provided multiaddrs for ${h}`),
                m || this._ps.emit('peer', p),
                this)
          }
          add(p, y) {
            if (!u.isPeerId(p))
              throw (
                (n.error('peerId must be an instance of peer-id to store data'),
                i(new Error('peerId must be an instance of peer-id'), a))
              )
            let d = this._toAddresses(y),
              h = p.toB58String()
            if (!d.length) return this
            let m = this.data.get(h)
            return m &&
              m.addresses &&
              (m.addresses.forEach((_) => {
                d.find((A) => A.multiaddr.equals(_.multiaddr)) || d.push(_)
              }),
              m.addresses.length === d.length)
              ? (n(`the addresses provided to store are already stored for ${h}`), this)
              : (this._setData(p, { addresses: d, record: m && m.record }),
                n(`added provided multiaddrs for ${h}`),
                (m && m.addresses) || this._ps.emit('peer', p),
                this)
          }
          get(p) {
            if (!u.isPeerId(p)) throw i(new Error('peerId must be an instance of peer-id'), a)
            let y = this.data.get(p.toB58String())
            return y && y.addresses ? [...y.addresses] : void 0
          }
          _toAddresses(p, y = !1) {
            if (!p)
              throw (
                (n.error('multiaddrs must be provided to store data'), i(new Error('multiaddrs must be provided'), a))
              )
            let d = []
            return (
              p.forEach((h) => {
                if (!s.isMultiaddr(h))
                  throw (
                    (n.error(`multiaddr ${h} must be an instance of multiaddr`),
                    i(new Error(`multiaddr ${h} must be an instance of multiaddr`), a))
                  )
                d.find((m) => m.multiaddr.equals(h)) || d.push({ multiaddr: h, isCertified: y })
              }),
              d
            )
          }
          getMultiaddrsForPeer(p, y = (d) => d) {
            if (!u.isPeerId(p)) throw i(new Error('peerId must be an instance of peer-id'), a)
            let d = this.data.get(p.toB58String())
            if (!(!d || !d.addresses))
              return y(d.addresses || []).map((h) => {
                let m = h.multiaddr,
                  _ = m.getPeerId()
                return _ && _ === p.toB58String() ? m : m.encapsulate(`/p2p/${p.toB58String()}`)
              })
          }
        }
      r.exports = f
    }
  }),
  ej = te({
    'node_modules/libp2p/src/peer-store/key-book.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:peer-store:key-book'), { error: t('libp2p:peer-store:key-book:err') }),
        i = pt(),
        s = er(),
        u = If(),
        {
          codes: { ERR_INVALID_PARAMETERS: o }
        } = or(),
        l = class extends u {
          constructor(a) {
            super({
              peerStore: a,
              eventName: 'change:pubkey',
              eventProperty: 'pubkey',
              eventTransformer: (c) => c.pubKey
            })
            this.data = new Map()
          }
          set(a, c) {
            if (!s.isPeerId(a))
              throw (
                (n.error('peerId must be an instance of peer-id to store data'),
                i(new Error('peerId must be an instance of peer-id'), o))
              )
            let f = a.toB58String()
            return (
              !this.data.get(f) && c && ((a.pubKey = c), this._setData(a, a), n(`stored provided public key for ${f}`)),
              this
            )
          }
          get(a) {
            if (!s.isPeerId(a)) throw i(new Error('peerId must be an instance of peer-id'), o)
            let c = this.data.get(a.toB58String())
            return c ? c.pubKey : void 0
          }
        }
      r.exports = l
    }
  }),
  tj = te({
    'node_modules/libp2p/src/peer-store/metadata-book.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:peer-store:proto-book'), { error: t('libp2p:peer-store:proto-book:err') }),
        i = pt(),
        s = vf(),
        u = er(),
        o = If(),
        {
          codes: { ERR_INVALID_PARAMETERS: l }
        } = or(),
        a = class extends o {
          constructor(c) {
            super({ peerStore: c, eventName: 'change:metadata', eventProperty: 'metadata' })
            this.data = new Map()
          }
          set(c, f, p) {
            if (!u.isPeerId(c))
              throw (
                (n.error('peerId must be an instance of peer-id to store data'),
                i(new Error('peerId must be an instance of peer-id'), l))
              )
            if (typeof f != 'string' || !(p instanceof Uint8Array))
              throw (
                (n.error('valid key and value must be provided to store data'),
                i(new Error('valid key and value must be provided'), l))
              )
            return this._setValue(c, f, p), this
          }
          _setValue(c, f, p, { emit: y = !0 } = {}) {
            let d = c.toB58String(),
              h = this.data.get(d) || new Map(),
              m = h.get(f)
            if (m && s(p, m)) {
              n(`the metadata provided to store is equal to the already stored for ${d} on ${f}`)
              return
            }
            h.set(f, p), this.data.set(d, h), y && this._emit(c, f)
          }
          get(c) {
            if (!u.isPeerId(c)) throw i(new Error('peerId must be an instance of peer-id'), l)
            return this.data.get(c.toB58String())
          }
          getValue(c, f) {
            if (!u.isPeerId(c)) throw i(new Error('peerId must be an instance of peer-id'), l)
            let p = this.data.get(c.toB58String())
            return p && p.get(f)
          }
          delete(c) {
            if (!u.isPeerId(c)) throw i(new Error('peerId must be an instance of peer-id'), l)
            return this.data.delete(c.toB58String()) ? (this._emit(c), !0) : !1
          }
          deleteValue(c, f) {
            if (!u.isPeerId(c)) throw i(new Error('peerId must be an instance of peer-id'), l)
            let p = this.data.get(c.toB58String())
            return !p || !p.delete(f) ? !1 : (this._emit(c, f), !0)
          }
        }
      r.exports = a
    }
  }),
  rj = te({
    'node_modules/libp2p/src/peer-store/proto-book.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:peer-store:proto-book'), { error: t('libp2p:peer-store:proto-book:err') }),
        i = pt(),
        s = er(),
        u = If(),
        {
          codes: { ERR_INVALID_PARAMETERS: o }
        } = or(),
        l = class extends u {
          constructor(a) {
            super({
              peerStore: a,
              eventName: 'change:protocols',
              eventProperty: 'protocols',
              eventTransformer: (c) => Array.from(c)
            })
            this.data = new Map()
          }
          set(a, c) {
            if (!s.isPeerId(a))
              throw (
                (n.error('peerId must be an instance of peer-id to store data'),
                i(new Error('peerId must be an instance of peer-id'), o))
              )
            if (!c)
              throw (n.error('protocols must be provided to store data'), i(new Error('protocols must be provided'), o))
            let f = a.toB58String(),
              p = this.data.get(f),
              y = new Set(c)
            return p && ((h, m) => h.size === m.size && [...h].every((_) => m.has(_)))(p, y)
              ? (n(`the protocols provided to store are equal to the already stored for ${f}`), this)
              : (this._setData(a, y), n(`stored provided protocols for ${f}`), this)
          }
          add(a, c) {
            if (!s.isPeerId(a))
              throw (
                (n.error('peerId must be an instance of peer-id to store data'),
                i(new Error('peerId must be an instance of peer-id'), o))
              )
            if (!c)
              throw (n.error('protocols must be provided to store data'), i(new Error('protocols must be provided'), o))
            let f = a.toB58String(),
              p = this.data.get(f) || new Set(),
              y = new Set([...p, ...c])
            return p.size === y.size
              ? (n(`the protocols provided to store are already stored for ${f}`), this)
              : (this._setData(a, y), n(`added provided protocols for ${f}`), this)
          }
          remove(a, c) {
            if (!s.isPeerId(a))
              throw (
                (n.error('peerId must be an instance of peer-id to store data'),
                i(new Error('peerId must be an instance of peer-id'), o))
              )
            if (!c)
              throw (n.error('protocols must be provided to store data'), i(new Error('protocols must be provided'), o))
            let f = a.toB58String(),
              p = this.data.get(f)
            if (p) {
              let y = new Set([...p].filter((d) => !c.includes(d)))
              if (p.size === y.size) return this
              this._setData(a, y), n(`removed provided protocols for ${f}`)
            }
            return this
          }
        }
      r.exports = l
    }
  }),
  wk = te({
    'node_modules/libp2p/src/peer-store/index.js'(e, r) {
      V(), F()
      var t = pt(),
        { EventEmitter: n } = ln(),
        i = er(),
        s = Qq(),
        u = ej(),
        o = tj(),
        l = rj(),
        {
          codes: { ERR_INVALID_PARAMETERS: a }
        } = or(),
        c = class extends n {
          constructor({ peerId: f }) {
            super()
            ;(this._peerId = f),
              (this.addressBook = new s(this)),
              (this.keyBook = new u(this)),
              (this.metadataBook = new o(this)),
              (this.protoBook = new l(this))
          }
          start() {}
          stop() {}
          get peers() {
            let f = new Set([
              ...this.addressBook.data.keys(),
              ...this.keyBook.data.keys(),
              ...this.protoBook.data.keys(),
              ...this.metadataBook.data.keys()
            ])
            this._peerId && f.delete(this._peerId.toB58String())
            let p = new Map()
            return (
              f.forEach((y) => {
                p.set(y, this.get(i.createFromCID(y)))
              }),
              p
            )
          }
          delete(f) {
            let p = this.addressBook.delete(f),
              y = this.keyBook.delete(f),
              d = this.protoBook.delete(f),
              h = this.metadataBook.delete(f)
            return p || y || d || h
          }
          get(f) {
            if (!i.isPeerId(f)) throw t(new Error('peerId must be an instance of peer-id'), a)
            let p = this.keyBook.data.get(f.toB58String()),
              y = this.addressBook.get(f),
              d = this.metadataBook.get(f),
              h = this.protoBook.get(f)
            if (!(!p && !y && !d && !h)) return { id: p || f, addresses: y || [], protocols: h || [], metadata: d }
          }
        }
      r.exports = c
    }
  }),
  nj = te({
    'node_modules/libp2p/src/pubsub-adapter.js'(e, r) {
      V(), F()
      function t(n, i, s) {
        let u = new n(i, s)
        ;(u._subscribeAdapter = u.subscribe), (u._unsubscribeAdapter = u.unsubscribe)
        function o(a, c) {
          c && u.on(a, c), u._subscribeAdapter(a)
        }
        function l(a, c) {
          c ? u.removeListener(a, c) : u.removeAllListeners(a), u.listenerCount(a) === 0 && u._unsubscribeAdapter(a)
        }
        return (u.subscribe = o), (u.unsubscribe = l), u
      }
      r.exports = t
    }
  }),
  ij = te({
    'node_modules/libp2p/src/peer-store/persistent/consts.js'(e, r) {
      V(),
        F(),
        (r.exports.NAMESPACE_COMMON = '/peers/'),
        (r.exports.NAMESPACE_ADDRESS = '/peers/addrs/'),
        (r.exports.NAMESPACE_KEYS = '/peers/keys/'),
        (r.exports.NAMESPACE_METADATA = '/peers/metadata/'),
        (r.exports.NAMESPACE_PROTOCOL = '/peers/protos/')
    }
  }),
  sj = te({
    'node_modules/libp2p/src/peer-store/persistent/pb/address-book.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-address-book'] || (t.roots['libp2p-address-book'] = {})
      ;(u.Addresses = (function () {
        function o(l) {
          if (((this.addrs = []), l))
            for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
        }
        return (
          (o.prototype.addrs = s.emptyArray),
          (o.prototype.certifiedRecord = null),
          (o.encode = function (a, c) {
            if ((c || (c = i.create()), a.addrs != null && a.addrs.length))
              for (var f = 0; f < a.addrs.length; ++f)
                u.Addresses.Address.encode(a.addrs[f], c.uint32(10).fork()).ldelim()
            return (
              a.certifiedRecord != null &&
                Object.hasOwnProperty.call(a, 'certifiedRecord') &&
                u.Addresses.CertifiedRecord.encode(a.certifiedRecord, c.uint32(18).fork()).ldelim(),
              c
            )
          }),
          (o.decode = function (a, c) {
            a instanceof n || (a = n.create(a))
            for (var f = c === void 0 ? a.len : a.pos + c, p = new u.Addresses(); a.pos < f; ) {
              var y = a.uint32()
              switch (y >>> 3) {
                case 1:
                  ;(p.addrs && p.addrs.length) || (p.addrs = []),
                    p.addrs.push(u.Addresses.Address.decode(a, a.uint32()))
                  break
                case 2:
                  p.certifiedRecord = u.Addresses.CertifiedRecord.decode(a, a.uint32())
                  break
                default:
                  a.skipType(y & 7)
                  break
              }
            }
            return p
          }),
          (o.fromObject = function (a) {
            if (a instanceof u.Addresses) return a
            var c = new u.Addresses()
            if (a.addrs) {
              if (!Array.isArray(a.addrs)) throw TypeError('.Addresses.addrs: array expected')
              c.addrs = []
              for (var f = 0; f < a.addrs.length; ++f) {
                if (typeof a.addrs[f] != 'object') throw TypeError('.Addresses.addrs: object expected')
                c.addrs[f] = u.Addresses.Address.fromObject(a.addrs[f])
              }
            }
            if (a.certifiedRecord != null) {
              if (typeof a.certifiedRecord != 'object') throw TypeError('.Addresses.certifiedRecord: object expected')
              c.certifiedRecord = u.Addresses.CertifiedRecord.fromObject(a.certifiedRecord)
            }
            return c
          }),
          (o.toObject = function (a, c) {
            c || (c = {})
            var f = {}
            if (
              ((c.arrays || c.defaults) && (f.addrs = []),
              c.defaults && (f.certifiedRecord = null),
              a.addrs && a.addrs.length)
            ) {
              f.addrs = []
              for (var p = 0; p < a.addrs.length; ++p) f.addrs[p] = u.Addresses.Address.toObject(a.addrs[p], c)
            }
            return (
              a.certifiedRecord != null &&
                a.hasOwnProperty('certifiedRecord') &&
                (f.certifiedRecord = u.Addresses.CertifiedRecord.toObject(a.certifiedRecord, c)),
              f
            )
          }),
          (o.prototype.toJSON = function () {
            return this.constructor.toObject(this, t.util.toJSONOptions)
          }),
          (o.Address = (function () {
            function l(a) {
              if (a) for (var c = Object.keys(a), f = 0; f < c.length; ++f) a[c[f]] != null && (this[c[f]] = a[c[f]])
            }
            return (
              (l.prototype.multiaddr = s.newBuffer([])),
              (l.prototype.isCertified = !1),
              (l.encode = function (c, f) {
                return (
                  f || (f = i.create()),
                  c.multiaddr != null && Object.hasOwnProperty.call(c, 'multiaddr') && f.uint32(10).bytes(c.multiaddr),
                  c.isCertified != null &&
                    Object.hasOwnProperty.call(c, 'isCertified') &&
                    f.uint32(16).bool(c.isCertified),
                  f
                )
              }),
              (l.decode = function (c, f) {
                c instanceof n || (c = n.create(c))
                for (var p = f === void 0 ? c.len : c.pos + f, y = new u.Addresses.Address(); c.pos < p; ) {
                  var d = c.uint32()
                  switch (d >>> 3) {
                    case 1:
                      y.multiaddr = c.bytes()
                      break
                    case 2:
                      y.isCertified = c.bool()
                      break
                    default:
                      c.skipType(d & 7)
                      break
                  }
                }
                return y
              }),
              (l.fromObject = function (c) {
                if (c instanceof u.Addresses.Address) return c
                var f = new u.Addresses.Address()
                return (
                  c.multiaddr != null &&
                    (typeof c.multiaddr == 'string'
                      ? s.base64.decode(c.multiaddr, (f.multiaddr = s.newBuffer(s.base64.length(c.multiaddr))), 0)
                      : c.multiaddr.length && (f.multiaddr = c.multiaddr)),
                  c.isCertified != null && (f.isCertified = Boolean(c.isCertified)),
                  f
                )
              }),
              (l.toObject = function (c, f) {
                f || (f = {})
                var p = {}
                return (
                  f.defaults &&
                    (f.bytes === String
                      ? (p.multiaddr = '')
                      : ((p.multiaddr = []), f.bytes !== Array && (p.multiaddr = s.newBuffer(p.multiaddr))),
                    (p.isCertified = !1)),
                  c.multiaddr != null &&
                    c.hasOwnProperty('multiaddr') &&
                    (p.multiaddr =
                      f.bytes === String
                        ? s.base64.encode(c.multiaddr, 0, c.multiaddr.length)
                        : f.bytes === Array
                        ? Array.prototype.slice.call(c.multiaddr)
                        : c.multiaddr),
                  c.isCertified != null && c.hasOwnProperty('isCertified') && (p.isCertified = c.isCertified),
                  p
                )
              }),
              (l.prototype.toJSON = function () {
                return this.constructor.toObject(this, t.util.toJSONOptions)
              }),
              l
            )
          })()),
          (o.CertifiedRecord = (function () {
            function l(a) {
              if (a) for (var c = Object.keys(a), f = 0; f < c.length; ++f) a[c[f]] != null && (this[c[f]] = a[c[f]])
            }
            return (
              (l.prototype.seq = s.Long ? s.Long.fromBits(0, 0, !0) : 0),
              (l.prototype.raw = s.newBuffer([])),
              (l.encode = function (c, f) {
                return (
                  f || (f = i.create()),
                  c.seq != null && Object.hasOwnProperty.call(c, 'seq') && f.uint32(8).uint64(c.seq),
                  c.raw != null && Object.hasOwnProperty.call(c, 'raw') && f.uint32(18).bytes(c.raw),
                  f
                )
              }),
              (l.decode = function (c, f) {
                c instanceof n || (c = n.create(c))
                for (var p = f === void 0 ? c.len : c.pos + f, y = new u.Addresses.CertifiedRecord(); c.pos < p; ) {
                  var d = c.uint32()
                  switch (d >>> 3) {
                    case 1:
                      y.seq = c.uint64()
                      break
                    case 2:
                      y.raw = c.bytes()
                      break
                    default:
                      c.skipType(d & 7)
                      break
                  }
                }
                return y
              }),
              (l.fromObject = function (c) {
                if (c instanceof u.Addresses.CertifiedRecord) return c
                var f = new u.Addresses.CertifiedRecord()
                return (
                  c.seq != null &&
                    (s.Long
                      ? ((f.seq = s.Long.fromValue(c.seq)).unsigned = !0)
                      : typeof c.seq == 'string'
                      ? (f.seq = parseInt(c.seq, 10))
                      : typeof c.seq == 'number'
                      ? (f.seq = c.seq)
                      : typeof c.seq == 'object' &&
                        (f.seq = new s.LongBits(c.seq.low >>> 0, c.seq.high >>> 0).toNumber(!0))),
                  c.raw != null &&
                    (typeof c.raw == 'string'
                      ? s.base64.decode(c.raw, (f.raw = s.newBuffer(s.base64.length(c.raw))), 0)
                      : c.raw.length && (f.raw = c.raw)),
                  f
                )
              }),
              (l.toObject = function (c, f) {
                f || (f = {})
                var p = {}
                if (f.defaults) {
                  if (s.Long) {
                    var y = new s.Long(0, 0, !0)
                    p.seq = f.longs === String ? y.toString() : f.longs === Number ? y.toNumber() : y
                  } else p.seq = f.longs === String ? '0' : 0
                  f.bytes === String ? (p.raw = '') : ((p.raw = []), f.bytes !== Array && (p.raw = s.newBuffer(p.raw)))
                }
                return (
                  c.seq != null &&
                    c.hasOwnProperty('seq') &&
                    (typeof c.seq == 'number'
                      ? (p.seq = f.longs === String ? String(c.seq) : c.seq)
                      : (p.seq =
                          f.longs === String
                            ? s.Long.prototype.toString.call(c.seq)
                            : f.longs === Number
                            ? new s.LongBits(c.seq.low >>> 0, c.seq.high >>> 0).toNumber(!0)
                            : c.seq)),
                  c.raw != null &&
                    c.hasOwnProperty('raw') &&
                    (p.raw =
                      f.bytes === String
                        ? s.base64.encode(c.raw, 0, c.raw.length)
                        : f.bytes === Array
                        ? Array.prototype.slice.call(c.raw)
                        : c.raw),
                  p
                )
              }),
              (l.prototype.toJSON = function () {
                return this.constructor.toObject(this, t.util.toJSONOptions)
              }),
              l
            )
          })()),
          o
        )
      })()),
        (r.exports = u)
    }
  }),
  oj = te({
    'node_modules/libp2p/src/peer-store/persistent/pb/proto-book.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-proto-book'] || (t.roots['libp2p-proto-book'] = {})
      ;(u.Protocols = (function () {
        function o(l) {
          if (((this.protocols = []), l))
            for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
        }
        return (
          (o.prototype.protocols = s.emptyArray),
          (o.encode = function (a, c) {
            if ((c || (c = i.create()), a.protocols != null && a.protocols.length))
              for (var f = 0; f < a.protocols.length; ++f) c.uint32(10).string(a.protocols[f])
            return c
          }),
          (o.decode = function (a, c) {
            a instanceof n || (a = n.create(a))
            for (var f = c === void 0 ? a.len : a.pos + c, p = new u.Protocols(); a.pos < f; ) {
              var y = a.uint32()
              switch (y >>> 3) {
                case 1:
                  ;(p.protocols && p.protocols.length) || (p.protocols = []), p.protocols.push(a.string())
                  break
                default:
                  a.skipType(y & 7)
                  break
              }
            }
            return p
          }),
          (o.fromObject = function (a) {
            if (a instanceof u.Protocols) return a
            var c = new u.Protocols()
            if (a.protocols) {
              if (!Array.isArray(a.protocols)) throw TypeError('.Protocols.protocols: array expected')
              c.protocols = []
              for (var f = 0; f < a.protocols.length; ++f) c.protocols[f] = String(a.protocols[f])
            }
            return c
          }),
          (o.toObject = function (a, c) {
            c || (c = {})
            var f = {}
            if (((c.arrays || c.defaults) && (f.protocols = []), a.protocols && a.protocols.length)) {
              f.protocols = []
              for (var p = 0; p < a.protocols.length; ++p) f.protocols[p] = a.protocols[p]
            }
            return f
          }),
          (o.prototype.toJSON = function () {
            return this.constructor.toObject(this, t.util.toJSONOptions)
          }),
          o
        )
      })()),
        (r.exports = u)
    }
  }),
  aj = te({
    'node_modules/libp2p/src/peer-store/persistent/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:persistent-peer-store'), { error: t('libp2p:persistent-peer-store:err') }),
        { Key: i } = RT(),
        { Multiaddr: s } = Zr(),
        u = er(),
        o = wk(),
        {
          NAMESPACE_ADDRESS: l,
          NAMESPACE_COMMON: a,
          NAMESPACE_KEYS: c,
          NAMESPACE_METADATA: f,
          NAMESPACE_PROTOCOL: p
        } = ij(),
        { Addresses: y } = sj(),
        { Protocols: d } = oj(),
        h = class extends o {
          constructor({ peerId: m, datastore: _, threshold: A = 5 }) {
            super({ peerId: m })
            ;(this._datastore = _),
              (this._dirtyPeers = new Set()),
              (this._dirtyMetadata = new Map()),
              (this.threshold = A),
              (this._addDirtyPeer = this._addDirtyPeer.bind(this))
          }
          async start() {
            n('PeerStore is starting'),
              this.on('change:protocols', this._addDirtyPeer),
              this.on('change:multiaddrs', this._addDirtyPeer),
              this.on('change:pubkey', this._addDirtyPeerKey),
              this.on('change:metadata', this._addDirtyPeerMetadata)
            for await (let m of this._datastore.query({ prefix: a })) await this._processDatastoreEntry(m)
            n('PeerStore started')
          }
          async stop() {
            n('PeerStore is stopping'), this.removeAllListeners(), await this._commitData(), n('PeerStore stopped')
          }
          _addDirtyPeer({ peerId: m }) {
            let _ = m.toB58String()
            n('add dirty peer', _),
              this._dirtyPeers.add(_),
              this._dirtyPeers.size >= this.threshold &&
                this._commitData().catch((A) => {
                  n.error('error committing data', A)
                })
          }
          _addDirtyPeerKey({ peerId: m }) {
            if (m.hasInlinePublicKey()) return
            let _ = m.toB58String()
            n('add dirty peer key', _),
              this._dirtyPeers.add(_),
              this._dirtyPeers.size >= this.threshold &&
                this._commitData().catch((A) => {
                  n.error('error committing data', A)
                })
          }
          _addDirtyPeerMetadata({ peerId: m, metadata: _ }) {
            let A = m.toB58String()
            n('add dirty metadata peer', A), this._dirtyPeers.add(A)
            let T = this._dirtyMetadata.get(A) || new Set()
            T.add(_),
              this._dirtyMetadata.set(A, T),
              this._dirtyPeers.size >= this.threshold &&
                this._commitData().catch((E) => {
                  n.error('error committing data', E)
                })
          }
          async _commitData() {
            let m = Array.from(this._dirtyPeers)
            if (!m.length) return
            this._dirtyPeers.clear(), n('create batch commit')
            let _ = this._datastore.batch()
            for (let A of m) {
              let T = this.keyBook.data.get(A) || u.createFromCID(A)
              this._batchAddressBook(T, _),
                !T.hasInlinePublicKey() && this._batchKeyBook(T, _),
                this._batchMetadataBook(T, _),
                this._batchProtoBook(T, _)
            }
            await _.commit(), n('batch committed')
          }
          _batchAddressBook(m, _) {
            let A = m.toString(),
              T = new i(`${l}${A}`),
              E = this.addressBook.data.get(m.toB58String())
            try {
              if (!E) {
                _.delete(T)
                return
              }
              let k = y
                .encode({
                  addrs: E.addresses.map((w) => ({ multiaddr: w.multiaddr.bytes, isCertified: w.isCertified })),
                  certifiedRecord: E.record ? { seq: E.record.seqNumber, raw: E.record.raw } : void 0
                })
                .finish()
              _.put(T, k)
            } catch (k) {
              n.error(k)
            }
          }
          _batchKeyBook(m, _) {
            let A = m.toString(),
              T = new i(`${c}${A}`)
            try {
              if (!m.pubKey) {
                _.delete(T)
                return
              }
              let E = m.marshalPubKey()
              _.put(T, E)
            } catch (E) {
              n.error(E)
            }
          }
          _batchMetadataBook(m, _) {
            let A = m.toString(),
              T = this._dirtyMetadata.get(m.toB58String()) || []
            try {
              T.forEach((E) => {
                let k = new i(`${f}${A}/${E}`),
                  w = this.metadataBook.getValue(m, E)
                w ? _.put(k, w) : _.delete(k)
              })
            } catch (E) {
              n.error(E)
            }
          }
          _batchProtoBook(m, _) {
            let A = m.toString(),
              T = new i(`${p}${A}`),
              E = this.protoBook.get(m)
            try {
              if (!E) {
                _.delete(T)
                return
              }
              let k = d.encode({ protocols: E }).finish()
              _.put(T, k)
            } catch (k) {
              n.error(k)
            }
          }
          async _processDatastoreEntry({ key: m, value: _ }) {
            try {
              let A = m.toString().split('/'),
                T = u.createFromCID(A[3]),
                E
              switch (A[2]) {
                case 'addrs':
                  ;(E = y.decode(_)),
                    this.addressBook._setData(
                      T,
                      {
                        addresses: E.addrs.map((k) => ({
                          multiaddr: new s(k.multiaddr),
                          isCertified: Boolean(k.isCertified)
                        })),
                        record: E.certifiedRecord
                          ? { raw: E.certifiedRecord.raw, seqNumber: E.certifiedRecord.seq }
                          : void 0
                      },
                      { emit: !1 }
                    )
                  break
                case 'keys':
                  ;(E = await u.createFromPubKey(_)), this.keyBook._setData(E, E, { emit: !1 })
                  break
                case 'metadata':
                  this.metadataBook._setValue(T, A[4], _, { emit: !1 })
                  break
                case 'protos':
                  ;(E = d.decode(_)), this.protoBook._setData(T, new Set(E.protocols), { emit: !1 })
                  break
                default:
                  n('invalid data persisted for: ', m.toString())
              }
            } catch (A) {
              n.error(A)
            }
          }
        }
      r.exports = h
    }
  }),
  cj = te({
    'node_modules/libp2p-interfaces/src/topology/index.js'(e, r) {
      V(), F()
      var t = () => {},
        n = Symbol.for('@libp2p/js-interfaces/topology'),
        i = class {
          constructor({ min: s = 0, max: u = 1 / 0, handlers: o = {} }) {
            ;(this.min = s),
              (this.max = u),
              (this._onConnect = o.onConnect || t),
              (this._onDisconnect = o.onDisconnect || t),
              (this.peers = new Set())
          }
          get [Symbol.toStringTag]() {
            return 'Topology'
          }
          get [n]() {
            return !0
          }
          static isTopology(s) {
            return Boolean(s && s[n])
          }
          set registrar(s) {
            this._registrar = s
          }
          disconnect(s) {
            this._onDisconnect(s)
          }
        }
      r.exports = i
    }
  }),
  uj = te({
    'node_modules/libp2p/src/registrar.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:registrar'), { error: t('libp2p:registrar:err') }),
        i = pt(),
        {
          codes: { ERR_INVALID_PARAMETERS: s }
        } = or(),
        u = cj(),
        o = class {
          constructor({ peerStore: l, connectionManager: a }) {
            ;(this.peerStore = l),
              (this.connectionManager = a),
              (this.topologies = new Map()),
              (this._handle = void 0),
              (this._onDisconnect = this._onDisconnect.bind(this)),
              this.connectionManager.on('peer:disconnect', this._onDisconnect)
          }
          get handle() {
            return this._handle
          }
          set handle(l) {
            this._handle = l
          }
          getConnection(l) {
            return this.connectionManager.get(l)
          }
          register(l) {
            if (!u.isTopology(l))
              throw (
                (n.error('topology must be an instance of interfaces/topology'),
                i(new Error('topology must be an instance of interfaces/topology'), s))
              )
            let a = (Math.random() * 1e9).toString(36) + Date.now()
            return this.topologies.set(a, l), (l.registrar = this), a
          }
          unregister(l) {
            return this.topologies.delete(l)
          }
          _onDisconnect(l) {
            for (let [, a] of this.topologies) a.disconnect(l.remotePeer)
          }
        }
      r.exports = o
    }
  }),
  lj = te({
    'node_modules/libp2p/src/ping/constants.js'(e, r) {
      V(), F(), (r.exports = { PROTOCOL: '/ipfs/ping/1.0.0', PING_LENGTH: 32 })
    }
  }),
  fj = te({
    'node_modules/libp2p/src/ping/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:ping'), { error: t('libp2p:ping:err') }),
        i = pt(),
        s = H1(),
        { pipe: u } = wn(),
        { toBuffer: o } = V1(),
        { collect: l, take: a } = _2(),
        c = vf(),
        { PROTOCOL: f, PING_LENGTH: p } = lj()
      async function y(m, _) {
        n('dialing %s to %s', f, _.toB58String ? _.toB58String() : _)
        let A = await m.dial(_),
          { stream: T } = await A.newStream(f),
          E = Date.now(),
          k = s.randomBytes(p),
          [w] = await u([k], T, (I) => a(1, I), o, l),
          v = Date.now()
        if (!c(k, w)) throw i(new Error('Received wrong ping ack'), 'ERR_WRONG_PING_ACK')
        return v - E
      }
      function d(m) {
        m.handle(f, ({ stream: _ }) => u(_, _))
      }
      function h(m) {
        m.unhandle(f)
      }
      ;(e = r.exports = y), (e.mount = d), (e.unmount = h)
    }
  }),
  dj = te({
    'node_modules/libp2p/src/identify/message.js'(e, r) {
      V(), F()
      var t = oi(),
        n = t.Reader,
        i = t.Writer,
        s = t.util,
        u = t.roots['libp2p-identify'] || (t.roots['libp2p-identify'] = {})
      ;(u.Identify = (function () {
        function o(l) {
          if (((this.listenAddrs = []), (this.protocols = []), l))
            for (var a = Object.keys(l), c = 0; c < a.length; ++c) l[a[c]] != null && (this[a[c]] = l[a[c]])
        }
        return (
          (o.prototype.protocolVersion = ''),
          (o.prototype.agentVersion = ''),
          (o.prototype.publicKey = s.newBuffer([])),
          (o.prototype.listenAddrs = s.emptyArray),
          (o.prototype.observedAddr = s.newBuffer([])),
          (o.prototype.protocols = s.emptyArray),
          (o.prototype.signedPeerRecord = s.newBuffer([])),
          (o.encode = function (a, c) {
            if (
              (c || (c = i.create()),
              a.publicKey != null && Object.hasOwnProperty.call(a, 'publicKey') && c.uint32(10).bytes(a.publicKey),
              a.listenAddrs != null && a.listenAddrs.length)
            )
              for (var f = 0; f < a.listenAddrs.length; ++f) c.uint32(18).bytes(a.listenAddrs[f])
            if (a.protocols != null && a.protocols.length)
              for (var f = 0; f < a.protocols.length; ++f) c.uint32(26).string(a.protocols[f])
            return (
              a.observedAddr != null &&
                Object.hasOwnProperty.call(a, 'observedAddr') &&
                c.uint32(34).bytes(a.observedAddr),
              a.protocolVersion != null &&
                Object.hasOwnProperty.call(a, 'protocolVersion') &&
                c.uint32(42).string(a.protocolVersion),
              a.agentVersion != null &&
                Object.hasOwnProperty.call(a, 'agentVersion') &&
                c.uint32(50).string(a.agentVersion),
              a.signedPeerRecord != null &&
                Object.hasOwnProperty.call(a, 'signedPeerRecord') &&
                c.uint32(66).bytes(a.signedPeerRecord),
              c
            )
          }),
          (o.decode = function (a, c) {
            a instanceof n || (a = n.create(a))
            for (var f = c === void 0 ? a.len : a.pos + c, p = new u.Identify(); a.pos < f; ) {
              var y = a.uint32()
              switch (y >>> 3) {
                case 5:
                  p.protocolVersion = a.string()
                  break
                case 6:
                  p.agentVersion = a.string()
                  break
                case 1:
                  p.publicKey = a.bytes()
                  break
                case 2:
                  ;(p.listenAddrs && p.listenAddrs.length) || (p.listenAddrs = []), p.listenAddrs.push(a.bytes())
                  break
                case 4:
                  p.observedAddr = a.bytes()
                  break
                case 3:
                  ;(p.protocols && p.protocols.length) || (p.protocols = []), p.protocols.push(a.string())
                  break
                case 8:
                  p.signedPeerRecord = a.bytes()
                  break
                default:
                  a.skipType(y & 7)
                  break
              }
            }
            return p
          }),
          (o.fromObject = function (a) {
            if (a instanceof u.Identify) return a
            var c = new u.Identify()
            if (
              (a.protocolVersion != null && (c.protocolVersion = String(a.protocolVersion)),
              a.agentVersion != null && (c.agentVersion = String(a.agentVersion)),
              a.publicKey != null &&
                (typeof a.publicKey == 'string'
                  ? s.base64.decode(a.publicKey, (c.publicKey = s.newBuffer(s.base64.length(a.publicKey))), 0)
                  : a.publicKey.length && (c.publicKey = a.publicKey)),
              a.listenAddrs)
            ) {
              if (!Array.isArray(a.listenAddrs)) throw TypeError('.Identify.listenAddrs: array expected')
              c.listenAddrs = []
              for (var f = 0; f < a.listenAddrs.length; ++f)
                typeof a.listenAddrs[f] == 'string'
                  ? s.base64.decode(
                      a.listenAddrs[f],
                      (c.listenAddrs[f] = s.newBuffer(s.base64.length(a.listenAddrs[f]))),
                      0
                    )
                  : a.listenAddrs[f].length && (c.listenAddrs[f] = a.listenAddrs[f])
            }
            if (
              (a.observedAddr != null &&
                (typeof a.observedAddr == 'string'
                  ? s.base64.decode(a.observedAddr, (c.observedAddr = s.newBuffer(s.base64.length(a.observedAddr))), 0)
                  : a.observedAddr.length && (c.observedAddr = a.observedAddr)),
              a.protocols)
            ) {
              if (!Array.isArray(a.protocols)) throw TypeError('.Identify.protocols: array expected')
              c.protocols = []
              for (var f = 0; f < a.protocols.length; ++f) c.protocols[f] = String(a.protocols[f])
            }
            return (
              a.signedPeerRecord != null &&
                (typeof a.signedPeerRecord == 'string'
                  ? s.base64.decode(
                      a.signedPeerRecord,
                      (c.signedPeerRecord = s.newBuffer(s.base64.length(a.signedPeerRecord))),
                      0
                    )
                  : a.signedPeerRecord.length && (c.signedPeerRecord = a.signedPeerRecord)),
              c
            )
          }),
          (o.toObject = function (a, c) {
            c || (c = {})
            var f = {}
            if (
              ((c.arrays || c.defaults) && ((f.listenAddrs = []), (f.protocols = [])),
              c.defaults &&
                (c.bytes === String
                  ? (f.publicKey = '')
                  : ((f.publicKey = []), c.bytes !== Array && (f.publicKey = s.newBuffer(f.publicKey))),
                c.bytes === String
                  ? (f.observedAddr = '')
                  : ((f.observedAddr = []), c.bytes !== Array && (f.observedAddr = s.newBuffer(f.observedAddr))),
                (f.protocolVersion = ''),
                (f.agentVersion = ''),
                c.bytes === String
                  ? (f.signedPeerRecord = '')
                  : ((f.signedPeerRecord = []),
                    c.bytes !== Array && (f.signedPeerRecord = s.newBuffer(f.signedPeerRecord)))),
              a.publicKey != null &&
                a.hasOwnProperty('publicKey') &&
                (f.publicKey =
                  c.bytes === String
                    ? s.base64.encode(a.publicKey, 0, a.publicKey.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.publicKey)
                    : a.publicKey),
              a.listenAddrs && a.listenAddrs.length)
            ) {
              f.listenAddrs = []
              for (var p = 0; p < a.listenAddrs.length; ++p)
                f.listenAddrs[p] =
                  c.bytes === String
                    ? s.base64.encode(a.listenAddrs[p], 0, a.listenAddrs[p].length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.listenAddrs[p])
                    : a.listenAddrs[p]
            }
            if (a.protocols && a.protocols.length) {
              f.protocols = []
              for (var p = 0; p < a.protocols.length; ++p) f.protocols[p] = a.protocols[p]
            }
            return (
              a.observedAddr != null &&
                a.hasOwnProperty('observedAddr') &&
                (f.observedAddr =
                  c.bytes === String
                    ? s.base64.encode(a.observedAddr, 0, a.observedAddr.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.observedAddr)
                    : a.observedAddr),
              a.protocolVersion != null &&
                a.hasOwnProperty('protocolVersion') &&
                (f.protocolVersion = a.protocolVersion),
              a.agentVersion != null && a.hasOwnProperty('agentVersion') && (f.agentVersion = a.agentVersion),
              a.signedPeerRecord != null &&
                a.hasOwnProperty('signedPeerRecord') &&
                (f.signedPeerRecord =
                  c.bytes === String
                    ? s.base64.encode(a.signedPeerRecord, 0, a.signedPeerRecord.length)
                    : c.bytes === Array
                    ? Array.prototype.slice.call(a.signedPeerRecord)
                    : a.signedPeerRecord),
              f
            )
          }),
          (o.prototype.toJSON = function () {
            return this.constructor.toObject(this, t.util.toJSONOptions)
          }),
          o
        )
      })()),
        (r.exports = u)
    }
  }),
  hj = te({
    'node_modules/libp2p/src/identify/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p:identify'), { error: t('libp2p:identify:err') }),
        i = pt(),
        s = Zc(),
        { pipe: u } = wn(),
        { collect: o, take: l, consume: a } = _2(),
        c = xs(),
        f = er(),
        { Multiaddr: p } = Zr(),
        { toBuffer: y } = V1(),
        d = dj(),
        h = m2(),
        m = b2(),
        { MULTICODEC_IDENTIFY: _, MULTICODEC_IDENTIFY_PUSH: A, PROTOCOL_VERSION: T } = lT(),
        { codes: E } = or(),
        k = class {
          constructor({ libp2p: v }) {
            ;(this._libp2p = v),
              (this.peerStore = v.peerStore),
              (this.addressManager = v.addressManager),
              (this.connectionManager = v.connectionManager),
              (this.peerId = v.peerId),
              (this.handleMessage = this.handleMessage.bind(this)),
              (this._host = { protocolVersion: T, ...v._options.host }),
              this.peerStore.metadataBook.set(this.peerId, 'AgentVersion', c(this._host.agentVersion)),
              this.peerStore.metadataBook.set(this.peerId, 'ProtocolVersion', c(this._host.protocolVersion)),
              this.connectionManager.on('peer:connect', (I) => {
                this.identify(I).catch(n.error)
              }),
              this.peerStore.on('change:multiaddrs', ({ peerId: I }) => {
                I.toString() === this.peerId.toString() && this.pushToPeerStore()
              }),
              this.peerStore.on('change:protocols', ({ peerId: I }) => {
                I.toString() === this.peerId.toString() && this.pushToPeerStore()
              })
          }
          async push(v) {
            let I = await this.peerStore.addressBook.getRawEnvelope(this.peerId),
              M = this._libp2p.multiaddrs.map((O) => O.bytes),
              q = this.peerStore.protoBook.get(this.peerId) || [],
              G = v.map(async (O) => {
                try {
                  let { stream: x } = await O.newStream(A)
                  await u(
                    [d.Identify.encode({ listenAddrs: M, signedPeerRecord: I, protocols: q }).finish()],
                    s.encode(),
                    x,
                    a
                  )
                } catch (x) {
                  n.error('could not push identify update to peer', x)
                }
              })
            return Promise.all(G)
          }
          pushToPeerStore() {
            if (!this._libp2p.isStarted()) return
            let v = [],
              I
            for (let M of this.peerStore.peers.values())
              M.protocols.includes(A) && (I = this.connectionManager.get(M.id)) && v.push(I)
            this.push(v)
          }
          async identify(v) {
            let { stream: I } = await v.newStream(_),
              [M] = await u([], I, s.decode(), l(1), y, o)
            if (!M) throw i(new Error('No data could be retrieved'), E.ERR_CONNECTION_ENDED)
            let q
            try {
              q = d.Identify.decode(M)
            } catch (Q) {
              throw i(Q, E.ERR_INVALID_MESSAGE)
            }
            let { publicKey: G, listenAddrs: O, protocols: x, observedAddr: L, signedPeerRecord: K } = q,
              J = await f.createFromPubKey(G)
            if (v.remotePeer.toB58String() !== J.toB58String())
              throw i(new Error('identified peer does not match the expected peer'), E.ERR_INVALID_PEER)
            let Z = k.getCleanMultiaddr(L)
            try {
              let Q = await h.openAndCertify(K, m.DOMAIN)
              if (this.peerStore.addressBook.consumePeerRecord(Q)) {
                this.peerStore.protoBook.set(J, x),
                  this.peerStore.metadataBook.set(J, 'AgentVersion', c(q.agentVersion)),
                  this.peerStore.metadataBook.set(J, 'ProtocolVersion', c(q.protocolVersion))
                return
              }
            } catch (Q) {
              n('received invalid envelope, discard it and fallback to listenAddrs is available', Q)
            }
            try {
              this.peerStore.addressBook.set(
                J,
                O.map((Q) => new p(Q))
              )
            } catch (Q) {
              n.error('received invalid addrs', Q)
            }
            this.peerStore.protoBook.set(J, x),
              this.peerStore.metadataBook.set(J, 'AgentVersion', c(q.agentVersion)),
              this.peerStore.metadataBook.set(J, 'ProtocolVersion', c(q.protocolVersion)),
              n('received observed address of %s', Z)
          }
          handleMessage({ connection: v, stream: I, protocol: M }) {
            switch (M) {
              case _:
                return this._handleIdentify({ connection: v, stream: I })
              case A:
                return this._handlePush({ connection: v, stream: I })
              default:
                n.error('cannot handle unknown protocol %s', M)
            }
          }
          async _handleIdentify({ connection: v, stream: I }) {
            let M = new Uint8Array(0)
            this.peerId.pubKey && (M = this.peerId.pubKey.bytes)
            let q = await this.peerStore.addressBook.getRawEnvelope(this.peerId),
              G = this.peerStore.protoBook.get(this.peerId) || [],
              O = d.Identify.encode({
                protocolVersion: this._host.protocolVersion,
                agentVersion: this._host.agentVersion,
                publicKey: M,
                listenAddrs: this._libp2p.multiaddrs.map((x) => x.bytes),
                signedPeerRecord: q,
                observedAddr: v.remoteAddr.bytes,
                protocols: G
              }).finish()
            try {
              await u([O], s.encode(), I, a)
            } catch (x) {
              n.error('could not respond to identify request', x)
            }
          }
          async _handlePush({ connection: v, stream: I }) {
            let M
            try {
              let [G] = await u([], I, s.decode(), l(1), y, o)
              M = d.Identify.decode(G)
            } catch (G) {
              return n.error('received invalid message', G)
            }
            let q = v.remotePeer
            try {
              let G = await h.openAndCertify(M.signedPeerRecord, m.DOMAIN)
              if (this.peerStore.addressBook.consumePeerRecord(G)) {
                this.peerStore.protoBook.set(q, M.protocols)
                return
              }
            } catch (G) {
              n('received invalid envelope, discard it and fallback to listenAddrs is available', G)
            }
            try {
              this.peerStore.addressBook.set(
                q,
                M.listenAddrs.map((G) => new p(G))
              )
            } catch (G) {
              n.error('received invalid addrs', G)
            }
            this.peerStore.protoBook.set(q, M.protocols)
          }
          static getCleanMultiaddr(v) {
            if (v && v.length > 0)
              try {
                return new p(v)
              } catch (I) {
                return null
              }
            return null
          }
        },
        w = { IDENTIFY: _, IDENTIFY_PUSH: A }
      ;(k.multicodecs = w), (k.Messsage = d), (r.exports = k)
    }
  }),
  pj = te({
    '(disabled):node_modules/@motrix/nat-api/index.js'() {
      V(), F()
    }
  }),
  mj = te({
    'node_modules/es6-promisify/dist/promisify.js'(e) {
      V(), F(), Object.defineProperty(e, '__esModule', { value: !0 }), (e.promisify = t)
      var r = '__ES6-PROMISIFY--CUSTOM-ARGUMENTS__'
      function t(n) {
        if (typeof n != 'function') throw new TypeError('Argument to promisify must be a function')
        var i = n[r],
          s = t.Promise || Promise
        if (typeof s != 'function') throw new Error('No Promise implementation found; do you need a polyfill?')
        return function () {
          for (var u = this, o = arguments.length, l = new Array(o), a = 0; a < o; a++) l[a] = arguments[a]
          return new s(function (c, f) {
            l.push(function (y) {
              if (y) return f(y)
              for (var d = arguments.length, h = new Array(d > 1 ? d - 1 : 0), m = 1; m < d; m++)
                h[m - 1] = arguments[m]
              if (h.length === 1 || !i) return c(h[0])
              var _ = {}
              h.forEach(function (A, T) {
                var E = i[T]
                E && (_[E] = A)
              }),
                c(_)
            }),
              n.apply(u, l)
          })
        }
      }
      ;(t.argumentNames = r), (t.Promise = void 0)
    }
  }),
  bj = te({
    'node_modules/wherearewe/src/index.js'(e, r) {
      V(), F()
      var t = b3(),
        n = typeof window == 'object' && typeof document == 'object' && document.nodeType === 9,
        i = t(),
        s = n && !i,
        u = i && !n,
        o = i && n,
        l =
          typeof c0 == 'function' &&
          typeof lt != 'undefined' &&
          typeof lt.release != 'undefined' &&
          lt.release.name === 'node' &&
          !i,
        a =
          typeof importScripts == 'function' &&
          typeof self != 'undefined' &&
          typeof WorkerGlobalScope != 'undefined' &&
          self instanceof WorkerGlobalScope,
        c = typeof lt != 'undefined' && typeof lt.env != 'undefined' && !1
      r.exports = {
        isTest: c,
        isElectron: i,
        isElectronMain: u,
        isElectronRenderer: o,
        isNode: l,
        isBrowser: s,
        isWebWorker: a,
        isEnvWithDom: n
      }
    }
  }),
  yj = te({
    'node_modules/retry/lib/retry_operation.js'(e, r) {
      V(), F()
      function t(n, i) {
        typeof i == 'boolean' && (i = { forever: i }),
          (this._originalTimeouts = JSON.parse(JSON.stringify(n))),
          (this._timeouts = n),
          (this._options = i || {}),
          (this._maxRetryTime = (i && i.maxRetryTime) || 1 / 0),
          (this._fn = null),
          (this._errors = []),
          (this._attempts = 1),
          (this._operationTimeout = null),
          (this._operationTimeoutCb = null),
          (this._timeout = null),
          (this._operationStart = null),
          (this._timer = null),
          this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0))
      }
      ;(r.exports = t),
        (t.prototype.reset = function () {
          ;(this._attempts = 1), (this._timeouts = this._originalTimeouts.slice(0))
        }),
        (t.prototype.stop = function () {
          this._timeout && clearTimeout(this._timeout),
            this._timer && clearTimeout(this._timer),
            (this._timeouts = []),
            (this._cachedTimeouts = null)
        }),
        (t.prototype.retry = function (n) {
          if ((this._timeout && clearTimeout(this._timeout), !n)) return !1
          var i = new Date().getTime()
          if (n && i - this._operationStart >= this._maxRetryTime)
            return this._errors.push(n), this._errors.unshift(new Error('RetryOperation timeout occurred')), !1
          this._errors.push(n)
          var s = this._timeouts.shift()
          if (s === void 0)
            if (this._cachedTimeouts)
              this._errors.splice(0, this._errors.length - 1), (s = this._cachedTimeouts.slice(-1))
            else return !1
          var u = this
          return (
            (this._timer = setTimeout(function () {
              u._attempts++,
                u._operationTimeoutCb &&
                  ((u._timeout = setTimeout(function () {
                    u._operationTimeoutCb(u._attempts)
                  }, u._operationTimeout)),
                  u._options.unref && u._timeout.unref()),
                u._fn(u._attempts)
            }, s)),
            this._options.unref && this._timer.unref(),
            !0
          )
        }),
        (t.prototype.attempt = function (n, i) {
          ;(this._fn = n),
            i && (i.timeout && (this._operationTimeout = i.timeout), i.cb && (this._operationTimeoutCb = i.cb))
          var s = this
          this._operationTimeoutCb &&
            (this._timeout = setTimeout(function () {
              s._operationTimeoutCb()
            }, s._operationTimeout)),
            (this._operationStart = new Date().getTime()),
            this._fn(this._attempts)
        }),
        (t.prototype.try = function (n) {
          console.log('Using RetryOperation.try() is deprecated'), this.attempt(n)
        }),
        (t.prototype.start = function (n) {
          console.log('Using RetryOperation.start() is deprecated'), this.attempt(n)
        }),
        (t.prototype.start = t.prototype.try),
        (t.prototype.errors = function () {
          return this._errors
        }),
        (t.prototype.attempts = function () {
          return this._attempts
        }),
        (t.prototype.mainError = function () {
          if (this._errors.length === 0) return null
          for (var n = {}, i = null, s = 0, u = 0; u < this._errors.length; u++) {
            var o = this._errors[u],
              l = o.message,
              a = (n[l] || 0) + 1
            ;(n[l] = a), a >= s && ((i = o), (s = a))
          }
          return i
        })
    }
  }),
  vj = te({
    'node_modules/retry/lib/retry.js'(e) {
      V(), F()
      var r = yj()
      ;(e.operation = function (t) {
        var n = e.timeouts(t)
        return new r(n, {
          forever: t && (t.forever || t.retries === 1 / 0),
          unref: t && t.unref,
          maxRetryTime: t && t.maxRetryTime
        })
      }),
        (e.timeouts = function (t) {
          if (t instanceof Array) return [].concat(t)
          var n = { retries: 10, factor: 2, minTimeout: 1 * 1e3, maxTimeout: 1 / 0, randomize: !1 }
          for (var i in t) n[i] = t[i]
          if (n.minTimeout > n.maxTimeout) throw new Error('minTimeout is greater than maxTimeout')
          for (var s = [], u = 0; u < n.retries; u++) s.push(this.createTimeout(u, n))
          return (
            t && t.forever && !s.length && s.push(this.createTimeout(u, n)),
            s.sort(function (o, l) {
              return o - l
            }),
            s
          )
        }),
        (e.createTimeout = function (t, n) {
          var i = n.randomize ? Math.random() + 1 : 1,
            s = Math.round(i * Math.max(n.minTimeout, 1) * Math.pow(n.factor, t))
          return (s = Math.min(s, n.maxTimeout)), s
        }),
        (e.wrap = function (t, n, i) {
          if ((n instanceof Array && ((i = n), (n = null)), !i)) {
            i = []
            for (var s in t) typeof t[s] == 'function' && i.push(s)
          }
          for (var u = 0; u < i.length; u++) {
            var o = i[u],
              l = t[o]
            ;(t[o] = function (c) {
              var f = e.operation(n),
                p = Array.prototype.slice.call(arguments, 1),
                y = p.pop()
              p.push(function (d) {
                f.retry(d) || (d && (arguments[0] = f.mainError()), y.apply(this, arguments))
              }),
                f.attempt(function () {
                  c.apply(t, p)
                })
            }.bind(t, l)),
              (t[o].options = n)
          }
        })
    }
  }),
  gj = te({
    'node_modules/retry/index.js'(e, r) {
      V(), F(), (r.exports = vj())
    }
  }),
  wj = te({
    'node_modules/p-retry/index.js'(e, r) {
      V(), F()
      var t = gj(),
        n = [
          'Failed to fetch',
          'NetworkError when attempting to fetch resource.',
          'The Internet connection appears to be offline.',
          'Network request failed'
        ],
        i = class extends Error {
          constructor(l) {
            super()
            l instanceof Error
              ? ((this.originalError = l), ({ message: l } = l))
              : ((this.originalError = new Error(l)), (this.originalError.stack = this.stack)),
              (this.name = 'AbortError'),
              (this.message = l)
          }
        },
        s = (l, a, c) => {
          let f = c.retries - (a - 1)
          return (l.attemptNumber = a), (l.retriesLeft = f), l
        },
        u = (l) => n.includes(l),
        o = (l, a) =>
          new Promise((c, f) => {
            a = { onFailedAttempt: () => {}, retries: 10, ...a }
            let p = t.operation(a)
            p.attempt(async (y) => {
              try {
                c(await l(y))
              } catch (d) {
                if (!(d instanceof Error)) {
                  f(new TypeError(`Non-error was thrown: "${d}". You should only throw errors.`))
                  return
                }
                if (d instanceof i) p.stop(), f(d.originalError)
                else if (d instanceof TypeError && !u(d.message)) p.stop(), f(d)
                else {
                  s(d, y, a)
                  try {
                    await a.onFailedAttempt(d)
                  } catch (h) {
                    f(h)
                    return
                  }
                  p.retry(d) || f(p.mainError())
                }
              }
            })
          })
      ;(r.exports = o), (r.exports.default = o), (r.exports.AbortError = i)
    }
  }),
  _j = te({
    'node_modules/is-loopback-addr/index.js'(e, r) {
      V(), F()
      function t(n) {
        return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(n) || /^::1$/.test(n)
      }
      r.exports = t
    }
  }),
  Ej = te({
    'node_modules/libp2p-utils/src/multiaddr/is-loopback.js'(e, r) {
      V(), F()
      var t = _j()
      function n(i) {
        let { address: s } = i.nodeAddress()
        return t(s)
      }
      r.exports = n
    }
  }),
  Sj = te({
    'node_modules/libp2p/src/nat-manager.js'(e, r) {
      V(), F()
      var t = pj(),
        n = mt(),
        { promisify: i } = mj(),
        { Multiaddr: s } = Zr(),
        u = Object.assign(n('libp2p:nat'), { error: n('libp2p:nat:err') }),
        { isBrowser: o } = bj(),
        l = wj(),
        a = fT(),
        c = uT(),
        f = pt(),
        {
          codes: { ERR_INVALID_PARAMETERS: p }
        } = or(),
        y = Ej(),
        d = 7200
      function h(_ = 1024, A = 65535) {
        return Math.floor(Math.random() * (A - _ + 1) + _)
      }
      var m = class {
        constructor({ peerId: _, addressManager: A, transportManager: T, ...E }) {
          if (
            ((this._peerId = _),
            (this._addressManager = A),
            (this._transportManager = T),
            (this._enabled = E.enabled),
            (this._externalIp = E.externalIp),
            (this._options = {
              description: E.description || `${c.name}@${c.version} ${this._peerId}`,
              ttl: E.ttl || d,
              autoUpdate: E.keepAlive || !0,
              gateway: E.gateway,
              enablePMP: Boolean(E.pmp && E.pmp.enabled)
            }),
            this._options.ttl < d)
          )
            throw f(new Error(`NatManager ttl should be at least ${d} seconds`), p)
        }
        start() {
          o ||
            !this._enabled ||
            this._start().catch((_) => {
              u.error(_)
            })
        }
        async _start() {
          let _ = this._transportManager.getAddrs()
          for (let A of _) {
            let { family: T, host: E, port: k, transport: w } = A.toOptions()
            if (!A.isThinWaistAddress() || w !== 'tcp' || y(A) || T !== 4) continue
            let v = this._getClient(),
              I = this._externalIp || (await v.externalIp())
            if (a(I))
              throw new Error(
                `${I} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`
              )
            let M = h()
            u(`opening uPnP connection from ${I}:${M} to ${E}:${k}`),
              await v.map({ publicPort: M, privatePort: k, protocol: w.toUpperCase() }),
              this._addressManager.addObservedAddr(s.fromNodeAddress({ family: 4, address: I, port: M }, w))
          }
        }
        _getClient() {
          if (this._client) return this._client
          let _ = new t(this._options),
            A = i(_.map.bind(_)),
            T = i(_.destroy.bind(_)),
            E = i(_.externalIp.bind(_))
          return (
            (this._client = {
              map: (...k) => l(() => A(...k), { onFailedAttempt: u.error, unref: !0 }),
              destroy: (...k) => l(() => T(...k), { onFailedAttempt: u.error, unref: !0 }),
              externalIp: (...k) => l(() => E(...k), { onFailedAttempt: u.error, unref: !0 })
            }),
            this._client
          )
        }
        async stop() {
          if (!(o || !this._client))
            try {
              await this._client.destroy(), (this._client = null)
            } catch (_) {
              u.error(_)
            }
        }
      }
      r.exports = m
    }
  }),
  Aj = te({
    'node_modules/libp2p/src/index.js'(e, r) {
      V(), F()
      var t = mt(),
        n = Object.assign(t('libp2p'), { error: t('libp2p:err') }),
        { EventEmitter: i } = ln(),
        s = pt(),
        u = er(),
        { Multiaddr: o } = Zr(),
        l = YL(),
        a = ZL(),
        c = cT(),
        { validate: f } = yU(),
        { codes: p, messages: y } = or(),
        d = vU(),
        h = EU(),
        m = IU(),
        _ = UU(),
        A = YU(),
        T = pq(),
        E = wq(),
        k = pT(),
        w = Zq(),
        v = wk(),
        I = nj(),
        M = aj(),
        q = uj(),
        G = fj(),
        O = hj(),
        x = O.multicodecs,
        L = Sj(),
        { updateSelfPeerRecord: K } = hT(),
        J = class extends i {
          static async create(Z) {
            if (Z.peerId) return new J(Z)
            let Q = await u.create()
            return (Z.peerId = Q), new J(Z)
          }
          constructor(Z) {
            super()
            if (
              ((this._options = f(Z)),
              (this.peerId = this._options.peerId),
              (this.datastore = this._options.datastore),
              (this.peerStore =
                this.datastore && this._options.peerStore.persistence
                  ? new M({ peerId: this.peerId, datastore: this.datastore, ...this._options.peerStore })
                  : new v({ peerId: this.peerId })),
              (this.addresses = this._options.addresses),
              (this.addressManager = new d(this.peerId, this._options.addresses)),
              this.addressManager.on('change:addresses', () => {
                K(this).catch((fe) => {
                  n.error('Error updating self peer record', fe)
                })
              }),
              (this._modules = this._options.modules),
              (this._config = this._options.config),
              (this._transport = []),
              (this._discovery = new Map()),
              (this.connectionManager = new h(this, {
                autoDial: this._config.peerDiscovery.autoDial,
                ...this._options.connectionManager
              })),
              this._options.metrics.enabled &&
                (this.metrics = new E({ ...this._options.metrics, connectionManager: this.connectionManager })),
              this._options.keychain && this._options.keychain.datastore)
            ) {
              n('creating keychain')
              let fe = T.generateOptions()
              ;(this.keychain = new T(this._options.keychain.datastore, { ...fe, ...this._options.keychain })),
                n('keychain constructed')
            }
            if (
              ((this.upgrader = new w({
                localPeer: this.peerId,
                metrics: this.metrics,
                onConnection: (fe) => this.connectionManager.onConnect(fe),
                onConnectionEnd: (fe) => this.connectionManager.onDisconnect(fe)
              })),
              (this.transportManager = new k({
                libp2p: this,
                upgrader: this.upgrader,
                faultTolerance: this._options.transportManager.faultTolerance
              })),
              (this.natManager = new L({
                peerId: this.peerId,
                addressManager: this.addressManager,
                transportManager: this.transportManager,
                ...this._options.config.nat
              })),
              (this.registrar = new q({ peerStore: this.peerStore, connectionManager: this.connectionManager })),
              (this.handle = this.handle.bind(this)),
              (this.registrar.handle = this.handle),
              !this._modules.connEncryption || !this._modules.connEncryption.length)
            )
              throw s(new Error(y.CONN_ENCRYPTION_REQUIRED), p.CONN_ENCRYPTION_REQUIRED)
            if (
              (this._modules.connEncryption.forEach((fe) => {
                this.upgrader.cryptos.set(fe.protocol, fe)
              }),
              (this.dialer = new A({
                transportManager: this.transportManager,
                peerStore: this.peerStore,
                ...this._options.dialer
              })),
              this._modules.transport.forEach((fe) => {
                let ie = fe.prototype[Symbol.toStringTag],
                  W = this._config.transport[ie]
                this.transportManager.add(ie, fe, W)
              }),
              this._config.relay.enabled &&
                (this.transportManager.add(m.prototype[Symbol.toStringTag], m), (this.relay = new _(this))),
              this._modules.streamMuxer &&
                (this._modules.streamMuxer.forEach((ie) => {
                  this.upgrader.muxers.set(ie.multicodec, ie)
                }),
                (this.identifyService = new O({ libp2p: this })),
                this.handle(Object.values(x), this.identifyService.handleMessage)),
              this._modules.connProtector)
            )
              this.upgrader.protector = this._modules.connProtector
            else if (
              globalThis.process !== void 0 &&
              globalThis.process.env &&
              globalThis.process.env.LIBP2P_FORCE_PNET
            )
              throw new Error('Private network is enforced, but no protector was provided')
            if (this._modules.dht) {
              let fe = this._modules.dht
              this._dht = new fe({
                libp2p: this,
                dialer: this.dialer,
                peerId: this.peerId,
                peerStore: this.peerStore,
                registrar: this.registrar,
                datastore: this.datastore,
                ...this._config.dht
              })
            }
            if (this._modules.pubsub) {
              let fe = this._modules.pubsub
              this.pubsub = I(fe, this, this._config.pubsub)
            }
            ;(this.peerRouting = new l(this)),
              (this.contentRouting = new a(this)),
              G.mount(this),
              (this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this))
          }
          emit(Z, ...Q) {
            return Z === 'error' && !this._events.error ? (n.error(Q), !1) : super.emit(Z, ...Q)
          }
          async start() {
            n('libp2p is starting')
            try {
              await this._onStarting(), await this._onDidStart(), n('libp2p has started')
            } catch (Z) {
              throw (this.emit('error', Z), n.error('An error occurred starting libp2p', Z), await this.stop(), Z)
            }
          }
          async stop() {
            n('libp2p is stopping')
            try {
              ;(this._isStarted = !1), this.relay && this.relay.stop(), this.peerRouting.stop()
              for (let Z of this._discovery.values()) Z.removeListener('peer', this._onDiscoveryPeer)
              await Promise.all(Array.from(this._discovery.values(), (Z) => Z.stop())),
                (this._discovery = new Map()),
                await this.peerStore.stop(),
                await this.connectionManager.stop(),
                await Promise.all([
                  this.pubsub && this.pubsub.stop(),
                  this._dht && this._dht.stop(),
                  this.metrics && this.metrics.stop()
                ]),
                await this.natManager.stop(),
                await this.transportManager.close(),
                G.unmount(this),
                this.dialer.destroy()
            } catch (Z) {
              Z && (n.error(Z), this.emit('error', Z))
            }
            n('libp2p has stopped')
          }
          async loadKeychain() {
            if (!!this.keychain)
              try {
                await this.keychain.findKeyByName('self')
              } catch (Z) {
                await this.keychain.importPeer('self', this.peerId)
              }
          }
          isStarted() {
            return this._isStarted
          }
          get connections() {
            return this.connectionManager.connections
          }
          dial(Z, Q) {
            return this._dial(Z, Q)
          }
          async dialProtocol(Z, Q, fe) {
            if (!Q || !Q.length)
              throw s(new Error('no protocols were provided to open a stream'), p.ERR_INVALID_PROTOCOLS_FOR_STREAM)
            return (await this._dial(Z, fe)).newStream(Q)
          }
          async _dial(Z, Q) {
            let { id: fe, multiaddrs: ie } = c(Z)
            if (fe.equals(this.peerId)) throw s(new Error('Cannot dial self'), p.ERR_DIALED_SELF)
            let W = this.connectionManager.get(fe)
            return W ? ie && this.peerStore.addressBook.add(fe, ie) : (W = await this.dialer.connectToPeer(Z, Q)), W
          }
          get multiaddrs() {
            let Z = this.addressManager.getAnnounceAddrs().map((ie) => ie.toString())
            Z.length || (Z = this.transportManager.getAddrs().map((ie) => ie.toString())),
              (Z = Z.concat(this.addressManager.getObservedAddrs().map((ie) => ie.toString())))
            let Q = this._options.addresses.announceFilter,
              fe = new Set(Z)
            return Q(Array.from(fe).map((ie) => new o(ie)))
          }
          async hangUp(Z) {
            let { id: Q } = c(Z),
              fe = this.connectionManager.connections.get(Q.toB58String())
            !fe || (await Promise.all(fe.map((ie) => ie.close())))
          }
          ping(Z) {
            let { id: Q, multiaddrs: fe } = c(Z)
            return fe ? G(this, fe[0]) : G(this, Q)
          }
          handle(Z, Q) {
            ;(Z = Array.isArray(Z) ? Z : [Z]),
              Z.forEach((fe) => {
                this.upgrader.protocols.set(fe, Q)
              }),
              this.peerStore.protoBook.add(this.peerId, Z)
          }
          unhandle(Z) {
            ;(Z = Array.isArray(Z) ? Z : [Z]),
              Z.forEach((Q) => {
                this.upgrader.protocols.delete(Q)
              }),
              this.peerStore.protoBook.remove(this.peerId, Z)
          }
          async _onStarting() {
            let Z = this.addressManager.getListenAddrs()
            await this.transportManager.listen(Z),
              this.natManager.start(),
              await this.peerStore.start(),
              this._config.pubsub.enabled && this.pubsub && this.pubsub.start(),
              this._config.dht.enabled && (this._dht && this._dht.start(), this._dht.on('peer', this._onDiscoveryPeer)),
              this.metrics && this.metrics.start()
          }
          async _onDidStart() {
            ;(this._isStarted = !0),
              this.peerStore.on('peer', (Z) => {
                this.emit('peer:discovery', Z), this._maybeConnect(Z)
              })
            for (let Z of this.peerStore.peers.values()) this.emit('peer:discovery', Z.id)
            this.connectionManager.start(),
              await this._setupPeerDiscovery(),
              this.relay && this.relay.start(),
              this.peerRouting.start()
          }
          _onDiscoveryPeer(Z) {
            if (Z.id.toB58String() === this.peerId.toB58String()) {
              n.error(new Error(p.ERR_DISCOVERED_SELF))
              return
            }
            Z.multiaddrs && this.peerStore.addressBook.add(Z.id, Z.multiaddrs),
              Z.protocols && this.peerStore.protoBook.set(Z.id, Z.protocols)
          }
          async _maybeConnect(Z) {
            if (
              this._config.peerDiscovery.autoDial === !0 &&
              !this.connectionManager.get(Z) &&
              (this._options.connectionManager.minConnections || 0) > this.connectionManager.size
            ) {
              n('connecting to discovered peer %s', Z.toB58String())
              try {
                await this.dialer.connectToPeer(Z)
              } catch (fe) {
                n.error(`could not connect to discovered peer ${Z.toB58String()} with ${fe}`)
              }
            }
          }
          async _setupPeerDiscovery() {
            let Z = (Q) => {
              let fe = { enabled: !0 }
              if (
                (Q.tag &&
                  this._config.peerDiscovery &&
                  this._config.peerDiscovery[Q.tag] &&
                  (fe = { ...fe, ...this._config.peerDiscovery[Q.tag] }),
                fe.enabled && !this._discovery.has(Q.tag))
              ) {
                let ie
                typeof Q == 'function'
                  ? (ie = new Q(Object.assign({}, fe, { peerId: this.peerId, libp2p: this })))
                  : (ie = Q),
                  ie.on('peer', this._onDiscoveryPeer),
                  this._discovery.set(Q.tag, ie)
              }
            }
            for (let Q of this._modules.peerDiscovery || []) Z(Q)
            for (let Q of this.transportManager.getTransports()) Q.discovery && Z(Q.discovery)
            await Promise.all(Array.from(this._discovery.values(), (Q) => Q.start()))
          }
        }
      r.exports = J
    }
  })
V()
F()
V()
F()
V()
F()
function K2() {
  let e,
    r = new Promise((t) => {
      e = t
    })
  if (e !== void 0) return [r, e]
  throw 'Something Wrong'
}
function F2() {
  let e = K2(),
    r = [e],
    t = {},
    n = (u) => {
      let [o, l] = e
      l(u), (e = K2()), r.unshift(e)
    },
    i = async function* () {
      for (; r.length > 0; ) {
        let [u] = r.pop()
        ;(await u) !== t && (yield u), globalThis?.process?.env?.VERBOSE && console.debug(`In queue: ${r.length}`)
      }
    },
    s = () => {
      let [u, o] = e
      o(t)
    }
  return [i(), n, s]
}
function Ij(e) {
  let [r, t, n] = F2()
  return e.subscribe(t, (i) => t(Promise.reject(i)), n), r
}
function _k(e) {
  if (typeof e[Symbol.asyncIterator] == 'function') return e
  if (typeof e.subscribe == 'function') return Ij(e)
  let r
  return (
    typeof e[Symbol.iterator] == 'function'
      ? (r = async function* () {
          for (let t of e) yield await t
        })
      : (r = async function* () {
          yield await e
        }),
    r()
  )
}
function Tf(e) {
  return typeof e == 'undefined' ? (r) => _k(r) : _k(e)
}
function Tj(e, r) {
  let t = 0,
    [n, i, s] = F2(),
    [u, o, l] = F2()
  return (
    (async () => {
      for await (let c of r) t == e && s(), t < e ? i(c) : o(c), t++
      s(), l()
    })(),
    [n, u]
  )
}
async function Ek(e, r) {
  let t = 0
  for await (let n of r) {
    if (t == e) return n
    t++
  }
  throw new ReferenceError(`Index ${e} not found in iterable`)
}
function Sk(e, r) {
  return r ? Ek(e, r) : (t) => Ek(e, t)
}
function Cj(e) {
  return e ? Sk(0, e) : Sk(0)
}
V()
F()
var sa = {}
Re(sa, {
  PROTOCOL: () => Cf,
  handleFile: () => Bz,
  incomingFiles: () => Xk,
  receiveContent: () => Cz,
  receiveMeta: () => Rz,
  sendFile: () => Sz,
  setContentRetrievalMethod: () => Tz,
  setMetaRetrievalMethod: () => xz
})
V()
F()
V()
F()
var Cf = 'fx/file/0.1.0'
V()
F()
var V2 = Yr(Ol())
V()
F()
async function kj(e) {
  for await (let r of e);
}
function Mj(e) {
  if (e[Symbol.asyncIterator]) return kj(e)
  for (let r of e);
}
async function* Ak(e, r) {
  for await (let t of r) yield await e(t)
}
function Ik(e, r) {
  return r === void 0 ? (t) => Ak(e, t) : Ak(e, r)
}
function xj(e, ...r) {
  let t = e()
  for (let n of r) t = n(t)
  return t
}
V()
F()
V()
F()
V()
F()
function Tk(e) {
  let r = typeof e
  if (r == 'object') {
    if (Array.isArray(e)) return 'array'
    if (e === null) return 'null'
  }
  return r
}
function Rj(e) {
  return e !== null && typeof e == 'object' && !Array.isArray(e)
}
V()
F()
var di = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split(''),
  kf = []
for (let e = 0; e < di.length; e++) kf[di[e].charCodeAt(0)] = e
kf['-'.charCodeAt(0)] = di.indexOf('+')
kf['_'.charCodeAt(0)] = di.indexOf('/')
function Bj(e) {
  let r = (e.length * 3) / 4
  e[e.length - 2] == '=' ? (r -= 2) : e[e.length - 1] == '=' && (r -= 1)
  let t = new Uint8Array(r),
    n = 0,
    i = 0,
    s,
    u = 0
  for (let o = 0; o < e.length; o++) {
    if (((s = kf[e.charCodeAt(o)]), s === void 0))
      switch (e[o]) {
        case '=':
          i = 0
        case `
`:
        case '\r':
        case '	':
        case ' ':
          continue
        default:
          throw Error('invalid base64 string.')
      }
    switch (i) {
      case 0:
        ;(u = s), (i = 1)
        break
      case 1:
        ;(t[n++] = (u << 2) | ((s & 48) >> 4)), (u = s), (i = 2)
        break
      case 2:
        ;(t[n++] = ((u & 15) << 4) | ((s & 60) >> 2)), (u = s), (i = 3)
        break
      case 3:
        ;(t[n++] = ((u & 3) << 6) | s), (i = 0)
        break
    }
  }
  if (i == 1) throw Error('invalid base64 string.')
  return t.subarray(0, n)
}
function Nj(e) {
  let r = '',
    t = 0,
    n,
    i = 0
  for (let s = 0; s < e.length; s++)
    switch (((n = e[s]), t)) {
      case 0:
        ;(r += di[n >> 2]), (i = (n & 3) << 4), (t = 1)
        break
      case 1:
        ;(r += di[i | (n >> 4)]), (i = (n & 15) << 2), (t = 2)
        break
      case 2:
        ;(r += di[i | (n >> 6)]), (r += di[n & 63]), (t = 0)
        break
    }
  return t && ((r += di[i]), (r += '='), t == 1 && (r += '=')), r
}
V()
F()
var H2 = (e) => String.fromCharCode.apply(String, e)
function Pj(e) {
  if (e.length < 1) return ''
  let r = 0,
    t = [],
    n = [],
    i = 0,
    s,
    u = e.length
  for (; r < u; )
    (s = e[r++]),
      s < 128
        ? (n[i++] = s)
        : s > 191 && s < 224
        ? (n[i++] = ((s & 31) << 6) | (e[r++] & 63))
        : s > 239 && s < 365
        ? ((s = (((s & 7) << 18) | ((e[r++] & 63) << 12) | ((e[r++] & 63) << 6) | (e[r++] & 63)) - 65536),
          (n[i++] = 55296 + (s >> 10)),
          (n[i++] = 56320 + (s & 1023)))
        : (n[i++] = ((s & 15) << 12) | ((e[r++] & 63) << 6) | (e[r++] & 63)),
      i > 8191 && (t.push(H2(n)), (i = 0))
  return t.length ? (i && t.push(H2(n.slice(0, i))), t.join('')) : H2(n.slice(0, i))
}
V()
F()
V()
F()
V()
F()
V()
F()
function Oj() {
  let e = 0,
    r = 0
  for (let n = 0; n < 28; n += 7) {
    let i = this.buf[this.pos++]
    if (((e |= (i & 127) << n), (i & 128) == 0)) return this.assertBounds(), [e, r]
  }
  let t = this.buf[this.pos++]
  if (((e |= (t & 15) << 28), (r = (t & 112) >> 4), (t & 128) == 0)) return this.assertBounds(), [e, r]
  for (let n = 3; n <= 31; n += 7) {
    let i = this.buf[this.pos++]
    if (((r |= (i & 127) << n), (i & 128) == 0)) return this.assertBounds(), [e, r]
  }
  throw new Error('invalid varint')
}
function $2(e, r, t) {
  for (let s = 0; s < 28; s = s + 7) {
    let u = e >>> s,
      o = !(u >>> 7 == 0 && r == 0),
      l = (o ? u | 128 : u) & 255
    if ((t.push(l), !o)) return
  }
  let n = ((e >>> 28) & 15) | ((r & 7) << 4),
    i = r >> 3 != 0
  if ((t.push((i ? n | 128 : n) & 255), !!i)) {
    for (let s = 3; s < 31; s = s + 7) {
      let u = r >>> s,
        o = u >>> 7 != 0,
        l = (o ? u | 128 : u) & 255
      if ((t.push(l), !o)) return
    }
    t.push((r >>> 31) & 1)
  }
}
var Mf = (1 << 16) * (1 << 16)
function Ck(e) {
  let r = e[0] == '-'
  r && (e = e.slice(1))
  let t = 1e6,
    n = 0,
    i = 0
  function s(u, o) {
    let l = Number(e.slice(u, o))
    ;(i *= t), (n = n * t + l), n >= Mf && ((i = i + ((n / Mf) | 0)), (n = n % Mf))
  }
  return s(-24, -18), s(-18, -12), s(-12, -6), s(-6), [r, n, i]
}
function G2(e, r) {
  if (r <= 2097151) return '' + (Mf * r + e)
  let t = e & 16777215,
    n = (((e >>> 24) | (r << 8)) >>> 0) & 16777215,
    i = (r >> 16) & 65535,
    s = t + n * 6777216 + i * 6710656,
    u = n + i * 8147497,
    o = i * 2,
    l = 1e7
  s >= l && ((u += Math.floor(s / l)), (s %= l)), u >= l && ((o += Math.floor(u / l)), (u %= l))
  function a(c, f) {
    let p = c ? String(c) : ''
    return f ? '0000000'.slice(p.length) + p : p
  }
  return a(o, 0) + a(u, o) + a(s, 1)
}
function kk(e, r) {
  if (e >= 0) {
    for (; e > 127; ) r.push((e & 127) | 128), (e = e >>> 7)
    r.push(e)
  } else {
    for (let t = 0; t < 9; t++) r.push((e & 127) | 128), (e = e >> 7)
    r.push(1)
  }
}
function Dj() {
  let e = this.buf[this.pos++],
    r = e & 127
  if ((e & 128) == 0) return this.assertBounds(), r
  if (((e = this.buf[this.pos++]), (r |= (e & 127) << 7), (e & 128) == 0)) return this.assertBounds(), r
  if (((e = this.buf[this.pos++]), (r |= (e & 127) << 14), (e & 128) == 0)) return this.assertBounds(), r
  if (((e = this.buf[this.pos++]), (r |= (e & 127) << 21), (e & 128) == 0)) return this.assertBounds(), r
  ;(e = this.buf[this.pos++]), (r |= (e & 15) << 28)
  for (let t = 5; (e & 128) != 0 && t < 10; t++) e = this.buf[this.pos++]
  if ((e & 128) != 0) throw new Error('invalid varint')
  return this.assertBounds(), r >>> 0
}
function Lj() {
  let e = new DataView(new ArrayBuffer(8))
  return globalThis.BigInt !== void 0 &&
    typeof e.getBigInt64 == 'function' &&
    typeof e.getBigUint64 == 'function' &&
    typeof e.setBigInt64 == 'function' &&
    typeof e.setBigUint64 == 'function'
    ? {
        MIN: BigInt('-9223372036854775808'),
        MAX: BigInt('9223372036854775807'),
        UMIN: BigInt('0'),
        UMAX: BigInt('18446744073709551615'),
        C: BigInt,
        V: e
      }
    : void 0
}
var Kt = Lj()
function Mk(e) {
  if (!e)
    throw new Error(
      'BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support'
    )
}
var xk = /^-?[0-9]+$/,
  xf = (1 << 16) * (1 << 16),
  Rk = class {
    constructor(e, r) {
      ;(this.lo = e | 0), (this.hi = r | 0)
    }
    isZero() {
      return this.lo == 0 && this.hi == 0
    }
    toNumber() {
      let e = this.hi * xf + (this.lo >>> 0)
      if (!Number.isSafeInteger(e)) throw new Error('cannot convert to safe number')
      return e
    }
  },
  zr = class extends Rk {
    static from(e) {
      if (Kt)
        switch (typeof e) {
          case 'string':
            if (e == '0') return this.ZERO
            if (e == '') throw new Error('string is no integer')
            e = Kt.C(e)
          case 'number':
            if (e === 0) return this.ZERO
            e = Kt.C(e)
          case 'bigint':
            if (!e) return this.ZERO
            if (e < Kt.UMIN) throw new Error('signed value for ulong')
            if (e > Kt.UMAX) throw new Error('ulong too large')
            return Kt.V.setBigUint64(0, e, !0), new zr(Kt.V.getInt32(0, !0), Kt.V.getInt32(4, !0))
        }
      else
        switch (typeof e) {
          case 'string':
            if (e == '0') return this.ZERO
            if (((e = e.trim()), !xk.test(e))) throw new Error('string is no integer')
            let [r, t, n] = Ck(e)
            if (r) throw new Error('signed value')
            return new zr(t, n)
          case 'number':
            if (e == 0) return this.ZERO
            if (!Number.isSafeInteger(e)) throw new Error('number is no integer')
            if (e < 0) throw new Error('signed value for ulong')
            return new zr(e, e / xf)
        }
      throw new Error('unknown value ' + typeof e)
    }
    toString() {
      return Kt ? this.toBigInt().toString() : G2(this.lo, this.hi)
    }
    toBigInt() {
      return Mk(Kt), Kt.V.setInt32(0, this.lo, !0), Kt.V.setInt32(4, this.hi, !0), Kt.V.getBigUint64(0, !0)
    }
  }
zr.ZERO = new zr(0, 0)
var rr = class extends Rk {
  static from(e) {
    if (Kt)
      switch (typeof e) {
        case 'string':
          if (e == '0') return this.ZERO
          if (e == '') throw new Error('string is no integer')
          e = Kt.C(e)
        case 'number':
          if (e === 0) return this.ZERO
          e = Kt.C(e)
        case 'bigint':
          if (!e) return this.ZERO
          if (e < Kt.MIN) throw new Error('ulong too small')
          if (e > Kt.MAX) throw new Error('ulong too large')
          return Kt.V.setBigInt64(0, e, !0), new rr(Kt.V.getInt32(0, !0), Kt.V.getInt32(4, !0))
      }
    else
      switch (typeof e) {
        case 'string':
          if (e == '0') return this.ZERO
          if (((e = e.trim()), !xk.test(e))) throw new Error('string is no integer')
          let [r, t, n] = Ck(e),
            i = new rr(t, n)
          return r ? i.negate() : i
        case 'number':
          if (e == 0) return this.ZERO
          if (!Number.isSafeInteger(e)) throw new Error('number is no integer')
          return e > 0 ? new rr(e, e / xf) : new rr(-e, -e / xf).negate()
      }
    throw new Error('unknown value ' + typeof e)
  }
  isNegative() {
    return (this.hi & 2147483648) != 0
  }
  negate() {
    let e = ~this.hi,
      r = this.lo
    return r ? (r = ~r + 1) : (e += 1), new rr(r, e)
  }
  toString() {
    if (Kt) return this.toBigInt().toString()
    if (this.isNegative()) {
      let e = this.negate()
      return '-' + G2(e.lo, e.hi)
    }
    return G2(this.lo, this.hi)
  }
  toBigInt() {
    return Mk(Kt), Kt.V.setInt32(0, this.lo, !0), Kt.V.setInt32(4, this.hi, !0), Kt.V.getBigInt64(0, !0)
  }
}
rr.ZERO = new rr(0, 0)
var Uj = class {
  constructor(e) {
    ;(this.varint64 = Oj),
      (this.uint32 = Dj),
      (this.buf = e),
      (this.len = e.length),
      (this.pos = 0),
      (this.view = new DataView(e.buffer, e.byteOffset, e.byteLength))
  }
  tag() {
    let e = this.uint32(),
      r = e >>> 3,
      t = e & 7
    if (r <= 0 || t < 0 || t > 5) throw new Error('illegal tag: field no ' + r + ' wire type ' + t)
    return [r, t]
  }
  skip(e) {
    let r = this.pos
    switch (e) {
      case kt.Bit64:
        this.pos += 4
      case kt.Bit32:
        this.pos += 4
        break
      case kt.LengthDelimited:
        let t = this.uint32()
        this.pos += t
        break
      case kt.Varint:
        for (; this.buf[this.pos++] & 128; );
        break
    }
    return this.assertBounds(), this.buf.slice(r, this.pos)
  }
  assertBounds() {
    if (this.pos > this.len) throw new RangeError('premature EOF')
  }
  int32() {
    return this.uint32() | 0
  }
  sint32() {
    let e = this.uint32()
    return (e >>> 1) ^ -(e & 1)
  }
  int64() {
    return new rr(...this.varint64())
  }
  uint64() {
    return new zr(...this.varint64())
  }
  sint64() {
    let [e, r] = this.varint64(),
      t = -(e & 1)
    return (e = ((e >>> 1) | ((r & 1) << 31)) ^ t), (r = (r >>> 1) ^ t), new rr(e, r)
  }
  bool() {
    let [e, r] = this.varint64()
    return e !== 0 || r !== 0
  }
  fixed32() {
    return this.view.getUint32((this.pos += 4) - 4, !0)
  }
  sfixed32() {
    return this.view.getInt32((this.pos += 4) - 4, !0)
  }
  fixed64() {
    return new zr(this.sfixed32(), this.sfixed32())
  }
  sfixed64() {
    return new rr(this.sfixed32(), this.sfixed32())
  }
  float() {
    return this.view.getFloat32((this.pos += 4) - 4, !0)
  }
  double() {
    return this.view.getFloat64((this.pos += 8) - 8, !0)
  }
  bytes() {
    let e = this.uint32(),
      r = this.pos
    return (this.pos += e), this.assertBounds(), this.buf.slice(r, this.pos)
  }
  string() {
    return Pj(this.bytes())
  }
}
V()
F()
V()
F()
function Bt(e, r) {
  if (!e) throw new Error(r)
}
var qj = 34028234663852886e22,
  jj = -34028234663852886e22,
  zj = 4294967295,
  Kj = 2147483647,
  Fj = -2147483648
function hu(e) {
  if (typeof e != 'number') throw new Error('invalid int 32: ' + typeof e)
  if (!Number.isInteger(e) || e > Kj || e < Fj) throw new Error('invalid int 32: ' + e)
}
function Rf(e) {
  if (typeof e != 'number') throw new Error('invalid uint 32: ' + typeof e)
  if (!Number.isInteger(e) || e > zj || e < 0) throw new Error('invalid uint 32: ' + e)
}
function W2(e) {
  if (typeof e != 'number') throw new Error('invalid float 32: ' + typeof e)
  if (!!Number.isFinite(e) && (e > qj || e < jj)) throw new Error('invalid float 32: ' + e)
}
var Vj = class {
    constructor(e) {
      ;(this.stack = []), (this.textEncoder = e ?? new TextEncoder()), (this.chunks = []), (this.buf = [])
    }
    finish() {
      this.chunks.push(new Uint8Array(this.buf))
      let e = 0
      for (let n = 0; n < this.chunks.length; n++) e += this.chunks[n].length
      let r = new Uint8Array(e),
        t = 0
      for (let n = 0; n < this.chunks.length; n++) r.set(this.chunks[n], t), (t += this.chunks[n].length)
      return (this.chunks = []), r
    }
    fork() {
      return this.stack.push({ chunks: this.chunks, buf: this.buf }), (this.chunks = []), (this.buf = []), this
    }
    join() {
      let e = this.finish(),
        r = this.stack.pop()
      if (!r) throw new Error('invalid state, fork stack empty')
      return (this.chunks = r.chunks), (this.buf = r.buf), this.uint32(e.byteLength), this.raw(e)
    }
    tag(e, r) {
      return this.uint32(((e << 3) | r) >>> 0)
    }
    raw(e) {
      return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), (this.buf = [])), this.chunks.push(e), this
    }
    uint32(e) {
      for (Rf(e); e > 127; ) this.buf.push((e & 127) | 128), (e = e >>> 7)
      return this.buf.push(e), this
    }
    int32(e) {
      return hu(e), kk(e, this.buf), this
    }
    bool(e) {
      return this.buf.push(e ? 1 : 0), this
    }
    bytes(e) {
      return this.uint32(e.byteLength), this.raw(e)
    }
    string(e) {
      let r = this.textEncoder.encode(e)
      return this.uint32(r.byteLength), this.raw(r)
    }
    float(e) {
      W2(e)
      let r = new Uint8Array(4)
      return new DataView(r.buffer).setFloat32(0, e, !0), this.raw(r)
    }
    double(e) {
      let r = new Uint8Array(8)
      return new DataView(r.buffer).setFloat64(0, e, !0), this.raw(r)
    }
    fixed32(e) {
      Rf(e)
      let r = new Uint8Array(4)
      return new DataView(r.buffer).setUint32(0, e, !0), this.raw(r)
    }
    sfixed32(e) {
      hu(e)
      let r = new Uint8Array(4)
      return new DataView(r.buffer).setInt32(0, e, !0), this.raw(r)
    }
    sint32(e) {
      return hu(e), (e = ((e << 1) ^ (e >> 31)) >>> 0), kk(e, this.buf), this
    }
    sfixed64(e) {
      let r = new Uint8Array(8),
        t = new DataView(r.buffer),
        n = rr.from(e)
      return t.setInt32(0, n.lo, !0), t.setInt32(4, n.hi, !0), this.raw(r)
    }
    fixed64(e) {
      let r = new Uint8Array(8),
        t = new DataView(r.buffer),
        n = zr.from(e)
      return t.setInt32(0, n.lo, !0), t.setInt32(4, n.hi, !0), this.raw(r)
    }
    int64(e) {
      let r = rr.from(e)
      return $2(r.lo, r.hi, this.buf), this
    }
    sint64(e) {
      let r = rr.from(e),
        t = r.hi >> 31,
        n = (r.lo << 1) ^ t,
        i = ((r.hi << 1) | (r.lo >>> 31)) ^ t
      return $2(n, i, this.buf), this
    }
    uint64(e) {
      let r = zr.from(e)
      return $2(r.lo, r.hi, this.buf), this
    }
  },
  dn
;(function (e) {
  ;(e.symbol = Symbol('protobuf-ts/unknown')),
    (e.onRead = (t, n, i, s, u) => {
      ;(r(n) ? n[e.symbol] : (n[e.symbol] = [])).push({ no: i, wireType: s, data: u })
    }),
    (e.onWrite = (t, n, i) => {
      for (let { no: s, wireType: u, data: o } of e.list(n)) i.tag(s, u).raw(o)
    }),
    (e.list = (t, n) => {
      if (r(t)) {
        let i = t[e.symbol]
        return n ? i.filter((s) => s.no == n) : i
      }
      return []
    }),
    (e.last = (t, n) => e.list(t, n).slice(-1)[0])
  let r = (t) => t && Array.isArray(t[e.symbol])
})(dn || (dn = {}))
function Hj(e) {
  return e ? Object.assign(Object.assign({}, Nk), e) : Nk
}
function $j(e) {
  return e ? Object.assign(Object.assign({}, Bk), e) : Bk
}
var Bk = { readUnknownField: !0, readerFactory: (e) => new Uj(e) },
  Nk = { writeUnknownFields: !0, writerFactory: () => new Vj() },
  kt
;(function (e) {
  ;(e[(e.Varint = 0)] = 'Varint'),
    (e[(e.Bit64 = 1)] = 'Bit64'),
    (e[(e.LengthDelimited = 2)] = 'LengthDelimited'),
    (e[(e.StartGroup = 3)] = 'StartGroup'),
    (e[(e.EndGroup = 4)] = 'EndGroup'),
    (e[(e.Bit32 = 5)] = 'Bit32')
})(kt || (kt = {}))
V()
F()
var Pk = { emitDefaultValues: !1, enumAsInteger: !1, useProtoFieldName: !1, prettySpaces: 0 },
  Ok = { ignoreUnknownFields: !1 }
function Gj(e) {
  return e ? Object.assign(Object.assign({}, Ok), e) : Ok
}
function Wj(e) {
  return e ? Object.assign(Object.assign({}, Pk), e) : Pk
}
V()
F()
V()
F()
V()
F()
function Dk(e) {
  let r = !1,
    t = []
  for (let n = 0; n < e.length; n++) {
    let i = e.charAt(n)
    i == '_'
      ? (r = !0)
      : /\d/.test(i)
      ? (t.push(i), (r = !0))
      : r
      ? (t.push(i.toUpperCase()), (r = !1))
      : n == 0
      ? t.push(i.toLowerCase())
      : t.push(i)
  }
  return t.join('')
}
var Ue
;(function (e) {
  ;(e[(e.DOUBLE = 1)] = 'DOUBLE'),
    (e[(e.FLOAT = 2)] = 'FLOAT'),
    (e[(e.INT64 = 3)] = 'INT64'),
    (e[(e.UINT64 = 4)] = 'UINT64'),
    (e[(e.INT32 = 5)] = 'INT32'),
    (e[(e.FIXED64 = 6)] = 'FIXED64'),
    (e[(e.FIXED32 = 7)] = 'FIXED32'),
    (e[(e.BOOL = 8)] = 'BOOL'),
    (e[(e.STRING = 9)] = 'STRING'),
    (e[(e.BYTES = 12)] = 'BYTES'),
    (e[(e.UINT32 = 13)] = 'UINT32'),
    (e[(e.SFIXED32 = 15)] = 'SFIXED32'),
    (e[(e.SFIXED64 = 16)] = 'SFIXED64'),
    (e[(e.SINT32 = 17)] = 'SINT32'),
    (e[(e.SINT64 = 18)] = 'SINT64')
})(Ue || (Ue = {}))
var Fn
;(function (e) {
  ;(e[(e.BIGINT = 0)] = 'BIGINT'), (e[(e.STRING = 1)] = 'STRING'), (e[(e.NUMBER = 2)] = 'NUMBER')
})(Fn || (Fn = {}))
var Bf
;(function (e) {
  ;(e[(e.NO = 0)] = 'NO'), (e[(e.PACKED = 1)] = 'PACKED'), (e[(e.UNPACKED = 2)] = 'UNPACKED')
})(Bf || (Bf = {}))
function Jj(e) {
  var r, t, n, i
  return (
    (e.localName = (r = e.localName) !== null && r !== void 0 ? r : Dk(e.name)),
    (e.jsonName = (t = e.jsonName) !== null && t !== void 0 ? t : Dk(e.name)),
    (e.repeat = (n = e.repeat) !== null && n !== void 0 ? n : Bf.NO),
    (e.opt = (i = e.opt) !== null && i !== void 0 ? i : e.repeat || e.oneof ? !1 : e.kind == 'message'),
    e
  )
}
V()
F()
V()
F()
function Xj(e) {
  if (typeof e != 'object' || e === null || !e.hasOwnProperty('oneofKind')) return !1
  switch (typeof e.oneofKind) {
    case 'string':
      return e[e.oneofKind] === void 0 ? !1 : Object.keys(e).length == 2
    case 'undefined':
      return Object.keys(e).length == 1
    default:
      return !1
  }
}
var Yj = class {
  constructor(e) {
    this.info = e
  }
  prepare() {
    if (this.data) return
    let e = [],
      r = [],
      t = []
    for (let n of this.info.fields)
      if (n.oneof) t.includes(n.oneof) || (t.push(n.oneof), e.push(n.oneof), r.push(n.oneof))
      else
        switch ((r.push(n.localName), n.kind)) {
          case 'scalar':
          case 'enum':
            ;(!n.opt || n.repeat) && e.push(n.localName)
            break
          case 'message':
            n.repeat && e.push(n.localName)
            break
          case 'map':
            e.push(n.localName)
            break
        }
    this.data = { req: e, known: r, oneofs: Object.values(t) }
  }
  is(e, r, t = !1) {
    if (r < 0) return !0
    if (e == null || typeof e != 'object') return !1
    this.prepare()
    let n = Object.keys(e),
      i = this.data
    if (n.length < i.req.length || i.req.some((s) => !n.includes(s)) || (!t && n.some((s) => !i.known.includes(s))))
      return !1
    if (r < 1) return !0
    for (let s of i.oneofs) {
      let u = e[s]
      if (!Xj(u)) return !1
      if (u.oneofKind === void 0) continue
      let o = this.info.fields.find((l) => l.localName === u.oneofKind)
      if (!o || !this.field(u[u.oneofKind], o, t, r)) return !1
    }
    for (let s of this.info.fields) if (s.oneof === void 0 && !this.field(e[s.localName], s, t, r)) return !1
    return !0
  }
  field(e, r, t, n) {
    let i = r.repeat
    switch (r.kind) {
      case 'scalar':
        return e === void 0 ? r.opt : i ? this.scalars(e, r.T, n, r.L) : this.scalar(e, r.T, r.L)
      case 'enum':
        return e === void 0 ? r.opt : i ? this.scalars(e, Ue.INT32, n) : this.scalar(e, Ue.INT32)
      case 'message':
        return e === void 0 ? !0 : i ? this.messages(e, r.T(), t, n) : this.message(e, r.T(), t, n)
      case 'map':
        if (typeof e != 'object' || e === null) return !1
        if (n < 2) return !0
        if (!this.mapKeys(e, r.K, n)) return !1
        switch (r.V.kind) {
          case 'scalar':
            return this.scalars(Object.values(e), r.V.T, n, r.V.L)
          case 'enum':
            return this.scalars(Object.values(e), Ue.INT32, n)
          case 'message':
            return this.messages(Object.values(e), r.V.T(), t, n)
        }
        break
    }
    return !0
  }
  message(e, r, t, n) {
    return t ? r.isAssignable(e, n) : r.is(e, n)
  }
  messages(e, r, t, n) {
    if (!Array.isArray(e)) return !1
    if (n < 2) return !0
    if (t) {
      for (let i = 0; i < e.length && i < n; i++) if (!r.isAssignable(e[i], n - 1)) return !1
    } else for (let i = 0; i < e.length && i < n; i++) if (!r.is(e[i], n - 1)) return !1
    return !0
  }
  scalar(e, r, t) {
    let n = typeof e
    switch (r) {
      case Ue.UINT64:
      case Ue.FIXED64:
      case Ue.INT64:
      case Ue.SFIXED64:
      case Ue.SINT64:
        switch (t) {
          case Fn.BIGINT:
            return n == 'bigint'
          case Fn.NUMBER:
            return n == 'number' && !isNaN(e)
          default:
            return n == 'string'
        }
      case Ue.BOOL:
        return n == 'boolean'
      case Ue.STRING:
        return n == 'string'
      case Ue.BYTES:
        return e instanceof Uint8Array
      case Ue.DOUBLE:
      case Ue.FLOAT:
        return n == 'number' && !isNaN(e)
      default:
        return n == 'number' && Number.isInteger(e)
    }
  }
  scalars(e, r, t, n) {
    if (!Array.isArray(e)) return !1
    if (t < 2) return !0
    if (Array.isArray(e)) {
      for (let i = 0; i < e.length && i < t; i++) if (!this.scalar(e[i], r, n)) return !1
    }
    return !0
  }
  mapKeys(e, r, t) {
    let n = Object.keys(e)
    switch (r) {
      case Ue.INT32:
      case Ue.FIXED32:
      case Ue.SFIXED32:
      case Ue.SINT32:
      case Ue.UINT32:
        return this.scalars(
          n.slice(0, t).map((i) => parseInt(i)),
          r,
          t
        )
      case Ue.BOOL:
        return this.scalars(
          n.slice(0, t).map((i) => (i == 'true' ? !0 : i == 'false' ? !1 : i)),
          r,
          t
        )
      default:
        return this.scalars(n, r, t, Fn.STRING)
    }
  }
}
V()
F()
V()
F()
function _n(e, r) {
  switch (r) {
    case Fn.BIGINT:
      return e.toBigInt()
    case Fn.NUMBER:
      return e.toNumber()
    default:
      return e.toString()
  }
}
var Zj = class {
  constructor(e) {
    this.info = e
  }
  prepare() {
    if (this.fMap === void 0) {
      this.fMap = {}
      for (let e of this.info.fields) (this.fMap[e.name] = e), (this.fMap[e.jsonName] = e), (this.fMap[e.localName] = e)
    }
  }
  assert(e, r, t) {
    if (!e) {
      let n = Tk(t)
      throw (
        ((n == 'number' || n == 'boolean') && (n = t.toString()),
        new Error(`Cannot parse JSON ${n} for ${this.info.typeName}#${r}`))
      )
    }
  }
  read(e, r, t) {
    this.prepare()
    let n = []
    for (let [i, s] of Object.entries(e)) {
      let u = this.fMap[i]
      if (!u) {
        if (!t.ignoreUnknownFields)
          throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${i}`)
        continue
      }
      let o = u.localName,
        l
      if (u.oneof) {
        if (n.includes(u.oneof))
          throw new Error(
            `Multiple members of the oneof group "${u.oneof}" of ${this.info.typeName} are present in JSON.`
          )
        n.push(u.oneof), (l = r[u.oneof] = { oneofKind: o })
      } else l = r
      if (u.kind == 'map') {
        if (s === null) continue
        this.assert(Rj(s), u.name, s)
        let a = l[o]
        for (let [c, f] of Object.entries(s)) {
          this.assert(f !== null, u.name + ' map value', null)
          let p
          switch (u.V.kind) {
            case 'message':
              p = u.V.T().internalJsonRead(f, t)
              break
            case 'enum':
              p = this.enum(u.V.T(), f, u.name)
              break
            case 'scalar':
              p = this.scalar(f, u.V.T, u.V.L, u.name)
              break
          }
          this.assert(p !== void 0, u.name + ' map value', f)
          let y = c
          u.K == Ue.BOOL && (y = y == 'true' ? !0 : y == 'false' ? !1 : y),
            (y = this.scalar(y, u.K, Fn.STRING, u.name).toString()),
            (a[y] = p)
        }
      } else if (u.repeat) {
        if (s === null) continue
        this.assert(Array.isArray(s), u.name, s)
        let a = l[o]
        for (let c of s) {
          this.assert(c !== null, u.name, null)
          let f
          switch (u.kind) {
            case 'message':
              f = u.T().internalJsonRead(c, t)
              break
            case 'enum':
              f = this.enum(u.T(), c, u.name)
              break
            case 'scalar':
              f = this.scalar(c, u.T, u.L, u.name)
              break
          }
          this.assert(f !== void 0, u.name, s), a.push(f)
        }
      } else
        switch (u.kind) {
          case 'message':
            if (s === null && u.T().typeName != 'google.protobuf.Value') {
              this.assert(u.oneof === void 0, u.name + ' (oneof member)', null)
              continue
            }
            l[o] = u.T().internalJsonRead(s, t, l[o])
            break
          case 'enum':
            l[o] = this.enum(u.T(), s, u.name)
            break
          case 'scalar':
            l[o] = this.scalar(s, u.T, u.L, u.name)
            break
        }
    }
  }
  enum(e, r, t) {
    if (
      (e[0] == 'google.protobuf.NullValue' &&
        Bt(r === null, `Unable to parse field ${this.info.typeName}#${t}, enum ${e[0]} only accepts null.`),
      r === null)
    )
      return 0
    switch (typeof r) {
      case 'number':
        return (
          Bt(
            Number.isInteger(r),
            `Unable to parse field ${this.info.typeName}#${t}, enum can only be integral number, got ${r}.`
          ),
          r
        )
      case 'string':
        let n = r
        e[2] && r.substring(0, e[2].length) === e[2] && (n = r.substring(e[2].length))
        let i = e[1][n]
        return (
          Bt(
            typeof i == 'number',
            `Unable to parse field ${this.info.typeName}#${t}, enum ${e[0]} has no value for "${r}".`
          ),
          i
        )
    }
    Bt(!1, `Unable to parse field ${this.info.typeName}#${t}, cannot parse enum value from ${typeof r}".`)
  }
  scalar(e, r, t, n) {
    let i
    try {
      switch (r) {
        case Ue.DOUBLE:
        case Ue.FLOAT:
          if (e === null) return 0
          if (e === 'NaN') return Number.NaN
          if (e === 'Infinity') return Number.POSITIVE_INFINITY
          if (e === '-Infinity') return Number.NEGATIVE_INFINITY
          if (e === '') {
            i = 'empty string'
            break
          }
          if (typeof e == 'string' && e.trim().length !== e.length) {
            i = 'extra whitespace'
            break
          }
          if (typeof e != 'string' && typeof e != 'number') break
          let s = Number(e)
          if (Number.isNaN(s)) {
            i = 'not a number'
            break
          }
          if (!Number.isFinite(s)) {
            i = 'too large or small'
            break
          }
          return r == Ue.FLOAT && W2(s), s
        case Ue.INT32:
        case Ue.FIXED32:
        case Ue.SFIXED32:
        case Ue.SINT32:
        case Ue.UINT32:
          if (e === null) return 0
          let u
          if (
            (typeof e == 'number'
              ? (u = e)
              : e === ''
              ? (i = 'empty string')
              : typeof e == 'string' && (e.trim().length !== e.length ? (i = 'extra whitespace') : (u = Number(e))),
            u === void 0)
          )
            break
          return r == Ue.UINT32 ? Rf(u) : hu(u), u
        case Ue.INT64:
        case Ue.SFIXED64:
        case Ue.SINT64:
          if (e === null) return _n(rr.ZERO, t)
          if (typeof e != 'number' && typeof e != 'string') break
          return _n(rr.from(e), t)
        case Ue.FIXED64:
        case Ue.UINT64:
          if (e === null) return _n(zr.ZERO, t)
          if (typeof e != 'number' && typeof e != 'string') break
          return _n(zr.from(e), t)
        case Ue.BOOL:
          if (e === null) return !1
          if (typeof e != 'boolean') break
          return e
        case Ue.STRING:
          if (e === null) return ''
          if (typeof e != 'string') {
            i = 'extra whitespace'
            break
          }
          try {
            encodeURIComponent(e)
          } catch (o) {
            o = 'invalid UTF8'
            break
          }
          return e
        case Ue.BYTES:
          if (e === null || e === '') return new Uint8Array(0)
          if (typeof e != 'string') break
          return Bj(e)
      }
    } catch (s) {
      i = s.message
    }
    this.assert(!1, n + (i ? ' - ' + i : ''), e)
  }
}
V()
F()
var Qj = class {
  constructor(e) {
    this.info = e
  }
  write(e, r) {
    let t = {},
      n = e
    for (let i of this.info.fields.filter((s) => !s.oneof)) {
      let s = this.field(i, n[i.localName], r)
      s !== void 0 && (t[r.useProtoFieldName ? i.name : i.jsonName] = s)
    }
    for (let i of this.info.fields) {
      if (!i.oneof) continue
      let s = n[i.oneof]
      if (s.oneofKind !== i.localName) continue
      let u
      i.kind == 'scalar' || i.kind == 'enum'
        ? (u = this.field(i, s[i.localName], {
            enumAsInteger: r.enumAsInteger,
            useProtoFieldName: r.useProtoFieldName,
            emitDefaultValues: !0
          }))
        : (u = this.field(i, s[i.localName], r)),
        Bt(u !== void 0),
        (t[r.useProtoFieldName ? i.name : i.jsonName] = u)
    }
    return t
  }
  field(e, r, t) {
    let n
    if (e.kind == 'map') {
      Bt(typeof r == 'object' && r !== null)
      let i = {}
      switch (e.V.kind) {
        case 'scalar':
          for (let [o, l] of Object.entries(r)) {
            let a = this.scalar(e.V.T, l, e.name, !1, !0)
            Bt(a !== void 0), (i[o.toString()] = a)
          }
          break
        case 'message':
          let s = e.V.T()
          for (let [o, l] of Object.entries(r)) {
            let a = this.message(s, l, e.name, t)
            Bt(a !== void 0), (i[o.toString()] = a)
          }
          break
        case 'enum':
          let u = e.V.T()
          for (let [o, l] of Object.entries(r)) {
            Bt(l === void 0 || typeof l == 'number')
            let a = this.enum(u, l, e.name, !1, !0, t.enumAsInteger)
            Bt(a !== void 0), (i[o.toString()] = a)
          }
          break
      }
      ;(t.emitDefaultValues || Object.keys(i).length > 0) && (n = i)
    } else if (e.repeat) {
      Bt(Array.isArray(r))
      let i = []
      switch (e.kind) {
        case 'scalar':
          for (let o = 0; o < r.length; o++) {
            let l = this.scalar(e.T, r[o], e.name, e.opt, !0)
            Bt(l !== void 0), i.push(l)
          }
          break
        case 'enum':
          let s = e.T()
          for (let o = 0; o < r.length; o++) {
            Bt(r[o] === void 0 || typeof r[o] == 'number')
            let l = this.enum(s, r[o], e.name, e.opt, !0, t.enumAsInteger)
            Bt(l !== void 0), i.push(l)
          }
          break
        case 'message':
          let u = e.T()
          for (let o = 0; o < r.length; o++) {
            let l = this.message(u, r[o], e.name, t)
            Bt(l !== void 0), i.push(l)
          }
          break
      }
      ;(t.emitDefaultValues || i.length > 0 || t.emitDefaultValues) && (n = i)
    } else
      switch (e.kind) {
        case 'scalar':
          n = this.scalar(e.T, r, e.name, e.opt, t.emitDefaultValues)
          break
        case 'enum':
          n = this.enum(e.T(), r, e.name, e.opt, t.emitDefaultValues, t.enumAsInteger)
          break
        case 'message':
          n = this.message(e.T(), r, e.name, t)
          break
      }
    return n
  }
  enum(e, r, t, n, i, s) {
    if (e[0] == 'google.protobuf.NullValue') return null
    if (r === void 0) {
      Bt(n)
      return
    }
    if (!(r === 0 && !i && !n))
      return (
        Bt(typeof r == 'number'),
        Bt(Number.isInteger(r)),
        s || !e[1].hasOwnProperty(r) ? r : e[2] ? e[2] + e[1][r] : e[1][r]
      )
  }
  message(e, r, t, n) {
    return r === void 0 ? (n.emitDefaultValues ? null : void 0) : e.internalJsonWrite(r, n)
  }
  scalar(e, r, t, n, i) {
    if (r === void 0) {
      Bt(n)
      return
    }
    let s = i || n
    switch (e) {
      case Ue.INT32:
      case Ue.SFIXED32:
      case Ue.SINT32:
        return r === 0 ? (s ? 0 : void 0) : (hu(r), r)
      case Ue.FIXED32:
      case Ue.UINT32:
        return r === 0 ? (s ? 0 : void 0) : (Rf(r), r)
      case Ue.FLOAT:
        W2(r)
      case Ue.DOUBLE:
        return r === 0
          ? s
            ? 0
            : void 0
          : (Bt(typeof r == 'number'),
            Number.isNaN(r)
              ? 'NaN'
              : r === Number.POSITIVE_INFINITY
              ? 'Infinity'
              : r === Number.NEGATIVE_INFINITY
              ? '-Infinity'
              : r)
      case Ue.STRING:
        return r === '' ? (s ? '' : void 0) : (Bt(typeof r == 'string'), r)
      case Ue.BOOL:
        return r === !1 ? (s ? !1 : void 0) : (Bt(typeof r == 'boolean'), r)
      case Ue.UINT64:
      case Ue.FIXED64:
        Bt(typeof r == 'number' || typeof r == 'string' || typeof r == 'bigint')
        let u = zr.from(r)
        return u.isZero() && !s ? void 0 : u.toString()
      case Ue.INT64:
      case Ue.SFIXED64:
      case Ue.SINT64:
        Bt(typeof r == 'number' || typeof r == 'string' || typeof r == 'bigint')
        let o = rr.from(r)
        return o.isZero() && !s ? void 0 : o.toString()
      case Ue.BYTES:
        return Bt(r instanceof Uint8Array), r.byteLength ? Nj(r) : s ? '' : void 0
    }
  }
}
V()
F()
V()
F()
function J2(e, r = Fn.STRING) {
  switch (e) {
    case Ue.BOOL:
      return !1
    case Ue.UINT64:
    case Ue.FIXED64:
      return _n(zr.ZERO, r)
    case Ue.INT64:
    case Ue.SFIXED64:
    case Ue.SINT64:
      return _n(rr.ZERO, r)
    case Ue.DOUBLE:
    case Ue.FLOAT:
      return 0
    case Ue.BYTES:
      return new Uint8Array(0)
    case Ue.STRING:
      return ''
    default:
      return 0
  }
}
var ez = class {
  constructor(e) {
    this.info = e
  }
  prepare() {
    this.fieldNoToField || (this.fieldNoToField = new Map(this.info.fields.map((e) => [e.no, e])))
  }
  read(e, r, t, n) {
    this.prepare()
    let i = n === void 0 ? e.len : e.pos + n
    for (; e.pos < i; ) {
      let [s, u] = e.tag(),
        o = this.fieldNoToField.get(s)
      if (!o) {
        let f = t.readUnknownField
        if (f == 'throw') throw new Error(`Unknown field ${s} (wire type ${u}) for ${this.info.typeName}`)
        let p = e.skip(u)
        f !== !1 && (f === !0 ? dn.onRead : f)(this.info.typeName, r, s, u, p)
        continue
      }
      let l = r,
        a = o.repeat,
        c = o.localName
      switch ((o.oneof && ((l = l[o.oneof]), l.oneofKind !== c && (l = r[o.oneof] = { oneofKind: c })), o.kind)) {
        case 'scalar':
        case 'enum':
          let f = o.kind == 'enum' ? Ue.INT32 : o.T,
            p = o.kind == 'scalar' ? o.L : void 0
          if (a) {
            let h = l[c]
            if (u == kt.LengthDelimited && f != Ue.STRING && f != Ue.BYTES) {
              let m = e.uint32() + e.pos
              for (; e.pos < m; ) h.push(this.scalar(e, f, p))
            } else h.push(this.scalar(e, f, p))
          } else l[c] = this.scalar(e, f, p)
          break
        case 'message':
          if (a) {
            let h = l[c],
              m = o.T().internalBinaryRead(e, e.uint32(), t)
            h.push(m)
          } else l[c] = o.T().internalBinaryRead(e, e.uint32(), t, l[c])
          break
        case 'map':
          let [y, d] = this.mapEntry(o, e, t)
          l[c][y] = d
          break
      }
    }
  }
  mapEntry(e, r, t) {
    let n = r.uint32(),
      i = r.pos + n,
      s,
      u
    for (; r.pos < i; ) {
      let [o, l] = r.tag()
      switch (o) {
        case 1:
          e.K == Ue.BOOL ? (s = r.bool().toString()) : (s = this.scalar(r, e.K, Fn.STRING))
          break
        case 2:
          switch (e.V.kind) {
            case 'scalar':
              u = this.scalar(r, e.V.T, e.V.L)
              break
            case 'enum':
              u = r.int32()
              break
            case 'message':
              u = e.V.T().internalBinaryRead(r, r.uint32(), t)
              break
          }
          break
        default:
          throw new Error(`Unknown field ${o} (wire type ${l}) in map entry for ${this.info.typeName}#${e.name}`)
      }
    }
    if (s === void 0) {
      let o = J2(e.K)
      s = e.K == Ue.BOOL ? o.toString() : o
    }
    if (u === void 0)
      switch (e.V.kind) {
        case 'scalar':
          u = J2(e.V.T, e.V.L)
          break
        case 'enum':
          u = 0
          break
        case 'message':
          u = e.V.T().create()
          break
      }
    return [s, u]
  }
  scalar(e, r, t) {
    switch (r) {
      case Ue.INT32:
        return e.int32()
      case Ue.STRING:
        return e.string()
      case Ue.BOOL:
        return e.bool()
      case Ue.DOUBLE:
        return e.double()
      case Ue.FLOAT:
        return e.float()
      case Ue.INT64:
        return _n(e.int64(), t)
      case Ue.UINT64:
        return _n(e.uint64(), t)
      case Ue.FIXED64:
        return _n(e.fixed64(), t)
      case Ue.FIXED32:
        return e.fixed32()
      case Ue.BYTES:
        return e.bytes()
      case Ue.UINT32:
        return e.uint32()
      case Ue.SFIXED32:
        return e.sfixed32()
      case Ue.SFIXED64:
        return _n(e.sfixed64(), t)
      case Ue.SINT32:
        return e.sint32()
      case Ue.SINT64:
        return _n(e.sint64(), t)
    }
  }
}
V()
F()
var tz = class {
  constructor(e) {
    this.info = e
  }
  prepare() {
    this.fields || (this.fields = this.info.fields.concat().sort((e, r) => e.no - r.no))
  }
  write(e, r, t) {
    this.prepare()
    for (let i of this.fields) {
      let s,
        u,
        o = i.repeat,
        l = i.localName
      if (i.oneof) {
        let a = e[i.oneof]
        if (a.oneofKind !== l) continue
        ;(s = a[l]), (u = !0)
      } else (s = e[l]), (u = !1)
      switch (i.kind) {
        case 'scalar':
        case 'enum':
          let a = i.kind == 'enum' ? Ue.INT32 : i.T
          if (o)
            if ((Bt(Array.isArray(s)), o == Bf.PACKED)) this.packed(r, a, i.no, s)
            else for (let c of s) this.scalar(r, a, i.no, c, !0)
          else s === void 0 ? Bt(i.opt) : this.scalar(r, a, i.no, s, u || i.opt)
          break
        case 'message':
          if (o) {
            Bt(Array.isArray(s))
            for (let c of s) this.message(r, t, i.T(), i.no, c)
          } else this.message(r, t, i.T(), i.no, s)
          break
        case 'map':
          Bt(typeof s == 'object' && s !== null)
          for (let [c, f] of Object.entries(s)) this.mapEntry(r, t, i, c, f)
          break
      }
    }
    let n = t.writeUnknownFields
    n !== !1 && (n === !0 ? dn.onWrite : n)(this.info.typeName, e, r)
  }
  mapEntry(e, r, t, n, i) {
    e.tag(t.no, kt.LengthDelimited), e.fork()
    let s = n
    switch (t.K) {
      case Ue.INT32:
      case Ue.FIXED32:
      case Ue.UINT32:
      case Ue.SFIXED32:
      case Ue.SINT32:
        s = Number.parseInt(n)
        break
      case Ue.BOOL:
        Bt(n == 'true' || n == 'false'), (s = n == 'true')
        break
    }
    switch ((this.scalar(e, t.K, 1, s, !0), t.V.kind)) {
      case 'scalar':
        this.scalar(e, t.V.T, 2, i, !0)
        break
      case 'enum':
        this.scalar(e, Ue.INT32, 2, i, !0)
        break
      case 'message':
        this.message(e, r, t.V.T(), 2, i)
        break
    }
    e.join()
  }
  message(e, r, t, n, i) {
    i !== void 0 && (t.internalBinaryWrite(i, e.tag(n, kt.LengthDelimited).fork(), r), e.join())
  }
  scalar(e, r, t, n, i) {
    let [s, u, o] = this.scalarInfo(r, n)
    ;(!o || i) && (e.tag(t, s), e[u](n))
  }
  packed(e, r, t, n) {
    if (!n.length) return
    Bt(r !== Ue.BYTES && r !== Ue.STRING), e.tag(t, kt.LengthDelimited), e.fork()
    let [, i] = this.scalarInfo(r)
    for (let s = 0; s < n.length; s++) e[i](n[s])
    e.join()
  }
  scalarInfo(e, r) {
    let t = kt.Varint,
      n,
      i = r === void 0,
      s = r === 0
    switch (e) {
      case Ue.INT32:
        n = 'int32'
        break
      case Ue.STRING:
        ;(s = i || !r.length), (t = kt.LengthDelimited), (n = 'string')
        break
      case Ue.BOOL:
        ;(s = r === !1), (n = 'bool')
        break
      case Ue.UINT32:
        n = 'uint32'
        break
      case Ue.DOUBLE:
        ;(t = kt.Bit64), (n = 'double')
        break
      case Ue.FLOAT:
        ;(t = kt.Bit32), (n = 'float')
        break
      case Ue.INT64:
        ;(s = i || rr.from(r).isZero()), (n = 'int64')
        break
      case Ue.UINT64:
        ;(s = i || zr.from(r).isZero()), (n = 'uint64')
        break
      case Ue.FIXED64:
        ;(s = i || zr.from(r).isZero()), (t = kt.Bit64), (n = 'fixed64')
        break
      case Ue.BYTES:
        ;(s = i || !r.byteLength), (t = kt.LengthDelimited), (n = 'bytes')
        break
      case Ue.FIXED32:
        ;(t = kt.Bit32), (n = 'fixed32')
        break
      case Ue.SFIXED32:
        ;(t = kt.Bit32), (n = 'sfixed32')
        break
      case Ue.SFIXED64:
        ;(s = i || rr.from(r).isZero()), (t = kt.Bit64), (n = 'sfixed64')
        break
      case Ue.SINT32:
        n = 'sint32'
        break
      case Ue.SINT64:
        ;(s = i || rr.from(r).isZero()), (n = 'sint64')
        break
    }
    return [t, n, i || s]
  }
}
V()
F()
function rz(e) {
  let r = {}
  for (let t of e.fields) {
    let n = t.localName
    if (!t.opt)
      if (t.oneof) r[t.oneof] = { oneofKind: void 0 }
      else if (t.repeat) r[n] = []
      else
        switch (t.kind) {
          case 'scalar':
            r[n] = J2(t.T, t.L)
            break
          case 'enum':
            r[n] = 0
            break
          case 'map':
            r[n] = {}
            break
        }
  }
  return r
}
V()
F()
function Ns(e, r, t) {
  let n,
    i = t,
    s
  for (let u of e.fields) {
    let o = u.localName
    if (u.oneof) {
      let l = i[u.oneof]
      if (l === void 0) continue
      if (((n = l[o]), (s = r[u.oneof]), (s.oneofKind = l.oneofKind), n === void 0)) {
        delete s[o]
        continue
      }
    } else if (((n = i[o]), (s = r), n === void 0)) continue
    switch (u.kind) {
      case 'scalar':
      case 'enum':
        u.repeat ? (s[o] = n.concat()) : (s[o] = n)
        break
      case 'message':
        let l = u.T()
        if (u.repeat) for (let a = 0; a < n.length; a++) s[o][a] = l.create(n[a])
        else s[o] === void 0 ? (s[o] = l.create(n)) : l.mergePartial(s[o], n)
        break
      case 'map':
        switch (u.V.kind) {
          case 'scalar':
          case 'enum':
            Object.assign(s[o], n)
            break
          case 'message':
            let a = u.V.T()
            for (let c of Object.keys(n)) s[o][c] = a.create(n[c])
            break
        }
        break
    }
  }
}
V()
F()
function nz(e, r, t) {
  if (r === t) return !0
  if (!r || !t) return !1
  for (let n of e.fields) {
    let i = n.localName,
      s = n.oneof ? r[n.oneof][i] : r[i],
      u = n.oneof ? t[n.oneof][i] : t[i]
    switch (n.kind) {
      case 'enum':
      case 'scalar':
        let o = n.kind == 'enum' ? Ue.INT32 : n.T
        if (!(n.repeat ? Uk(o, s, u) : Lk(o, s, u))) return !1
        break
      case 'map':
        if (
          !(n.V.kind == 'message' ? qk(n.V.T(), Nf(s), Nf(u)) : Uk(n.V.kind == 'enum' ? Ue.INT32 : n.V.T, Nf(s), Nf(u)))
        )
          return !1
        break
      case 'message':
        let l = n.T()
        if (!(n.repeat ? qk(l, s, u) : l.equals(s, u))) return !1
        break
    }
  }
  return !0
}
var Nf = Object.values
function Lk(e, r, t) {
  if (r === t) return !0
  if (e !== Ue.BYTES) return !1
  let n = r,
    i = t
  if (n.length !== i.length) return !1
  for (let s = 0; s < n.length; s++) if (n[s] != i[s]) return !1
  return !0
}
function Uk(e, r, t) {
  if (r.length !== t.length) return !1
  for (let n = 0; n < r.length; n++) if (!Lk(e, r[n], t[n])) return !1
  return !0
}
function qk(e, r, t) {
  if (r.length !== t.length) return !1
  for (let n = 0; n < r.length; n++) if (!e.equals(r[n], t[n])) return !1
  return !0
}
var Pf = class {
    constructor(e, r) {
      ;(this.defaultCheckDepth = 16),
        (this.typeName = e),
        (this.fields = r.map(Jj)),
        (this.refTypeCheck = new Yj(this)),
        (this.refJsonReader = new Zj(this)),
        (this.refJsonWriter = new Qj(this)),
        (this.refBinReader = new ez(this)),
        (this.refBinWriter = new tz(this))
    }
    create(e) {
      let r = rz(this)
      return e !== void 0 && Ns(this, r, e), r
    }
    clone(e) {
      let r = this.create()
      return Ns(this, r, e), r
    }
    equals(e, r) {
      return nz(this, e, r)
    }
    is(e, r = this.defaultCheckDepth) {
      return this.refTypeCheck.is(e, r, !1)
    }
    isAssignable(e, r = this.defaultCheckDepth) {
      return this.refTypeCheck.is(e, r, !0)
    }
    mergePartial(e, r) {
      Ns(this, e, r)
    }
    fromBinary(e, r) {
      let t = $j(r)
      return this.internalBinaryRead(t.readerFactory(e), e.byteLength, t)
    }
    fromJson(e, r) {
      return this.internalJsonRead(e, Gj(r))
    }
    fromJsonString(e, r) {
      let t = JSON.parse(e)
      return this.fromJson(t, r)
    }
    toJson(e, r) {
      return this.internalJsonWrite(e, Wj(r))
    }
    toJsonString(e, r) {
      var t
      let n = this.toJson(e, r)
      return JSON.stringify(n, null, (t = r == null ? void 0 : r.prettySpaces) !== null && t !== void 0 ? t : 0)
    }
    toBinary(e, r) {
      let t = Hj(r)
      return this.internalBinaryWrite(e, t.writerFactory(), t).finish()
    }
    internalJsonRead(e, r, t) {
      if (e !== null && typeof e == 'object' && !Array.isArray(e)) {
        let n = t ?? this.create()
        return this.refJsonReader.read(e, n, r), n
      }
      throw new Error(`Unable to parse message ${this.typeName} from JSON ${Tk(e)}.`)
    }
    internalJsonWrite(e, r) {
      return this.refJsonWriter.write(e, r)
    }
    internalBinaryWrite(e, r, t) {
      return this.refBinWriter.write(e, r, t), r
    }
    internalBinaryRead(e, r, t, n) {
      let i = n ?? this.create()
      return this.refBinReader.read(e, i, t, r), i
    }
  },
  iz = class extends Pf {
    constructor() {
      super('Meta', [
        { no: 1, name: 'name', kind: 'scalar', T: 9 },
        { no: 2, name: 'type', kind: 'scalar', T: 9 },
        { no: 3, name: 'size', kind: 'scalar', T: 4, L: 0 },
        { no: 4, name: 'lastModified', kind: 'scalar', T: 3, L: 0 },
        { no: 5, name: 'preview', kind: 'scalar', opt: !0, T: 12 }
      ])
    }
    create(e) {
      let r = { name: '', type: '', size: 0n, lastModified: 0n }
      return e !== void 0 && Ns(this, r, e), r
    }
    internalBinaryRead(e, r, t, n) {
      let i = n ?? this.create(),
        s = e.pos + r
      for (; e.pos < s; ) {
        let [u, o] = e.tag()
        switch (u) {
          case 1:
            i.name = e.string()
            break
          case 2:
            i.type = e.string()
            break
          case 3:
            i.size = e.uint64().toBigInt()
            break
          case 4:
            i.lastModified = e.int64().toBigInt()
            break
          case 5:
            i.preview = e.bytes()
            break
          default:
            let l = t.readUnknownField
            if (l === 'throw') throw new globalThis.Error(`Unknown field ${u} (wire type ${o}) for ${this.typeName}`)
            let a = e.skip(o)
            l !== !1 && (l === !0 ? dn.onRead : l)(this.typeName, i, u, o, a)
        }
      }
      return i
    }
    internalBinaryWrite(e, r, t) {
      e.name !== '' && r.tag(1, kt.LengthDelimited).string(e.name),
        e.type !== '' && r.tag(2, kt.LengthDelimited).string(e.type),
        e.size !== 0n && r.tag(3, kt.Varint).uint64(e.size),
        e.lastModified !== 0n && r.tag(4, kt.Varint).int64(e.lastModified),
        e.preview !== void 0 && r.tag(5, kt.LengthDelimited).bytes(e.preview)
      let n = t.writeUnknownFields
      return n !== !1 && (n == !0 ? dn.onWrite : n)(this.typeName, e, r), r
    }
  },
  Ki = new iz(),
  sz = class extends Pf {
    constructor() {
      super('Chunk', [
        { no: 1, name: 'id', kind: 'scalar', T: 9 },
        { no: 2, name: 'skip', kind: 'scalar', opt: !0, T: 4, L: 0 },
        { no: 3, name: 'limit', kind: 'scalar', opt: !0, T: 4, L: 0 }
      ])
    }
    create(e) {
      let r = { id: '' }
      return e !== void 0 && Ns(this, r, e), r
    }
    internalBinaryRead(e, r, t, n) {
      let i = n ?? this.create(),
        s = e.pos + r
      for (; e.pos < s; ) {
        let [u, o] = e.tag()
        switch (u) {
          case 1:
            i.id = e.string()
            break
          case 2:
            i.skip = e.uint64().toBigInt()
            break
          case 3:
            i.limit = e.uint64().toBigInt()
            break
          default:
            let l = t.readUnknownField
            if (l === 'throw') throw new globalThis.Error(`Unknown field ${u} (wire type ${o}) for ${this.typeName}`)
            let a = e.skip(o)
            l !== !1 && (l === !0 ? dn.onRead : l)(this.typeName, i, u, o, a)
        }
      }
      return i
    }
    internalBinaryWrite(e, r, t) {
      e.id !== '' && r.tag(1, kt.LengthDelimited).string(e.id),
        e.skip !== void 0 && r.tag(2, kt.Varint).uint64(e.skip),
        e.limit !== void 0 && r.tag(3, kt.Varint).uint64(e.limit)
      let n = t.writeUnknownFields
      return n !== !1 && (n == !0 ? dn.onWrite : n)(this.typeName, e, r), r
    }
  },
  X2 = new sz(),
  oz = class extends Pf {
    constructor() {
      super('Request', [
        { no: 1, name: 'meta', kind: 'scalar', oneof: 'type', T: 9 },
        { no: 2, name: 'receive', kind: 'message', oneof: 'type', T: () => X2 },
        { no: 3, name: 'send', kind: 'message', oneof: 'type', T: () => Ki }
      ])
    }
    create(e) {
      let r = { type: { oneofKind: void 0 } }
      return e !== void 0 && Ns(this, r, e), r
    }
    internalBinaryRead(e, r, t, n) {
      let i = n ?? this.create(),
        s = e.pos + r
      for (; e.pos < s; ) {
        let [u, o] = e.tag()
        switch (u) {
          case 1:
            i.type = { oneofKind: 'meta', meta: e.string() }
            break
          case 2:
            i.type = { oneofKind: 'receive', receive: X2.internalBinaryRead(e, e.uint32(), t, i.type.receive) }
            break
          case 3:
            i.type = { oneofKind: 'send', send: Ki.internalBinaryRead(e, e.uint32(), t, i.type.send) }
            break
          default:
            let l = t.readUnknownField
            if (l === 'throw') throw new globalThis.Error(`Unknown field ${u} (wire type ${o}) for ${this.typeName}`)
            let a = e.skip(o)
            l !== !1 && (l === !0 ? dn.onRead : l)(this.typeName, i, u, o, a)
        }
      }
      return i
    }
    internalBinaryWrite(e, r, t) {
      e.type.oneofKind === 'meta' && r.tag(1, kt.LengthDelimited).string(e.type.meta),
        e.type.oneofKind === 'receive' &&
          X2.internalBinaryWrite(e.type.receive, r.tag(2, kt.LengthDelimited).fork(), t).join(),
        e.type.oneofKind === 'send' &&
          Ki.internalBinaryWrite(e.type.send, r.tag(3, kt.LengthDelimited).fork(), t).join()
      let n = t.writeUnknownFields
      return n !== !1 && (n == !0 ? dn.onWrite : n)(this.typeName, e, r), r
    }
  },
  Of = new oz(),
  az = class extends Pf {
    constructor() {
      super('File', [
        { no: 1, name: 'meta', kind: 'message', T: () => Ki },
        { no: 2, name: 'contentPath', kind: 'scalar', T: 9 }
      ])
    }
    create(e) {
      let r = { contentPath: '' }
      return e !== void 0 && Ns(this, r, e), r
    }
    internalBinaryRead(e, r, t, n) {
      let i = n ?? this.create(),
        s = e.pos + r
      for (; e.pos < s; ) {
        let [u, o] = e.tag()
        switch (u) {
          case 1:
            i.meta = Ki.internalBinaryRead(e, e.uint32(), t, i.meta)
            break
          case 2:
            i.contentPath = e.string()
            break
          default:
            let l = t.readUnknownField
            if (l === 'throw') throw new globalThis.Error(`Unknown field ${u} (wire type ${o}) for ${this.typeName}`)
            let a = e.skip(o)
            l !== !1 && (l === !0 ? dn.onRead : l)(this.typeName, i, u, o, a)
        }
      }
      return i
    }
    internalBinaryWrite(e, r, t) {
      e.meta && Ki.internalBinaryWrite(e.meta, r.tag(1, kt.LengthDelimited).fork(), t).join(),
        e.contentPath !== '' && r.tag(2, kt.LengthDelimited).string(e.contentPath)
      let n = t.writeUnknownFields
      return n !== !1 && (n == !0 ? dn.onWrite : n)(this.typeName, e, r), r
    }
  },
  iK = new az()
V()
F()
var cz = Yr(Ol())
V()
F()
V()
F()
V()
F()
V()
F()
var uz = Yr(RR()),
  {
    __extends: Df,
    __assign: sK,
    __rest: oK,
    __decorate: aK,
    __param: cK,
    __metadata: uK,
    __awaiter: lK,
    __generator: fK,
    __exportStar: dK,
    __createBinding: hK,
    __values: Y2,
    __read: Lf,
    __spread: pK,
    __spreadArrays: mK,
    __spreadArray: Uf,
    __await: bK,
    __asyncGenerator: yK,
    __asyncDelegator: vK,
    __asyncValues: gK,
    __makeTemplateObject: wK,
    __importStar: _K,
    __importDefault: EK,
    __classPrivateFieldGet: SK,
    __classPrivateFieldSet: AK
  } = uz.default
V()
F()
function hi(e) {
  return typeof e == 'function'
}
V()
F()
V()
F()
V()
F()
function jk(e) {
  var r = function (n) {
      Error.call(n), (n.stack = new Error().stack)
    },
    t = e(r)
  return (t.prototype = Object.create(Error.prototype)), (t.prototype.constructor = t), t
}
var Z2 = jk(function (e) {
  return function (t) {
    e(this),
      (this.message = t
        ? t.length +
          ` errors occurred during unsubscription:
` +
          t.map(function (n, i) {
            return i + 1 + ') ' + n.toString()
          }).join(`
  `)
        : ''),
      (this.name = 'UnsubscriptionError'),
      (this.errors = t)
  }
})
V()
F()
function Q2(e, r) {
  if (e) {
    var t = e.indexOf(r)
    0 <= t && e.splice(t, 1)
  }
}
var qf = (function () {
    function e(r) {
      ;(this.initialTeardown = r), (this.closed = !1), (this._parentage = null), (this._teardowns = null)
    }
    return (
      (e.prototype.unsubscribe = function () {
        var r, t, n, i, s
        if (!this.closed) {
          this.closed = !0
          var u = this._parentage
          if (u)
            if (((this._parentage = null), Array.isArray(u)))
              try {
                for (var o = Y2(u), l = o.next(); !l.done; l = o.next()) {
                  var a = l.value
                  a.remove(this)
                }
              } catch (h) {
                r = { error: h }
              } finally {
                try {
                  l && !l.done && (t = o.return) && t.call(o)
                } finally {
                  if (r) throw r.error
                }
              }
            else u.remove(this)
          var c = this.initialTeardown
          if (hi(c))
            try {
              c()
            } catch (h) {
              s = h instanceof Z2 ? h.errors : [h]
            }
          var f = this._teardowns
          if (f) {
            this._teardowns = null
            try {
              for (var p = Y2(f), y = p.next(); !y.done; y = p.next()) {
                var d = y.value
                try {
                  Fk(d)
                } catch (h) {
                  ;(s = s ?? []), h instanceof Z2 ? (s = Uf(Uf([], Lf(s)), Lf(h.errors))) : s.push(h)
                }
              }
            } catch (h) {
              n = { error: h }
            } finally {
              try {
                y && !y.done && (i = p.return) && i.call(p)
              } finally {
                if (n) throw n.error
              }
            }
          }
          if (s) throw new Z2(s)
        }
      }),
      (e.prototype.add = function (r) {
        var t
        if (r && r !== this)
          if (this.closed) Fk(r)
          else {
            if (r instanceof e) {
              if (r.closed || r._hasParent(this)) return
              r._addParent(this)
            }
            ;(this._teardowns = (t = this._teardowns) !== null && t !== void 0 ? t : []).push(r)
          }
      }),
      (e.prototype._hasParent = function (r) {
        var t = this._parentage
        return t === r || (Array.isArray(t) && t.includes(r))
      }),
      (e.prototype._addParent = function (r) {
        var t = this._parentage
        this._parentage = Array.isArray(t) ? (t.push(r), t) : t ? [t, r] : r
      }),
      (e.prototype._removeParent = function (r) {
        var t = this._parentage
        t === r ? (this._parentage = null) : Array.isArray(t) && Q2(t, r)
      }),
      (e.prototype.remove = function (r) {
        var t = this._teardowns
        t && Q2(t, r), r instanceof e && r._removeParent(this)
      }),
      (e.EMPTY = (function () {
        var r = new e()
        return (r.closed = !0), r
      })()),
      e
    )
  })(),
  zk = qf.EMPTY
function Kk(e) {
  return e instanceof qf || (e && 'closed' in e && hi(e.remove) && hi(e.add) && hi(e.unsubscribe))
}
function Fk(e) {
  hi(e) ? e() : e.unsubscribe()
}
V()
F()
var Ps = {
  onUnhandledError: null,
  onStoppedNotification: null,
  Promise: void 0,
  useDeprecatedSynchronousErrorHandling: !1,
  useDeprecatedNextContext: !1
}
V()
F()
V()
F()
var jf = {
  setTimeout: function () {
    for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r]
    var t = jf.delegate
    return ((t == null ? void 0 : t.setTimeout) || setTimeout).apply(void 0, Uf([], Lf(e)))
  },
  clearTimeout: function (e) {
    var r = jf.delegate
    return ((r == null ? void 0 : r.clearTimeout) || clearTimeout)(e)
  },
  delegate: void 0
}
function lz(e) {
  jf.setTimeout(function () {
    var r = Ps.onUnhandledError
    if (r) r(e)
    else throw e
  })
}
V()
F()
function zf() {}
V()
F()
var fz = (function () {
  return em('C', void 0, void 0)
})()
function dz(e) {
  return em('E', void 0, e)
}
function hz(e) {
  return em('N', e, void 0)
}
function em(e, r, t) {
  return { kind: e, value: r, error: t }
}
V()
F()
var Os = null
function Kf(e) {
  if (Ps.useDeprecatedSynchronousErrorHandling) {
    var r = !Os
    if ((r && (Os = { errorThrown: !1, error: null }), e(), r)) {
      var t = Os,
        n = t.errorThrown,
        i = t.error
      if (((Os = null), n)) throw i
    }
  } else e()
}
function pz(e) {
  Ps.useDeprecatedSynchronousErrorHandling && Os && ((Os.errorThrown = !0), (Os.error = e))
}
var Vk = (function (e) {
    Df(r, e)
    function r(t) {
      var n = e.call(this) || this
      return (n.isStopped = !1), t ? ((n.destination = t), Kk(t) && t.add(n)) : (n.destination = mz), n
    }
    return (
      (r.create = function (t, n, i) {
        return new Hk(t, n, i)
      }),
      (r.prototype.next = function (t) {
        this.isStopped ? rm(hz(t), this) : this._next(t)
      }),
      (r.prototype.error = function (t) {
        this.isStopped ? rm(dz(t), this) : ((this.isStopped = !0), this._error(t))
      }),
      (r.prototype.complete = function () {
        this.isStopped ? rm(fz, this) : ((this.isStopped = !0), this._complete())
      }),
      (r.prototype.unsubscribe = function () {
        this.closed || ((this.isStopped = !0), e.prototype.unsubscribe.call(this), (this.destination = null))
      }),
      (r.prototype._next = function (t) {
        this.destination.next(t)
      }),
      (r.prototype._error = function (t) {
        try {
          this.destination.error(t)
        } finally {
          this.unsubscribe()
        }
      }),
      (r.prototype._complete = function () {
        try {
          this.destination.complete()
        } finally {
          this.unsubscribe()
        }
      }),
      r
    )
  })(qf),
  Hk = (function (e) {
    Df(r, e)
    function r(t, n, i) {
      var s = e.call(this) || this,
        u
      if (hi(t)) u = t
      else if (t) {
        ;(u = t.next), (n = t.error), (i = t.complete)
        var o
        s && Ps.useDeprecatedNextContext
          ? ((o = Object.create(t)),
            (o.unsubscribe = function () {
              return s.unsubscribe()
            }))
          : (o = t),
          (u = u == null ? void 0 : u.bind(o)),
          (n = n == null ? void 0 : n.bind(o)),
          (i = i == null ? void 0 : i.bind(o))
      }
      return (s.destination = { next: u ? tm(u, s) : zf, error: tm(n ?? $k, s), complete: i ? tm(i, s) : zf }), s
    }
    return r
  })(Vk)
function tm(e, r) {
  return function () {
    for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n]
    try {
      e.apply(void 0, Uf([], Lf(t)))
    } catch (i) {
      Ps.useDeprecatedSynchronousErrorHandling ? pz(i) : lz(i)
    }
  }
}
function $k(e) {
  throw e
}
function rm(e, r) {
  var t = Ps.onStoppedNotification
  t &&
    jf.setTimeout(function () {
      return t(e, r)
    })
}
var mz = { closed: !0, next: zf, error: $k, complete: zf }
V()
F()
var bz = (function () {
  return (typeof Symbol == 'function' && Symbol.observable) || '@@observable'
})()
V()
F()
V()
F()
function yz(e) {
  return e
}
function vz(e) {
  return e.length === 0
    ? yz
    : e.length === 1
    ? e[0]
    : function (t) {
        return e.reduce(function (n, i) {
          return i(n)
        }, t)
      }
}
var Gk = (function () {
  function e(r) {
    r && (this._subscribe = r)
  }
  return (
    (e.prototype.lift = function (r) {
      var t = new e()
      return (t.source = this), (t.operator = r), t
    }),
    (e.prototype.subscribe = function (r, t, n) {
      var i = this,
        s = wz(r) ? r : new Hk(r, t, n)
      return (
        Kf(function () {
          var u = i,
            o = u.operator,
            l = u.source
          s.add(o ? o.call(s, l) : l ? i._subscribe(s) : i._trySubscribe(s))
        }),
        s
      )
    }),
    (e.prototype._trySubscribe = function (r) {
      try {
        return this._subscribe(r)
      } catch (t) {
        r.error(t)
      }
    }),
    (e.prototype.forEach = function (r, t) {
      var n = this
      return (
        (t = Wk(t)),
        new t(function (i, s) {
          var u
          u = n.subscribe(
            function (o) {
              try {
                r(o)
              } catch (l) {
                s(l), u == null || u.unsubscribe()
              }
            },
            s,
            i
          )
        })
      )
    }),
    (e.prototype._subscribe = function (r) {
      var t
      return (t = this.source) === null || t === void 0 ? void 0 : t.subscribe(r)
    }),
    (e.prototype[bz] = function () {
      return this
    }),
    (e.prototype.pipe = function () {
      for (var r = [], t = 0; t < arguments.length; t++) r[t] = arguments[t]
      return vz(r)(this)
    }),
    (e.prototype.toPromise = function (r) {
      var t = this
      return (
        (r = Wk(r)),
        new r(function (n, i) {
          var s
          t.subscribe(
            function (u) {
              return (s = u)
            },
            function (u) {
              return i(u)
            },
            function () {
              return n(s)
            }
          )
        })
      )
    }),
    (e.create = function (r) {
      return new e(r)
    }),
    e
  )
})()
function Wk(e) {
  var r
  return (r = e ?? Ps.Promise) !== null && r !== void 0 ? r : Promise
}
function gz(e) {
  return e && hi(e.next) && hi(e.error) && hi(e.complete)
}
function wz(e) {
  return (e && e instanceof Vk) || (gz(e) && Kk(e))
}
V()
F()
V()
F()
var _z = jk(function (e) {
    return function () {
      e(this), (this.name = 'ObjectUnsubscribedError'), (this.message = 'object unsubscribed')
    }
  }),
  nm = (function (e) {
    Df(r, e)
    function r() {
      var t = e.call(this) || this
      return (t.closed = !1), (t.observers = []), (t.isStopped = !1), (t.hasError = !1), (t.thrownError = null), t
    }
    return (
      (r.prototype.lift = function (t) {
        var n = new Jk(this, this)
        return (n.operator = t), n
      }),
      (r.prototype._throwIfClosed = function () {
        if (this.closed) throw new _z()
      }),
      (r.prototype.next = function (t) {
        var n = this
        Kf(function () {
          var i, s
          if ((n._throwIfClosed(), !n.isStopped)) {
            var u = n.observers.slice()
            try {
              for (var o = Y2(u), l = o.next(); !l.done; l = o.next()) {
                var a = l.value
                a.next(t)
              }
            } catch (c) {
              i = { error: c }
            } finally {
              try {
                l && !l.done && (s = o.return) && s.call(o)
              } finally {
                if (i) throw i.error
              }
            }
          }
        })
      }),
      (r.prototype.error = function (t) {
        var n = this
        Kf(function () {
          if ((n._throwIfClosed(), !n.isStopped)) {
            ;(n.hasError = n.isStopped = !0), (n.thrownError = t)
            for (var i = n.observers; i.length; ) i.shift().error(t)
          }
        })
      }),
      (r.prototype.complete = function () {
        var t = this
        Kf(function () {
          if ((t._throwIfClosed(), !t.isStopped)) {
            t.isStopped = !0
            for (var n = t.observers; n.length; ) n.shift().complete()
          }
        })
      }),
      (r.prototype.unsubscribe = function () {
        ;(this.isStopped = this.closed = !0), (this.observers = null)
      }),
      Object.defineProperty(r.prototype, 'observed', {
        get: function () {
          var t
          return ((t = this.observers) === null || t === void 0 ? void 0 : t.length) > 0
        },
        enumerable: !1,
        configurable: !0
      }),
      (r.prototype._trySubscribe = function (t) {
        return this._throwIfClosed(), e.prototype._trySubscribe.call(this, t)
      }),
      (r.prototype._subscribe = function (t) {
        return this._throwIfClosed(), this._checkFinalizedStatuses(t), this._innerSubscribe(t)
      }),
      (r.prototype._innerSubscribe = function (t) {
        var n = this,
          i = n.hasError,
          s = n.isStopped,
          u = n.observers
        return i || s
          ? zk
          : (u.push(t),
            new qf(function () {
              return Q2(u, t)
            }))
      }),
      (r.prototype._checkFinalizedStatuses = function (t) {
        var n = this,
          i = n.hasError,
          s = n.thrownError,
          u = n.isStopped
        i ? t.error(s) : u && t.complete()
      }),
      (r.prototype.asObservable = function () {
        var t = new Gk()
        return (t.source = this), t
      }),
      (r.create = function (t, n) {
        return new Jk(t, n)
      }),
      r
    )
  })(Gk),
  Jk = (function (e) {
    Df(r, e)
    function r(t, n) {
      var i = e.call(this) || this
      return (i.destination = t), (i.source = n), i
    }
    return (
      (r.prototype.next = function (t) {
        var n, i
        ;(i = (n = this.destination) === null || n === void 0 ? void 0 : n.next) === null ||
          i === void 0 ||
          i.call(n, t)
      }),
      (r.prototype.error = function (t) {
        var n, i
        ;(i = (n = this.destination) === null || n === void 0 ? void 0 : n.error) === null ||
          i === void 0 ||
          i.call(n, t)
      }),
      (r.prototype.complete = function () {
        var t, n
        ;(n = (t = this.destination) === null || t === void 0 ? void 0 : t.complete) === null ||
          n === void 0 ||
          n.call(t)
      }),
      (r.prototype._subscribe = function (t) {
        var n, i
        return (i = (n = this.source) === null || n === void 0 ? void 0 : n.subscribe(t)) !== null && i !== void 0
          ? i
          : zk
      }),
      r
    )
  })(nm),
  Xk = new nm()
async function Ez({ meta: e, bytes: r }) {
  let [t, n] = K2(),
    i = new nm()
  return (
    Xk.next({ meta: e, getContent: () => Tf(i), declareId: n }),
    await xj(
      () => r,
      Ik((s) => i.next(s)),
      Mj
    ),
    i.complete(),
    Tf(t)
  )
}
async function Sz({ to: e, node: r, file: t }) {
  let { name: n, type: i, size: s, lastModified: u } = t,
    o = async function* () {
      yield Of.toBinary({
        type: { oneofKind: 'send', send: { name: n, type: i, size: BigInt(s), lastModified: BigInt(u) } }
      })
      let a = t.stream().getReader()
      for (;;) {
        let { value: c, done: f } = await a.read()
        if (f) break
        yield c
      }
    },
    { stream: l } = await r.dialProtocol(e, Cf)
  return (0, cz.default)(o, l, async function (a) {
    for await (let c of a) return String(c)
  })
}
V()
F()
var Az = Yr(Ol()),
  Iz = () => {
    throw new Error('This node does not support file content retrieval')
  },
  Yk = Iz
function Tz(e) {
  Yk = e
}
async function* Cz({ from: e, node: r, id: t, skip: n, limit: i }) {
  let s = async function* () {
      yield Of.toBinary({ type: { oneofKind: 'receive', receive: { id: t, skip: n, limit: i } } })
    },
    { stream: u } = await r.dialProtocol(e, Cf),
    o = await (0, Az.default)(s, u, async function* (l) {
      for await (let a of l) yield a.slice()
    })
  for await (let l of o) yield l
}
V()
F()
var kz = Yr(Ol()),
  Mz = () => {
    throw new Error('This node does not support file meta retrieval')
  },
  Zk = Mz
function xz(e) {
  Zk = async ({ id: r }) => {
    let t = await e({ id: r }),
      n = t && Ki.toBinary(t)
    return n && Tf([n])
  }
}
async function Rz({ from: e, node: r, id: t }) {
  let n = async function* () {
      yield Of.toBinary({ type: { oneofKind: 'meta', meta: t } })
    },
    { stream: i } = await r.dialProtocol(e, Cf)
  return (0, kz.default)(n, i, async function (s) {
    for await (let u of s) return Ki.fromBinary(u.slice())
  })
}
var Bz = async ({ stream: e }) => {
    let r = Promise.resolve(Qk.EMPTY)
    await (0, V2.default)(e, async function (t) {
      let [n, i] = Tj(
          1,
          Ik((u) => u.slice(), t)
        ),
        s = Of.fromBinary(await Cj(n))
      switch (s.type.oneofKind) {
        case 'send':
          r = Ez({ meta: s.type.send, bytes: i })
          break
        case 'receive':
          r = Yk(s.type.receive)
          break
        case 'meta':
          r = Zk({ id: s.type.meta })
          break
      }
    }),
      await (0, V2.default)((await r) || Qk.EMPTY, e),
      await (0, V2.default)([], e)
  },
  Qk = {
    get EMPTY() {
      return Tf(Promise.resolve('Empty response'))
    }
  }
V()
F()
var eM = Yr(QN()),
  Nz = Yr(Z8()),
  Pz = Yr(ND()),
  IK = Yr($r()),
  Oz = Yr(EL()),
  Dz = Yr(kL())
function tM(e = {}) {
  return {
    addresses: { listen: ['/ip4/127.0.0.1/tcp/9090/ws/p2p-webrtc-star/'] },
    modules: { transport: [eM.default, Pz.default], streamMuxer: [Dz.default], connEncryption: [Oz.NOISE] },
    config: { transport: { [eM.default.prototype[Symbol.toStringTag]]: { filter: Nz.default.all } } },
    ...e
  }
}
var Lz = Yr(Aj())
function rM(e) {
  let r, t, n
  return (
    e ? (t = tM(e)) : (t = tM()),
    {
      async connect(i) {
        i && (n = i), (r = await Lz.default.create(t)), r.handle(sa.PROTOCOL, sa.handleFile), await r.start()
      },
      async sendFile(i) {
        if (!n) throw 'listener not found'
        return await sa.sendFile({ to: n, node: r, file: i })
      },
      async receiveFile(i) {
        if (!n) throw 'listener not found'
        let s = '',
          u = new TextDecoder()
        for await (let o of sa.receiveContent({ from: n, node: r, id: i })) (s += u.decode(o)), console.log(s)
        return s
      },
      async receiveMeta(i) {
        if (!n) throw 'listener not found'
        let s = '',
          u = await sa.receiveMeta({ from: n, node: r, id: i })
        return (s = JSON.stringify({ ...u, size: Number(u.size), lastModified: Number(u.lastModified) }, null, 2)), s
      },
      async connectionHandler(i, s) {
        r.connectionManager.on(i, s)
      },
      async nodeHandler(i, s) {
        r.on(i, s)
      },
      setListener(i) {
        n = i
      }
    }
  )
}
function Uz() {
  return gu(this, null, function* () {
    let e = (n) =>
        gu(this, null, function* () {
          console.log(`Found peer ${n.toB58String()}`)
        }),
      r = (n) =>
        gu(this, null, function* () {
          console.log(`Disconnected from ${n.remotePeer.toB58String()}`)
        }),
      t = rM()
    return yield t.connect(), t.connectionHandler('peer:disconnect', r), t.nodeHandler('peer:discovery', e), t
  })
}
function im() {
  return (
    (0, pu.useEffect)(() => {
      let e = Uz()
    }, []),
    pu.default.createElement('div', null, 'Hello World!', pu.default.createElement(Tv, null))
  )
}
iM.default.render(nM.default.createElement(im, null), document.getElementById('root'))
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * aead.js - aead for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://tools.ietf.org/html/rfc7539#section-2.8
 *   https://github.com/openssh/openssh-portable
 */
/*!
 * assert.js - assert for bcrypto
 * Copyright (c) 2020, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
/*!
 * bn.js - big numbers for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/bn.js:
 *   Copyright (c) 2015, Fedor Indutny (MIT License).
 *   https://github.com/indutny/bn.js
 *
 * Parts of this software are based on golang/go:
 *   Copyright (c) 2009, The Go Authors. All rights reserved.
 *   https://github.com/golang/go
 *
 * Parts of this software are based on openssl/openssl:
 *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
 *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
 *   https://github.com/openssl/openssl
 *
 * Parts of this software are based on libgmp:
 *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
 *   https://gmplib.org/
 *
 * Parts of this software are based on v8/v8:
 *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
 *   https://github.com/v8/v8
 *
 * Resources:
 *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
 *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
 *   https://github.com/golang/go/blob/master/src/math/big/int.go
 *   https://github.com/golang/go/blob/master/src/math/big/nat.go
 *   https://github.com/golang/go/blob/master/src/math/big/prime.go
 *   https://github.com/openssl/openssl/tree/master/crypto/bn
 *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
 *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
 *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
 */
/*!
 * chacha20.js - chacha20 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources
 *   https://en.wikipedia.org/wiki/Chacha20
 *   https://tools.ietf.org/html/rfc7539#section-2
 *   https://cr.yp.to/chacha.html
 */
/*!
 * custom.js - custom inspect symbol for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
/*!
 * ecdh.js - ECDH for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://cr.yp.to/ecdh.html
 *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
 *   https://tools.ietf.org/html/rfc7748
 */
/*!
 * elliptic.js - elliptic curves for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/elliptic:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/elliptic
 *
 * Formulas from DJB and Tanja Lange [EFD].
 *
 * References:
 *
 *   [GECC] Guide to Elliptic Curve Cryptography
 *     D. Hankerson, A. Menezes, and S. Vanstone
 *     https://tinyurl.com/guide-to-ecc
 *
 *   [GLV] Faster Point Multiplication on Elliptic Curves
 *     R. Gallant, R. Lambert, and S. Vanstone
 *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
 *
 *   [MONT1] Montgomery curves and the Montgomery ladder
 *     Daniel J. Bernstein, Tanja Lange
 *     https://eprint.iacr.org/2017/293.pdf
 *
 *   [SQUARED] Elligator Squared
 *     Mehdi Tibouchi
 *     https://eprint.iacr.org/2014/043.pdf
 *
 *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
 *     Certicom Research
 *     https://www.secg.org/sec1-v2.pdf
 *
 *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
 *     Certicom Research
 *     https://www.secg.org/sec2-v2.pdf
 *
 *   [SIDE1] Elliptic Curves and Side-Channel Attacks
 *     Marc Joye
 *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
 *
 *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
 *     B. Feix, M. Roussellet, A. Venelli
 *     https://eprint.iacr.org/2014/191.pdf
 *
 *   [ALT] Alternative Elliptic Curve Representations
 *     R. Struik
 *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
 *
 *   [ARITH1] Arithmetic of Elliptic Curves
 *     Christophe Doche, Tanja Lange
 *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
 *     Page 267, Section 13 (978-1-58488-518-4)
 *     https://hyperelliptic.org/HEHCC/index.html
 *
 *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
 *     Joseph H. Silverman
 *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
 *
 *   [EFD] Explicit-Formulas Database
 *     Daniel J. Bernstein, Tanja Lange
 *     https://hyperelliptic.org/EFD/index.html
 *
 *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
 *     Daniel J. Bernstein
 *     https://safecurves.cr.yp.to/
 *
 *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
 *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
 *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
 *
 *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
 *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
 *     https://eprint.iacr.org/2009/340.pdf
 *
 *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
 *     Maciej Ulas
 *     https://arxiv.org/abs/0706.1448
 *
 *   [H2EC] Hashing to Elliptic Curves
 *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
 *     https://git.io/JeWz6
 *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
 *
 *   [SVDW1] Construction of Rational Points on Elliptic Curves
 *     A. Shallue, C. E. van de Woestijne
 *     https://works.bepress.com/andrew_shallue/1/download/
 *
 *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
 *     Pierre-Alain Fouque, Mehdi Tibouchi
 *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
 *
 *   [SVDW3] Covert ECDH over secp256k1
 *     Pieter Wuille
 *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
 *
 *   [MONT2] Montgomery Curve (wikipedia)
 *     https://en.wikipedia.org/wiki/Montgomery_curve
 *
 *   [MONT3] Montgomery Curves and their arithmetic
 *     C. Costello, B. Smith
 *     https://eprint.iacr.org/2017/212.pdf
 *
 *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
 *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
 *     https://elligator.cr.yp.to/elligator-20130828.pdf
 *
 *   [RFC7748] Elliptic Curves for Security
 *     A. Langley, M. Hamburg, S. Turner
 *     https://tools.ietf.org/html/rfc7748
 *
 *   [TWISTED] Twisted Edwards Curves
 *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
 *     https://eprint.iacr.org/2008/013.pdf
 *
 *   [ELL1] Injective Encodings to Elliptic Curves
 *     P. Fouque, A. Joux, M. Tibouchi
 *     https://eprint.iacr.org/2013/373.pdf
 *
 *   [ISOGENY] Twisting Edwards curves with isogenies
 *     Mike Hamburg
 *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
 *
 *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
 *     S. Josefsson, SJD AB, I. Liusvaara
 *     https://tools.ietf.org/html/rfc8032
 *
 *   [SCHNORR] Schnorr Signatures for secp256k1
 *     Pieter Wuille
 *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
 *
 *   [BIP340] Schnorr Signatures for secp256k1
 *     Pieter Wuille, Jonas Nick, Tim Ruffing
 *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 *
 *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
 *            on Sensor Networks Using the MSP430X Microcontroller
 *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
 *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
 *
 *   [FIPS186] Federal Information Processing Standards Publication
 *     National Institute of Standards and Technology
 *     https://tinyurl.com/fips-186-3
 *
 *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
 *             Standard Curves and Curve Generation
 *     M. Lochter, BSI, J. Merkle
 *     https://tools.ietf.org/html/rfc5639
 *
 *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
 *     Christopher Jeffrey
 *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
 *
 *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
 *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
 */
/*!
 * hkdf.js - hkdf for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HKDF
 *   https://tools.ietf.org/html/rfc5869
 */
/*!
 * hkdf.js - hkdf for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
/*!
 * hmac.js - hmac for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/HMAC
 *   https://tools.ietf.org/html/rfc2104
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
 */
/*!
 * poly1305.js - poly1305 for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on floodyberry/poly1305-donna:
 *   Placed into the public domain by Andrew Moon.
 *   https://github.com/floodyberry/poly1305-donna
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Poly1305
 *   https://cr.yp.to/mac.html
 *   https://tools.ietf.org/html/rfc7539#section-2.5
 *   https://github.com/floodyberry/poly1305-donna/blob/master/poly1305-donna-16.h
 */
/*!
 * random.js - random for bcrypto
 * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 */
/*!
 * random.js - random number generator for bcrypto
 * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://wiki.openssl.org/index.php/Random_Numbers
 *   https://csrc.nist.gov/projects/random-bit-generation/
 *   http://www.pcg-random.org/posts/bounded-rands.html
 *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
 */
/*!
 * sha256.js - SHA256 implementation for bcrypto
 * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Parts of this software are based on indutny/hash.js:
 *   Copyright (c) 2014, Fedor Indutny (MIT License).
 *   https://github.com/indutny/hash.js
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/SHA-2
 *   https://tools.ietf.org/html/rfc4634
 *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
 */
/*!
 * x25519.js - x25519 for bcrypto
 * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
 * https://github.com/bcoin-org/bcrypto
 *
 * Resources:
 *   https://en.wikipedia.org/wiki/Curve25519
 *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
 *   https://tools.ietf.org/html/rfc7748#section-5
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
//# sourceMappingURL=index.js.map
